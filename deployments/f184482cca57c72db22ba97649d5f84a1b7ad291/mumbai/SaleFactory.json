{
  "address": "0xB12524A002451212f6F336010A41fa3b6BAbe135",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "maximumSaleTimeout",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maximumCooldownDuration",
              "type": "uint256"
            },
            {
              "internalType": "contract RedeemableERC20Factory",
              "name": "redeemableERC20Factory",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "vmStateBuilder",
              "type": "address"
            }
          ],
          "internalType": "struct SaleConstructorConfig",
          "name": "config_",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        }
      ],
      "name": "Implementation",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "child",
          "type": "address"
        }
      ],
      "name": "NewChild",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data_",
          "type": "bytes"
        }
      ],
      "name": "createChild",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "bytes[]",
                  "name": "sources",
                  "type": "bytes[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "constants",
                  "type": "uint256[]"
                }
              ],
              "internalType": "struct StateConfig",
              "name": "vmStateConfig",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "reserve",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "saleTimeout",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "cooldownDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minimumRaise",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "dustSize",
              "type": "uint256"
            }
          ],
          "internalType": "struct SaleConfig",
          "name": "config_",
          "type": "tuple"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "symbol",
                  "type": "string"
                },
                {
                  "internalType": "address",
                  "name": "distributor",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "initialSupply",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ERC20Config",
              "name": "erc20Config",
              "type": "tuple"
            },
            {
              "internalType": "address",
              "name": "tier",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "minimumTier",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "distributionEndForwardingAddress",
              "type": "address"
            }
          ],
          "internalType": "struct SaleRedeemableERC20Config",
          "name": "saleRedeemableERC20Config_",
          "type": "tuple"
        }
      ],
      "name": "createChildTyped",
      "outputs": [
        {
          "internalType": "contract Sale",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "maybeChild_",
          "type": "address"
        }
      ],
      "name": "isChild",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xfeb1f7c835234ea31f171e91727442a1cdbd357c88431b51d0ed9a88eb2f724f",
  "receipt": {
    "to": null,
    "from": "0xbF334f8BD1420a1CbFE15407f73919424934B1B3",
    "contractAddress": "0xB12524A002451212f6F336010A41fa3b6BAbe135",
    "transactionIndex": 2,
    "gasUsed": "5992065",
    "logsBloom": "0x00000000000000020000000000000000000000000000002008000000800000000000000000000000000000001000000000008000200000000000000000000000000000000000000000000000000000800000000000000000020100000000000000000000000200000000000000000000000000010000000080000000110000000000000000000000000000100000000000000000000000000000000000000000200000000000000020000000000000000001000000000000000000000000004002000000000000000001000000000020000000000000000000100040000000000000000000000000000000000000000000000000000000100000000000100000",
    "blockHash": "0x781e7dfcc8dd020871f72ce8219040b598dda2d85c92104c8c22685c2ffc6a96",
    "transactionHash": "0xfeb1f7c835234ea31f171e91727442a1cdbd357c88431b51d0ed9a88eb2f724f",
    "logs": [
      {
        "transactionIndex": 2,
        "blockNumber": 27020749,
        "transactionHash": "0xfeb1f7c835234ea31f171e91727442a1cdbd357c88431b51d0ed9a88eb2f724f",
        "address": "0xE31f5398483F6Dc1875937987c8ed46E2423fC95",
        "topics": [
          "0xff17a663a2bf6c40dc1bc40139e25068b0f997d33219ddf9910b87c489ef1b0e"
        ],
        "data": "0x000000000000000000000000b12524a002451212f6f336010a41fa3b6babe135000000000000000000000000000000000000000000000000000000000000271000000000000000000000000000000000000000000000000000000000000003e800000000000000000000000048fe1d487826d7aec87920b19a7c19dd19de9cca0000000000000000000000006d6aeda4ba6687f7a5a040875b6ba2ef0c468696",
        "logIndex": 4,
        "blockHash": "0x781e7dfcc8dd020871f72ce8219040b598dda2d85c92104c8c22685c2ffc6a96"
      },
      {
        "transactionIndex": 2,
        "blockNumber": 27020749,
        "transactionHash": "0xfeb1f7c835234ea31f171e91727442a1cdbd357c88431b51d0ed9a88eb2f724f",
        "address": "0xB12524A002451212f6F336010A41fa3b6BAbe135",
        "topics": [
          "0x7fac34ecf0b1b374cd9659e3d17db602659d53f1162b1f20142e6c02694aed70"
        ],
        "data": "0x000000000000000000000000bf334f8bd1420a1cbfe15407f73919424934b1b3000000000000000000000000e31f5398483f6dc1875937987c8ed46e2423fc95",
        "logIndex": 5,
        "blockHash": "0x781e7dfcc8dd020871f72ce8219040b598dda2d85c92104c8c22685c2ffc6a96"
      },
      {
        "transactionIndex": 2,
        "blockNumber": 27020749,
        "transactionHash": "0xfeb1f7c835234ea31f171e91727442a1cdbd357c88431b51d0ed9a88eb2f724f",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000bf334f8bd1420a1cbfe15407f73919424934b1b3",
          "0x000000000000000000000000c26880a0af2ea0c7e8130e6ec47af756465452e8"
        ],
        "data": "0x000000000000000000000000000000000000000000000000015b112d6859e6da000000000000000000000000000000000000000000000000ba8af5d19361430800000000000000000000000000000000000000000000100d484c09d65078b977000000000000000000000000000000000000000000000000b92fe4a42b075c2e00000000000000000000000000000000000000000000100d49a71b03b8d2a051",
        "logIndex": 6,
        "blockHash": "0x781e7dfcc8dd020871f72ce8219040b598dda2d85c92104c8c22685c2ffc6a96"
      }
    ],
    "blockNumber": 27020749,
    "cumulativeGasUsed": "6076586",
    "status": 1,
    "byzantium": true
  },
  "args": [
    {
      "maximumSaleTimeout": 10000,
      "maximumCooldownDuration": 1000,
      "redeemableERC20Factory": "0x48fe1d487826D7aEc87920b19a7C19Dd19de9CCA",
      "vmStateBuilder": "0x6D6aEda4Ba6687F7a5A040875b6ba2Ef0C468696"
    }
  ],
  "numDeployments": 1,
  "solcInputHash": "055c200f462499c3452e24a9d9708423",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maximumSaleTimeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumCooldownDuration\",\"type\":\"uint256\"},{\"internalType\":\"contract RedeemableERC20Factory\",\"name\":\"redeemableERC20Factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vmStateBuilder\",\"type\":\"address\"}],\"internalType\":\"struct SaleConstructorConfig\",\"name\":\"config_\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Implementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"child\",\"type\":\"address\"}],\"name\":\"NewChild\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"createChild\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"bytes[]\",\"name\":\"sources\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"internalType\":\"struct StateConfig\",\"name\":\"vmStateConfig\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"saleTimeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cooldownDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumRaise\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dustSize\",\"type\":\"uint256\"}],\"internalType\":\"struct SaleConfig\",\"name\":\"config_\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC20Config\",\"name\":\"erc20Config\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"tier\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumTier\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"distributionEndForwardingAddress\",\"type\":\"address\"}],\"internalType\":\"struct SaleRedeemableERC20Config\",\"name\":\"saleRedeemableERC20Config_\",\"type\":\"tuple\"}],\"name\":\"createChildTyped\",\"outputs\":[{\"internalType\":\"contract Sale\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"maybeChild_\",\"type\":\"address\"}],\"name\":\"isChild\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"createChild(bytes)\":{\"params\":{\"data_\":\"Encoded data to pass down to child contract constructor.\"},\"returns\":{\"_0\":\"New child contract address.\"}},\"createChildTyped(((bytes[],uint256[]),address,address,uint256,uint256,uint256,uint256),((string,string,address,uint256),address,uint256,address))\":{\"params\":{\"config_\":\"`SaleConfig` constructor configuration.\"},\"returns\":{\"_0\":\"New `Sale` child contract.\"}},\"isChild(address)\":{\"params\":{\"maybeChild_\":\"Address of child contract to look up.\"},\"returns\":{\"_0\":\"Returns `true` if address is a contract created by this contract factory, otherwise `false`.\"}}},\"title\":\"SaleFactory\",\"version\":1},\"userdoc\":{\"events\":{\"Implementation(address,address)\":{\"notice\":\"Factories that clone a template contract MUST emit an event any time they set the implementation being cloned. Factories that deploy new contracts without cloning do NOT need to emit this.\"},\"NewChild(address,address)\":{\"notice\":\"Whenever a new child contract is deployed, a `NewChild` event containing the new child contract address MUST be emitted.\"}},\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"Build the reference implementation to clone for each child.\"},\"createChild(bytes)\":{\"notice\":\"Implements `IFactory`. Calls the `_createChild` hook that inheriting contracts must override. Registers child contract address such that `isChild` is `true`. Emits `NewChild` event.\"},\"createChildTyped(((bytes[],uint256[]),address,address,uint256,uint256,uint256,uint256),((string,string,address,uint256),address,uint256,address))\":{\"notice\":\"Allows calling `createChild` with `SeedERC20Config` struct. Use original `Factory` `createChild` function signature if function parameters are already encoded.\"},\"isChild(address)\":{\"notice\":\"Implements `IFactory`. Checks if address is registered as a child contract of this factory.\"}},\"notice\":\"Factory for creating and deploying `Sale` contracts.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/sale/SaleFactory.sol\":\"SaleFactory\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = _setInitializedVersion(1);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        bool isTopLevelCall = _setInitializedVersion(version);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(version);\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        _setInitializedVersion(type(uint8).max);\\n    }\\n\\n    function _setInitializedVersion(uint8 version) private returns (bool) {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\\n        // of initializers, because in other contexts the contract may have been reentered.\\n        if (_initializing) {\\n            require(\\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\\n                \\\"Initializable: contract is already initialized\\\"\\n            );\\n            return false;\\n        } else {\\n            require(_initialized < version, \\\"Initializable: contract is already initialized\\\");\\n            _initialized = version;\\n            return true;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7454006cccb737612b00104d2f606d728e2818b778e7e55542f063c614ce46ba\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\",\"keccak256\":\"0xb71b875e7f1b8ad082eb6ff83bca4bfa7d050476cc98fd39295826b654edfb46\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4e733d3164f73f461eaf9d8087a7ad1ea180bdc8ba0d3d61b0e1ae16d8e63dff\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\\n    function __ERC20Burnable_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        _spendAllowance(account, _msgSender(), amount);\\n        _burn(account, amount);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xea2c6f9d434127bf36b1e3e5ebaaf6d28a64dbaeea560508e570014e905a5ad2\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x605434219ebbe4653f703640f06969faa5a1d78f0bfef878e5ddbb1ca369ceeb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55cf2bd9fc76704ddcdc19834cd288b7de00fc0f298a40ea16a954ae8991db2d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x1cc0efb01cbf008b768fd7b334786a6e358809198bb7e67f1c530af4957c6a21\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = _setInitializedVersion(1);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        bool isTopLevelCall = _setInitializedVersion(version);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(version);\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        _setInitializedVersion(type(uint8).max);\\n    }\\n\\n    function _setInitializedVersion(uint8 version) private returns (bool) {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\\n        // of initializers, because in other contexts the contract may have been reentered.\\n        if (_initializing) {\\n            require(\\n                version == 1 && !Address.isContract(address(this)),\\n                \\\"Initializable: contract is already initialized\\\"\\n            );\\n            return false;\\n        } else {\\n            require(_initialized < version, \\\"Initializable: contract is already initialized\\\");\\n            _initialized = version;\\n            return true;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb68c2016cd41840646addd6f79f17f80f42a6279acb0cd4d9d85cab6e8d9b777\",\"license\":\"MIT\"},\"@openzeppelin/contracts/security/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x0e9621f60b2faabe65549f7ed0f24e8853a45c1b7990d47e8160e523683f3935\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x8e93de94c9062ebc94fb7e2e3929b0781ac6a2b7772e2f7a59045861c93e5be9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0xe0c8b625a79bac0fe80f17cfb521e072805cc9cef1c96a5caf45b264e74812fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/ERC20Snapshot.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"../../../utils/Arrays.sol\\\";\\nimport \\\"../../../utils/Counters.sol\\\";\\n\\n/**\\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\\n * total supply at the time are recorded for later access.\\n *\\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\\n * In naive implementations it's possible to perform a \\\"double spend\\\" attack by reusing the same balance from different\\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\\n * used to create an efficient ERC20 forking mechanism.\\n *\\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\\n * and the account address.\\n *\\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\\n * return `block.number` will trigger the creation of snapshot at the beginning of each new block. When overriding this\\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\\n *\\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\\n * alternative consider {ERC20Votes}.\\n *\\n * ==== Gas Costs\\n *\\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\\n *\\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\\n * transfers will have normal cost until the next snapshot, and so on.\\n */\\n\\nabstract contract ERC20Snapshot is ERC20 {\\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\\n    // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\\n\\n    using Arrays for uint256[];\\n    using Counters for Counters.Counter;\\n\\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\\n    // Snapshot struct, but that would impede usage of functions that work on an array.\\n    struct Snapshots {\\n        uint256[] ids;\\n        uint256[] values;\\n    }\\n\\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\\n    Snapshots private _totalSupplySnapshots;\\n\\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\\n    Counters.Counter private _currentSnapshotId;\\n\\n    /**\\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\\n     */\\n    event Snapshot(uint256 id);\\n\\n    /**\\n     * @dev Creates a new snapshot and returns its snapshot id.\\n     *\\n     * Emits a {Snapshot} event that contains the same id.\\n     *\\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\\n     *\\n     * [WARNING]\\n     * ====\\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\\n     * you must consider that it can potentially be used by attackers in two ways.\\n     *\\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\\n     * section above.\\n     *\\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\\n     * ====\\n     */\\n    function _snapshot() internal virtual returns (uint256) {\\n        _currentSnapshotId.increment();\\n\\n        uint256 currentId = _getCurrentSnapshotId();\\n        emit Snapshot(currentId);\\n        return currentId;\\n    }\\n\\n    /**\\n     * @dev Get the current snapshotId\\n     */\\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\\n        return _currentSnapshotId.current();\\n    }\\n\\n    /**\\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\\n     */\\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\\n\\n        return snapshotted ? value : balanceOf(account);\\n    }\\n\\n    /**\\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\\n     */\\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\\n\\n        return snapshotted ? value : totalSupply();\\n    }\\n\\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        if (from == address(0)) {\\n            // mint\\n            _updateAccountSnapshot(to);\\n            _updateTotalSupplySnapshot();\\n        } else if (to == address(0)) {\\n            // burn\\n            _updateAccountSnapshot(from);\\n            _updateTotalSupplySnapshot();\\n        } else {\\n            // transfer\\n            _updateAccountSnapshot(from);\\n            _updateAccountSnapshot(to);\\n        }\\n    }\\n\\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\\n        require(snapshotId > 0, \\\"ERC20Snapshot: id is 0\\\");\\n        require(snapshotId <= _getCurrentSnapshotId(), \\\"ERC20Snapshot: nonexistent id\\\");\\n\\n        // When a valid snapshot is queried, there are three possibilities:\\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\\n        //  to this id is the current one.\\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\\n        //  requested id, and its value is the one to return.\\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\\n        //  larger than the requested one.\\n        //\\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\\n        // exactly this.\\n\\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\\n\\n        if (index == snapshots.ids.length) {\\n            return (false, 0);\\n        } else {\\n            return (true, snapshots.values[index]);\\n        }\\n    }\\n\\n    function _updateAccountSnapshot(address account) private {\\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\\n    }\\n\\n    function _updateTotalSupplySnapshot() private {\\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\\n    }\\n\\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\\n        uint256 currentId = _getCurrentSnapshotId();\\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\\n            snapshots.ids.push(currentId);\\n            snapshots.values.push(currentValue);\\n        }\\n    }\\n\\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\\n        if (ids.length == 0) {\\n            return 0;\\n        } else {\\n            return ids[ids.length - 1];\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x29f7bc7f4d461a2a2698052f71b29344baf0cb7bdb31ca66e4b534a5fc5e844e\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc3d946432c0ddbb1f846a0d3985be71299df331b91d06732152117f62f0be2b5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x0d4de01fe5360c38b4ad2b0822a12722958428f5138a7ff47c1720eb6fa52bba\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Arrays.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Arrays.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to array types.\\n */\\nlibrary Arrays {\\n    /**\\n     * @dev Searches a sorted `array` and returns the first index that contains\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\n     * values in the array are strictly less than `element`), the array length is\\n     * returned. Time complexity O(log n).\\n     *\\n     * `array` is expected to be sorted in ascending order, and to contain no\\n     * repeated elements.\\n     */\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        if (array.length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds down (it does integer division with truncation).\\n            if (array[mid] > element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low > 0 && array[low - 1] == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa7bc891be2bc5948340a8fb14ad36c8846230c9086269e37f3febf0dc239c9f7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Counters.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\",\"keccak256\":\"0xf0018c2440fbe238dd3a8732fa8e17a0f9dce84d31451dc8a32f6d62b349c9f1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface,\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in _interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\\n        if (result.length < 32) return false;\\n        return success && abi.decode(result, (bool));\\n    }\\n}\\n\",\"keccak256\":\"0xf7291d7213336b00ee7edbf7cd5034778dd7b0bda2a7489e664f1e5cacc6c24e\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\",\"keccak256\":\"0xc995bddbca1ae19788db9f8b61e63385edd3fddf89693b612d5abd1a275974d2\",\"license\":\"MIT\"},\"contracts/cooldown/Cooldown.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title Cooldown\\n/// @notice `Cooldown` is a base contract that rate limits functions on\\n/// the implementing contract per `msg.sender`.\\n///\\n/// Each time a function with the `onlyAfterCooldown` modifier is called the\\n/// `msg.sender` must wait N seconds before calling any modified function.\\n///\\n/// This does nothing to prevent sybils who can generate an arbitrary number of\\n/// `msg.sender` values in parallel to spam a contract.\\n///\\n/// `Cooldown` is intended to prevent rapid state cycling to grief a contract,\\n/// such as rapidly locking and unlocking a large amount of capital in the\\n/// `SeedERC20` contract.\\n///\\n/// Requiring a lock/deposit of significant economic stake that sybils will not\\n/// have access to AND applying a cooldown IS a sybil mitigation. The economic\\n/// stake alone is NOT sufficient if gas is cheap as sybils can cycle the same\\n/// stake between each other. The cooldown alone is NOT sufficient as many\\n/// sybils can be created, each as a new `msg.sender`.\\n///\\n/// @dev Base for anything that enforces a cooldown delay on functions.\\n/// `Cooldown` requires a minimum time in seconds to elapse between actions\\n/// that cooldown. The modifier `onlyAfterCooldown` both enforces and triggers\\n/// the cooldown. There is a single cooldown across all functions per-contract\\n/// so any function call that requires a cooldown will also trigger it for\\n/// all other functions.\\n///\\n/// Cooldown is NOT an effective sybil resistance alone, as the cooldown is\\n/// per-address only. It is always possible for many accounts to be created\\n/// to spam a contract with dust in parallel.\\n/// Cooldown is useful to stop a single account rapidly cycling contract\\n/// state in a way that can be disruptive to peers. Cooldown works best when\\n/// coupled with economic stake associated with each state change so that\\n/// peers must lock capital during the cooldown. `Cooldown` tracks the first\\n/// `msg.sender` it sees for a call stack so cooldowns are enforced across\\n/// reentrant code. Any function that enforces a cooldown also has reentrancy\\n/// protection.\\ncontract Cooldown {\\n    event CooldownInitialize(address sender, uint256 cooldownDuration);\\n    event CooldownTriggered(address caller, uint256 cooldown);\\n    /// Time in blocks to restrict access to modified functions.\\n    uint256 internal cooldownDuration;\\n\\n    /// Every caller has its own cooldown, the minimum block that the caller\\n    /// call another function sharing the same cooldown state.\\n    mapping(address => uint256) private cooldowns;\\n    address private caller;\\n\\n    /// Initialize the cooldown duration.\\n    /// The cooldown duration is global to the contract.\\n    /// Cooldown duration must be greater than 0.\\n    /// Cooldown duration can only be set once.\\n    /// @param cooldownDuration_ The global cooldown duration.\\n    function initializeCooldown(uint256 cooldownDuration_) internal {\\n        require(cooldownDuration_ > 0, \\\"COOLDOWN_0\\\");\\n        require(cooldownDuration <= type(uint32).max, \\\"COOLDOWN_MAX\\\");\\n        // Reinitialization is a bug.\\n        assert(cooldownDuration == 0);\\n        cooldownDuration = cooldownDuration_;\\n        emit CooldownInitialize(msg.sender, cooldownDuration_);\\n    }\\n\\n    /// Modifies a function to enforce the cooldown for `msg.sender`.\\n    /// Saves the original caller so that cooldowns are enforced across\\n    /// reentrant code.\\n    modifier onlyAfterCooldown() {\\n        address caller_ = caller == address(0) ? caller = msg.sender : caller;\\n        require(cooldowns[caller_] <= block.timestamp, \\\"COOLDOWN\\\");\\n        // Every action that requires a cooldown also triggers a cooldown.\\n        uint256 cooldown_ = block.timestamp + cooldownDuration;\\n        cooldowns[caller_] = cooldown_;\\n        emit CooldownTriggered(caller_, cooldown_);\\n        _;\\n        // Refund as much gas as we can.\\n        delete caller;\\n    }\\n}\\n\",\"keccak256\":\"0x41f86ac816bf45a48ef45b6cefa9d4784151575428e040c28c94e0ea48ba151e\",\"license\":\"CAL\"},\"contracts/erc20/ERC20Config.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// Constructor config for standard Open Zeppelin ERC20.\\n/// @param name Name as defined by Open Zeppelin ERC20.\\n/// @param symbol Symbol as defined by Open Zeppelin ERC20.\\n/// @param distributor Distributor address of the initial supply.\\n/// MAY be zero.\\n/// @param initialSupply Initial supply to mint.\\n/// MAY be zero.\\nstruct ERC20Config {\\n    string name;\\n    string symbol;\\n    address distributor;\\n    uint256 initialSupply;\\n}\\n\",\"keccak256\":\"0xd71c17e9354e155991a6d315fc38050377f65f4a7770b146ba0070819e99c3f0\",\"license\":\"CAL\"},\"contracts/erc20/ERC20Redeem.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n// solhint-disable-next-line max-line-length\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n// solhint-disable-next-line max-line-length\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\\\";\\n\\ncontract ERC20Redeem is ERC20BurnableUpgradeable {\\n    using SafeERC20 for IERC20;\\n\\n    /// Anon has burned their tokens in exchange for some treasury assets.\\n    /// Emitted once per redeemed asset.\\n    /// @param sender `msg.sender` is burning.\\n    /// @param treasuryAsset Treasury asset being sent to redeemer.\\n    /// @param redeemAmount Amount of token being burned.\\n    /// @param assetAmount Amount of treasury asset being sent.\\n    event Redeem(\\n        address sender,\\n        address treasuryAsset,\\n        uint256 redeemAmount,\\n        uint256 assetAmount\\n    );\\n\\n    /// Anon can notify the world that they are adding treasury assets to the\\n    /// contract. Indexers are strongly encouraged to ignore untrusted anons.\\n    /// @param sender `msg.sender` adding a treasury asset.\\n    /// @param asset The treasury asset being added.\\n    event TreasuryAsset(address sender, address asset);\\n\\n    /// Anon can emit a `TreasuryAsset` event to notify token holders that\\n    /// an asset could be redeemed by burning `RedeemableERC20` tokens.\\n    /// As this is callable by anon the events should be filtered by the\\n    /// indexer to those from trusted entities only.\\n    /// @param newTreasuryAsset_ The asset to log.\\n    function newTreasuryAsset(address newTreasuryAsset_) public {\\n        emit TreasuryAsset(msg.sender, newTreasuryAsset_);\\n    }\\n\\n    /// Burn tokens for a prorata share of the current treasury.\\n    ///\\n    /// The assets to be redeemed for must be specified as an array. This keeps\\n    /// the redeem functionality:\\n    /// - Gas efficient as we avoid tracking assets in storage\\n    /// - Decentralised as any user can deposit any asset to be redeemed\\n    /// - Error resistant as any individual asset reverting can be avoided by\\n    ///   redeeming againt sans the problematic asset.\\n    /// It is also a super sharp edge if someone burns their tokens prematurely\\n    /// or with an incorrect asset list. Implementing contracts are strongly\\n    /// encouraged to implement additional safety rails to prevent high value\\n    /// mistakes.\\n    /// Only \\\"vanilla\\\" erc20 token balances are supported as treasury assets.\\n    /// I.e. if the balance is changing such as due to a rebasing token or\\n    /// other mechanism then the WRONG token amounts will be redeemed. The\\n    /// redemption calculation is very simple and naive in that it takes the\\n    /// current balance of this contract of the assets being claimed via\\n    /// redemption to calculate the \\\"prorata\\\" entitlement. If the contract's\\n    /// balance of the claimed token is changing between redemptions (other\\n    /// than due to the redemption itself) then each redemption will send\\n    /// incorrect amounts.\\n    /// @param treasuryAssets_ The list of assets to redeem.\\n    /// @param redeemAmount_ The amount of redeemable token to burn.\\n    function _redeem(IERC20[] memory treasuryAssets_, uint256 redeemAmount_)\\n        internal\\n    {\\n        uint256 assetsLength_ = treasuryAssets_.length;\\n\\n        // Calculate everything before any balances change.\\n        uint256[] memory amounts_ = new uint256[](assetsLength_);\\n\\n        // The fraction of the assets we release is the fraction of the\\n        // outstanding total supply of the redeemable being burned.\\n        // Every treasury asset is released in the same proportion.\\n        // Guard against no asset redemptions and log all events before we\\n        // change any contract state or call external contracts.\\n        require(assetsLength_ > 0, \\\"EMPTY_ASSETS\\\");\\n        uint256 supply_ = IERC20(address(this)).totalSupply();\\n        uint256 amount_ = 0;\\n        for (uint256 i_ = 0; i_ < assetsLength_; i_++) {\\n            amount_ =\\n                (treasuryAssets_[i_].balanceOf(address(this)) * redeemAmount_) /\\n                supply_;\\n            require(amount_ > 0, \\\"ZERO_AMOUNT\\\");\\n            emit Redeem(\\n                msg.sender,\\n                address(treasuryAssets_[i_]),\\n                redeemAmount_,\\n                amount_\\n            );\\n            amounts_[i_] = amount_;\\n        }\\n\\n        // Burn FIRST (reentrancy safety).\\n        _burn(msg.sender, redeemAmount_);\\n\\n        // THEN send all assets.\\n        for (uint256 i_ = 0; i_ < assetsLength_; i_++) {\\n            treasuryAssets_[i_].safeTransfer(msg.sender, amounts_[i_]);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x01e0e94c9dabf2a7784af0ec801b0b5f5696821b205bb06117fb31572fb4fc3e\",\"license\":\"CAL\"},\"contracts/factory/Factory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {IFactory} from \\\"./IFactory.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\n/// @title Factory\\n/// @notice Base contract for deploying and registering child contracts.\\nabstract contract Factory is IFactory, ReentrancyGuard {\\n    /// @dev state to track each deployed contract address. A `Factory` will\\n    /// never lie about deploying a child, unless `isChild` is overridden to do\\n    /// so.\\n    mapping(address => bool) private contracts;\\n\\n    /// Implements `IFactory`.\\n    ///\\n    /// `_createChild` hook must be overridden to actually create child\\n    /// contract.\\n    ///\\n    /// Implementers may want to overload this function with a typed equivalent\\n    /// to expose domain specific structs etc. to the compiled ABI consumed by\\n    /// tooling and other scripts. To minimise gas costs for deployment it is\\n    /// expected that the tooling will consume the typed ABI, then encode the\\n    /// arguments and pass them to this function directly.\\n    ///\\n    /// @param data_ ABI encoded data to pass to child contract constructor.\\n    function _createChild(bytes calldata data_)\\n        internal\\n        virtual\\n        returns (address);\\n\\n    /// Implements `IFactory`.\\n    ///\\n    /// Calls the `_createChild` hook that inheriting contracts must override.\\n    /// Registers child contract address such that `isChild` is `true`.\\n    /// Emits `NewChild` event.\\n    ///\\n    /// @param data_ Encoded data to pass down to child contract constructor.\\n    /// @return New child contract address.\\n    function createChild(bytes calldata data_)\\n        external\\n        virtual\\n        override\\n        nonReentrant\\n        returns (address)\\n    {\\n        // Create child contract using hook.\\n        address child_ = _createChild(data_);\\n        // Ensure the child at this address has not previously been deployed.\\n        require(!contracts[child_], \\\"DUPLICATE_CHILD\\\");\\n        // Register child contract address to `contracts` mapping.\\n        contracts[child_] = true;\\n        // Emit `NewChild` event with child contract address.\\n        emit IFactory.NewChild(msg.sender, child_);\\n        return child_;\\n    }\\n\\n    /// Implements `IFactory`.\\n    ///\\n    /// Checks if address is registered as a child contract of this factory.\\n    ///\\n    /// @param maybeChild_ Address of child contract to look up.\\n    /// @return Returns `true` if address is a contract created by this\\n    /// contract factory, otherwise `false`.\\n    function isChild(address maybeChild_)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return contracts[maybeChild_];\\n    }\\n}\\n\",\"keccak256\":\"0xbf45bbfb39b88c9adcfc25ad278928a495c16a75b3dd179baa33ca3298a85fd5\",\"license\":\"CAL\"},\"contracts/factory/IFactory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\ninterface IFactory {\\n    /// Whenever a new child contract is deployed, a `NewChild` event\\n    /// containing the new child contract address MUST be emitted.\\n    /// @param sender `msg.sender` that deployed the contract (factory).\\n    /// @param child address of the newly deployed child.\\n    event NewChild(address sender, address child);\\n\\n    /// Factories that clone a template contract MUST emit an event any time\\n    /// they set the implementation being cloned. Factories that deploy new\\n    /// contracts without cloning do NOT need to emit this.\\n    /// @param sender `msg.sender` that deployed the implementation (factory).\\n    /// @param implementation address of the implementation contract that will\\n    /// be used for future clones if relevant.\\n    event Implementation(address sender, address implementation);\\n\\n    /// Creates a new child contract.\\n    ///\\n    /// @param data_ Domain specific data for the child contract constructor.\\n    /// @return New child contract address.\\n    function createChild(bytes calldata data_) external returns (address);\\n\\n    /// Checks if address is registered as a child contract of this factory.\\n    ///\\n    /// Addresses that were not deployed by `createChild` MUST NOT return\\n    /// `true` from `isChild`. This is CRITICAL to the security guarantees for\\n    /// any contract implementing `IFactory`.\\n    ///\\n    /// @param maybeChild_ Address to check registration for.\\n    /// @return `true` if address was deployed by this contract factory,\\n    /// otherwise `false`.\\n    function isChild(address maybeChild_) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x3e9ca6613b0c19d98c4e19a7586d4109e498db2cf7d6e38e34fc2d2c0dbc32e2\",\"license\":\"CAL\"},\"contracts/math/FixedPointMath.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @dev The scale of all fixed point math. This is adopting the conventions of\\n/// both ETH (wei) and most ERC20 tokens, so is hopefully uncontroversial.\\nuint256 constant FP_DECIMALS = 18;\\n/// @dev The number `1` in the standard fixed point math scaling. Most of the\\n/// differences between fixed point math and regular math is multiplying or\\n/// dividing by `ONE` after the appropriate scaling has been applied.\\nuint256 constant FP_ONE = 1e18;\\n\\n/// @title FixedPointMath\\n/// @notice Sometimes we want to do math with decimal values but all we have\\n/// are integers, typically uint256 integers. Floats are very complex so we\\n/// don't attempt to simulate them. Instead we provide a standard definition of\\n/// \\\"one\\\" as 10 ** 18 and scale everything up/down to this as fixed point math.\\n/// Overflows are errors as per Solidity.\\nlibrary FixedPointMath {\\n    /// Scale a fixed point decimal of some scale factor to match `DECIMALS`.\\n    /// @param a_ Some fixed point decimal value.\\n    /// @param aDecimals_ The number of fixed decimals of `a_`.\\n    /// @return `a_` scaled to match `DECIMALS`.\\n    function scale18(uint256 a_, uint256 aDecimals_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 decimals_;\\n        if (FP_DECIMALS == aDecimals_) {\\n            return a_;\\n        } else if (FP_DECIMALS > aDecimals_) {\\n            unchecked {\\n                decimals_ = FP_DECIMALS - aDecimals_;\\n            }\\n            return a_ * 10**decimals_;\\n        } else {\\n            unchecked {\\n                decimals_ = aDecimals_ - FP_DECIMALS;\\n            }\\n            return a_ / 10**decimals_;\\n        }\\n    }\\n\\n    /// Scale a fixed point decimals of `DECIMALS` to some other scale.\\n    /// @param a_ A `DECIMALS` fixed point decimals.\\n    /// @param targetDecimals_ The new scale of `a_`.\\n    /// @return `a_` rescaled from `DECIMALS` to `targetDecimals_`.\\n    function scaleN(uint256 a_, uint256 targetDecimals_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 decimals_;\\n        if (targetDecimals_ == FP_DECIMALS) {\\n            return a_;\\n        } else if (FP_DECIMALS > targetDecimals_) {\\n            unchecked {\\n                decimals_ = FP_DECIMALS - targetDecimals_;\\n            }\\n            return a_ / 10**decimals_;\\n        } else {\\n            unchecked {\\n                decimals_ = targetDecimals_ - FP_DECIMALS;\\n            }\\n            return a_ * 10**decimals_;\\n        }\\n    }\\n\\n    /// Scale a fixed point up or down by `scaleBy_` orders of magnitude.\\n    /// The caller MUST ensure the end result matches `DECIMALS` if other\\n    /// functions in this library are to work correctly.\\n    /// Notably `scaleBy` is a SIGNED integer so scaling down by negative OOMS\\n    /// is supported.\\n    /// @param a_ Some integer of any scale.\\n    /// @param scaleBy_ OOMs to scale `a_` up or down by.\\n    /// @return `a_` rescaled according to `scaleBy_`.\\n    function scaleBy(uint256 a_, int8 scaleBy_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (scaleBy_ == 0) {\\n            return a_;\\n        } else if (scaleBy_ > 0) {\\n            return a_ * 10**uint8(scaleBy_);\\n        } else {\\n            uint256 posScaleDownBy_;\\n            unchecked {\\n                posScaleDownBy_ = uint8(-1 * scaleBy_);\\n            }\\n            return a_ / 10**posScaleDownBy_;\\n        }\\n    }\\n\\n    /// Fixed point multiplication in native scale decimals.\\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return `a_` multiplied by `b_` to `DECIMALS` fixed point decimals.\\n    function fixedPointMul(uint256 a_, uint256 b_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return (a_ * b_) / FP_ONE;\\n    }\\n\\n    /// Fixed point division in native scale decimals.\\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return `a_` divided by `b_` to `DECIMALS` fixed point decimals.\\n    function fixedPointDiv(uint256 a_, uint256 b_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return (a_ * FP_ONE) / b_;\\n    }\\n}\\n\",\"keccak256\":\"0xf2ac4d2307fb5b32d6c9a428b9704d14c93aa71f171f04215176a611d61aef9c\",\"license\":\"CAL\"},\"contracts/math/SaturatingMath.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title SaturatingMath\\n/// @notice Sometimes we neither want math operations to error nor wrap around\\n/// on an overflow or underflow. In the case of transferring assets an error\\n/// may cause assets to be locked in an irretrievable state within the erroring\\n/// contract, e.g. due to a tiny rounding/calculation error. We also can't have\\n/// assets underflowing and attempting to approve/transfer \\\"infinity\\\" when we\\n/// wanted \\\"almost or exactly zero\\\" but some calculation bug underflowed zero.\\n/// Ideally there are no calculation mistakes, but in guarding against bugs it\\n/// may be safer pragmatically to saturate arithmatic at the numeric bounds.\\n/// Note that saturating div is not supported because 0/0 is undefined.\\nlibrary SaturatingMath {\\n    /// Saturating addition.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return Minimum of a_ + b_ and max uint256.\\n    function saturatingAdd(uint256 a_, uint256 b_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        unchecked {\\n            uint256 c_ = a_ + b_;\\n            return c_ < a_ ? type(uint256).max : c_;\\n        }\\n    }\\n\\n    /// Saturating subtraction.\\n    /// @param a_ Minuend.\\n    /// @param b_ Subtrahend.\\n    /// @return Maximum of a_ - b_ and 0.\\n    function saturatingSub(uint256 a_, uint256 b_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        unchecked {\\n            return a_ > b_ ? a_ - b_ : 0;\\n        }\\n    }\\n\\n    /// Saturating multiplication.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return Minimum of a_ * b_ and max uint256.\\n    function saturatingMul(uint256 a_, uint256 b_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being\\n            // zero, but the benefit is lost if 'b' is also tested.\\n            // https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a_ == 0) return 0;\\n            uint256 c_ = a_ * b_;\\n            return c_ / a_ != b_ ? type(uint256).max : c_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9078a23bd04812d8a57e26ef51ddc7f2c6b0c65d8c7cfc2f2ebf40e6642fff88\",\"license\":\"CAL\"},\"contracts/phased/Phased.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title Phased\\n/// @notice `Phased` is an abstract contract that defines up to `9` phases that\\n/// an implementing contract moves through.\\n///\\n/// Phase `0` is always the first phase and does not, and cannot, be set\\n/// expicitly. Effectively it is implied that phase `0` has been active\\n/// since block zero.\\n///\\n/// Each subsequent phase `1` through `8` must be scheduled sequentially and\\n/// explicitly at a block timestamp.\\n///\\n/// Only the immediate next phase can be scheduled with `scheduleNextPhase`,\\n/// it is not possible to schedule multiple phases ahead.\\n///\\n/// Multiple phases can be scheduled in a single second if each scheduled phase\\n/// is scheduled for the current block OR the contract is operating on a chain\\n/// with sub-second block times. I.e. if uniqueness of block timestamps is NOT\\n/// enforced by a chain then phases scheduling can share a timstamp across\\n/// multiple transactions. To enforce uniqueness of timestamps across\\n/// transactions on subsecond blockchains, simply schedule the final phase\\n/// shift of a transaction in the future.\\n///\\n/// Several utility functions and modifiers are provided.\\n///\\n/// One event `PhaseShiftScheduled` is emitted each time a phase shift is\\n/// scheduled (not when the scheduled phase is reached).\\n///\\n/// @dev `Phased` contracts have a defined timeline with available\\n/// functionality grouped into phases.\\n/// Every `Phased` contract starts at `0` and moves sequentially\\n/// through phases `1` to `8`.\\n/// Every `Phase` other than `0` is optional, there is no requirement\\n/// that all 9 phases are implemented.\\n/// Phases can never be revisited, the inheriting contract always moves through\\n/// each achieved phase linearly.\\n/// This is enforced by only allowing `scheduleNextPhase` to be called once per\\n/// phase.\\n/// It is possible to call `scheduleNextPhase` several times in a single second\\n/// but the `block.timestamp` for each phase must be reached each time to\\n/// schedule the next phase.\\n/// Importantly there are events and several modifiers and checks available to\\n/// ensure that functionality is limited to the current phase.\\n/// The full history of each phase shift block is recorded as a fixed size\\n/// array of `uint32`.\\ncontract Phased {\\n    /// @dev Every phase block starts uninitialized.\\n    /// Only uninitialized blocks can be set by the phase scheduler.\\n    uint32 private constant UNINITIALIZED = type(uint32).max;\\n    /// @dev This is how many phases can fit in a `uint256`.\\n    uint256 private constant MAX_PHASE = 8;\\n\\n    /// `PhaseScheduled` is emitted when the next phase is scheduled.\\n    /// @param sender `msg.sender` that scheduled the next phase.\\n    /// @param newPhase The next phase being scheduled.\\n    /// @param scheduledTime The timestamp the phase will be achieved.\\n    event PhaseScheduled(\\n        address sender,\\n        uint256 newPhase,\\n        uint256 scheduledTime\\n    );\\n\\n    /// 8 phases each as 32 bits to fit a single 32 byte word.\\n    uint32[MAX_PHASE] public phaseTimes;\\n\\n    /// Initialize the blocks at \\\"never\\\".\\n    /// All phase blocks are initialized to `UNINITIALIZED`.\\n    /// i.e. not fallback solidity value of `0`.\\n    function initializePhased() internal {\\n        // Reinitialization is a bug.\\n        // Only need to check the first block as all times are about to be set\\n        // to `UNINITIALIZED`.\\n        assert(phaseTimes[0] < 1);\\n        uint32[MAX_PHASE] memory phaseTimes_ = [\\n            UNINITIALIZED,\\n            UNINITIALIZED,\\n            UNINITIALIZED,\\n            UNINITIALIZED,\\n            UNINITIALIZED,\\n            UNINITIALIZED,\\n            UNINITIALIZED,\\n            UNINITIALIZED\\n        ];\\n        phaseTimes = phaseTimes_;\\n        // 0 is always the timestamp for implied phase 0.\\n        emit PhaseScheduled(msg.sender, 0, 0);\\n    }\\n\\n    /// Pure function to reduce an array of phase times and block timestamp to\\n    /// a specific `Phase`.\\n    /// The phase will be the highest attained even if several phases have the\\n    /// same timestamp.\\n    /// If every phase block is after the timestamp then `0` is returned.\\n    /// If every phase block is before the timestamp then `MAX_PHASE` is\\n    /// returned.\\n    /// @param phaseTimes_ Fixed array of phase times to compare against.\\n    /// @param timestamp_ Determine the relevant phase relative to this time.\\n    /// @return phase_ The \\\"current\\\" phase relative to the timestamp and phase\\n    /// times list.\\n    function phaseAtTime(\\n        uint32[MAX_PHASE] memory phaseTimes_,\\n        uint256 timestamp_\\n    ) public pure returns (uint256 phase_) {\\n        for (phase_ = 0; phase_ < MAX_PHASE; phase_++) {\\n            if (timestamp_ < phaseTimes_[phase_]) {\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// Pure function to reduce an array of phase times and phase to a\\n    /// specific timestamp.\\n    /// `Phase.ZERO` will always return block `0`.\\n    /// Every other phase will map to a time in `phaseTimes_`.\\n    /// @param phaseTimes_ Fixed array of phase blocks to compare against.\\n    /// @param phase_ Determine the relevant block number for this phase.\\n    /// @return timestamp_ The timestamp for the phase according to\\n    /// `phaseTimes_`.\\n    function timeForPhase(uint32[MAX_PHASE] memory phaseTimes_, uint256 phase_)\\n        public\\n        pure\\n        returns (uint256 timestamp_)\\n    {\\n        timestamp_ = phase_ > 0 ? phaseTimes_[phase_ - 1] : 0;\\n    }\\n\\n    /// Impure read-only function to return the \\\"current\\\" phase from internal\\n    /// contract state.\\n    /// Simply wraps `phaseAtTime` for current values of `phaseTimes`\\n    /// and `block.timestamp`.\\n    function currentPhase() public view returns (uint256 phase_) {\\n        phase_ = phaseAtTime(phaseTimes, block.timestamp);\\n    }\\n\\n    /// Modifies functions to only be callable in a specific phase.\\n    /// @param phase_ Modified functions can only be called during this phase.\\n    modifier onlyPhase(uint256 phase_) {\\n        require(currentPhase() == phase_, \\\"BAD_PHASE\\\");\\n        _;\\n    }\\n\\n    /// Modifies functions to only be callable in a specific phase OR if the\\n    /// specified phase has passed.\\n    /// @param phase_ Modified function only callable during or after this\\n    /// phase.\\n    modifier onlyAtLeastPhase(uint256 phase_) {\\n        require(currentPhase() >= phase_, \\\"MIN_PHASE\\\");\\n        _;\\n    }\\n\\n    /// Writes the timestamp for the next phase.\\n    /// Only uninitialized times can be written to.\\n    /// Only the immediate next phase relative to `currentPhase` can be written\\n    /// to. It is still required to specify the `phase_` so that it is explicit\\n    /// and clear in the calling code which phase is being moved to.\\n    /// Emits `PhaseShiftScheduled` with the phase timestamp.\\n    /// @param phase_ The phase being scheduled.\\n    /// @param timestamp_ The timestamp for the phase.\\n    function schedulePhase(uint256 phase_, uint256 timestamp_) internal {\\n        require(block.timestamp <= timestamp_, \\\"NEXT_TIME_PAST\\\");\\n        require(timestamp_ < UNINITIALIZED, \\\"NEXT_TIME_UNINITIALIZED\\\");\\n        // Don't need to check for underflow as the index will be used as a\\n        // fixed array index below. Implies that scheduling phase `0` is NOT\\n        // supported.\\n        uint256 index_;\\n        unchecked {\\n            index_ = phase_ - 1;\\n        }\\n        // Bit of a hack to check the current phase against the index to\\n        // save calculating the subtraction twice.\\n        require(currentPhase() == index_, \\\"NEXT_PHASE\\\");\\n\\n        require(UNINITIALIZED == phaseTimes[index_], \\\"NEXT_TIME_SET\\\");\\n\\n        // Cannot exceed UNINITIALIZED (see above) so don't need to check\\n        // overflow on downcast.\\n        unchecked {\\n            phaseTimes[index_] = uint32(timestamp_);\\n        }\\n\\n        emit PhaseScheduled(msg.sender, phase_, timestamp_);\\n    }\\n}\\n\",\"keccak256\":\"0x0660c03cb0a704335a22ad0b2bb969ab411a3b41bd221e085b43ed7a7e9b89df\",\"license\":\"CAL\"},\"contracts/redeemableERC20/RedeemableERC20.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {ERC20Config} from \\\"../erc20/ERC20Config.sol\\\";\\nimport \\\"../erc20/ERC20Redeem.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n// solhint-disable-next-line max-line-length\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport {ITierV2} from \\\"../tier/ITierV2.sol\\\";\\nimport {TierReport} from \\\"../tier/libraries/TierReport.sol\\\";\\n\\nimport {Phased} from \\\"../phased/Phased.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\n\\n/// Everything required by the `RedeemableERC20` constructor.\\n/// @param reserve Reserve token that the associated `Trust` or equivalent\\n/// raise contract will be forwarding to the `RedeemableERC20` contract.\\n/// @param erc20Config ERC20 config forwarded to the ERC20 constructor.\\n/// @param tier Tier contract to compare statuses against on transfer.\\n/// @param minimumTier Minimum tier required for transfers in `Phase.ZERO`.\\n/// Can be `0`.\\n/// @param distributionEndForwardingAddress Optional address to send rTKN to at\\n/// the end of the distribution phase. If `0` address then all undistributed\\n/// rTKN will burn itself at the end of the distribution.\\nstruct RedeemableERC20Config {\\n    address reserve;\\n    ERC20Config erc20Config;\\n    address tier;\\n    uint256 minimumTier;\\n    address distributionEndForwardingAddress;\\n}\\n\\n/// @title RedeemableERC20\\n/// @notice This is the ERC20 token that is minted and distributed.\\n///\\n/// During `Phase.ZERO` the token can be traded and so compatible with the\\n/// Balancer pool mechanics.\\n///\\n/// During `Phase.ONE` the token is frozen and no longer able to be traded on\\n/// any AMM or transferred directly.\\n///\\n/// The token can be redeemed during `Phase.ONE` which burns the token in\\n/// exchange for pro-rata erc20 tokens held by the `RedeemableERC20` contract\\n/// itself.\\n///\\n/// The token balances can be used indirectly for other claims, promotions and\\n/// events as a proof of participation in the original distribution by token\\n/// holders.\\n///\\n/// The token can optionally be restricted by the `ITierV2` contract to only\\n/// allow receipients with a specified membership status.\\n///\\n/// @dev `RedeemableERC20` is an ERC20 with 2 phases.\\n///\\n/// `Phase.ZERO` is the distribution phase where the token can be freely\\n/// transfered but not redeemed.\\n/// `Phase.ONE` is the redemption phase where the token can be redeemed but no\\n/// longer transferred.\\n///\\n/// Redeeming some amount of `RedeemableERC20` burns the token in exchange for\\n/// some other tokens held by the contract. For example, if the\\n/// `RedeemableERC20` token contract holds 100 000 USDC then a holder of the\\n/// redeemable token can burn some of their tokens to receive a % of that USDC.\\n/// If they redeemed (burned) an amount equal to 10% of the redeemable token\\n/// supply then they would receive 10 000 USDC.\\n///\\n/// To make the treasury assets discoverable anyone can call `newTreasuryAsset`\\n/// to emit an event containing the treasury asset address. As malicious and/or\\n/// spam users can emit many treasury events there is a need for sensible\\n/// indexing and filtering of asset events to only trusted users. This contract\\n/// is agnostic to how that trust relationship is defined for each user.\\n///\\n/// Users must specify all the treasury assets they wish to redeem to the\\n/// `redeem` function. After `redeem` is called the redeemed tokens are burned\\n/// so all treasury assets must be specified and claimed in a batch atomically.\\n/// Note: The same amount of `RedeemableERC20` is burned, regardless of which\\n/// treasury assets were specified. Specifying fewer assets will NOT increase\\n/// the proportion of each that is returned.\\n///\\n/// `RedeemableERC20` has several owner administrative functions:\\n/// - Owner can add senders and receivers that can send/receive tokens even\\n///   during `Phase.ONE`\\n/// - Owner can end `Phase.ONE` during `Phase.ZERO` by specifying the address\\n///   of a distributor, which will have any undistributed tokens burned.\\n/// The owner should be a `Trust` not an EOA.\\n///\\n/// The redeem functions MUST be used to redeem and burn RedeemableERC20s\\n/// (NOT regular transfers).\\n///\\n/// `redeem` will simply revert if called outside `Phase.ONE`.\\n/// A `Redeem` event is emitted on every redemption (per treasury asset) as\\n/// `(redeemer, asset, redeemAmount)`.\\ncontract RedeemableERC20 is Initializable, Phased, ERC20Redeem {\\n    using SafeERC20 for IERC20;\\n\\n    /// @dev Phase constants.\\n    /// Contract is not yet initialized.\\n    uint256 private constant PHASE_UNINITIALIZED = 0;\\n    /// @dev Token is in the distribution phase and can be transferred freely\\n    /// subject to tier requirements.\\n    uint256 private constant PHASE_DISTRIBUTING = 1;\\n    /// @dev Token is frozen and cannot be transferred unless the\\n    /// sender/receiver is authorized as a sender/receiver.\\n    uint256 private constant PHASE_FROZEN = 2;\\n\\n    /// @dev Bits for a receiver.\\n    uint256 private constant RECEIVER = 0x1;\\n    /// @dev Bits for a sender.\\n    uint256 private constant SENDER = 0x2;\\n\\n    /// @dev To be clear, this admin is NOT intended to be an EOA.\\n    /// This contract is designed assuming the admin is a `Sale` or equivalent\\n    /// contract that itself does NOT have an admin key.\\n    address private admin;\\n    /// @dev Tracks addresses that can always send/receive regardless of phase.\\n    /// sender/receiver => access bits\\n    mapping(address => uint256) private access;\\n\\n    /// Results of initializing.\\n    /// @param sender `msg.sender` of initialize.\\n    /// @param config Initialization config.\\n    event Initialize(address sender, RedeemableERC20Config config);\\n\\n    /// A new token sender has been added.\\n    /// @param sender `msg.sender` that approved the token sender.\\n    /// @param grantedSender address that is now a token sender.\\n    event Sender(address sender, address grantedSender);\\n\\n    /// A new token receiver has been added.\\n    /// @param sender `msg.sender` that approved the token receiver.\\n    /// @param grantedReceiver address that is now a token receiver.\\n    event Receiver(address sender, address grantedReceiver);\\n\\n    /// RedeemableERC20 uses the standard/default 18 ERC20 decimals.\\n    /// The minimum supply enforced by the constructor is \\\"one\\\" token which is\\n    /// `10 ** 18`.\\n    /// The minimum supply does not prevent subsequent redemption/burning.\\n    uint256 private constant MINIMUM_INITIAL_SUPPLY = 10**18;\\n\\n    /// Tier contract that produces the report that `minimumTier` is checked\\n    /// against.\\n    /// Public so external contracts can interface with the required tier.\\n    ITierV2 public tier;\\n\\n    /// The minimum status that a user must hold to receive transfers during\\n    /// `Phase.ZERO`.\\n    /// The tier contract passed to `TierByConstruction` determines if\\n    /// the status is held during `_beforeTokenTransfer`.\\n    /// Public so external contracts can interface with the required tier.\\n    uint256 public minimumTier;\\n\\n    /// Optional address to send rTKN to at the end of the distribution phase.\\n    /// If `0` address then all undistributed rTKN will burn itself at the end\\n    /// of the distribution.\\n    address private distributionEndForwardingAddress;\\n\\n    /// Mint the full ERC20 token supply and configure basic transfer\\n    /// restrictions. Initializes all base contracts.\\n    /// @param config_ Initialized configuration.\\n    function initialize(RedeemableERC20Config calldata config_)\\n        external\\n        initializer\\n    {\\n        initializePhased();\\n\\n        tier = ITierV2(config_.tier);\\n\\n        require(\\n            ERC165Checker.supportsInterface(\\n                config_.tier,\\n                type(ITierV2).interfaceId\\n            ),\\n            \\\"ERC165_TIERV2\\\"\\n        );\\n\\n        __ERC20_init(config_.erc20Config.name, config_.erc20Config.symbol);\\n\\n        require(\\n            config_.erc20Config.initialSupply >= MINIMUM_INITIAL_SUPPLY,\\n            \\\"MINIMUM_INITIAL_SUPPLY\\\"\\n        );\\n        minimumTier = config_.minimumTier;\\n        distributionEndForwardingAddress = config_\\n            .distributionEndForwardingAddress;\\n\\n        // Minting and burning must never fail.\\n        access[address(0)] = RECEIVER | SENDER;\\n\\n        // Admin receives full supply.\\n        access[config_.erc20Config.distributor] = RECEIVER;\\n\\n        // Forwarding address must be able to receive tokens.\\n        if (distributionEndForwardingAddress != address(0)) {\\n            access[distributionEndForwardingAddress] = RECEIVER;\\n        }\\n\\n        admin = config_.erc20Config.distributor;\\n\\n        // Need to mint after assigning access.\\n        _mint(\\n            config_.erc20Config.distributor,\\n            config_.erc20Config.initialSupply\\n        );\\n\\n        // The reserve must always be one of the treasury assets.\\n        newTreasuryAsset(config_.reserve);\\n\\n        emit Initialize(msg.sender, config_);\\n\\n        schedulePhase(PHASE_DISTRIBUTING, block.timestamp);\\n    }\\n\\n    /// Require a function is only admin callable.\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"ONLY_ADMIN\\\");\\n        _;\\n    }\\n\\n    /// Check that an address is a receiver.\\n    /// A sender is also a receiver.\\n    /// @param maybeReceiver_ account to check.\\n    /// @return True if account is a receiver.\\n    function isReceiver(address maybeReceiver_) public view returns (bool) {\\n        return access[maybeReceiver_] & RECEIVER > 0;\\n    }\\n\\n    /// Admin can grant an address receiver rights.\\n    /// @param newReceiver_ The account to grand receiver.\\n    function grantReceiver(address newReceiver_) external onlyAdmin {\\n        // Using `|` preserves sender if previously granted.\\n        access[newReceiver_] |= RECEIVER;\\n        emit Receiver(msg.sender, newReceiver_);\\n    }\\n\\n    /// Check that an address is a sender.\\n    /// @param maybeSender_ account to check.\\n    /// @return True if account is a sender.\\n    function isSender(address maybeSender_) public view returns (bool) {\\n        return access[maybeSender_] & SENDER > 0;\\n    }\\n\\n    /// Admin can grant an addres sender rights.\\n    /// @param newSender_ The account to grant sender.\\n    function grantSender(address newSender_) external onlyAdmin {\\n        // Uinsg `|` preserves receiver if previously granted.\\n        access[newSender_] |= SENDER;\\n        emit Sender(msg.sender, newSender_);\\n    }\\n\\n    /// The admin can forward or burn all tokens of a single address to end\\n    /// `PHASE_DISTRIBUTING`.\\n    /// The intent is that during `PHASE_DISTRIBUTING` there is some contract\\n    /// responsible for distributing the tokens.\\n    /// The admin specifies the distributor to end `PHASE_DISTRIBUTING` and the\\n    /// forwarding address set during initialization is used. If the forwarding\\n    /// address is `0` the rTKN will be burned, otherwise the entire balance of\\n    /// the distributor is forwarded to the nominated address. In practical\\n    /// terms the forwarding allows for escrow depositors to receive a prorata\\n    /// claim on unsold rTKN if they forward it to themselves, otherwise raise\\n    /// participants will receive a greater share of the final escrowed tokens\\n    /// due to the burn reducing the total supply.\\n    /// The distributor is NOT set during the constructor because it may not\\n    /// exist at that point. For example, Balancer needs the paired erc20\\n    /// tokens to exist before the trading pool can be built.\\n    /// @param distributor_ The distributor according to the admin.\\n    /// BURN the tokens if `address(0)`.\\n    function endDistribution(address distributor_)\\n        external\\n        onlyPhase(PHASE_DISTRIBUTING)\\n        onlyAdmin\\n    {\\n        schedulePhase(PHASE_FROZEN, block.timestamp);\\n        address forwardTo_ = distributionEndForwardingAddress;\\n        uint256 distributorBalance_ = balanceOf(distributor_);\\n        if (distributorBalance_ > 0) {\\n            if (forwardTo_ == address(0)) {\\n                _burn(distributor_, distributorBalance_);\\n            } else {\\n                _transfer(distributor_, forwardTo_, distributorBalance_);\\n            }\\n        }\\n    }\\n\\n    /// Wraps `_redeem` from `ERC20Redeem`.\\n    /// Very thin wrapper so be careful when calling!\\n    /// @param treasuryAssets_ The treasury assets to redeem for. If this is\\n    /// empty or incomplete then tokens will be permanently burned for no\\n    /// reason by the caller and the remaining funds will be effectively\\n    /// redistributed to everyone else.\\n    function redeem(IERC20[] calldata treasuryAssets_, uint256 redeemAmount_)\\n        external\\n        onlyPhase(PHASE_FROZEN)\\n    {\\n        _redeem(treasuryAssets_, redeemAmount_);\\n    }\\n\\n    /// Apply phase sensitive transfer restrictions.\\n    /// During `Phase.ZERO` only tier requirements apply.\\n    /// During `Phase.ONE` all transfers except burns are prevented.\\n    /// If a transfer involves either a sender or receiver with the SENDER\\n    /// or RECEIVER role, respectively, it will bypass these restrictions.\\n    /// @inheritdoc ERC20Upgradeable\\n    function _beforeTokenTransfer(\\n        address sender_,\\n        address receiver_,\\n        uint256 amount_\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(sender_, receiver_, amount_);\\n\\n        // Sending tokens to this contract (e.g. instead of redeeming) is\\n        // always an error.\\n        require(receiver_ != address(this), \\\"TOKEN_SEND_SELF\\\");\\n\\n        // Some contracts may attempt a preflight (e.g. Balancer) of a 0 amount\\n        // transfer.\\n        // We don't want to accidentally cause external errors due to zero\\n        // value transfers.\\n        if (\\n            amount_ > 0 &&\\n            // The sender and receiver lists bypass all access restrictions.\\n            !(isSender(sender_) || isReceiver(receiver_))\\n        ) {\\n            // During `PHASE_DISTRIBUTING` transfers are only restricted by the\\n            // tier of the recipient. Every other phase only allows senders and\\n            // receivers as above.\\n            require(currentPhase() == PHASE_DISTRIBUTING, \\\"FROZEN\\\");\\n\\n            // Receivers act as \\\"hubs\\\" that can send to \\\"spokes\\\".\\n            // i.e. any address of the minimum tier.\\n            // Spokes cannot send tokens another \\\"hop\\\" e.g. to each other.\\n            // Spokes can only send back to a receiver (doesn't need to be\\n            // the same receiver they received from).\\n            require(isReceiver(sender_), \\\"2SPOKE\\\");\\n            require(\\n                TierReport.tierAtTimeFromReport(\\n                    tier.report(receiver_, new uint256[](0)),\\n                    block.timestamp\\n                ) >= minimumTier,\\n                \\\"MIN_TIER\\\"\\n            );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb9f6ce4a352972cbd5205a2c3dca2778cb0ba4dcdf204c7b645c3c72896e89be\",\"license\":\"CAL\"},\"contracts/redeemableERC20/RedeemableERC20Factory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {Factory} from \\\"../factory/Factory.sol\\\";\\nimport {RedeemableERC20, RedeemableERC20Config} from \\\"./RedeemableERC20.sol\\\";\\nimport {ITierV2} from \\\"../tier/ITierV2.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\n\\n/// @title RedeemableERC20Factory\\n/// @notice Factory for deploying and registering `RedeemableERC20` contracts.\\ncontract RedeemableERC20Factory is Factory {\\n    /// Template contract to clone.\\n    /// Deployed by the constructor.\\n    address public immutable implementation;\\n\\n    /// Build the reference implementation to clone for each child.\\n    constructor() {\\n        address implementation_ = address(new RedeemableERC20());\\n        emit Implementation(msg.sender, implementation_);\\n        implementation = implementation_;\\n    }\\n\\n    /// @inheritdoc Factory\\n    function _createChild(bytes calldata data_)\\n        internal\\n        virtual\\n        override\\n        returns (address)\\n    {\\n        RedeemableERC20Config memory config_ = abi.decode(\\n            data_,\\n            (RedeemableERC20Config)\\n        );\\n        address clone_ = Clones.clone(implementation);\\n        RedeemableERC20(clone_).initialize(config_);\\n        return clone_;\\n    }\\n\\n    /// Allows calling `createChild` with `RedeemableERC20Config` struct.\\n    /// Use original `Factory` `createChild` function signature if function\\n    /// parameters are already encoded.\\n    ///\\n    /// @param config_ `RedeemableERC20` initializer configuration.\\n    /// @return New `RedeemableERC20` child contract.\\n    function createChildTyped(RedeemableERC20Config calldata config_)\\n        external\\n        returns (RedeemableERC20)\\n    {\\n        return RedeemableERC20(this.createChild(abi.encode(config_)));\\n    }\\n}\\n\",\"keccak256\":\"0x9d84ff8195df9423a3f2fdf58a3b15d2b2db974a9fd9e6201176f667895e8c0b\",\"license\":\"CAL\"},\"contracts/sale/ISale.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// An `ISale` can be in one of 4 possible states and a linear progression is\\n/// expected from an \\\"in flight\\\" status to an immutable definitive outcome.\\n/// - Pending: The sale is deployed onchain but cannot be interacted with yet.\\n/// - Active: The sale can now be bought into and otherwise interacted with.\\n/// - Success: The sale has ended AND reached its minimum raise target.\\n/// - Fail: The sale has ended BUT NOT reached its minimum raise target.\\n/// Once an `ISale` reaches `Active` it MUST NOT return `Pending` ever again.\\n/// Once an `ISale` reaches `Success` or `Fail` it MUST NOT return any other\\n/// status ever again.\\nenum SaleStatus {\\n    Pending,\\n    Active,\\n    Success,\\n    Fail\\n}\\n\\ninterface ISale {\\n    /// Returns the address of the token being sold in the sale.\\n    /// MUST NOT change during the lifecycle of the sale contract.\\n    function token() external view returns (address);\\n\\n    /// Returns the address of the token that sale prices are denominated in.\\n    /// MUST NOT change during the lifecycle of the sale contract.\\n    function reserve() external view returns (address);\\n\\n    /// Returns the current `SaleStatus` of the sale.\\n    /// Represents a linear progression of the sale through its major lifecycle\\n    /// events.\\n    function saleStatus() external view returns (SaleStatus);\\n}\\n\",\"keccak256\":\"0x05ea99f5e024326b2964dfed6c49b895376826e7115265978ceeccd9278a5b20\",\"license\":\"CAL\"},\"contracts/sale/Sale.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {Cooldown} from \\\"../cooldown/Cooldown.sol\\\";\\n\\nimport \\\"../math/FixedPointMath.sol\\\";\\nimport \\\"../vm/RainVM.sol\\\";\\nimport {AllStandardOps} from \\\"../vm/ops/AllStandardOps.sol\\\";\\nimport {ERC20Config} from \\\"../erc20/ERC20Config.sol\\\";\\nimport \\\"./ISale.sol\\\";\\n//solhint-disable-next-line max-line-length\\nimport {RedeemableERC20, RedeemableERC20Config} from \\\"../redeemableERC20/RedeemableERC20.sol\\\";\\n//solhint-disable-next-line max-line-length\\nimport {RedeemableERC20Factory} from \\\"../redeemableERC20/RedeemableERC20Factory.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n// solhint-disable-next-line max-line-length\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n// solhint-disable-next-line max-line-length\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport \\\"../sstore2/SSTORE2.sol\\\";\\nimport \\\"../vm/VMStateBuilder.sol\\\";\\n\\n/// Everything required to construct a Sale (not initialize).\\n/// @param maximumSaleTimeout The sale timeout set in initialize cannot exceed\\n/// this. Avoids downstream escrows and similar trapping funds due to sales\\n/// that never end, or perhaps never even start.\\n/// @param maximumCooldownDuration The cooldown duration set in initialize\\n/// cannot exceed this. Avoids the \\\"no refunds\\\" situation where someone sets an\\n/// infinite cooldown, then accidentally or maliciously the sale ends up in a\\n/// state where it cannot end (bad \\\"can end\\\" script), leading to trapped funds.\\n/// @param redeemableERC20Factory The factory contract that creates redeemable\\n/// erc20 tokens that the `Sale` can mint, sell and burn.\\nstruct SaleConstructorConfig {\\n    uint256 maximumSaleTimeout;\\n    uint256 maximumCooldownDuration;\\n    RedeemableERC20Factory redeemableERC20Factory;\\n    address vmStateBuilder;\\n}\\n\\n/// Everything required to configure (initialize) a Sale.\\n/// @param canStartStateConfig State config for the script that allows a Sale\\n/// to start.\\n/// @param canEndStateConfig State config for the script that allows a Sale to\\n/// end. IMPORTANT: A Sale can always end if/when its rTKN sells out,\\n/// regardless of the result of this script.\\n/// @param calculatePriceStateConfig State config for the script that defines\\n/// the current price quoted by a Sale.\\n/// @param recipient The recipient of the proceeds of a Sale, if/when the Sale\\n/// is successful.\\n/// @param reserve The reserve token the Sale is deonominated in.\\n/// @param saleTimeout The number of seconds before this sale can timeout.\\n/// SHOULD be well after the expected end time as a timeout will fail an active\\n/// or pending sale regardless of any funds raised.\\n/// @param cooldownDuration forwarded to `Cooldown` contract initialization.\\n/// @param minimumRaise defines the amount of reserve required to raise that\\n/// defines success/fail of the sale. Reaching the minimum raise DOES NOT cause\\n/// the raise to end early (unless the \\\"can end\\\" script allows it of course).\\n/// @param dustSize The minimum amount of rTKN that must remain in the Sale\\n/// contract unless it is all purchased, clearing the raise to 0 stock and thus\\n/// ending the raise.\\nstruct SaleConfig {\\n    StateConfig vmStateConfig;\\n    address recipient;\\n    address reserve;\\n    uint256 saleTimeout;\\n    uint256 cooldownDuration;\\n    uint256 minimumRaise;\\n    uint256 dustSize;\\n}\\n\\n/// Forwarded config to RedeemableERC20 initialization.\\nstruct SaleRedeemableERC20Config {\\n    ERC20Config erc20Config;\\n    address tier;\\n    uint256 minimumTier;\\n    address distributionEndForwardingAddress;\\n}\\n\\n/// Defines a request to buy rTKN from an active sale.\\n/// @param feeRecipient Optional recipient to send fees to. Intended to be a\\n/// \\\"tip\\\" for the front-end client that the buyer is using to fund development,\\n/// infrastructure, etc.\\n/// @param fee Size of the optional fee to send to the recipient. Denominated\\n/// in the reserve token of the `Sale` contract.\\n/// @param minimumUnits The minimum size of the buy. If the sale is close to\\n/// selling out then the buyer may not fulfill their entire order, so this sets\\n/// the minimum units the buyer is willing to accept for their order. MAY be 0\\n/// if the buyer is willing to accept any amount of tokens.\\n/// @param desiredUnits The maximum and desired size of the buy. The sale will\\n/// always attempt to fulfill the buy order to the maximum rTKN amount possible\\n/// according to the unsold stock on hand. Typically all the desired units will\\n/// clear but as the sale runs low on stock it may not be able to.\\n/// @param maximumPrice As the price quoted by the sale is a programmable curve\\n/// it may change rapidly between when the buyer submitted a transaction to the\\n/// mempool and when it is mined. Setting a maximum price is akin to setting\\n/// slippage on a traditional AMM. The transaction will revert if the sale\\n/// price exceeds the buyer's maximum.\\nstruct BuyConfig {\\n    address feeRecipient;\\n    uint256 fee;\\n    uint256 minimumUnits;\\n    uint256 desiredUnits;\\n    uint256 maximumPrice;\\n}\\n\\n/// Defines the receipt for a successful buy.\\n/// The receipt includes the final units and price paid for rTKN, which are\\n/// known as possible ranges in `BuyConfig`.\\n/// Importantly a receipt allows a buy to be reversed for as long as the sale\\n/// is active, subject to buyer cooldowns as per `Cooldown`. In the case of a\\n/// finalized but failed sale, all buyers can immediately process refunds for\\n/// their receipts without cooldown. As the receipt is crucial to the refund\\n/// process every receipt is logged so it can be indexed and never lost, and\\n/// unique IDs bound to the buyer in onchain storage prevent receipts from\\n/// being used in a fraudulent context. The entire receipt including the id is\\n/// hashed in the storage mapping that binds it to a buyer so that a buyer\\n/// cannot change the receipt offchain to claim fraudulent refunds.\\n/// Front-end fees are also tracked and refunded for each receipt, to prevent\\n/// front end clients from gaming/abusing sale contracts.\\n/// @param id Every receipt is assigned a sequential ID to ensure uniqueness\\n/// across all receipts.\\n/// @param feeRecipient as per `BuyConfig`.\\n/// @param fee as per `BuyConfig`.\\n/// @param units number of rTKN bought and refundable.\\n/// @param price price paid per unit denominated and refundable in reserve.\\nstruct Receipt {\\n    uint256 id;\\n    address feeRecipient;\\n    uint256 fee;\\n    uint256 units;\\n    uint256 price;\\n}\\n\\nuint256 constant CAN_LIVE_ENTRYPOINT = 0;\\nuint256 constant CALCULATE_PRICE_ENTRYPOINT = 1;\\n\\nuint256 constant CAN_LIVE_MIN_FINAL_STACK_INDEX = 1;\\nuint256 constant CALCULATE_PRICE_MIN_FINAL_STACK_INDEX = 2;\\n\\nuint256 constant STORAGE_OPCODES_LENGTH = 4;\\n\\n// solhint-disable-next-line max-states-count\\ncontract Sale is Initializable, Cooldown, RainVM, ISale, ReentrancyGuard {\\n    using Math for uint256;\\n    using FixedPointMath for uint256;\\n    using SafeERC20 for IERC20;\\n    using LibState for State;\\n\\n    /// Contract is constructing.\\n    /// @param sender `msg.sender` of the contract deployer.\\n    event Construct(address sender, SaleConstructorConfig config);\\n    /// Contract is initializing (being cloned by factory).\\n    /// @param sender `msg.sender` of the contract initializer (cloner).\\n    /// @param config All initialization config passed by the sender.\\n    /// @param token The freshly deployed and minted rTKN for the sale.\\n    event Initialize(address sender, SaleConfig config, address token);\\n    /// Sale is started (moved to active sale state).\\n    /// @param sender `msg.sender` that started the sale.\\n    event Start(address sender);\\n    /// Sale has ended (moved to success/fail sale state).\\n    /// @param sender `msg.sender` that ended the sale.\\n    /// @param saleStatus The final success/fail state of the sale.\\n    event End(address sender, SaleStatus saleStatus);\\n    /// Sale has failed due to a timeout (failed to even start/end).\\n    /// @param sender `msg.sender` that timed out the sale.\\n    event Timeout(address sender);\\n    /// rTKN being bought.\\n    /// Importantly includes the receipt that sender can use to apply for a\\n    /// refund later if they wish.\\n    /// @param sender `msg.sender` buying rTKN.\\n    /// @param config All buy config passed by the sender.\\n    /// @param receipt The purchase receipt, can be used to claim refunds.\\n    event Buy(address sender, BuyConfig config, Receipt receipt);\\n    /// rTKN being refunded.\\n    /// Includes the receipt used to justify the refund.\\n    event Refund(address sender, Receipt receipt);\\n\\n    address private immutable self;\\n    address private immutable vmStateBuilder;\\n\\n    /// @dev the saleTimeout cannot exceed this. Prevents downstream contracts\\n    /// that require a finalization such as escrows from getting permanently\\n    /// stuck in a pending or active status due to buggy scripts.\\n    uint256 private immutable maximumSaleTimeout;\\n\\n    /// *** STORAGE OPCODES START ***\\n\\n    /// @dev remaining rTKN units to sell. MAY NOT be the rTKN balance of the\\n    /// Sale contract if rTKN has been sent directly to the sale contract\\n    /// outside the standard buy/refund loop.\\n    uint256 private _remainingUnits;\\n\\n    /// @dev total reserve taken in to the sale contract via. buys. Does NOT\\n    /// include any reserve sent directly to the sale contract outside the\\n    /// standard buy/refund loop.\\n    uint256 private _totalReserveIn;\\n\\n    /// Minted rTKN for each sale.\\n    /// Exposed via. `ISale.token()`.\\n    /// Represented as uint NOT address so that it is VM safe.\\n    uint256 private _token;\\n\\n    /// @dev as per `SaleConfig`.\\n    /// Exposed via. `ISale.reserve()`.\\n    /// Represented as uint NOT address so that it is VM safe.\\n    uint256 private _reserve;\\n\\n    /// *** STORAGE OPCODES END ***\\n\\n    /// Factory responsible for minting rTKN.\\n    RedeemableERC20Factory private immutable redeemableERC20Factory;\\n\\n    /// @dev as per `SaleConfig`.\\n    address private recipient;\\n    /// @dev as per `SaleConfig`.\\n    address private vmStatePointer;\\n    /// @dev as per `SaleConfig`.\\n    uint256 private minimumRaise;\\n    /// @dev as per `SaleConfig`.\\n    uint256 private dustSize;\\n\\n    /// @dev the current sale status exposed as `ISale.saleStatus`.\\n    SaleStatus private _saleStatus;\\n    /// @dev the current sale can always end in failure at this time even if\\n    /// it did not start. Provided it did not already end of course.\\n    uint256 private saleTimeoutStamp;\\n\\n    /// @dev Binding buyers to receipt hashes to maybe a non-zero value.\\n    /// A receipt will only be honoured if the mapping resolves to non-zero.\\n    /// The receipt hashing ensures that receipts cannot be manipulated before\\n    /// redemption. Each mapping is deleted if/when receipt is used for refund.\\n    /// Buyer => keccak receipt => exists (1+ or 0).\\n    mapping(address => mapping(bytes32 => uint256)) private receipts;\\n    /// @dev simple incremental counter to keep all receipts unique so that\\n    /// receipt hashes bound to buyers never collide.\\n    uint256 private nextReceiptId;\\n\\n    /// @dev Tracks combined fees per recipient to be claimed if/when a sale\\n    /// is successful.\\n    /// Fee recipient => unclaimed fees.\\n    mapping(address => uint256) private fees;\\n\\n    constructor(SaleConstructorConfig memory config_) {\\n        self = address(this);\\n        vmStateBuilder = config_.vmStateBuilder;\\n        maximumSaleTimeout = config_.maximumSaleTimeout;\\n\\n        redeemableERC20Factory = config_.redeemableERC20Factory;\\n\\n        emit Construct(msg.sender, config_);\\n    }\\n\\n    function initialize(\\n        SaleConfig calldata config_,\\n        SaleRedeemableERC20Config memory saleRedeemableERC20Config_\\n    ) external initializer {\\n        initializeCooldown(config_.cooldownDuration);\\n\\n        require(config_.saleTimeout <= maximumSaleTimeout, \\\"MAX_TIMEOUT\\\");\\n        saleTimeoutStamp = block.timestamp + config_.saleTimeout;\\n\\n        // 0 minimum raise is ambiguous as to how it should be handled. It\\n        // literally means \\\"the raise succeeds without any trades\\\", which\\n        // doesn't have a clear way to move funds around as there are no\\n        // recipients of potentially escrowed or redeemable funds. There needs\\n        // to be at least 1 reserve token paid from 1 buyer in order to\\n        // meaningfully process success logic.\\n        require(config_.minimumRaise > 0, \\\"MIN_RAISE_0\\\");\\n        minimumRaise = config_.minimumRaise;\\n\\n        Bounds memory canLiveBounds_;\\n        canLiveBounds_.entrypoint = CAN_LIVE_ENTRYPOINT;\\n        canLiveBounds_.minFinalStackIndex = CAN_LIVE_MIN_FINAL_STACK_INDEX;\\n        Bounds memory calculatePriceBounds_;\\n        calculatePriceBounds_.entrypoint = CALCULATE_PRICE_ENTRYPOINT;\\n        calculatePriceBounds_\\n            .minFinalStackIndex = CALCULATE_PRICE_MIN_FINAL_STACK_INDEX;\\n        Bounds[] memory boundss_ = new Bounds[](2);\\n        boundss_[0] = canLiveBounds_;\\n        boundss_[1] = calculatePriceBounds_;\\n        bytes memory vmStateBytes_ = VMStateBuilder(vmStateBuilder).buildState(\\n            self,\\n            config_.vmStateConfig,\\n            boundss_\\n        );\\n        vmStatePointer = SSTORE2.write(vmStateBytes_);\\n        recipient = config_.recipient;\\n\\n        dustSize = config_.dustSize;\\n\\n        // just making this explicit during initialization in case it ever\\n        // takes a nonzero value somehow due to refactor.\\n        _saleStatus = SaleStatus.Pending;\\n\\n        _reserve = uint256(uint160(config_.reserve));\\n\\n        // The distributor of the rTKN is always set to the sale contract.\\n        // It is an error for the deployer to attempt to set the distributor.\\n        require(\\n            saleRedeemableERC20Config_.erc20Config.distributor == address(0),\\n            \\\"DISTRIBUTOR_SET\\\"\\n        );\\n        saleRedeemableERC20Config_.erc20Config.distributor = address(this);\\n\\n        _remainingUnits = saleRedeemableERC20Config_.erc20Config.initialSupply;\\n\\n        address token_ = redeemableERC20Factory.createChild(\\n            abi.encode(\\n                RedeemableERC20Config(\\n                    address(config_.reserve),\\n                    saleRedeemableERC20Config_.erc20Config,\\n                    saleRedeemableERC20Config_.tier,\\n                    saleRedeemableERC20Config_.minimumTier,\\n                    saleRedeemableERC20Config_.distributionEndForwardingAddress\\n                )\\n            )\\n        );\\n        _token = uint256(uint160(token_));\\n\\n        emit Initialize(msg.sender, config_, address(token_));\\n    }\\n\\n    /// @inheritdoc RainVM\\n    function storageOpcodesRange()\\n        public\\n        pure\\n        override\\n        returns (StorageOpcodesRange memory)\\n    {\\n        uint256 pointer_;\\n        assembly {\\n            pointer_ := _remainingUnits.slot\\n        }\\n        return StorageOpcodesRange(pointer_, STORAGE_OPCODES_LENGTH);\\n    }\\n\\n    /// @inheritdoc ISale\\n    function token() external view returns (address) {\\n        return address(uint160(_token));\\n    }\\n\\n    /// @inheritdoc ISale\\n    function reserve() external view returns (address) {\\n        return address(uint160(_reserve));\\n    }\\n\\n    /// @inheritdoc ISale\\n    function saleStatus() external view returns (SaleStatus) {\\n        return _saleStatus;\\n    }\\n\\n    function _loadState() internal view returns (State memory) {\\n        return LibState.fromBytesPacked(SSTORE2.read(vmStatePointer));\\n    }\\n\\n    /// Can the Sale live?\\n    /// Evals the \\\"can live\\\" script.\\n    /// If a non zero value is returned then the sale can move from pending to\\n    /// active, or remain active.\\n    /// If a zero value is returned the sale can remain pending or move from\\n    /// active to a finalised status.\\n    /// An out of stock (0 remaining units) WILL ALWAYS return `false` without\\n    /// evaluating the script.\\n    function _canLive(State memory state_) internal view returns (bool) {\\n        unchecked {\\n            if (_remainingUnits < 1) {\\n                return false;\\n            }\\n            eval(\\\"\\\", state_, CAN_LIVE_ENTRYPOINT);\\n            bool canLive_ = state_.stack[state_.stackIndex - 1] > 0;\\n            state_.reset();\\n            return canLive_;\\n        }\\n    }\\n\\n    /// Calculates the current reserve price quoted for 1 unit of rTKN.\\n    /// Used internally to process `buy`.\\n    /// @param targetUnits_ Amount of rTKN to quote a price and units for, will\\n    /// be available to the price script from OPCODE_CURRENT_BUY_UNITS. When\\n    /// `buy` executes the target units will be the smaller of the remaining\\n    /// stock and the desired units set by the caller.\\n    /// @return (maxUnits, price) The top two items on the stack are used for\\n    /// the units and price. When `buy` executes the real purchase size will be\\n    /// the smaller of the target units and the returned maximum units. If this\\n    /// is below the buyer's minimum the buy will revert.\\n    function _calculateBuy(State memory state_, uint256 targetUnits_)\\n        internal\\n        view\\n        returns (uint256, uint256)\\n    {\\n        unchecked {\\n            bytes memory context_ = new bytes(0x20);\\n            assembly {\\n                mstore(add(context_, 0x20), targetUnits_)\\n            }\\n            eval(context_, state_, CALCULATE_PRICE_ENTRYPOINT);\\n\\n            (uint256 maxUnits_, uint256 price_) = (\\n                state_.stack[state_.stackIndex - 2],\\n                state_.stack[state_.stackIndex - 1]\\n            );\\n            state_.reset();\\n            return (maxUnits_, price_);\\n        }\\n    }\\n\\n    function _start() internal {\\n        _saleStatus = SaleStatus.Active;\\n        emit Start(msg.sender);\\n    }\\n\\n    function _end() internal {\\n        bool success_ = _totalReserveIn >= minimumRaise;\\n        SaleStatus endStatus_ = success_ ? SaleStatus.Success : SaleStatus.Fail;\\n\\n        _remainingUnits = 0;\\n        _saleStatus = endStatus_;\\n        emit End(msg.sender, endStatus_);\\n        RedeemableERC20(address(uint160(_token))).endDistribution(\\n            address(this)\\n        );\\n\\n        // Only send reserve to recipient if the raise is a success.\\n        // If the raise is NOT a success then everyone can refund their reserve\\n        // deposited individually.\\n        if (success_) {\\n            IERC20(address(uint160(_reserve))).safeTransfer(\\n                recipient,\\n                _totalReserveIn\\n            );\\n        }\\n    }\\n\\n    function canLive() external view returns (bool) {\\n        return _canLive(_loadState());\\n    }\\n\\n    function calculateBuy(uint256 targetUnits_)\\n        external\\n        view\\n        returns (uint256, uint256)\\n    {\\n        return _calculateBuy(_loadState(), targetUnits_);\\n    }\\n\\n    /// Start the sale (move from pending to active).\\n    /// This is also done automatically inline with each `buy` call so is\\n    /// optional for anon to call outside of a purchase.\\n    /// `canStart` MUST return true.\\n    function start() external {\\n        require(_saleStatus == SaleStatus.Pending, \\\"NOT_PENDING\\\");\\n        require(_canLive(_loadState()), \\\"NOT_LIVE\\\");\\n        _start();\\n    }\\n\\n    /// End the sale (move from active to success or fail).\\n    /// This is also done automatically inline with each `buy` call so is\\n    /// optional for anon to call outside of a purchase.\\n    /// `canEnd` MUST return true.\\n    function end() external {\\n        require(_saleStatus == SaleStatus.Active, \\\"NOT_ACTIVE\\\");\\n        require(!_canLive(_loadState()), \\\"LIVE\\\");\\n        _end();\\n    }\\n\\n    /// Timeout the sale (move from pending or active to fail).\\n    /// The ONLY condition for a timeout is that the `saleTimeout` block set\\n    /// during initialize is in the past. This means that regardless of what\\n    /// happens re: starting, ending, buying, etc. if the sale does NOT manage\\n    /// to unambiguously end by the timeout block then it can timeout to a fail\\n    /// state. This means that any downstream escrows or similar can always\\n    /// expect that eventually they will see a pass/fail state and so are safe\\n    /// to lock funds while a Sale is active.\\n    function timeout() external {\\n        require(saleTimeoutStamp < block.timestamp, \\\"EARLY_TIMEOUT\\\");\\n        require(\\n            _saleStatus == SaleStatus.Pending ||\\n                _saleStatus == SaleStatus.Active,\\n            \\\"ALREADY_ENDED\\\"\\n        );\\n\\n        // Mimic `end` with a failed state but `Timeout` event.\\n        _remainingUnits = 0;\\n        _saleStatus = SaleStatus.Fail;\\n        emit Timeout(msg.sender);\\n        RedeemableERC20(address(uint160(_token))).endDistribution(\\n            address(this)\\n        );\\n    }\\n\\n    /// Main entrypoint to the sale. Sells rTKN in exchange for reserve token.\\n    /// The price curve is eval'd to produce a reserve price quote. Each 1 unit\\n    /// of rTKN costs `price` reserve token where BOTH the rTKN units and price\\n    /// are treated as 18 decimal fixed point values. If the reserve token has\\n    /// more or less precision by its own conventions (e.g. \\\"decimals\\\" method\\n    /// on ERC20 tokens) then the price will need to scale accordingly.\\n    /// The receipt is _logged_ rather than returned as it cannot be used in\\n    /// same block for a refund anyway due to cooldowns.\\n    /// @param config_ All parameters to configure the purchase.\\n    function buy(BuyConfig memory config_)\\n        external\\n        onlyAfterCooldown\\n        nonReentrant\\n    {\\n        require(0 < config_.minimumUnits, \\\"0_MINIMUM\\\");\\n        require(\\n            config_.minimumUnits <= config_.desiredUnits,\\n            \\\"MINIMUM_OVER_DESIRED\\\"\\n        );\\n\\n        // This state is loaded once and shared between 2x `_canLive` calls and\\n        // a `_calculateBuy` call.\\n        State memory state_ = _loadState();\\n\\n        // Start or end the sale as required.\\n        if (_canLive(state_)) {\\n            if (_saleStatus == SaleStatus.Pending) {\\n                _start();\\n            }\\n        } else {\\n            if (_saleStatus == SaleStatus.Active) {\\n                _end();\\n            }\\n        }\\n\\n        // Check the status AFTER possibly modifying it to ensure the potential\\n        // modification is respected.\\n        require(_saleStatus == SaleStatus.Active, \\\"NOT_ACTIVE\\\");\\n\\n        uint256 targetUnits_ = config_.desiredUnits.min(_remainingUnits);\\n\\n        (uint256 maxUnits_, uint256 price_) = _calculateBuy(\\n            state_,\\n            targetUnits_\\n        );\\n\\n        // The script may return a larger max units than the target so we have\\n        // to cap it to prevent the sale selling more than requested. Scripts\\n        // SHOULD NOT exceed the target units as it may be confusing to end\\n        // users but it MUST be safe from the sale's perspective to do so.\\n        // Scripts MAY return max units lower than the target units to enforce\\n        // per-user or other purchase limits.\\n        uint256 units_ = maxUnits_.min(targetUnits_);\\n        require(units_ >= config_.minimumUnits, \\\"INSUFFICIENT_STOCK\\\");\\n\\n        require(price_ <= config_.maximumPrice, \\\"MAXIMUM_PRICE\\\");\\n        uint256 cost_ = price_.fixedPointMul(units_);\\n\\n        Receipt memory receipt_ = Receipt(\\n            nextReceiptId,\\n            config_.feeRecipient,\\n            config_.fee,\\n            units_,\\n            price_\\n        );\\n        nextReceiptId++;\\n        // There should never be more than one of the same key due to the ID\\n        // counter but we can use checked math to easily cover the case of\\n        // potential duplicate receipts due to some bug.\\n        receipts[msg.sender][keccak256(abi.encode(receipt_))]++;\\n\\n        fees[config_.feeRecipient] += config_.fee;\\n\\n        // We ignore any rTKN or reserve that is sent to the contract directly\\n        // outside of a `buy` call. This also means we don't support reserve\\n        // tokens with balances that can change outside of transfers\\n        // (e.g. rebase).\\n        _remainingUnits -= units_;\\n        _totalReserveIn += cost_;\\n\\n        // This happens before `end` so that the transfer from happens before\\n        // the transfer to.\\n        // `end` changes state so `buy` needs to be nonReentrant.\\n        IERC20(address(uint160(_reserve))).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            cost_ + config_.fee\\n        );\\n        // This happens before `end` so that the transfer happens before the\\n        // distributor is burned and token is frozen.\\n        IERC20(address(uint160(_token))).safeTransfer(msg.sender, units_);\\n\\n        emit Buy(msg.sender, config_, receipt_);\\n\\n        // Enforce the status of the sale after the purchase.\\n        // The sale ending AFTER the purchase does NOT rollback the purchase,\\n        // it simply prevents further purchases.\\n        if (_canLive(state_)) {\\n            // This prevents the sale from being left with so little stock that\\n            // nobody else will want to clear it out. E.g. the dust might be\\n            // worth significantly less than the price of gas to call `buy`.\\n            require(_remainingUnits >= dustSize, \\\"DUST\\\");\\n        } else {\\n            _end();\\n        }\\n    }\\n\\n    /// @dev This is here so we can use a modifier like a function call.\\n    function refundCooldown() private onlyAfterCooldown {}\\n\\n    /// Rollback a buy given its receipt.\\n    /// Ignoring gas (which cannot be refunded) the refund process rolls back\\n    /// all state changes caused by a buy, other than the receipt id increment.\\n    /// Refunds are limited by the global cooldown to mitigate rapid buy/refund\\n    /// cycling that could cause volatile price curves or other unwanted side\\n    /// effects for other sale participants. Cooldowns are bypassed if the sale\\n    /// ends and is a failure.\\n    /// @param receipt_ The receipt of the buy to rollback.\\n    function refund(Receipt calldata receipt_) external {\\n        require(_saleStatus != SaleStatus.Success, \\\"REFUND_SUCCESS\\\");\\n        // If the sale failed then cooldowns do NOT apply. Everyone should\\n        // immediately refund all their receipts.\\n        if (_saleStatus != SaleStatus.Fail) {\\n            refundCooldown();\\n        }\\n\\n        // Checked math here will prevent consuming a receipt that doesn't\\n        // exist or was already refunded as it will underflow.\\n        receipts[msg.sender][keccak256(abi.encode(receipt_))]--;\\n\\n        uint256 cost_ = receipt_.price.fixedPointMul(receipt_.units);\\n\\n        _totalReserveIn -= cost_;\\n        _remainingUnits += receipt_.units;\\n        fees[receipt_.feeRecipient] -= receipt_.fee;\\n\\n        emit Refund(msg.sender, receipt_);\\n\\n        IERC20(address(uint160(_token))).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            receipt_.units\\n        );\\n        IERC20(address(uint160(_reserve))).safeTransfer(\\n            msg.sender,\\n            cost_ + receipt_.fee\\n        );\\n    }\\n\\n    /// After a sale ends in success all fees collected for a recipient can be\\n    /// cleared. If the raise is active or fails then fees cannot be claimed as\\n    /// they are set aside in case of refund. A failed raise implies that all\\n    /// buyers should immediately refund and zero fees claimed.\\n    /// @param recipient_ The recipient to claim fees for. Does NOT need to be\\n    /// the `msg.sender`.\\n    function claimFees(address recipient_) external {\\n        require(_saleStatus == SaleStatus.Success, \\\"NOT_SUCCESS\\\");\\n        uint256 amount_ = fees[recipient_];\\n        if (amount_ > 0) {\\n            delete fees[recipient_];\\n            IERC20(address(uint160(_reserve))).safeTransfer(\\n                recipient_,\\n                amount_\\n            );\\n        }\\n    }\\n\\n    function fnPtrs() public pure override returns (bytes memory) {\\n        return AllStandardOps.fnPtrs();\\n    }\\n}\\n\",\"keccak256\":\"0x668007dafccf4ee4f0d7d82829512d4efe3fc1fb4c62778535d44ebd2d8c53cb\",\"license\":\"CAL\"},\"contracts/sale/SaleFactory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {Factory} from \\\"../factory/Factory.sol\\\";\\nimport \\\"./Sale.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\n\\n/// @title SaleFactory\\n/// @notice Factory for creating and deploying `Sale` contracts.\\ncontract SaleFactory is Factory {\\n    /// Template contract to clone.\\n    /// Deployed by the constructor.\\n    address private immutable implementation;\\n\\n    /// Build the reference implementation to clone for each child.\\n    constructor(SaleConstructorConfig memory config_) {\\n        address implementation_ = address(new Sale(config_));\\n        // silence slither.\\n        require(implementation_ != address(0), \\\"0_IMPLEMENTATION\\\");\\n        emit Implementation(msg.sender, implementation_);\\n        implementation = implementation_;\\n    }\\n\\n    /// @inheritdoc Factory\\n    function _createChild(bytes calldata data_)\\n        internal\\n        virtual\\n        override\\n        returns (address)\\n    {\\n        (\\n            SaleConfig memory config_,\\n            SaleRedeemableERC20Config memory saleRedeemableERC20Config_\\n        ) = abi.decode(data_, (SaleConfig, SaleRedeemableERC20Config));\\n        address clone_ = Clones.clone(implementation);\\n        Sale(clone_).initialize(config_, saleRedeemableERC20Config_);\\n        return clone_;\\n    }\\n\\n    /// Allows calling `createChild` with `SeedERC20Config` struct.\\n    /// Use original `Factory` `createChild` function signature if function\\n    /// parameters are already encoded.\\n    ///\\n    /// @param config_ `SaleConfig` constructor configuration.\\n    /// @return New `Sale` child contract.\\n    function createChildTyped(\\n        SaleConfig calldata config_,\\n        SaleRedeemableERC20Config calldata saleRedeemableERC20Config_\\n    ) external returns (Sale) {\\n        return\\n            Sale(\\n                this.createChild(\\n                    abi.encode(config_, saleRedeemableERC20Config_)\\n                )\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x3c5292d6ad368532cc3c366f705e5a5f9ff0eaabf3504b31c0624d7debd72215\",\"license\":\"CAL\"},\"contracts/sstore2/SSTORE2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\n\\nimport \\\"./utils/Bytecode.sol\\\";\\n\\n/**\\n  @title A key-value storage with auto-generated keys for storing chunks of\\n  data with a lower write & read cost.\\n  @author Agustin Aguilar <aa@horizon.io>\\n\\n  Readme: https://github.com/0xsequence/sstore2#readme\\n*/\\nlibrary SSTORE2 {\\n    error WriteError();\\n\\n    /**\\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\\n    @dev The pointer is a contract address with `_data` as code\\n    @param _data to be written\\n    @return pointer Pointer to the written `_data`\\n  */\\n    function write(bytes memory _data) internal returns (address pointer) {\\n        // Append 00 to _data so contract can't be called\\n        // Build init code\\n        bytes memory code = Bytecode.creationCodeFor(\\n            abi.encodePacked(hex\\\"00\\\", _data)\\n        );\\n\\n        // Deploy contract using create\\n        assembly {\\n            pointer := create(0, add(code, 32), mload(code))\\n        }\\n\\n        // Address MUST be non-zero\\n        if (pointer == address(0)) revert WriteError();\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first\\n    byte\\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @return data read from `_pointer` contract\\n  */\\n    function read(address _pointer) internal view returns (bytes memory) {\\n        return Bytecode.codeAt(_pointer, 1, type(uint256).max);\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first\\n    byte\\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @param _start number of bytes to skip\\n    @return data read from `_pointer` contract\\n  */\\n    function read(address _pointer, uint256 _start)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first\\n    byte\\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @param _start number of bytes to skip\\n    @param _end index before which to end extraction\\n    @return data read from `_pointer` contract\\n  */\\n    function read(\\n        address _pointer,\\n        uint256 _start,\\n        uint256 _end\\n    ) internal view returns (bytes memory) {\\n        return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\\n    }\\n}\\n\",\"keccak256\":\"0x233f8e9ad3717999efbf17923c0f16aaf910f79064aff273485237b4f2a1ef2f\",\"license\":\"MIT\"},\"contracts/sstore2/utils/Bytecode.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\n\\nlibrary Bytecode {\\n    error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\\n\\n    /**\\n    @notice Generate a creation code that results on a contract with `_code` as\\n    bytecode\\n    @param _code The returning value of the resulting `creationCode`\\n    @return creationCode (constructor) for new contract\\n  */\\n    function creationCodeFor(bytes memory _code)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        /*\\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\\n      0x01    0x80         0x80        DUP1                size size\\n      0x02    0x60         0x600e      PUSH1 14            14 size size\\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\\n      0x04    0x39         0x39        CODECOPY            size\\n      0x05    0x60         0x6000      PUSH1 00            0 size\\n      0x06    0xf3         0xf3        RETURN\\n      <CODE>\\n    */\\n\\n        return\\n            abi.encodePacked(\\n                hex\\\"63\\\",\\n                uint32(_code.length),\\n                hex\\\"80_60_0E_60_00_39_60_00_F3\\\",\\n                _code\\n            );\\n    }\\n\\n    /**\\n    @notice Returns the size of the code on a given address\\n    @param _addr Address that may or may not contain code\\n    @return size of the code on the given `_addr`\\n  */\\n    function codeSize(address _addr) internal view returns (uint256 size) {\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n    }\\n\\n    /**\\n    @notice Returns the code of a given address\\n    @dev It will fail if `_end < _start`\\n    @param _addr Address that may or may not contain code\\n    @param _start number of bytes of code to skip on read\\n    @param _end index before which to end extraction\\n    @return oCode read from `_addr` deployed bytecode\\n\\n    Forked: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\\n  */\\n    function codeAt(\\n        address _addr,\\n        uint256 _start,\\n        uint256 _end\\n    ) internal view returns (bytes memory oCode) {\\n        uint256 csize = codeSize(_addr);\\n        if (csize == 0) return bytes(\\\"\\\");\\n\\n        if (_start > csize) return bytes(\\\"\\\");\\n        if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end);\\n\\n        unchecked {\\n            uint256 reqSize = _end - _start;\\n            uint256 maxSize = csize - _start;\\n\\n            uint256 size = maxSize < reqSize ? maxSize : reqSize;\\n\\n            assembly {\\n                // allocate output byte array - this could also be done without\\n                // assembly\\n                // by using o_code = new bytes(size)\\n                oCode := mload(0x40)\\n                // new \\\"memory end\\\" including padding\\n                mstore(\\n                    0x40,\\n                    add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f)))\\n                )\\n                // store length in memory\\n                mstore(oCode, size)\\n                // actually retrieve the code, this needs assembly\\n                extcodecopy(_addr, add(oCode, 0x20), _start, size)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb113974373d234e70f518f0f7c3f34162c008031c168ba3b8ed12f438d5e7145\",\"license\":\"MIT\"},\"contracts/tier/ITierV2.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// @title ITierV2\\n/// @notice `ITierV2` is a simple interface that contracts can implement to\\n/// provide membership lists for other contracts.\\n///\\n/// There are many use-cases for a time-preserving conditional membership list.\\n///\\n/// Some examples include:\\n///\\n/// - Self-serve whitelist to participate in fundraising\\n/// - Lists of users who can claim airdrops and perks\\n/// - Pooling resources with implied governance/reward tiers\\n/// - POAP style attendance proofs allowing access to future exclusive events\\n///\\n/// @dev Standard interface to a tiered membership.\\n///\\n/// A \\\"membership\\\" can represent many things:\\n/// - Exclusive access.\\n/// - Participation in some event or process.\\n/// - KYC completion.\\n/// - Combination of sub-memberships.\\n/// - Etc.\\n///\\n/// The high level requirements for a contract implementing `ITierV2`:\\n/// - MUST represent held tiers as a `uint`.\\n/// - MUST implement `report`.\\n///   - The report is a `uint256` that SHOULD represent the time each tier has\\n///     been continuously held since encoded as `uint32`.\\n///   - The encoded tiers start at `1`; Tier `0` is implied if no tier has ever\\n///     been held.\\n///   - Tier `0` is NOT encoded in the report, it is simply the fallback value.\\n///   - If a tier is lost the time data is erased for that tier and will be\\n///     set if/when the tier is regained to the new time.\\n///   - If a tier is held but the historical time information is not available\\n///     the report MAY return `0x00000000` for all held tiers.\\n///   - Tiers that are lost or have never been held MUST return `0xFFFFFFFF`.\\n///   - Context can be a list of numbers that MAY pairwise define tiers such as\\n///     minimum thresholds, or MAY simply provide global context such as a\\n///     relevant NFT ID for example.\\n/// - MUST implement `reportTimeForTier`\\n///   - Functions exactly as `report` but only returns a single time for a\\n///     single tier\\n///   - MUST return the same time value `report` would for any given tier and\\n///     context combination.\\n///\\n/// So the four possible states and report values are:\\n/// - Tier is held and time is known: Timestamp is in the report\\n/// - Tier is held but time is NOT known: `0` is in the report\\n/// - Tier is NOT held: `0xFF..` is in the report\\n/// - Tier is unknown: `0xFF..` is in the report\\n///\\n/// The reason `context` is specified as a list of values rather than arbitrary\\n/// bytes is to allow clear and efficient compatibility with VM stacks. Some N\\n/// values can be taken from a VM stack and used directly as a context, which\\n/// would be difficult or impossible to ensure is safe for arbitrary bytes.\\ninterface ITierV2 {\\n    /// Same as report but only returns the time for a single tier.\\n    /// Often the implementing contract can calculate a single tier more\\n    /// efficiently than all 8 tiers. If the consumer only needs one or a few\\n    /// tiers it MAY be much cheaper to request only those tiers individually.\\n    /// This DOES NOT apply to all contracts, an obvious example is token\\n    /// balance based tiers which always return `ALWAYS` or `NEVER` for all\\n    /// tiers so no efficiency is gained.\\n    /// The return value is a `uint256` for gas efficiency but the values will\\n    /// be bounded by `type(uint32).max` as no single tier can report a value\\n    /// higher than this.\\n    function reportTimeForTier(\\n        address account,\\n        uint256 tier,\\n        uint256[] calldata context\\n    ) external view returns (uint256 time);\\n\\n    /// Same as `ITier` but with a list of values for `context` which allows a\\n    /// single underlying state to present many different reports dynamically.\\n    ///\\n    /// For example:\\n    /// - Staking ledgers can calculate different tier thresholds\\n    /// - NFTs can give different tiers based on different IDs\\n    /// - Snapshot ERC20s can give different reports based on snapshot ID\\n    ///\\n    /// `context` supercedes `setTier` function and `TierChange` event from\\n    /// `ITier` at the interface level. Implementing contracts are free to\\n    /// inherit both `ITier` and `ITierV2` if the old behaviour is desired.\\n    function report(address account, uint256[] calldata context)\\n        external\\n        view\\n        returns (uint256 report);\\n}\\n\",\"keccak256\":\"0xdc851fc7cd82f9752a2bc96dfe3914257af6a970f514a0a7ed50a7b327c4d035\",\"license\":\"CAL\"},\"contracts/tier/libraries/TierConstants.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title TierConstants\\n/// @notice Constants for use with tier logic.\\nlibrary TierConstants {\\n    /// NEVER is 0xFF.. as it is infinitely in the future.\\n    /// NEVER for an entire report.\\n    uint256 internal constant NEVER_REPORT = type(uint256).max;\\n    /// NEVER for a single tier time.\\n    uint32 internal constant NEVER_TIME = type(uint32).max;\\n\\n    /// Always is 0 as it is the genesis block.\\n    /// Tiers can't predate the chain but they can predate an `ITierV2`\\n    /// contract.\\n    uint256 internal constant ALWAYS = 0;\\n\\n    /// Account has never held a tier.\\n    uint256 internal constant TIER_ZERO = 0;\\n\\n    /// Magic number for tier one.\\n    uint256 internal constant TIER_ONE = 1;\\n    /// Magic number for tier two.\\n    uint256 internal constant TIER_TWO = 2;\\n    /// Magic number for tier three.\\n    uint256 internal constant TIER_THREE = 3;\\n    /// Magic number for tier four.\\n    uint256 internal constant TIER_FOUR = 4;\\n    /// Magic number for tier five.\\n    uint256 internal constant TIER_FIVE = 5;\\n    /// Magic number for tier six.\\n    uint256 internal constant TIER_SIX = 6;\\n    /// Magic number for tier seven.\\n    uint256 internal constant TIER_SEVEN = 7;\\n    /// Magic number for tier eight.\\n    uint256 internal constant TIER_EIGHT = 8;\\n    /// Maximum tier is `TIER_EIGHT`.\\n    uint256 internal constant MAX_TIER = TIER_EIGHT;\\n}\\n\",\"keccak256\":\"0x4d73c7a5d50d7dddfd0a6cacaf5a366f99b80199dc9f9e8aa9ba77e2736a19e5\",\"license\":\"CAL\"},\"contracts/tier/libraries/TierReport.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {ITierV2} from \\\"../ITierV2.sol\\\";\\nimport \\\"./TierConstants.sol\\\";\\n\\n/// @title TierReport\\n/// @notice `TierReport` implements several pure functions that can be\\n/// used to interface with reports.\\n/// - `tierAtTimeFromReport`: Returns the highest status achieved relative to\\n/// a block timestamp and report. Statuses gained after that block are ignored.\\n/// - `tierTime`: Returns the timestamp that a given tier has been held\\n/// since according to a report.\\n/// - `truncateTiersAbove`: Resets all the tiers above the reference tier.\\n/// - `updateTimesForTierRange`: Updates a report with a timestamp for every\\n///    tier in a range.\\n/// - `updateReportWithTierAtTime`: Updates a report to a new tier.\\n/// @dev Utilities to consistently read, write and manipulate tiers in reports.\\n/// The low-level bit shifting can be difficult to get right so this\\n/// factors that out.\\nlibrary TierReport {\\n    /// Enforce upper limit on tiers so we can do unchecked math.\\n    /// @param tier_ The tier to enforce bounds on.\\n    modifier maxTier(uint256 tier_) {\\n        require(tier_ <= TierConstants.MAX_TIER, \\\"MAX_TIER\\\");\\n        _;\\n    }\\n\\n    /// Returns the highest tier achieved relative to a block timestamp\\n    /// and report.\\n    ///\\n    /// Note that typically the report will be from the _current_ contract\\n    /// state, i.e. `block.timestamp` but not always. Tiers gained after the\\n    /// reference time are ignored.\\n    ///\\n    /// When the `report` comes from a later block than the `timestamp_` this\\n    /// means the user must have held the tier continuously from `timestamp_`\\n    /// _through_ to the report block.\\n    /// I.e. NOT a snapshot.\\n    ///\\n    /// @param report_ A report as per `ITierV2`.\\n    /// @param timestamp_ The timestamp to check the tiers against.\\n    /// @return tier_ The highest tier held since `timestamp_` as per `report`.\\n    function tierAtTimeFromReport(uint256 report_, uint256 timestamp_)\\n        internal\\n        pure\\n        returns (uint256 tier_)\\n    {\\n        unchecked {\\n            for (tier_ = 0; tier_ < 8; tier_++) {\\n                if (uint32(uint256(report_ >> (tier_ * 32))) > timestamp_) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// Returns the timestamp that a given tier has been held since from a\\n    /// report.\\n    ///\\n    /// The report MUST encode \\\"never\\\" as 0xFFFFFFFF. This ensures\\n    /// compatibility with `tierAtTimeFromReport`.\\n    ///\\n    /// @param report_ The report to read a timestamp from.\\n    /// @param tier_ The Tier to read the timestamp for.\\n    /// @return timestamp_ The timestamp the tier has been held since.\\n    function reportTimeForTier(uint256 report_, uint256 tier_)\\n        internal\\n        pure\\n        maxTier(tier_)\\n        returns (uint256 timestamp_)\\n    {\\n        unchecked {\\n            // ZERO is a special case. Everyone has always been at least ZERO,\\n            // since block 0.\\n            if (tier_ == 0) {\\n                return 0;\\n            }\\n\\n            uint256 offset_ = (tier_ - 1) * 32;\\n            timestamp_ = uint256(uint32(uint256(report_ >> offset_)));\\n        }\\n    }\\n\\n    /// Resets all the tiers above the reference tier to 0xFFFFFFFF.\\n    ///\\n    /// @param report_ Report to truncate with high bit 1s.\\n    /// @param tier_ Tier to truncate above (exclusive).\\n    /// @return Truncated report.\\n    function truncateTiersAbove(uint256 report_, uint256 tier_)\\n        internal\\n        pure\\n        maxTier(tier_)\\n        returns (uint256)\\n    {\\n        unchecked {\\n            uint256 offset_ = tier_ * 32;\\n            uint256 mask_ = (TierConstants.NEVER_REPORT >> offset_) << offset_;\\n            return report_ | mask_;\\n        }\\n    }\\n\\n    /// Updates a report with a timestamp for a given tier.\\n    /// More gas efficient than `updateTimesForTierRange` if only a single\\n    /// tier is being modified.\\n    /// The tier at/above the given tier is updated. E.g. tier `0` will update\\n    /// the time for tier `1`.\\n    /// @param report_ Report to use as the baseline for the updated report.\\n    /// @param tier_ The tier level to update.\\n    /// @param timestamp_ The new block number for `tier_`.\\n    /// @return updatedReport_ The newly updated `report_`.\\n    function updateTimeAtTier(\\n        uint256 report_,\\n        uint256 tier_,\\n        uint256 timestamp_\\n    ) internal pure maxTier(tier_) returns (uint256 updatedReport_) {\\n        unchecked {\\n            uint256 offset_ = tier_ * 32;\\n            updatedReport_ =\\n                (report_ &\\n                    ~uint256(uint256(TierConstants.NEVER_TIME) << offset_)) |\\n                uint256(timestamp_ << offset_);\\n        }\\n    }\\n\\n    /// Updates a report with a block number for every tier in a range.\\n    ///\\n    /// Does nothing if the end status is equal or less than the start tier.\\n    /// @param report_ The report to update.\\n    /// @param startTier_ The tier at the start of the range (exclusive).\\n    /// @param endTier_ The tier at the end of the range (inclusive).\\n    /// @param timestamp_ The timestamp to set for every tier in the range.\\n    /// @return updatedReport_ The updated report.\\n    function updateTimesForTierRange(\\n        uint256 report_,\\n        uint256 startTier_,\\n        uint256 endTier_,\\n        uint256 timestamp_\\n    ) internal pure maxTier(endTier_) returns (uint256 updatedReport_) {\\n        unchecked {\\n            uint256 offset_;\\n            for (uint256 i_ = startTier_; i_ < endTier_; i_++) {\\n                offset_ = i_ * 32;\\n                report_ =\\n                    (report_ &\\n                        ~uint256(\\n                            uint256(TierConstants.NEVER_TIME) << offset_\\n                        )) |\\n                    uint256(timestamp_ << offset_);\\n            }\\n            updatedReport_ = report_;\\n        }\\n    }\\n\\n    /// Updates a report to a new status.\\n    ///\\n    /// Internally dispatches to `truncateTiersAbove` and\\n    /// `updateBlocksForTierRange`.\\n    /// The dispatch is based on whether the new tier is above or below the\\n    /// current tier.\\n    /// The `startTier_` MUST match the result of `tierAtBlockFromReport`.\\n    /// It is expected the caller will know the current tier when\\n    /// calling this function and need to do other things in the calling scope\\n    /// with it.\\n    ///\\n    /// @param report_ The report to update.\\n    /// @param startTier_ The tier to start updating relative to. Data above\\n    /// this tier WILL BE LOST so probably should be the current tier.\\n    /// @param endTier_ The new highest tier held, at the given block number.\\n    /// @param timestamp_ The timestamp_ to update the highest tier to, and\\n    /// intermediate tiers from `startTier_`.\\n    /// @return updatedReport_ The updated report.\\n    function updateReportWithTierAtTime(\\n        uint256 report_,\\n        uint256 startTier_,\\n        uint256 endTier_,\\n        uint256 timestamp_\\n    ) internal pure returns (uint256 updatedReport_) {\\n        updatedReport_ = endTier_ < startTier_\\n            ? truncateTiersAbove(report_, endTier_)\\n            : updateTimesForTierRange(\\n                report_,\\n                startTier_,\\n                endTier_,\\n                timestamp_\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x814ae8971bdddb4a0c8b3e460d1c338bc03a43c0e27452f5338816408519115e\",\"license\":\"CAL\"},\"contracts/tier/libraries/TierwiseCombine.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"./TierReport.sol\\\";\\nimport \\\"../../math/SaturatingMath.sol\\\";\\n\\nlibrary TierwiseCombine {\\n    using Math for uint256;\\n    using SaturatingMath for uint256;\\n\\n    /// Every lte check in `selectLte` must pass.\\n    uint256 internal constant LOGIC_EVERY = 0;\\n    /// Only one lte check in `selectLte` must pass.\\n    uint256 internal constant LOGIC_ANY = 1;\\n\\n    /// Select the minimum block number from passing blocks in `selectLte`.\\n    uint256 internal constant MODE_MIN = 0;\\n    /// Select the maximum block number from passing blocks in `selectLte`.\\n    uint256 internal constant MODE_MAX = 1;\\n    /// Select the first block number that passes in `selectLte`.\\n    uint256 internal constant MODE_FIRST = 2;\\n\\n    /// Performs a tierwise saturating subtraction of two reports.\\n    /// Intepret as \\\"# of blocks older report was held before newer report\\\".\\n    /// If older report is in fact newer then `0` will be returned.\\n    /// i.e. the diff cannot be negative, older report as simply spent 0 blocks\\n    /// existing before newer report, if it is in truth the newer report.\\n    /// @param newerReport_ Block to subtract from.\\n    /// @param olderReport_ Block to subtract.\\n    function saturatingSub(uint256 newerReport_, uint256 olderReport_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        unchecked {\\n            uint256 ret_;\\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\\n                uint256 newerBlock_ = TierReport.reportTimeForTier(\\n                    newerReport_,\\n                    tier_\\n                );\\n                uint256 olderBlock_ = TierReport.reportTimeForTier(\\n                    olderReport_,\\n                    tier_\\n                );\\n                uint256 diff_ = newerBlock_.saturatingSub(olderBlock_);\\n                ret_ = TierReport.updateTimeAtTier(ret_, tier_ - 1, diff_);\\n            }\\n            return ret_;\\n        }\\n    }\\n\\n    /// Given a list of reports, selects the best tier in a tierwise fashion.\\n    /// The \\\"best\\\" criteria can be configured by `logic_` and `mode_`.\\n    /// Logic can be \\\"every\\\" or \\\"any\\\", which means that the reports for a given\\n    /// tier must either all or any be less than or equal to the reference\\n    /// `blockNumber_`.\\n    /// Mode can be \\\"min\\\", \\\"max\\\", \\\"first\\\" which selects between all the block\\n    /// numbers for a given tier that meet the lte criteria.\\n    /// IMPORTANT: If the output of `selectLte` is used to write to storage\\n    /// care must be taken to ensure that \\\"upcoming\\\" tiers relative to the\\n    /// `blockNumber_` are not overwritten inappropriately. Typically this\\n    /// function should be used as a filter over reads only from an upstream\\n    /// source of truth.\\n    /// @param reports_ The list of reports to select over.\\n    /// @param blockNumber_ The block number that tier blocks must be lte.\\n    /// @param logic_ `LOGIC_EVERY` or `LOGIC_ANY`.\\n    /// @param mode_ `MODE_MIN`, `MODE_MAX` or `MODE_FIRST`.\\n    function selectLte(\\n        uint256[] memory reports_,\\n        uint256 blockNumber_,\\n        uint256 logic_,\\n        uint256 mode_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 ret_;\\n            uint256 block_;\\n            bool anyLte_;\\n            uint256 length_ = reports_.length;\\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\\n                uint256 accumulator_;\\n                // Nothing lte the reference block for this tier yet.\\n                anyLte_ = false;\\n\\n                // Initialize the accumulator for this tier.\\n                if (mode_ == MODE_MIN) {\\n                    accumulator_ = TierConstants.NEVER_REPORT;\\n                } else {\\n                    accumulator_ = 0;\\n                }\\n\\n                // Filter all the blocks at the current tier from all the\\n                // reports against the reference tier and each other.\\n                for (uint256 i_ = 0; i_ < length_; i_++) {\\n                    block_ = TierReport.reportTimeForTier(reports_[i_], tier_);\\n\\n                    if (block_ <= blockNumber_) {\\n                        // Min and max need to compare current value against\\n                        // the accumulator.\\n                        if (mode_ == MODE_MIN) {\\n                            accumulator_ = block_.min(accumulator_);\\n                        } else if (mode_ == MODE_MAX) {\\n                            accumulator_ = block_.max(accumulator_);\\n                        } else if (mode_ == MODE_FIRST && !anyLte_) {\\n                            accumulator_ = block_;\\n                        }\\n                        anyLte_ = true;\\n                    } else if (logic_ == LOGIC_EVERY) {\\n                        // Can short circuit for an \\\"every\\\" check.\\n                        accumulator_ = TierConstants.NEVER_REPORT;\\n                        break;\\n                    }\\n                }\\n                if (!anyLte_) {\\n                    accumulator_ = TierConstants.NEVER_REPORT;\\n                }\\n                ret_ = TierReport.updateTimeAtTier(\\n                    ret_,\\n                    tier_ - 1,\\n                    accumulator_\\n                );\\n            }\\n            return ret_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc2fc43f70f19af29a6b08f0de69ebde9ccdb6f1e360f22747071c5076a11a69c\",\"license\":\"CAL\"},\"contracts/vm/RainVM.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../math/SaturatingMath.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// Everything required to evaluate and track the state of a rain script.\\n/// As this is a struct it will be in memory when passed to `RainVM` and so\\n/// will be modified by reference internally. This is important for gas\\n/// efficiency; the stack, arguments and stackIndex will likely be mutated by\\n/// the running script.\\n/// @param stackIndex Opcodes write to the stack at the stack index and can\\n/// consume from the stack by decrementing the index and reading between the\\n/// old and new stack index.\\n/// IMPORANT: The stack is never zeroed out so the index must be used to\\n/// find the \\\"top\\\" of the stack as the result of an `eval`.\\n/// @param stack Stack is the general purpose runtime state that opcodes can\\n/// read from and write to according to their functionality.\\n/// @param sources Sources available to be executed by `eval`.\\n/// Notably `ZIPMAP` can also select a source to execute by index.\\n/// @param constants Constants that can be copied to the stack by index by\\n/// `VAL`.\\n/// @param arguments `ZIPMAP` populates arguments which can be copied to the\\n/// stack by `VAL`.\\nstruct State {\\n    uint256 stackIndex;\\n    uint256[] stack;\\n    bytes[] ptrSources;\\n    uint256[] constants;\\n    /// `ZIPMAP` populates arguments into constants which can be copied to the\\n    /// stack by `VAL` as usual, starting from this index. This copying is\\n    /// destructive so it is recommended to leave space in the constants array.\\n    uint256 argumentsIndex;\\n}\\n\\nstruct StorageOpcodesRange {\\n    uint256 pointer;\\n    uint256 length;\\n}\\n\\nlibrary LibState {\\n    /// Put the state back to a freshly eval-able value. The same state can be\\n    /// run more than once (e.g. two different entrypoints) to yield different\\n    /// stacks, as long as all the sources are VALID and reset is called\\n    /// between each eval call.\\n    /// Generally this should be called whenever eval is run over a state that\\n    /// is exposed to the calling context (e.g. it is an argument) so that the\\n    /// caller may safely eval multiple times on any state it has in scope.\\n    function reset(State memory state_) internal pure {\\n        state_.stackIndex = 0;\\n    }\\n\\n    function toBytesDebug(State memory state_)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return abi.encode(state_);\\n    }\\n\\n    function fromBytesPacked(bytes memory stateBytes_)\\n        internal\\n        pure\\n        returns (State memory)\\n    {\\n        unchecked {\\n            State memory state_;\\n            uint256 indexes_;\\n            assembly {\\n                // Load indexes from state bytes.\\n                indexes_ := mload(add(stateBytes_, 0x20))\\n                // mask out everything but the constants length from state\\n                // bytes.\\n                mstore(add(stateBytes_, 0x20), and(indexes_, 0xFF))\\n                // point state constants at state bytes\\n                mstore(add(state_, 0x60), add(stateBytes_, 0x20))\\n            }\\n            // Stack index 0 is implied.\\n            state_.stack = new uint256[]((indexes_ >> 8) & 0xFF);\\n            state_.argumentsIndex = (indexes_ >> 16) & 0xFF;\\n            uint256 sourcesLen_ = (indexes_ >> 24) & 0xFF;\\n            bytes[] memory ptrSources_;\\n            uint256[] memory ptrSourcesPtrs_ = new uint256[](sourcesLen_);\\n\\n            assembly {\\n                let sourcesStart_ := add(\\n                    stateBytes_,\\n                    add(\\n                        // 0x40 for constants and state array length\\n                        0x40,\\n                        // skip over length of constants\\n                        mul(0x20, mload(add(stateBytes_, 0x20)))\\n                    )\\n                )\\n                let cursor_ := sourcesStart_\\n\\n                for {\\n                    let i_ := 0\\n                } lt(i_, sourcesLen_) {\\n                    i_ := add(i_, 1)\\n                } {\\n                    // sources_ is a dynamic array so it is a list of\\n                    // pointers that can be set literally to the cursor_\\n                    mstore(\\n                        add(ptrSourcesPtrs_, add(0x20, mul(i_, 0x20))),\\n                        cursor_\\n                    )\\n                    // move the cursor by the length of the source in bytes\\n                    cursor_ := add(cursor_, add(0x20, mload(cursor_)))\\n                }\\n                // point state at sources_ rather than clone in memory\\n                ptrSources_ := ptrSourcesPtrs_\\n                mstore(add(state_, 0x40), ptrSources_)\\n            }\\n            return state_;\\n        }\\n    }\\n\\n    function toBytesPacked(State memory state_)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        unchecked {\\n            // indexes + constants\\n            uint256[] memory constants_ = state_.constants;\\n            // constants is first so we can literally use it on the other end\\n            uint256 indexes_ = state_.constants.length |\\n                (state_.stack.length << 8) |\\n                (state_.argumentsIndex << 16) |\\n                (state_.ptrSources.length << 24);\\n            bytes memory ret_ = bytes.concat(\\n                bytes32(indexes_),\\n                abi.encodePacked(constants_)\\n            );\\n            for (uint256 i_ = 0; i_ < state_.ptrSources.length; i_++) {\\n                ret_ = bytes.concat(\\n                    ret_,\\n                    bytes32(state_.ptrSources[i_].length),\\n                    state_.ptrSources[i_]\\n                );\\n            }\\n            return ret_;\\n        }\\n    }\\n}\\n\\n/// @dev Copies a value either off `constants` to the top of the stack.\\nuint256 constant OPCODE_CONSTANT = 0;\\n/// @dev Duplicates any value in the stack to the top of the stack. The operand\\n/// specifies the index to copy from.\\nuint256 constant OPCODE_STACK = 1;\\nuint256 constant OPCODE_CONTEXT = 2;\\nuint256 constant OPCODE_STORAGE = 3;\\n/// @dev Takes N values off the stack, interprets them as an array then zips\\n/// and maps a source from `sources` over them.\\nuint256 constant OPCODE_ZIPMAP = 4;\\n/// @dev ABI encodes the entire stack and logs it to the hardhat console.\\nuint256 constant OPCODE_DEBUG = 5;\\n/// @dev Number of provided opcodes for `RainVM`.\\nuint256 constant RAIN_VM_OPS_LENGTH = 6;\\n\\nuint256 constant DEBUG_STATE_ABI = 0;\\nuint256 constant DEBUG_STATE_PACKED = 1;\\nuint256 constant DEBUG_STACK = 2;\\nuint256 constant DEBUG_STACK_INDEX = 3;\\n\\n/// @title RainVM\\n/// @notice micro VM for implementing and executing custom contract DSLs.\\n/// Libraries and contracts map opcodes to `view` functionality then RainVM\\n/// runs rain scripts using these opcodes. Rain scripts dispatch as pairs of\\n/// bytes. The first byte is an opcode to run and the second byte is a value\\n/// the opcode can use contextually to inform how to run. Typically opcodes\\n/// will read/write to the stack to produce some meaningful final state after\\n/// all opcodes have been dispatched.\\n///\\n/// The only thing required to run a rain script is a `State` struct to pass\\n/// to `eval`, and the index of the source to run. Additional context can\\n/// optionally be provided to be used by opcodes. For example, an `ITierV2`\\n/// contract can take the input of `report`, abi encode it as context, then\\n/// expose a local opcode that copies this account to the stack. The state will\\n/// be mutated by reference rather than returned by `eval`, this is to make it\\n/// very clear to implementers that the inline mutation is occurring.\\n///\\n/// Rain scripts run \\\"top to bottom\\\", i.e. \\\"left to right\\\".\\n/// See the tests for examples on how to construct rain script in JavaScript\\n/// then pass to `ImmutableSource` contracts deployed by a factory that then\\n/// run `eval` to produce a final value.\\n///\\n/// There are only 4 \\\"core\\\" opcodes for `RainVM`:\\n/// - `0`: Copy value from either `constants` at index `operand` to the top of\\n///   the stack.\\n/// - `1`: Duplicates the value at stack index `operand_` to the top of the\\n///   stack.\\n/// - `2`: Zipmap takes N values from the stack, interprets each as an array of\\n///   configurable length, then zips them into `arguments` and maps a source\\n///   from `sources` over these. See `zipmap` for more details.\\n/// - `3`: Debug prints the state to the console log as per hardhat.\\n///\\n/// To do anything useful the contract that inherits `RainVM` needs to provide\\n/// opcodes to build up an internal DSL. This may sound complex but it only\\n/// requires mapping opcode integers to functions to call, and reading/writing\\n/// values to the stack as input/output for these functions. Further, opcode\\n/// packs are provided in rain that any inheriting contract can use as a normal\\n/// solidity library. See `MathOps.sol` opcode pack and the\\n/// `CalculatorTest.sol` test contract for an example of how to dispatch\\n/// opcodes and handle the results in a wrapping contract.\\n///\\n/// RainVM natively has no concept of branching logic such as `if` or loops.\\n/// An opcode pack could implement these similar to the core zipmap by lazily\\n/// evaluating a source from `sources` based on some condition, etc. Instead\\n/// some simpler, eagerly evaluated selection tools such as `min` and `max` in\\n/// the `MathOps` opcode pack are provided. Future versions of `RainVM` MAY\\n/// implement lazy `if` and other similar patterns.\\n///\\n/// The `eval` function is `view` because rain scripts are expected to compute\\n/// results only without modifying any state. The contract wrapping the VM is\\n/// free to mutate as usual. This model encourages exposing only read-only\\n/// functionality to end-user deployers who provide scripts to a VM factory.\\n/// Removing all writes removes a lot of potential foot-guns for rain script\\n/// authors and allows VM contract authors to reason more clearly about the\\n/// input/output of the wrapping solidity code.\\n///\\n/// Internally `RainVM` makes heavy use of unchecked math and assembly logic\\n/// as the opcode dispatch logic runs on a tight loop and so gas costs can ramp\\n/// up very quickly. Implementing contracts and opcode packs SHOULD require\\n/// that opcodes they receive do not exceed the codes they are expecting.\\nabstract contract RainVM {\\n    using Math for uint256;\\n    using SaturatingMath for uint256;\\n\\n    /// Default is to disallow all storage access to opcodes.\\n    function storageOpcodesRange()\\n        public\\n        pure\\n        virtual\\n        returns (StorageOpcodesRange memory)\\n    {\\n        return StorageOpcodesRange(0, 0);\\n    }\\n\\n    function fnPtrs() public pure virtual returns (bytes memory);\\n\\n    /// Zipmap is rain script's native looping construct.\\n    /// N values are taken from the stack as `uint256` then split into `uintX`\\n    /// values where X is configurable by `operand_`. Each 1 increment in the\\n    /// operand size config doubles the number of items in the implied arrays.\\n    /// For example, size 0 is 1 `uint256` value, size 1 is\\n    /// `2x `uint128` values, size 2 is 4x `uint64` values and so on.\\n    ///\\n    /// The implied arrays are zipped and then copied into `arguments` and\\n    /// mapped over with a source from `sources`. Each iteration of the mapping\\n    /// copies values into `arguments` from index `0` but there is no attempt\\n    /// to zero out any values that may already be in the `arguments` array.\\n    /// It is the callers responsibility to ensure that the `arguments` array\\n    /// is correctly sized and populated for the mapped source.\\n    ///\\n    /// The `operand_` for the zipmap opcode is split into 3 components:\\n    /// - 3 low bits: The index of the source to use from `sources`.\\n    /// - 2 middle bits: The size of the loop, where 0 is 1 iteration\\n    /// - 3 high bits: The number of vals to be zipped from the stack where 0\\n    ///   is 1 value to be zipped.\\n    ///\\n    /// This is a separate function to avoid blowing solidity compile stack.\\n    /// In the future it may be moved inline to `eval` for gas efficiency.\\n    ///\\n    /// See https://en.wikipedia.org/wiki/Zipping_(computer_science)\\n    /// See https://en.wikipedia.org/wiki/Map_(higher-order_function)\\n    /// @param context_ Domain specific context the wrapping contract can\\n    /// provide to passthrough back to its own opcodes.\\n    /// @param state_ The execution state of the VM.\\n    /// @param operand_ The operand_ associated with this dispatch to zipmap.\\n    function zipmap(\\n        bytes memory context_,\\n        State memory state_,\\n        uint256 stackTopLocation_,\\n        uint256 operand_\\n    ) internal view returns (uint256) {\\n        unchecked {\\n            uint256 sourceIndex_ = operand_ & 0x07;\\n            uint256 loopSize_ = (operand_ >> 3) & 0x03;\\n            uint256 mask_;\\n            uint256 stepSize_;\\n            if (loopSize_ == 0) {\\n                mask_ = type(uint256).max;\\n                stepSize_ = 0x100;\\n            } else if (loopSize_ == 1) {\\n                mask_ = type(uint128).max;\\n                stepSize_ = 0x80;\\n            } else if (loopSize_ == 2) {\\n                mask_ = type(uint64).max;\\n                stepSize_ = 0x40;\\n            } else {\\n                mask_ = type(uint32).max;\\n                stepSize_ = 0x20;\\n            }\\n            uint256 valLength_ = (operand_ >> 5) + 1;\\n\\n            // Set aside base values so they can't be clobbered during eval\\n            // as the stack changes on each loop.\\n            uint256[] memory baseVals_ = new uint256[](valLength_);\\n            uint256 baseValsBottom_;\\n            {\\n                assembly {\\n                    baseValsBottom_ := add(baseVals_, 0x20)\\n                    for {\\n                        let cursor_ := sub(\\n                            stackTopLocation_,\\n                            mul(valLength_, 0x20)\\n                        )\\n                        let baseValsCursor_ := baseValsBottom_\\n                    } lt(cursor_, stackTopLocation_) {\\n                        cursor_ := add(cursor_, 0x20)\\n                        baseValsCursor_ := add(baseValsCursor_, 0x20)\\n                    } {\\n                        mstore(baseValsCursor_, mload(cursor_))\\n                    }\\n                }\\n            }\\n\\n            uint256 argumentsBottomLocation_;\\n            assembly {\\n                let constantsBottomLocation_ := add(\\n                    mload(add(state_, 0x60)),\\n                    0x20\\n                )\\n                argumentsBottomLocation_ := add(\\n                    constantsBottomLocation_,\\n                    mul(\\n                        0x20,\\n                        mload(\\n                            // argumentsIndex\\n                            add(state_, 0x80)\\n                        )\\n                    )\\n                )\\n            }\\n\\n            for (uint256 step_ = 0; step_ < 0x100; step_ += stepSize_) {\\n                // Prepare arguments.\\n                {\\n                    // max cursor is in this scope to avoid stack overflow from\\n                    // solidity.\\n                    uint256 maxCursor_ = baseValsBottom_ + (valLength_ * 0x20);\\n                    uint256 argumentsCursor_ = argumentsBottomLocation_;\\n                    uint256 cursor_ = baseValsBottom_;\\n                    while (cursor_ < maxCursor_) {\\n                        assembly {\\n                            mstore(\\n                                argumentsCursor_,\\n                                and(shr(step_, mload(cursor_)), mask_)\\n                            )\\n                            cursor_ := add(cursor_, 0x20)\\n                            argumentsCursor_ := add(argumentsCursor_, 0x20)\\n                        }\\n                    }\\n                }\\n                stackTopLocation_ = eval(context_, state_, sourceIndex_);\\n            }\\n            return stackTopLocation_;\\n        }\\n    }\\n\\n    /// Evaluates a rain script.\\n    /// The main workhorse of the rain VM, `eval` runs any core opcodes and\\n    /// dispatches anything it is unaware of to the implementing contract.\\n    /// For a script to be useful the implementing contract must override\\n    /// `applyOp` and dispatch non-core opcodes to domain specific logic. This\\n    /// could be mathematical operations for a calculator, tier reports for\\n    /// a membership combinator, entitlements for a minting curve, etc.\\n    ///\\n    /// Everything required to coordinate the execution of a rain script to\\n    /// completion is contained in the `State`. The context and source index\\n    /// are provided so the caller can provide additional data and kickoff the\\n    /// opcode dispatch from the correct source in `sources`.\\n    function eval(\\n        bytes memory context_,\\n        State memory state_,\\n        uint256 sourceIndex_\\n    ) internal view returns (uint256) {\\n        unchecked {\\n            uint256 pc_ = 0;\\n            uint256 opcode_;\\n            uint256 operand_;\\n            uint256 sourceLocation_;\\n            uint256 sourceLen_;\\n            uint256 constantsBottomLocation_;\\n            uint256 stackBottomLocation_;\\n            uint256 stackTopLocation_;\\n            uint256 firstFnPtrLocation_;\\n\\n            assembly {\\n                let stackLocation_ := mload(add(state_, 0x20))\\n                stackBottomLocation_ := add(stackLocation_, 0x20)\\n                stackTopLocation_ := add(\\n                    stackBottomLocation_,\\n                    // Add stack index offset.\\n                    mul(mload(state_), 0x20)\\n                )\\n                sourceLocation_ := mload(\\n                    add(\\n                        mload(add(state_, 0x40)),\\n                        add(0x20, mul(sourceIndex_, 0x20))\\n                    )\\n                )\\n                sourceLen_ := mload(sourceLocation_)\\n                constantsBottomLocation_ := add(mload(add(state_, 0x60)), 0x20)\\n                // first fn pointer is seen if we move two bytes into the data.\\n                firstFnPtrLocation_ := add(mload(add(state_, 0xA0)), 0x02)\\n            }\\n\\n            // Loop until complete.\\n            while (pc_ < sourceLen_) {\\n                assembly {\\n                    pc_ := add(pc_, 3)\\n                    let op_ := mload(add(sourceLocation_, pc_))\\n                    operand_ := byte(31, op_)\\n                    opcode_ := and(shr(8, op_), 0xFFFF)\\n                }\\n\\n                if (opcode_ < RAIN_VM_OPS_LENGTH) {\\n                    if (opcode_ == OPCODE_CONSTANT) {\\n                        assembly {\\n                            mstore(\\n                                stackTopLocation_,\\n                                mload(\\n                                    add(\\n                                        constantsBottomLocation_,\\n                                        mul(0x20, operand_)\\n                                    )\\n                                )\\n                            )\\n                            stackTopLocation_ := add(stackTopLocation_, 0x20)\\n                        }\\n                    } else if (opcode_ == OPCODE_STACK) {\\n                        assembly {\\n                            mstore(\\n                                stackTopLocation_,\\n                                mload(\\n                                    add(\\n                                        stackBottomLocation_,\\n                                        mul(operand_, 0x20)\\n                                    )\\n                                )\\n                            )\\n                            stackTopLocation_ := add(stackTopLocation_, 0x20)\\n                        }\\n                    } else if (opcode_ == OPCODE_CONTEXT) {\\n                        // This is the only runtime integrity check that we do\\n                        // as it is not possible to know how long context might\\n                        // be in general until runtime.\\n                        require(\\n                            operand_ * 0x20 < context_.length,\\n                            \\\"CONTEXT_LENGTH\\\"\\n                        );\\n                        assembly {\\n                            mstore(\\n                                stackTopLocation_,\\n                                mload(\\n                                    add(\\n                                        context_,\\n                                        add(0x20, mul(0x20, operand_))\\n                                    )\\n                                )\\n                            )\\n                            stackTopLocation_ := add(stackTopLocation_, 0x20)\\n                        }\\n                    } else if (opcode_ == OPCODE_STORAGE) {\\n                        StorageOpcodesRange\\n                            memory storageOpcodesRange_ = storageOpcodesRange();\\n                        assembly {\\n                            mstore(\\n                                stackTopLocation_,\\n                                sload(\\n                                    add(operand_, mload(storageOpcodesRange_))\\n                                )\\n                            )\\n                            stackTopLocation_ := add(stackTopLocation_, 0x20)\\n                        }\\n                    } else if (opcode_ == OPCODE_ZIPMAP) {\\n                        stackTopLocation_ = zipmap(\\n                            context_,\\n                            state_,\\n                            stackTopLocation_,\\n                            operand_\\n                        );\\n                    } else {\\n                        bytes memory debug_;\\n                        if (operand_ == DEBUG_STATE_ABI) {\\n                            debug_ = abi.encode(state_);\\n                        } else if (operand_ == DEBUG_STATE_PACKED) {\\n                            debug_ = LibState.toBytesPacked(state_);\\n                        } else if (operand_ == DEBUG_STACK) {\\n                            debug_ = abi.encodePacked(state_.stack);\\n                        } else if (operand_ == DEBUG_STACK_INDEX) {\\n                            debug_ = abi.encodePacked(state_.stackIndex);\\n                        }\\n                        if (debug_.length > 0) {\\n                            console.logBytes(debug_);\\n                        }\\n                    }\\n                } else {\\n                    function(uint256, uint256) view returns (uint256) fn_;\\n                    assembly {\\n                        fn_ := opcode_\\n                    }\\n                    stackTopLocation_ = fn_(operand_, stackTopLocation_);\\n                }\\n                // The stack index may be the same as the length as this means\\n                // the stack is full. But we cannot write past the end of the\\n                // stack. This also catches a stack index that underflows due\\n                // to unchecked or assembly math. This check MAY be redundant\\n                // with standard OOB checks on the stack array due to indexing\\n                // into it, but is a required guard in the case of VM assembly.\\n                // Future versions of the VM will precalculate all stack\\n                // movements at deploy time rather than runtime as this kind of\\n                // accounting adds nontrivial gas across longer scripts that\\n                // include many opcodes.\\n                // Note: This check would NOT be safe in the case that some\\n                // opcode used assembly in a way that can underflow the stack\\n                // as this would allow a malicious rain script to write to the\\n                // stack length and/or the stack index.\\n                require(\\n                    state_.stackIndex <= state_.stack.length,\\n                    \\\"STACK_OVERFLOW\\\"\\n                );\\n            }\\n            state_.stackIndex =\\n                (stackTopLocation_ - stackBottomLocation_) /\\n                0x20;\\n            return stackTopLocation_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7c75c1fcfaa98a06d194a9476fc36df803b2bba3ca74912c6137660684b0e2ef\",\"license\":\"CAL\"},\"contracts/vm/VMStateBuilder.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\nimport \\\"./RainVM.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../sstore2/SSTORE2.sol\\\";\\n\\n/// Config required to build a new `State`.\\n/// @param sources Sources verbatim.\\n/// @param constants Constants verbatim.\\nstruct StateConfig {\\n    bytes[] sources;\\n    uint256[] constants;\\n}\\n\\n/// @param stackIndex The current stack index as the state builder moves\\n/// through each opcode and applies the appropriate pops and pushes.\\n/// @param stackLength The maximum length of the stack seen so far due to stack\\n/// index movements. If the stack index underflows this will be close to\\n/// uint256 max and will ultimately error. It will also error if it overflows\\n/// MAX_STACK_LENGTH.\\n/// @param argumentsLength The maximum length of arguments seen so far due to\\n/// zipmap calls. Will be 0 if there are no zipmap calls.\\n/// @param storageLength The VM contract MUST specify which range of storage\\n/// slots can be read by VM scripts as [0, storageLength). If the storageLength\\n/// is 0 then no storage slots may be read by opcodes. In practise opcodes are\\n/// uint8 so storage slots beyond 255 cannot be read, notably all mappings will\\n/// be inaccessible.\\n/// @param opcodesLength The VM contract MUST specify how many valid opcodes\\n/// there are, where a valid opcode is one with a corresponding valid function\\n/// pointer in the array returned by `fnPtrs`. If this is not set correctly\\n/// then an attacker may specify an opcode that points to data beyond the valid\\n/// fnPtrs, which has undefined and therefore possibly catastrophic behaviour\\n/// for the implementing contract, up to and including total funds loss.\\nstruct Bounds {\\n    uint256 entrypoint;\\n    uint256 minFinalStackIndex;\\n    uint256 stackIndex;\\n    uint256 stackLength;\\n    uint256 argumentsLength;\\n    uint256 storageLength;\\n    uint256 opcodesLength;\\n}\\n\\nuint256 constant MAX_STACK_LENGTH = type(uint8).max;\\n\\ncontract VMStateBuilder {\\n    using Math for uint256;\\n\\n    address private immutable _stackPopsFnPtrs;\\n    address private immutable _stackPushesFnPtrs;\\n    mapping(address => address) private ptrCache;\\n\\n    constructor() {\\n        _stackPopsFnPtrs = SSTORE2.write(stackPopsFnPtrs());\\n        _stackPushesFnPtrs = SSTORE2.write(stackPushesFnPtrs());\\n    }\\n\\n    function _packedFnPtrs(address vm_) private returns (bytes memory) {\\n        unchecked {\\n            bytes memory packedPtrs_ = SSTORE2.read(ptrCache[vm_]);\\n            if (packedPtrs_.length == 0) {\\n                ptrCache[vm_] = SSTORE2.write(packFnPtrs(RainVM(vm_).fnPtrs()));\\n                return _packedFnPtrs(vm_);\\n            }\\n            return packedPtrs_;\\n        }\\n    }\\n\\n    /// Builds a new `State` bytes from `StateConfig`.\\n    /// Empty stack and arguments with stack index 0.\\n    /// @param config_ State config to build the new `State`.\\n    function buildState(\\n        address vm_,\\n        StateConfig memory config_,\\n        Bounds[] memory boundss_\\n    ) external returns (bytes memory) {\\n        unchecked {\\n            bytes memory packedFnPtrs_ = _packedFnPtrs(vm_);\\n            uint256 storageLength_ = RainVM(vm_).storageOpcodesRange().length;\\n            uint256 argumentsLength_ = 0;\\n            uint256 stackLength_ = 0;\\n\\n            for (uint256 b_ = 0; b_ < boundss_.length; b_++) {\\n                boundss_[b_].storageLength = storageLength_;\\n\\n                // Opcodes are 1 byte and fnPtrs are 2 bytes so we halve the\\n                // length to get the valid opcodes length.\\n                boundss_[b_].opcodesLength = packedFnPtrs_.length / 2;\\n                ensureIntegrity(config_, boundss_[b_]);\\n                argumentsLength_ = argumentsLength_.max(\\n                    boundss_[b_].argumentsLength\\n                );\\n                stackLength_ = stackLength_.max(boundss_[b_].stackLength);\\n                // Stack needs to be high enough to read from after eval.\\n                require(\\n                    boundss_[b_].stackIndex >= boundss_[b_].minFinalStackIndex,\\n                    \\\"FINAL_STACK_INDEX\\\"\\n                );\\n            }\\n\\n            // build a new constants array with space for the arguments.\\n            uint256[] memory constants_ = new uint256[](\\n                config_.constants.length + argumentsLength_\\n            );\\n            for (uint256 i_ = 0; i_ < config_.constants.length; i_++) {\\n                constants_[i_] = config_.constants[i_];\\n            }\\n\\n            bytes[] memory ptrSources_ = new bytes[](config_.sources.length);\\n            for (uint256 i_ = 0; i_ < config_.sources.length; i_++) {\\n                ptrSources_[i_] = ptrSource(packedFnPtrs_, config_.sources[i_]);\\n            }\\n\\n            return\\n                LibState.toBytesPacked(\\n                    State(\\n                        0,\\n                        new uint256[](stackLength_),\\n                        ptrSources_,\\n                        constants_,\\n                        config_.constants.length\\n                    )\\n                );\\n        }\\n    }\\n\\n    function ptrSource(bytes memory packedFnPtrs_, bytes memory source_)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        unchecked {\\n            uint256 sourceLen_ = source_.length;\\n            require(sourceLen_ % 2 == 0, \\\"ODD_SOURCE_LENGTH\\\");\\n\\n            bytes memory ptrSource_ = new bytes((sourceLen_ * 3) / 2);\\n\\n            uint256 rainVMOpsLength_ = RAIN_VM_OPS_LENGTH;\\n            assembly {\\n                let start_ := 1\\n                let end_ := add(sourceLen_, 1)\\n                for {\\n                    let i_ := start_\\n                    let o_ := 0\\n                } lt(i_, end_) {\\n                    i_ := add(i_, 1)\\n                } {\\n                    let op_ := byte(31, mload(add(source_, i_)))\\n                    // is opcode\\n                    if mod(i_, 2) {\\n                        // core ops simply zero pad.\\n                        if lt(op_, rainVMOpsLength_) {\\n                            o_ := add(o_, 1)\\n                            mstore8(add(ptrSource_, add(0x20, o_)), op_)\\n                        }\\n                        if iszero(lt(op_, rainVMOpsLength_)) {\\n                            let fn_ := mload(\\n                                add(packedFnPtrs_, add(0x2, mul(op_, 0x2)))\\n                            )\\n                            mstore8(\\n                                add(ptrSource_, add(0x20, o_)),\\n                                byte(30, fn_)\\n                            )\\n                            o_ := add(o_, 1)\\n                            mstore8(\\n                                add(ptrSource_, add(0x20, o_)),\\n                                byte(31, fn_)\\n                            )\\n                        }\\n                    }\\n                    // is operand\\n                    if iszero(mod(i_, 2)) {\\n                        mstore8(add(ptrSource_, add(0x20, o_)), op_)\\n                    }\\n                    o_ := add(o_, 1)\\n                }\\n            }\\n            return ptrSource_;\\n        }\\n    }\\n\\n    function packFnPtrs(bytes memory fnPtrs_)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        unchecked {\\n            require(fnPtrs_.length % 0x20 == 0, \\\"BAD_FN_PTRS_LENGTH\\\");\\n            bytes memory fnPtrsPacked_ = new bytes(fnPtrs_.length / 0x10);\\n            assembly {\\n                for {\\n                    let i_ := 0\\n                    let o_ := 0x02\\n                } lt(i_, mload(fnPtrs_)) {\\n                    i_ := add(i_, 0x20)\\n                    o_ := add(o_, 0x02)\\n                } {\\n                    let location_ := add(fnPtrsPacked_, o_)\\n                    let old_ := mload(location_)\\n                    let new_ := or(old_, mload(add(fnPtrs_, add(0x20, i_))))\\n                    mstore(location_, new_)\\n                }\\n            }\\n            return fnPtrsPacked_;\\n        }\\n    }\\n\\n    function _ensureIntegrityZipmap(\\n        StateConfig memory stateConfig_,\\n        Bounds memory bounds_,\\n        uint256 operand_\\n    ) private view {\\n        unchecked {\\n            uint256 valLength_ = (operand_ >> 5) + 1;\\n            // read underflow here will show up as an OOB max later.\\n            bounds_.stackIndex -= valLength_;\\n            bounds_.stackLength = bounds_.stackLength.max(bounds_.stackIndex);\\n            bounds_.argumentsLength = bounds_.argumentsLength.max(valLength_);\\n            uint256 loopTimes_ = 1 << ((operand_ >> 3) & 0x03);\\n            uint256 outerEntrypoint_ = bounds_.entrypoint;\\n            uint256 innerEntrypoint_ = operand_ & 0x07;\\n            bounds_.entrypoint = innerEntrypoint_;\\n            for (uint256 n_ = 0; n_ < loopTimes_; n_++) {\\n                ensureIntegrity(stateConfig_, bounds_);\\n            }\\n            bounds_.entrypoint = outerEntrypoint_;\\n        }\\n    }\\n\\n    function ensureIntegrity(\\n        StateConfig memory stateConfig_,\\n        Bounds memory bounds_\\n    ) public view {\\n        unchecked {\\n            uint256 entrypoint_ = bounds_.entrypoint;\\n            require(stateConfig_.sources.length > entrypoint_, \\\"MIN_SOURCES\\\");\\n            bytes memory stackPopsFns_ = SSTORE2.read(_stackPopsFnPtrs);\\n            bytes memory stackPushesFns_ = SSTORE2.read(_stackPushesFnPtrs);\\n            uint256 i_ = 0;\\n            uint256 sourceLen_;\\n            uint256 opcode_;\\n            uint256 operand_;\\n            uint256 sourceLocation_;\\n\\n            assembly {\\n                sourceLocation_ := mload(\\n                    add(mload(stateConfig_), add(0x20, mul(entrypoint_, 0x20)))\\n                )\\n\\n                sourceLen_ := mload(sourceLocation_)\\n            }\\n\\n            while (i_ < sourceLen_) {\\n                assembly {\\n                    i_ := add(i_, 2)\\n                    let op_ := mload(add(sourceLocation_, i_))\\n                    opcode_ := byte(30, op_)\\n                    operand_ := byte(31, op_)\\n                }\\n\\n                // Additional integrity checks for core opcodes.\\n                if (opcode_ < RAIN_VM_OPS_LENGTH) {\\n                    if (opcode_ == OPCODE_CONSTANT) {\\n                        // trying to read past the end of the constants array.\\n                        // note that it is possible for a script to reach into\\n                        // arguments space after a zipmap has completed. While\\n                        // this is almost certainly a critical bug for the\\n                        // script it doesn't expose the ability to read past\\n                        // the constants array in memory so we allow it here.\\n                        require(\\n                            operand_ <\\n                                (bounds_.argumentsLength +\\n                                    stateConfig_.constants.length)\\n                        );\\n                        bounds_.stackIndex++;\\n                    } else if (opcode_ == OPCODE_STACK) {\\n                        // trying to read past the current stack top.\\n                        require(operand_ < bounds_.stackIndex);\\n                        bounds_.stackIndex++;\\n                    } else if (opcode_ == OPCODE_CONTEXT) {\\n                        // Note that context length check is handled at runtime\\n                        // because we don't know how long context should be at\\n                        // this point.\\n                        bounds_.stackIndex++;\\n                    } else if (opcode_ == OPCODE_STORAGE) {\\n                        // trying to read past allowed storage slots.\\n                        require(operand_ < bounds_.storageLength);\\n                        bounds_.stackIndex++;\\n                    }\\n                    if (opcode_ == OPCODE_ZIPMAP) {\\n                        _ensureIntegrityZipmap(stateConfig_, bounds_, operand_);\\n                    }\\n                } else {\\n                    // Opcodes can't exceed the bounds of valid fn pointers.\\n                    require(opcode_ < bounds_.opcodesLength, \\\"MAX_OPCODE\\\");\\n                    function(uint256) pure returns (uint256) popsFn_;\\n                    function(uint256) pure returns (uint256) pushesFn_;\\n                    assembly {\\n                        popsFn_ := mload(\\n                            add(stackPopsFns_, add(0x20, mul(opcode_, 0x20)))\\n                        )\\n                        pushesFn_ := mload(\\n                            add(stackPushesFns_, add(0x20, mul(opcode_, 0x20)))\\n                        )\\n                    }\\n\\n                    // This will catch popping/reading from underflowing the\\n                    // stack as it will show up as an overflow on the stack\\n                    // length below.\\n                    bounds_.stackIndex -= popsFn_(operand_);\\n                    bounds_.stackLength = bounds_.stackLength.max(\\n                        bounds_.stackIndex\\n                    );\\n\\n                    bounds_.stackIndex += pushesFn_(operand_);\\n                }\\n\\n                bounds_.stackLength = bounds_.stackLength.max(\\n                    bounds_.stackIndex\\n                );\\n            }\\n            // Both an overflow or underflow in uint256 space will show up as\\n            // an upper bound exceeding the uint8 space.\\n            require(bounds_.stackLength <= MAX_STACK_LENGTH, \\\"MAX_STACK\\\");\\n        }\\n    }\\n\\n    function stackPopsFnPtrs() public pure virtual returns (bytes memory) {}\\n\\n    function stackPushesFnPtrs() public pure virtual returns (bytes memory) {}\\n}\\n\",\"keccak256\":\"0xd60dd0ce86eb167d04e2514130fc53cb1d0911d15bdbf29fd82be84b29320f72\",\"license\":\"CAL\"},\"contracts/vm/ops/AllStandardOps.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../RainVM.sol\\\";\\nimport \\\"./erc20/OpERC20BalanceOf.sol\\\";\\nimport \\\"./erc20/OpERC20TotalSupply.sol\\\";\\nimport \\\"./erc20/snapshot/OpERC20SnapshotBalanceOfAt.sol\\\";\\nimport \\\"./erc20/snapshot/OpERC20SnapshotTotalSupplyAt.sol\\\";\\nimport \\\"./erc721/OpERC721BalanceOf.sol\\\";\\nimport \\\"./erc721/OpERC721OwnerOf.sol\\\";\\nimport \\\"./erc1155/OpERC1155BalanceOf.sol\\\";\\nimport \\\"./erc1155/OpERC1155BalanceOfBatch.sol\\\";\\nimport \\\"./evm/OpBlockNumber.sol\\\";\\nimport \\\"./evm/OpCaller.sol\\\";\\nimport \\\"./evm/OpThisAddress.sol\\\";\\nimport \\\"./evm/OpTimestamp.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScale18.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScale18Div.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScale18Mul.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScaleBy.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScaleN.sol\\\";\\nimport \\\"./math/logic/OpAny.sol\\\";\\nimport \\\"./math/logic/OpEagerIf.sol\\\";\\nimport \\\"./math/logic/OpEqualTo.sol\\\";\\nimport \\\"./math/logic/OpEvery.sol\\\";\\nimport \\\"./math/logic/OpGreaterThan.sol\\\";\\nimport \\\"./math/logic/OpIsZero.sol\\\";\\nimport \\\"./math/logic/OpLessThan.sol\\\";\\nimport \\\"./math/saturating/OpSaturatingAdd.sol\\\";\\nimport \\\"./math/saturating/OpSaturatingMul.sol\\\";\\nimport \\\"./math/saturating/OpSaturatingSub.sol\\\";\\nimport \\\"./math/OpAdd.sol\\\";\\nimport \\\"./math/OpDiv.sol\\\";\\nimport \\\"./math/OpExp.sol\\\";\\nimport \\\"./math/OpMax.sol\\\";\\nimport \\\"./math/OpMin.sol\\\";\\nimport \\\"./math/OpMod.sol\\\";\\nimport \\\"./math/OpMul.sol\\\";\\nimport \\\"./math/OpSub.sol\\\";\\nimport \\\"./tier/OpITierV2Report.sol\\\";\\nimport \\\"./tier/OpITierV2ReportTimeForTier.sol\\\";\\nimport \\\"./tier/OpSaturatingDiff.sol\\\";\\nimport \\\"./tier/OpSelectLte.sol\\\";\\nimport \\\"./tier/OpUpdateTimesForTierRange.sol\\\";\\n\\nuint256 constant ALL_STANDARD_OPS_LENGTH = RAIN_VM_OPS_LENGTH + 40;\\n\\n/// @title AllStandardOps\\n/// @notice RainVM opcode pack to expose all other packs.\\nlibrary AllStandardOps {\\n    function zero(uint256) internal pure returns (uint256) {\\n        return 0;\\n    }\\n\\n    function one(uint256) internal pure returns (uint256) {\\n        return 1;\\n    }\\n\\n    function two(uint256) internal pure returns (uint256) {\\n        return 2;\\n    }\\n\\n    function three(uint256) internal pure returns (uint256) {\\n        return 3;\\n    }\\n\\n    function nonzeroOperandN(uint256 operand_) internal pure returns (uint256) {\\n        require(operand_ > 0, \\\"0_OPERAND\\\");\\n        return operand_;\\n    }\\n\\n    function stackPopsFnPtrs() internal pure returns (bytes memory) {\\n        unchecked {\\n            uint256 lenBytes_ = ALL_STANDARD_OPS_LENGTH * 0x20;\\n            function(uint256) pure returns (uint256) zeroFn_;\\n            assembly {\\n                // using zero bytes in the fnPtrs array may save gas in certain\\n                // contexts.\\n                zeroFn_ := 0\\n            }\\n            function(uint256) pure returns (uint256)[ALL_STANDARD_OPS_LENGTH +\\n                1]\\n                memory fns_ = [\\n                    // will be overriden with length\\n                    zeroFn_,\\n                    // constant placeholder\\n                    zeroFn_,\\n                    // stack placeholder\\n                    zeroFn_,\\n                    // context placeholder\\n                    zeroFn_,\\n                    // storage placeholder\\n                    zeroFn_,\\n                    // zipmap placeholder\\n                    zeroFn_,\\n                    // debug placeholder\\n                    zeroFn_,\\n                    // erc20 balance of\\n                    two,\\n                    // erc20 total supply\\n                    one,\\n                    // erc20 snapshot balance of at\\n                    three,\\n                    // erc20 snapshot total supply at\\n                    two,\\n                    // erc721 balance of\\n                    two,\\n                    // erc721 owner of\\n                    two,\\n                    // erc1155 balance of\\n                    three,\\n                    // erc1155 balance of batch\\n                    OpERC1155BalanceOfBatch.stackPops,\\n                    // block number\\n                    zero,\\n                    // caller\\n                    zero,\\n                    // this address\\n                    zero,\\n                    // timestamp\\n                    zero,\\n                    // scale18\\n                    one,\\n                    // scale18 div\\n                    two,\\n                    // scale18 mul\\n                    two,\\n                    // scaleBy\\n                    one,\\n                    // scaleN\\n                    one,\\n                    // any\\n                    nonzeroOperandN,\\n                    // eager if\\n                    three,\\n                    // equal to\\n                    two,\\n                    // every\\n                    nonzeroOperandN,\\n                    // greater than\\n                    two,\\n                    // iszero\\n                    one,\\n                    // less than\\n                    two,\\n                    // saturating add\\n                    nonzeroOperandN,\\n                    // saturating mul\\n                    nonzeroOperandN,\\n                    // saturating sub\\n                    nonzeroOperandN,\\n                    // add\\n                    nonzeroOperandN,\\n                    // div\\n                    nonzeroOperandN,\\n                    // exp\\n                    nonzeroOperandN,\\n                    // max\\n                    nonzeroOperandN,\\n                    // min\\n                    nonzeroOperandN,\\n                    // mod\\n                    nonzeroOperandN,\\n                    // mul\\n                    nonzeroOperandN,\\n                    // sub\\n                    nonzeroOperandN,\\n                    // tier report\\n                    OpITierV2Report.stackPops,\\n                    // tier report time for tier\\n                    OpITierV2ReportTimeForTier.stackPops,\\n                    // tier saturating diff\\n                    two,\\n                    // select lte\\n                    OpSelectLte.stackPops,\\n                    // update times for tier range\\n                    two\\n                ];\\n            bytes memory ret_;\\n            assembly {\\n                mstore(fns_, lenBytes_)\\n                ret_ := fns_\\n            }\\n            return ret_;\\n        }\\n    }\\n\\n    function stackPushesFnPtrs() internal pure returns (bytes memory) {\\n        unchecked {\\n            uint256 lenBytes_ = ALL_STANDARD_OPS_LENGTH * 0x20;\\n            function(uint256) pure returns (uint256) zeroFn_;\\n            assembly {\\n                // using zero bytes in the fnPtrs array may save gas in certain\\n                // contexts.\\n                zeroFn_ := 0\\n            }\\n            function(uint256) pure returns (uint256)[ALL_STANDARD_OPS_LENGTH +\\n                1]\\n                memory fns_ = [\\n                    // will be overriden with length\\n                    zeroFn_,\\n                    // constant placeholder\\n                    zeroFn_,\\n                    // stack placeholder\\n                    zeroFn_,\\n                    // context placeholder\\n                    zeroFn_,\\n                    // storage placeholder\\n                    zeroFn_,\\n                    // zipmap placeholder\\n                    zeroFn_,\\n                    // debug placeholder\\n                    zeroFn_,\\n                    // erc20 balance of\\n                    one,\\n                    // erc20 total supply\\n                    one,\\n                    // erc20 snapshot balance of at\\n                    one,\\n                    // erc20 snapshot total supply at\\n                    one,\\n                    // erc721 balance of\\n                    one,\\n                    // erc721 owner of\\n                    one,\\n                    // erc1155 balance of\\n                    one,\\n                    // erc1155 balance of batch\\n                    nonzeroOperandN,\\n                    // block number\\n                    one,\\n                    // caller\\n                    one,\\n                    // this address\\n                    one,\\n                    // timestamp\\n                    one,\\n                    // scale18\\n                    one,\\n                    // scale18 div\\n                    one,\\n                    // scale18 mul\\n                    one,\\n                    // scaleBy\\n                    one,\\n                    // scaleN\\n                    one,\\n                    // any\\n                    one,\\n                    // eager if\\n                    one,\\n                    // equal to\\n                    one,\\n                    // every\\n                    one,\\n                    // greater than\\n                    one,\\n                    // iszero\\n                    one,\\n                    // less than\\n                    one,\\n                    // saturating add\\n                    one,\\n                    // saturating mul\\n                    one,\\n                    // saturating sub\\n                    one,\\n                    // add\\n                    one,\\n                    // div\\n                    one,\\n                    // exp\\n                    one,\\n                    // max\\n                    one,\\n                    // min\\n                    one,\\n                    // mod\\n                    one,\\n                    // mul\\n                    one,\\n                    // sub\\n                    one,\\n                    // tier report\\n                    one,\\n                    // tier report time for tier\\n                    one,\\n                    // tier saturating diff\\n                    one,\\n                    // select lte\\n                    one,\\n                    // update times for tier range\\n                    one\\n                ];\\n            bytes memory ret_;\\n            assembly {\\n                mstore(fns_, lenBytes_)\\n                ret_ := fns_\\n            }\\n            return ret_;\\n        }\\n    }\\n\\n    function fnPtrs() internal pure returns (bytes memory) {\\n        unchecked {\\n            uint256 lenBytes_ = ALL_STANDARD_OPS_LENGTH * 0x20;\\n            function(uint256, uint256) view returns (uint256) zeroFn_;\\n            assembly {\\n                // using zero bytes in the fnPtrs array may save gas in certain\\n                // contexts.\\n                zeroFn_ := 0\\n            }\\n            function(uint256, uint256)\\n                view\\n                returns (uint256)[ALL_STANDARD_OPS_LENGTH + 1]\\n                memory fns_ = [\\n                    // will be overridden with length\\n                    zeroFn_,\\n                    // placeholders for core ops\\n                    // constant\\n                    zeroFn_,\\n                    // stack\\n                    zeroFn_,\\n                    // context\\n                    zeroFn_,\\n                    // storage\\n                    zeroFn_,\\n                    // zipmap\\n                    zeroFn_,\\n                    // debug\\n                    zeroFn_,\\n                    // dispatchable ops\\n                    OpERC20BalanceOf.balanceOf,\\n                    OpERC20TotalSupply.totalSupply,\\n                    OpERC20SnapshotBalanceOfAt.balanceOfAt,\\n                    OpERC20SnapshotTotalSupplyAt.totalSupplyAt,\\n                    OpERC721BalanceOf.balanceOf,\\n                    OpERC721OwnerOf.ownerOf,\\n                    OpERC1155BalanceOf.balanceOf,\\n                    OpERC1155BalanceOfBatch.balanceOfBatch,\\n                    OpBlockNumber.blockNumber,\\n                    OpCaller.caller,\\n                    OpThisAddress.thisAddress,\\n                    OpTimestamp.timestamp,\\n                    OpFixedPointScale18.scale18,\\n                    OpFixedPointScale18Div.scale18Div,\\n                    OpFixedPointScale18Mul.scale18Mul,\\n                    OpFixedPointScaleBy.scaleBy,\\n                    OpFixedPointScaleN.scaleN,\\n                    OpAny.any,\\n                    OpEagerIf.eagerIf,\\n                    OpEqualTo.equalTo,\\n                    OpEvery.every,\\n                    OpGreaterThan.greaterThan,\\n                    OpIsZero.isZero,\\n                    OpLessThan.lessThan,\\n                    OpSaturatingAdd.saturatingAdd,\\n                    OpSaturatingMul.saturatingMul,\\n                    OpSaturatingSub.saturatingSub,\\n                    OpAdd.add,\\n                    OpDiv.div,\\n                    OpExp.exp,\\n                    OpMax.max,\\n                    OpMin.min,\\n                    OpMod.mod,\\n                    OpMul.mul,\\n                    OpSub.sub,\\n                    OpITierV2Report.report,\\n                    OpITierV2ReportTimeForTier.reportTimeForTier,\\n                    OpSaturatingDiff.saturatingDiff,\\n                    OpSelectLte.selectLte,\\n                    OpUpdateTimesForTierRange.updateTimesForTierRange\\n                ];\\n            bytes memory ret_;\\n            assembly {\\n                mstore(fns_, lenBytes_)\\n                ret_ := fns_\\n            }\\n            return ret_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc3b7cd0d079e0d7c530ff2c7af8156763644e3e20103a4025161ede57ad0ab1e\",\"license\":\"CAL\"},\"contracts/vm/ops/erc1155/OpERC1155BalanceOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\n/// @title OpERC1155BalanceOf\\n/// @notice Opcode for getting the current erc1155 balance of an account.\\nlibrary OpERC1155BalanceOf {\\n    // Stack the return of `balanceOf`.\\n    function balanceOf(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 token_;\\n        uint256 account_;\\n        uint256 id_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, 0x60)\\n            stackTopLocation_ := add(location_, 0x20)\\n            token_ := mload(location_)\\n            account_ := mload(stackTopLocation_)\\n            id_ := mload(add(location_, 0x40))\\n        }\\n        uint256 result_ = IERC1155(address(uint160(token_))).balanceOf(\\n            address(uint160(account_)),\\n            id_\\n        );\\n        assembly {\\n            mstore(location_, result_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x501ddca2cd98e596eaa6f85c0c76881250c9092beb2eaff40193786873b6f02b\",\"license\":\"CAL\"},\"contracts/vm/ops/erc1155/OpERC1155BalanceOfBatch.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\n/// @title OpERC1155BalanceOfBatch\\n/// @notice Opcode for getting the current erc1155 balance of an accounts batch.\\nlibrary OpERC1155BalanceOfBatch {\\n    function stackPops(uint256 operand_) internal pure returns (uint256) {\\n        unchecked {\\n            require(operand_ > 0, \\\"0_OPERAND\\\");\\n            return (operand_ * 2) + 1;\\n        }\\n    }\\n\\n    // Stack the return of `balanceOfBatch`.\\n    // Operand will be the length\\n    function balanceOfBatch(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        address[] memory addresses_ = new address[](operand_);\\n        uint256[] memory ids_ = new uint256[](operand_);\\n        uint256 token_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, add(0x20, mul(operand_, 0x40)))\\n            token_ := mload(location_)\\n            let cursor_ := add(location_, 0x20)\\n\\n            for {\\n                let maxCursor_ := add(cursor_, mul(operand_, 0x20))\\n                let addressesCursor_ := add(addresses_, 0x20)\\n            } lt(cursor_, maxCursor_) {\\n                cursor_ := add(cursor_, 0x20)\\n                addressesCursor_ := add(addressesCursor_, 0x20)\\n            } {\\n                mstore(addressesCursor_, mload(cursor_))\\n            }\\n\\n            for {\\n                let maxCursor_ := add(cursor_, mul(operand_, 0x20))\\n                let idsCursor_ := add(ids_, 0x20)\\n            } lt(cursor_, maxCursor_) {\\n                cursor_ := add(cursor_, 0x20)\\n                idsCursor_ := add(idsCursor_, 0x20)\\n            } {\\n                mstore(idsCursor_, mload(cursor_))\\n            }\\n        }\\n        uint256[] memory balances_ = IERC1155(address(uint160(token_)))\\n            .balanceOfBatch(addresses_, ids_);\\n\\n        assembly {\\n            let cursor_ := location_\\n            for {\\n                let balancesCursor_ := add(balances_, 0x20)\\n                let balancesCursorMax_ := add(\\n                    balancesCursor_,\\n                    mul(operand_, 0x20)\\n                )\\n            } lt(balancesCursor_, balancesCursorMax_) {\\n                cursor_ := add(cursor_, 0x20)\\n                balancesCursor_ := add(balancesCursor_, 0x20)\\n            } {\\n                mstore(cursor_, mload(balancesCursor_))\\n            }\\n            stackTopLocation_ := cursor_\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xedb0ce4945d3798ac92ea91daffefeee7e48e469a2750ffbc54f31022c54c950\",\"license\":\"CAL\"},\"contracts/vm/ops/erc20/OpERC20BalanceOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title OpERC20BalanceOf\\n/// @notice Opcode for ERC20 `balanceOf`.\\nlibrary OpERC20BalanceOf {\\n    /// Stack `balanceOf`.\\n    function balanceOf(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 token_;\\n        uint256 account_;\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            token_ := mload(location_)\\n            account_ := mload(stackTopLocation_)\\n        }\\n        uint256 balance_ = IERC20(address(uint160(token_))).balanceOf(\\n            address(uint160(account_))\\n        );\\n        assembly {\\n            mstore(location_, balance_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xc0100ed667adafe60d73f92acb3fabfa23ca400c15f1d1fbb6e680a9ff42206f\",\"license\":\"CAL\"},\"contracts/vm/ops/erc20/OpERC20TotalSupply.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title OpERC20TotalSupply\\n/// @notice Opcode for ERC20 `totalSupply`.\\nlibrary OpERC20TotalSupply {\\n    // Stack the return of `totalSupply`.\\n    function totalSupply(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 token_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, 0x20)\\n            token_ := mload(location_)\\n        }\\n        uint256 supply_ = IERC20(address(uint160(token_))).totalSupply();\\n        assembly {\\n            mstore(location_, supply_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x136befcb6391498835a5f63016b5fa5f0a714902b0887ce806ac60dea6f17cf7\",\"license\":\"CAL\"},\"contracts/vm/ops/erc20/snapshot/OpERC20SnapshotBalanceOfAt.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\\\";\\n\\n/// @title OpERC20SnapshotBalanceOfAt\\n/// @notice Opcode for Open Zeppelin `ERC20Snapshot.balanceOfAt`.\\n/// https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20Snapshot\\nlibrary OpERC20SnapshotBalanceOfAt {\\n    /// Stack `balanceOfAt`.\\n    function balanceOfAt(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 token_;\\n        uint256 account_;\\n        uint256 snapshotId_;\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x40)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            token_ := mload(location_)\\n            account_ := mload(stackTopLocation_)\\n            snapshotId_ := mload(add(stackTopLocation_, 0x20))\\n        }\\n        uint256 balance_ = ERC20Snapshot(address(uint160(token_))).balanceOfAt(\\n            address(uint160(account_)),\\n            snapshotId_\\n        );\\n        assembly {\\n            mstore(location_, balance_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x8d62ba45986e5585ef20e6526f44132a28b48dc927c1479f6befc331ec582b5b\",\"license\":\"CAL\"},\"contracts/vm/ops/erc20/snapshot/OpERC20SnapshotTotalSupplyAt.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\\\";\\n\\n/// @title OpERC20SnapshotTotalSupplyAt\\n/// @notice Opcode for Open Zeppelin `ERC20Snapshot.totalSupplyAt`.\\n/// https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20Snapshot\\nlibrary OpERC20SnapshotTotalSupplyAt {\\n    /// Stack `totalSupplyAt`.\\n    function totalSupplyAt(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 token_;\\n        uint256 snapshotId_;\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            token_ := mload(location_)\\n            snapshotId_ := mload(stackTopLocation_)\\n        }\\n        uint256 totalSupply_ = ERC20Snapshot(address(uint160(token_)))\\n            .totalSupplyAt(snapshotId_);\\n        assembly {\\n            mstore(location_, totalSupply_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x8528b1dd51723768595d35537141a1997cb3b322aa0f70d5dc736e8014142428\",\"license\":\"CAL\"},\"contracts/vm/ops/erc721/OpERC721BalanceOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n/// @title OpERC721BalanceOf\\n/// @notice Opcode for getting the current erc721 balance of an account.\\nlibrary OpERC721BalanceOf {\\n    // Stack the return of `balanceOf`.\\n    function balanceOf(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 token_;\\n        uint256 account_;\\n\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            token_ := mload(location_)\\n            account_ := mload(stackTopLocation_)\\n        }\\n        uint256 balance_ = IERC721(address(uint160(token_))).balanceOf(\\n            address(uint160(account_))\\n        );\\n\\n        assembly {\\n            mstore(location_, balance_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xeded12fa887be8e6d1358823d59078bfe55ff845feff02fe835f05dcb561c6a5\",\"license\":\"CAL\"},\"contracts/vm/ops/erc721/OpERC721OwnerOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n/// @title OpERC721OwnerOf\\n/// @notice Opcode for getting the current erc721 owner of an account.\\nlibrary OpERC721OwnerOf {\\n    // Stack the return of `ownerOf`.\\n    function ownerOf(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 token_;\\n        uint256 id_;\\n\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            token_ := mload(location_)\\n            id_ := mload(stackTopLocation_)\\n        }\\n        uint256 owner_ = uint256(\\n            uint160(IERC721(address(uint160(token_))).ownerOf(id_))\\n        );\\n        assembly {\\n            mstore(location_, owner_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xf1401b6f6cd8e5d861e75c9dc75e82ac7c9453f5e054422b7bef99e16b43b41e\",\"license\":\"CAL\"},\"contracts/vm/ops/evm/OpBlockNumber.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpBlockNumber\\n/// @notice Opcode for getting the current block number.\\nlibrary OpBlockNumber {\\n    function blockNumber(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        assembly {\\n            mstore(stackTopLocation_, number())\\n            stackTopLocation_ := add(stackTopLocation_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x838009d0b58ca254de3451dba393ba9d4da35179da51296dc631c72dfb8ce646\",\"license\":\"CAL\"},\"contracts/vm/ops/evm/OpCaller.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpCaller\\n/// @notice Opcode for getting the current caller.\\nlibrary OpCaller {\\n    function caller(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        assembly {\\n            mstore(stackTopLocation_, caller())\\n            stackTopLocation_ := add(stackTopLocation_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x60e8410815291d4e6e5d17077156ee4f7a7651b58e7993cc88e8f46432ac1380\",\"license\":\"CAL\"},\"contracts/vm/ops/evm/OpThisAddress.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpThisAddress\\n/// @notice Opcode for getting the address of the current contract.\\nlibrary OpThisAddress {\\n    function thisAddress(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        assembly {\\n            mstore(stackTopLocation_, address())\\n            stackTopLocation_ := add(stackTopLocation_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xd9599f95ad49825fcf48a91a248bacbdc9c58e831cb83228d6d2b5016969b411\",\"license\":\"CAL\"},\"contracts/vm/ops/evm/OpTimestamp.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpTimestamp\\n/// @notice Opcode for getting the current timestamp.\\nlibrary OpTimestamp {\\n    function timestamp(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        assembly {\\n            mstore(stackTopLocation_, timestamp())\\n            stackTopLocation_ := add(stackTopLocation_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xd8e1d955accbaf86289e7706550ee751ed8e0cf60205c81821a0bbd2eb30ceb5\",\"license\":\"CAL\"},\"contracts/vm/ops/math/OpAdd.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpAdd\\n/// @notice Opcode for adding N numbers.\\nlibrary OpAdd {\\n    function add(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            let accumulator_ := mload(location_)\\n            let intermediate_\\n            for {\\n                let cursor_ := add(location_, 0x20)\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                intermediate_ := add(accumulator_, mload(cursor_))\\n                // Adapted from Open Zeppelin safe math.\\n                if lt(intermediate_, accumulator_) {\\n                    revert(0, 0)\\n                }\\n                accumulator_ := intermediate_\\n            }\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x1a3e8c6f7a4b8e9001b3f9566968887ba0215b7a14638bd3f1a64b3bf0be1e69\",\"license\":\"CAL\"},\"contracts/vm/ops/math/OpDiv.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpDiv\\n/// @notice Opcode for dividing N numbers.\\nlibrary OpDiv {\\n    function div(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            let accumulator_ := mload(location_)\\n            let item_\\n            for {\\n                let cursor_ := add(location_, 0x20)\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                item_ := mload(cursor_)\\n                // Adapted from Open Zeppelin safe math.\\n                if iszero(item_) {\\n                    revert(0, 0)\\n                }\\n                accumulator_ := div(accumulator_, item_)\\n            }\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x7f9c5376a6d9820d20029928063a3c4d9ab24c021c8bd9bdeb964d6194a7316b\",\"license\":\"CAL\"},\"contracts/vm/ops/math/OpExp.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpExp\\n/// @notice Opcode to exponentiate N numbers.\\nlibrary OpExp {\\n    function exp(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 accumulator_;\\n        uint256 cursor_;\\n        uint256 item_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            accumulator_ := mload(location_)\\n            cursor_ := add(location_, 0x20)\\n        }\\n        while (cursor_ < stackTopLocation_) {\\n            assembly {\\n                item_ := mload(cursor_)\\n                cursor_ := add(cursor_, 0x20)\\n            }\\n            // This is NOT in assembly so that we get overflow safety.\\n            accumulator_ = accumulator_**item_;\\n        }\\n        assembly {\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x31be9d92aa9b7cd0db1a4780449ae801f4c7837df4f30a12f91615df257bf853\",\"license\":\"CAL\"},\"contracts/vm/ops/math/OpMax.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpMax\\n/// @notice Opcode to stack the maximum of N numbers.\\nlibrary OpMax {\\n    function max(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            let accumulator_ := mload(location_)\\n            let cursor_ := add(location_, 0x20)\\n            let item_\\n            for {\\n                cursor_ := add(location_, 0x20)\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                item_ := mload(cursor_)\\n                if gt(item_, accumulator_) {\\n                    accumulator_ := item_\\n                }\\n            }\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x3bdac5580e6117380789512b72b18cd339c2c80b703706287c8d6956a19a823b\",\"license\":\"CAL\"},\"contracts/vm/ops/math/OpMin.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpMin\\n/// @notice Opcode to stack the minimum of N numbers.\\nlibrary OpMin {\\n    function min(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            let accumulator_ := mload(location_)\\n            let cursor_ := add(location_, 0x20)\\n            let item_\\n            for {\\n                cursor_ := add(location_, 0x20)\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                item_ := mload(cursor_)\\n                if lt(item_, accumulator_) {\\n                    accumulator_ := item_\\n                }\\n            }\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x8fb9b180e85064de4f80619c105e4b611a0a649fb0f51ba07af23a3f7a9e14ce\",\"license\":\"CAL\"},\"contracts/vm/ops/math/OpMod.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpMod\\n/// @notice Opcode to mod N numbers.\\nlibrary OpMod {\\n    function mod(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            let accumulator_ := mload(location_)\\n            let item_\\n            for {\\n                let cursor_ := add(location_, 0x20)\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                item_ := mload(cursor_)\\n                // Adapted from Open Zeppelin safe math.\\n                if iszero(item_) {\\n                    revert(0, 0)\\n                }\\n                accumulator_ := mod(accumulator_, item_)\\n            }\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x9b49b493b5cd292bca88c381527b6ef958dd25a269862f27e5cb71bdf25998a1\",\"license\":\"CAL\"},\"contracts/vm/ops/math/OpMul.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpMul\\n/// @notice Opcode for multiplying N numbers.\\nlibrary OpMul {\\n    function mul(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            let accumulator_ := mload(location_)\\n            let item_\\n            let intermediate_\\n            for {\\n                let cursor_ := add(location_, 0x20)\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                if gt(accumulator_, 0) {\\n                    item_ := mload(cursor_)\\n                    intermediate_ := mul(accumulator_, item_)\\n                    // Adapted from Open Zeppelin safe math.\\n                    if iszero(eq(div(intermediate_, accumulator_), item_)) {\\n                        revert(0, 0)\\n                    }\\n                    accumulator_ := intermediate_\\n                }\\n            }\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xabf7186f7ced156af756cb4dd1628d65bb6f309b91a16b17f36a525ecff04f18\",\"license\":\"CAL\"},\"contracts/vm/ops/math/OpSub.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpSub\\n/// @notice Opcode for subtracting N numbers.\\nlibrary OpSub {\\n    function sub(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            let accumulator_ := mload(location_)\\n            let intermediate_\\n            for {\\n                let cursor_ := add(location_, 0x20)\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                intermediate_ := sub(accumulator_, mload(cursor_))\\n                // Adapted from Open Zeppelin safe math.\\n                if gt(intermediate_, accumulator_) {\\n                    revert(0, 0)\\n                }\\n                accumulator_ := intermediate_\\n            }\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x36065096154959455e85ac7fb43012d6c8ce0f179e6ad3155bf3953c7863d889\",\"license\":\"CAL\"},\"contracts/vm/ops/math/fixedPoint/OpFixedPointScale18.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\n\\n/// @title OpFixedPointScale18\\n/// @notice Opcode for scaling a number to 18 fixed point.\\nlibrary OpFixedPointScale18 {\\n    using FixedPointMath for uint256;\\n\\n    function scale18(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 a_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        uint256 b_ = a_.scale18(operand_);\\n        assembly {\\n            mstore(location_, b_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xe4e12a77b98ad57b090d62c02f232dc0a5797dc8b4470046f4b67e631ca14b58\",\"license\":\"CAL\"},\"contracts/vm/ops/math/fixedPoint/OpFixedPointScale18Div.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\n\\n/// @title OpFixedPointScale18Div\\n/// @notice Opcode for performing scale 18 fixed point division.\\nlibrary OpFixedPointScale18Div {\\n    using FixedPointMath for uint256;\\n\\n    function scale18Div(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 a_;\\n        uint256 b_;\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTopLocation_)\\n        }\\n        uint256 c_ = a_.scale18(operand_).fixedPointDiv(b_);\\n        assembly {\\n            mstore(location_, c_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x38cf55ac6dd8798ca462a102cdab3def122d9f9a2dfe74f49ec8d88a8ab785f1\",\"license\":\"CAL\"},\"contracts/vm/ops/math/fixedPoint/OpFixedPointScale18Mul.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\n\\n/// @title OpFixedPointScale18Mul\\n/// @notice Opcode for performing scale 18 fixed point multiplication.\\nlibrary OpFixedPointScale18Mul {\\n    using FixedPointMath for uint256;\\n\\n    function scale18Mul(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 a_;\\n        uint256 b_;\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTopLocation_)\\n        }\\n        uint256 c_ = a_.scale18(operand_).fixedPointMul(b_);\\n        assembly {\\n            mstore(location_, c_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x7c8149000e8ba541968b1822f1d716f4022a4ddc547ed7d661c6e06856f5f1c2\",\"license\":\"CAL\"},\"contracts/vm/ops/math/fixedPoint/OpFixedPointScaleBy.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\n\\n/// @title OpFixedPointScaleBy\\n/// @notice Opcode for scaling a number by some OOMs.\\nlibrary OpFixedPointScaleBy {\\n    using FixedPointMath for uint256;\\n\\n    function scaleBy(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 a_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        uint256 b_ = a_.scaleBy(int8(uint8(operand_)));\\n        assembly {\\n            mstore(location_, b_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x540c088d27152e8198f26e8ec00489562b7e77fe2d4e47b23ba701b31b16f5b4\",\"license\":\"CAL\"},\"contracts/vm/ops/math/fixedPoint/OpFixedPointScaleN.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\n\\n/// @title OpFixedPointScaleN\\n/// @notice Opcode for scaling a number to N fixed point.\\nlibrary OpFixedPointScaleN {\\n    using FixedPointMath for uint256;\\n\\n    function scaleN(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 a_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        uint256 b_ = a_.scaleN(operand_);\\n        assembly {\\n            mstore(location_, b_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xc6305a7fcc903e8f94c341d9c948469646e66b8e44ec74f7e15ce601944d49a7\",\"license\":\"CAL\"},\"contracts/vm/ops/math/logic/OpAny.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpAny\\n/// @notice Opcode to compare the top N stack values.\\nlibrary OpAny {\\n    // ANY\\n    // ANY is the first nonzero item, else 0.\\n    // operand_ id the length of items to check.\\n    function any(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            for {\\n                let cursor_ := location_\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                // If anything is NOT zero then ANY is a successful\\n                // check and can short-circuit.\\n                let item_ := mload(cursor_)\\n                if iszero(iszero(item_)) {\\n                    // Write the usable value to the top of the stack.\\n                    mstore(location_, item_)\\n                    break\\n                }\\n            }\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x0645452cc4b1fb710ad9457e11053c4b0e571d1a09925eafcb10675db4af490e\",\"license\":\"CAL\"},\"contracts/vm/ops/math/logic/OpEagerIf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpEagerIf\\n/// @notice Opcode for selecting a value based on a condition.\\nlibrary OpEagerIf {\\n    /// Eager because BOTH x_ and y_ must be eagerly evaluated\\n    /// before EAGER_IF will select one of them. If both x_ and y_\\n    /// are cheap (e.g. constant values) then this may also be the\\n    /// simplest and cheapest way to select one of them.\\n    function eagerIf(uint256, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, 0x60)\\n            stackTopLocation_ := add(location_, 0x20)\\n            // false => use second value\\n            // true => use first value\\n            mstore(\\n                location_,\\n                mload(\\n                    add(stackTopLocation_, mul(0x20, iszero(mload(location_))))\\n                )\\n            )\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xe969feef10104d8581d1eb951e6991a0dbed423f4e556c4815352f539c554458\",\"license\":\"CAL\"},\"contracts/vm/ops/math/logic/OpEqualTo.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpEqualTo\\n/// @notice Opcode to compare the top two stack values.\\nlibrary OpEqualTo {\\n    function equalTo(uint256, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            let location_ := sub(stackTopLocation_, 0x20)\\n            mstore(location_, eq(mload(location_), mload(stackTopLocation_)))\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x82f291dbd5982b4f42961720ff4e35ca3ee4a85f07ae501a2a31b08f96c89f4c\",\"license\":\"CAL\"},\"contracts/vm/ops/math/logic/OpEvery.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpEvery\\n/// @notice Opcode to compare the top N stack values.\\nlibrary OpEvery {\\n    // EVERY\\n    // EVERY is either the first item if every item is nonzero, else 0.\\n    // operand_ is the length of items to check.\\n    function every(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            for {\\n                let cursor_ := location_\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                // If anything is zero then EVERY is a failed check.\\n                if iszero(mload(cursor_)) {\\n                    mstore(location_, 0)\\n                    break\\n                }\\n            }\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x8a1c1c3f52e8cf9258a9ec041a67246e847316b8b5c6642e99f996f2a36eaee1\",\"license\":\"CAL\"},\"contracts/vm/ops/math/logic/OpGreaterThan.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpGreaterThan\\n/// @notice Opcode to compare the top two stack values.\\nlibrary OpGreaterThan {\\n    function greaterThan(uint256, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            let location_ := sub(stackTopLocation_, 0x20)\\n            mstore(location_, gt(mload(location_), mload(stackTopLocation_)))\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x70b58ac456f24f0047bdfeb1137f465dc3801ce6cba4006ab94bd3e1956105dd\",\"license\":\"CAL\"},\"contracts/vm/ops/math/logic/OpIsZero.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpIsZero\\n/// @notice Opcode for checking if the stack top is zero.\\nlibrary OpIsZero {\\n    function isZero(uint256, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            // The index doesn't change for iszero as there is\\n            // one input and output.\\n            let location_ := sub(stackTopLocation_, 0x20)\\n            mstore(location_, iszero(mload(location_)))\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x4fd2f15a887de7eb8355138abce5acb6d5d808ba78d360066ea29c8e743862d2\",\"license\":\"CAL\"},\"contracts/vm/ops/math/logic/OpLessThan.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpLessThan\\n/// @notice Opcode to compare the top two stack values.\\nlibrary OpLessThan {\\n    function lessThan(uint256, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            let location_ := sub(stackTopLocation_, 0x20)\\n            mstore(location_, lt(mload(location_), mload(stackTopLocation_)))\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x0a7df0155ff30495631aa1e466832cc53d2dd2c0fe2600386c12a2602ad9febd\",\"license\":\"CAL\"},\"contracts/vm/ops/math/saturating/OpSaturatingAdd.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../../math/SaturatingMath.sol\\\";\\n\\n/// @title OpSaturatingAdd\\n/// @notice Opcode for adding N numbers with saturating addition.\\nlibrary OpSaturatingAdd {\\n    using SaturatingMath for uint256;\\n\\n    function saturatingAdd(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 accumulator_;\\n        uint256 cursor_;\\n        uint256 item_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            accumulator_ := mload(location_)\\n            cursor_ := add(location_, 0x20)\\n        }\\n        while (\\n            cursor_ < stackTopLocation_ && accumulator_ < type(uint256).max\\n        ) {\\n            assembly {\\n                item_ := mload(cursor_)\\n                cursor_ := add(cursor_, 0x20)\\n            }\\n            accumulator_ = accumulator_.saturatingAdd(item_);\\n        }\\n        assembly {\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xd16cccb69cccb50c837ade18cbebd82df3ac6352bedb354f5b0c722bfad07702\",\"license\":\"CAL\"},\"contracts/vm/ops/math/saturating/OpSaturatingMul.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../../math/SaturatingMath.sol\\\";\\n\\n/// @title OpSaturatingMul\\n/// @notice Opcode for multiplying N numbers with saturating multiplication.\\nlibrary OpSaturatingMul {\\n    using SaturatingMath for uint256;\\n\\n    function saturatingMul(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 accumulator_;\\n        uint256 cursor_;\\n        uint256 item_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            accumulator_ := mload(location_)\\n            cursor_ := add(location_, 0x20)\\n        }\\n        while (\\n            cursor_ < stackTopLocation_ && accumulator_ < type(uint256).max\\n        ) {\\n            assembly {\\n                item_ := mload(cursor_)\\n                cursor_ := add(cursor_, 0x20)\\n            }\\n            accumulator_ = accumulator_.saturatingMul(item_);\\n        }\\n        assembly {\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x2ad362e8b053e7a2023ddac1ae84c591d2cf944e5bc4891b7cffba6033c29f92\",\"license\":\"CAL\"},\"contracts/vm/ops/math/saturating/OpSaturatingSub.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../../math/SaturatingMath.sol\\\";\\n\\n/// @title OpSaturatingSub\\n/// @notice Opcode for subtracting N numbers with saturating subtraction.\\nlibrary OpSaturatingSub {\\n    using SaturatingMath for uint256;\\n\\n    function saturatingSub(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 accumulator_;\\n        uint256 cursor_;\\n        uint256 item_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            accumulator_ := mload(location_)\\n            cursor_ := add(location_, 0x20)\\n        }\\n        while (cursor_ < stackTopLocation_ && 0 < accumulator_) {\\n            assembly {\\n                item_ := mload(cursor_)\\n                cursor_ := add(cursor_, 0x20)\\n            }\\n            accumulator_ = accumulator_.saturatingSub(item_);\\n        }\\n        assembly {\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xcb9885a02bed8efab382734cdf2022424b208052e662881433b1cabf0b07b922\",\"license\":\"CAL\"},\"contracts/vm/ops/tier/OpITierV2Report.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../tier/ITierV2.sol\\\";\\n\\n/// @title OpITierV2Report\\n/// @notice Exposes `ITierV2.report` as an opcode.\\nlibrary OpITierV2Report {\\n    function stackPops(uint256 operand_)\\n        internal\\n        pure\\n        returns (uint256 reportsLength_)\\n    {\\n        unchecked {\\n            reportsLength_ = operand_ + 2;\\n        }\\n    }\\n\\n    // Stack the `report` returned by an `ITierV2` contract.\\n    function report(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 tierContract_;\\n        uint256 account_;\\n        uint256[] memory context_;\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, add(0x20, operand_))\\n            location_ := sub(stackTopLocation_, 0x20)\\n            tierContract_ := mload(location_)\\n            account_ := mload(stackTopLocation_)\\n            // we can reuse the account_ as the length for context_\\n            // and achieve a near zero-cost bytes array to send to `report`.\\n            mstore(stackTopLocation_, operand_)\\n            context_ := stackTopLocation_\\n        }\\n        uint256 report_ = ITierV2(address(uint160(tierContract_))).report(\\n            address(uint160(account_)),\\n            context_\\n        );\\n        assembly {\\n            mstore(location_, report_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xcdb73c4531a175ffbecb2b2ea9787abe37d2082a5553f59aa8dacec82d0bf553\",\"license\":\"CAL\"},\"contracts/vm/ops/tier/OpITierV2ReportTimeForTier.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../tier/ITierV2.sol\\\";\\n\\n/// @title OpITierV2Report\\n/// @notice Exposes `ITierV2.reportTimeForTier` as an opcode.\\nlibrary OpITierV2ReportTimeForTier {\\n    function stackPops(uint256 operand_)\\n        internal\\n        pure\\n        returns (uint256 reportsLength_)\\n    {\\n        unchecked {\\n            reportsLength_ = operand_ + 3;\\n        }\\n    }\\n\\n    // Stack the `reportTimeForTier` returned by an `ITierV2` contract.\\n    function reportTimeForTier(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 tierContract_;\\n        uint256 account_;\\n        uint256 tier_;\\n        uint256[] memory context_;\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, add(0x20, operand_))\\n            location_ := sub(stackTopLocation_, 0x40)\\n            tierContract_ := mload(location_)\\n            account_ := mload(add(location_, 0x20))\\n            tier_ := mload(stackTopLocation_)\\n            // we can reuse the tier_ as the length for context_ and achieve a\\n            // near zero-cost bytes array to send to `reportTimeForTier`.\\n            mstore(stackTopLocation_, operand_)\\n            context_ := stackTopLocation_\\n        }\\n        uint256 reportTime_ = ITierV2(address(uint160(tierContract_)))\\n            .reportTimeForTier(address(uint160(account_)), tier_, context_);\\n        assembly {\\n            mstore(location_, reportTime_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x76c5ba4e00479285677779ee220e8d8a190decce447914055024effddc682fc7\",\"license\":\"CAL\"},\"contracts/vm/ops/tier/OpSaturatingDiff.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../tier/libraries/TierwiseCombine.sol\\\";\\n\\nlibrary OpSaturatingDiff {\\n    // Stack the tierwise saturating subtraction of two reports.\\n    // If the older report is newer than newer report the result will\\n    // be `0`, else a tierwise diff in blocks will be obtained.\\n    // The older and newer report are taken from the stack.\\n    function saturatingDiff(uint256, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 newerReport_;\\n        uint256 olderReport_;\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            newerReport_ := mload(location_)\\n            olderReport_ := mload(stackTopLocation_)\\n        }\\n        uint256 result_ = TierwiseCombine.saturatingSub(\\n            newerReport_,\\n            olderReport_\\n        );\\n        assembly {\\n            mstore(location_, result_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xc3426d11ef4b2090ece900ddfa2e802e4af8a539b336e32e4e7a9aac71af445b\",\"license\":\"CAL\"},\"contracts/vm/ops/tier/OpSelectLte.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../tier/libraries/TierwiseCombine.sol\\\";\\n\\n/// @title OpSelectLte\\n/// @notice Exposes `TierwiseCombine.selectLte` as an opcode.\\nlibrary OpSelectLte {\\n    function stackPops(uint256 operand_) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 reportsLength_ = operand_ & 0x1F; // & 00011111\\n            require(reportsLength_ > 0, \\\"BAD_OPERAND\\\");\\n            return reportsLength_;\\n        }\\n    }\\n\\n    // Stacks the result of a `selectLte` combinator.\\n    // All `selectLte` share the same stack and argument handling.\\n    // Takes the `logic_` and `mode_` from the `operand_` high bits.\\n    // `logic_` is the highest bit.\\n    // `mode_` is the 2 highest bits after `logic_`.\\n    // The other bits specify how many values to take from the stack\\n    // as reports to compare against each other and the block number.\\n    function selectLte(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 logic_ = operand_ >> 7;\\n        uint256 mode_ = (operand_ >> 5) & 0x3; // & 00000011\\n        uint256 reportsLength_ = operand_ & 0x1F; // & 00011111\\n\\n        uint256 location_;\\n        uint256[] memory reports_ = new uint256[](reportsLength_);\\n        uint256 time_;\\n        assembly {\\n            location_ := sub(\\n                stackTopLocation_,\\n                mul(add(reportsLength_, 1), 0x20)\\n            )\\n            let maxCursor_ := add(location_, mul(reportsLength_, 0x20))\\n            for {\\n                let cursor_ := location_\\n                let i_ := 0\\n            } lt(cursor_, maxCursor_) {\\n                cursor_ := add(cursor_, 0x20)\\n                i_ := add(i_, 0x20)\\n            } {\\n                mstore(add(reports_, add(0x20, i_)), mload(cursor_))\\n            }\\n            time_ := mload(maxCursor_)\\n        }\\n\\n        uint256 result_ = TierwiseCombine.selectLte(\\n            reports_,\\n            time_,\\n            logic_,\\n            mode_\\n        );\\n        assembly {\\n            mstore(location_, result_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x5ddbf756632e07e8c94dd00b90fb2e4db954b2105abefba3cf5fc97222451e78\",\"license\":\"CAL\"},\"contracts/vm/ops/tier/OpUpdateTimesForTierRange.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../tier/libraries/TierReport.sol\\\";\\n\\nlibrary OpUpdateTimesForTierRange {\\n    // Stacks a report with updated times over tier range.\\n    // The start and end tier are taken from the low and high bits of\\n    // the `operand_` respectively.\\n    // The report to update and timestamp to update to are both\\n    // taken from the stack.\\n    function updateTimesForTierRange(\\n        uint256 operand_,\\n        uint256 stackTopLocation_\\n    ) internal pure returns (uint256) {\\n        uint256 location_;\\n        uint256 report_;\\n        uint256 startTier_ = operand_ & 0x0f; // & 00001111\\n        uint256 endTier_ = (operand_ >> 4) & 0x0f; // & 00001111\\n        uint256 timestamp_;\\n\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            report_ := mload(location_)\\n            timestamp_ := mload(stackTopLocation_)\\n        }\\n\\n        uint256 result_ = TierReport.updateTimesForTierRange(\\n            report_,\\n            startTier_,\\n            endTier_,\\n            timestamp_\\n        );\\n\\n        assembly {\\n            mstore(location_, result_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x34aeb29dd80c3589ba83dbc5b6e6becf145990b605471cde925f97eb268166dc\",\"license\":\"CAL\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b5060405162006ddb38038062006ddb833981016040819052620000349162000168565b6001600090815560405182906200004b9062000141565b81518152602080830151908201526040808301516001600160a01b03908116828401526060938401511692820192909252905190819003608001906000f0801580156200009c573d6000803e3d6000fd5b5090506001600160a01b038116620000ed5760405162461bcd60e51b815260206004820152601060248201526f182fa4a6a82622a6a2a72a20aa24a7a760811b604482015260640160405180910390fd5b604080513381526001600160a01b03831660208201527f7fac34ecf0b1b374cd9659e3d17db602659d53f1162b1f20142e6c02694aed70910160405180910390a16001600160a01b031660805250620001f0565b6159a3806200143883390190565b6001600160a01b03811681146200016557600080fd5b50565b6000608082840312156200017b57600080fd5b604051608081016001600160401b0381118282101715620001ac57634e487b7160e01b600052604160045260246000fd5b806040525082518152602083015160208201526040830151620001cf816200014f565b60408201526060830151620001e4816200014f565b60608201529392505050565b60805161122c6200020c600039600061034e015261122c6000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80632ea72a491461004657806333504dad14610083578063fc91a89714610096575b600080fd5b6100596100543660046104e7565b6100df565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b610059610091366004610559565b61028d565b6100cf6100a43660046105fc565b73ffffffffffffffffffffffffffffffffffffffff1660009081526001602052604090205460ff1690565b604051901515815260200161007a565b600060026000541415610153576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064015b60405180910390fd5b600260009081556101648484610333565b73ffffffffffffffffffffffffffffffffffffffff811660009081526001602052604090205490915060ff16156101f7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f4455504c49434154455f4348494c440000000000000000000000000000000000604482015260640161014a565b73ffffffffffffffffffffffffffffffffffffffff811660008181526001602081815260409283902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169092179091558151338152908101929092527f7da70c4e5387d7038610b79ca7d304caaef815826e51e67cf247135387a79bce910160405180910390a160016000559392505050565b60003073ffffffffffffffffffffffffffffffffffffffff16632ea72a4984846040516020016102be92919061095e565b6040516020818303038152906040526040518263ffffffff1660e01b81526004016102e99190610aae565b6020604051808303816000875af1158015610308573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061032c9190610ac1565b9392505050565b6000808061034384860186610ed0565b9150915060006103727f0000000000000000000000000000000000000000000000000000000000000000610405565b6040517f278a6a6d00000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff82169063278a6a6d906103c99086908690600401611077565b600060405180830381600087803b1580156103e357600080fd5b505af11580156103f7573d6000803e3d6000fd5b509298975050505050505050565b60006040517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081528260601b60148201527f5af43d82803e903d91602b57fd5bf3000000000000000000000000000000000060288201526037816000f091505073ffffffffffffffffffffffffffffffffffffffff81166104e2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f455243313136373a20637265617465206661696c656400000000000000000000604482015260640161014a565b919050565b600080602083850312156104fa57600080fd5b823567ffffffffffffffff8082111561051257600080fd5b818501915085601f83011261052657600080fd5b81358181111561053557600080fd5b86602082850101111561054757600080fd5b60209290920196919550909350505050565b6000806040838503121561056c57600080fd5b823567ffffffffffffffff8082111561058457600080fd5b9084019060e0828703121561059857600080fd5b909250602084013590808211156105ae57600080fd5b508301608081860312156105c157600080fd5b809150509250929050565b73ffffffffffffffffffffffffffffffffffffffff811681146105ee57600080fd5b50565b80356104e2816105cc565b60006020828403121561060e57600080fd5b813561032c816105cc565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261064e57600080fd5b830160208101925035905067ffffffffffffffff81111561066e57600080fd5b8060051b360383131561068057600080fd5b9250929050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261070557600080fd5b830160208101925035905067ffffffffffffffff81111561072557600080fd5b80360383131561068057600080fd5b6000604083016107448384610619565b604086528281845260608701905060608260051b88010193508260005b838110156107bc577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa089870301835261079a82866106d0565b6107a5888284610687565b975050506020928301929190910190600101610761565b50505050506107ce6020840184610619565b85830360208701528083527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81111561080657600080fd5b60051b8082602085013760009201602001918252509392505050565b600081357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8183360301811261085657600080fd5b60808452820161086681806106d0565b60808087015261087b61010087018284610687565b91505061088b60208301836106d0565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808784030160a08801526108c0838284610687565b9250505060408201356108d2816105cc565b73ffffffffffffffffffffffffffffffffffffffff1660c0860152606082013560e0860152610903602085016105f1565b73ffffffffffffffffffffffffffffffffffffffff81166020870152915060408401356040860152610937606085016105f1565b73ffffffffffffffffffffffffffffffffffffffff8116606087015291505b949350505050565b60408152600083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc185360301811261099657600080fd5b60e060408401526109ad6101208401868301610734565b90506109bb602086016105f1565b73ffffffffffffffffffffffffffffffffffffffff1660608401526109e2604086016105f1565b73ffffffffffffffffffffffffffffffffffffffff8116608085015250606085013560a0840152608085013560c084015260a085013560e084015260c08501356101008401528281036020840152610a3a8185610822565b95945050505050565b6000815180845260005b81811015610a6957602081850181015186830182015201610a4d565b81811115610a7b576000602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b60208152600061032c6020830184610a43565b600060208284031215610ad357600080fd5b815161032c816105cc565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff81118282101715610b3057610b30610ade565b60405290565b6040516080810167ffffffffffffffff81118282101715610b3057610b30610ade565b60405160e0810167ffffffffffffffff81118282101715610b3057610b30610ade565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715610bc357610bc3610ade565b604052919050565b600067ffffffffffffffff821115610be557610be5610ade565b5060051b60200190565b600067ffffffffffffffff831115610c0957610c09610ade565b610c3a60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f86011601610b7c565b9050828152838383011115610c4e57600080fd5b828260208301376000602084830101529392505050565b600082601f830112610c7657600080fd5b81356020610c8b610c8683610bcb565b610b7c565b82815260059290921b84018101918181019086841115610caa57600080fd5b8286015b84811015610cc55780358352918301918301610cae565b509695505050505050565b60006040808385031215610ce357600080fd5b610ceb610b0d565b9150823567ffffffffffffffff80821115610d0557600080fd5b818501915085601f830112610d1957600080fd5b81356020610d29610c8683610bcb565b82815260059290921b84018101918181019089841115610d4857600080fd5b8286015b84811015610d9457803586811115610d645760008081fd5b8701603f81018c13610d765760008081fd5b610d868c868301358b8401610bef565b845250918301918301610d4c565b5087525086810135945082851115610dab57600080fd5b610db788868901610c65565b81870152505050505092915050565b600082601f830112610dd757600080fd5b61032c83833560208501610bef565b600060808284031215610df857600080fd5b610e00610b36565b9050813567ffffffffffffffff80821115610e1a57600080fd5b9083019060808286031215610e2e57600080fd5b610e36610b36565b823582811115610e4557600080fd5b610e5187828601610dc6565b825250602083013582811115610e6657600080fd5b610e7287828601610dc6565b60208301525060408301359150610e88826105cc565b81604082015260608301356060820152808452505050610eaa602083016105f1565b602082015260408201356040820152610ec5606083016105f1565b606082015292915050565b60008060408385031215610ee357600080fd5b823567ffffffffffffffff80821115610efb57600080fd5b9084019060e08287031215610f0f57600080fd5b610f17610b59565b823582811115610f2657600080fd5b610f3288828601610cd0565b825250610f41602084016105f1565b6020820152610f52604084016105f1565b6040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c0820152809450506020850135915080821115610f9757600080fd5b50610fa485828601610de6565b9150509250929050565b60008151608084528051608080860152610fcc610100860182610a43565b905060208201517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808683030160a08701526110078282610a43565b915050604082015173ffffffffffffffffffffffffffffffffffffffff80821660c0880152606084015160e088015280602087015116602088015250506040840151604086015260608401519150610956606086018373ffffffffffffffffffffffffffffffffffffffff169052565b604081526000835160e0604084015261016083018151604061012086015281815180845261018093508387019150838160051b88010193506020808401935060005b82811015611105577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe808987030184526110f3868651610a43565b955093810193928101926001016110b9565b50948501518785037ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee001610140890152805180865290860195600095810194509092505b828510156111695785518452948501946001949094019392830192611149565b8981015173ffffffffffffffffffffffffffffffffffffffff811660608a0152955060408a015173ffffffffffffffffffffffffffffffffffffffff811660808a0152955060608a015160a089015260808a015160c089015260a08a015160e089015260c08a0151610100890152878403818901525050506111eb8187610fae565b97965050505050505056fea2646970667358221220e3eef224e8797cb9b10ccecbe6ab8e1bb13cb6d44116f47500122da877eebdd264736f6c634300080a00336101006040523480156200001257600080fd5b50604051620059a3380380620059a38339810160408190526200003591620000e1565b6001600455306080908152606082810180516001600160a01b0390811660a0908152855160c05260408087018051841660e052815133815288516020808301919091528901519281019290925251831694810194909452915116928201929092527fff17a663a2bf6c40dc1bc40139e25068b0f997d33219ddf9910b87c489ef1b0e910160405180910390a15062000169565b6001600160a01b0381168114620000de57600080fd5b50565b600060808284031215620000f457600080fd5b604051608081016001600160401b03811182821017156200012557634e487b7160e01b600052604160045260246000fd5b8060405250825181526020830151602082015260408301516200014881620000c8565b604082015260608301516200015d81620000c8565b60608201529392505050565b60805160a05160c05160e051615800620001a360003960006109d80152600061051e015260006107750152600061079c01526158006000f3fe608060405234801561001057600080fd5b50600436106100ea5760003560e01c8063cd3293de1161008c578063efbe1c1c11610066578063efbe1c1c146101f7578063f2cd6c08146101ff578063f9020e33146103ab578063fc0c546a146103be57600080fd5b8063cd3293de1461017f578063d48827e9146101a8578063e0419ae3146101bb57600080fd5b8063504d14f8116100c8578063504d14f81461014457806368d1e1921461015757806370dea79a1461016f578063be9a65551461017757600080fd5b80630d548a17146100ef57806315a0ea6a1461011c578063278a6a6d14610131575b600080fd5b6101026100fd366004614506565b6103c6565b604080519283526020830191909152015b60405180910390f35b61012f61012a36600461454c565b6103e3565b005b61012f61013f3660046146ac565b6104ce565b61012f6101523660046147e6565b610bd7565b61015f610e23565b6040519015158152602001610113565b61012f610e3a565b61012f61102e565b6008545b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610113565b61012f6101b63660046147f8565b611129565b60408051808201825260008082526020918201528151808301835260058082526004918301918252835190815290519181019190915201610113565b61012f611887565b604080516105e081018252600060208201819052818301819052606082018190526080820181905260a0820181905260c082015261289260e08201819052612986610100830152612a12610120830152612b33610140830152610160820152612bdc610180820152612ce46101a0820152612db86101c0820152612fb56101e0820152612fc0610200820152612fcb610220820152612fd6610240820152612fe161026082015261301561028082015261307b6102a08201526130e16102c08201526131156102e082015261314961030082015261317e6103208201526131d961034082015261322f6103608201526132586103808201526132af6103a08201526132dc6103c08201526133336103e082015261339e6104008201526133fb6104208201526134396104408201526134726104608201526134a66104808201526134d86104a082015261350a6104c082015261353c6104e08201526135706105008201526135c26105208201526135fb6105408201526136ad6105608201526137da6105808201526138366105a08201526138f06105c0808301919091528152905161011391906148e7565b600d5460ff166040516101139190614964565b600754610183565b6000806103da6103d4611983565b846119e0565b91509150915091565b6002600d5460ff1660038111156103fc576103fc6148fa565b14610468576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600b60248201527f4e4f545f5355434345535300000000000000000000000000000000000000000060448201526064015b60405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff811660009081526011602052604090205480156104ca5773ffffffffffffffffffffffffffffffffffffffff8083166000908152601160205260408120556008546104ca91168383611a81565b5050565b60006104da6001611b55565b9050801561050f57600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff166101001790555b61051c8360800135611ce0565b7f0000000000000000000000000000000000000000000000000000000000000000836060013511156105aa576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600b60248201527f4d41585f54494d454f5554000000000000000000000000000000000000000000604482015260640161045f565b6105b86060840135426149a1565b600e5560a0830135610626576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600b60248201527f4d494e5f52414953455f30000000000000000000000000000000000000000000604482015260640161045f565b8260a00135600b819055506106716040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6000808252600160208084018290526040805160e08101825280820185905260608082018690526080820186905260a0820186905260c082018690529381526002818401819052825181815294850190925293929182015b6107096040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b8152602001906001900390816106c95790505090508281600081518110610732576107326149b9565b60200260200101819052508181600181518110610751576107516149b9565b6020908102919091010152600073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000166317376ae07f00000000000000000000000000000000000000000000000000000000000000006107c58a806149e8565b856040518463ffffffff1660e01b81526004016107e493929190614c2e565b6000604051808303816000875af1158015610803573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682016040526108499190810190614cdf565b905061085481611e0b565b600a80547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff929092169190911790556108a9604088016020890161454c565b600980547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff9290921691909117905560c0870135600c55600d80547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016905561092e606088016040890161454c565b73ffffffffffffffffffffffffffffffffffffffff90811660085586516040015116156109b7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f4449535452494255544f525f5345540000000000000000000000000000000000604482015260640161045f565b8551306040918201528651606090810151600555815160a0810183526000927f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff1692632ea72a4992918291610a2691908e01908e0161454c565b73ffffffffffffffffffffffffffffffffffffffff1681526020018a6000015181526020018a6020015173ffffffffffffffffffffffffffffffffffffffff1681526020018a6040015181526020018a6060015173ffffffffffffffffffffffffffffffffffffffff16815250604051602001610aa39190614d56565b6040516020818303038152906040526040518263ffffffff1660e01b8152600401610ace91906148e7565b6020604051808303816000875af1158015610aed573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b119190614e4f565b73ffffffffffffffffffffffffffffffffffffffff81166007556040519091507f1c4d4c08e04715f5f20860bc86635f62aebb8449c408e7d53d464fee566f3ff290610b629033908b908590614e6c565b60405180910390a150505050508015610bd257600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050565b6002600d5460ff166003811115610bf057610bf06148fa565b1415610c58576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f524546554e445f53554343455353000000000000000000000000000000000000604482015260640161045f565b6003600d5460ff166003811115610c7157610c716148fa565b14610c7e57610c7e611e96565b336000908152600f602090815260408083209051909291610ca191859101614fc5565b6040516020818303038152906040528051906020012081526020019081526020016000206000815480929190610cd690614fd3565b9091555060009050610cf060808301356060840135612035565b90508060066000828254610d049190615008565b92505081905550816060013560056000828254610d2191906149a1565b909155505060408201803590601190600090610d40906020870161454c565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254610d899190615008565b90915550506040517f92f85a40e83c8d882fe8d6e484c07c775950072962f3b22dd739834849a5a32490610dc0903390859061501f565b60405180910390a1600754610df19073ffffffffffffffffffffffffffffffffffffffff163330606086013561205d565b6104ca33610e036040850135846149a1565b60085473ffffffffffffffffffffffffffffffffffffffff169190611a81565b6000610e35610e30611983565b6120bb565b905090565b42600e5410610ea5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f4541524c595f54494d454f555400000000000000000000000000000000000000604482015260640161045f565b6000600d5460ff166003811115610ebe57610ebe6148fa565b1480610ee057506001600d5460ff166003811115610ede57610ede6148fa565b145b610f46576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f414c52454144595f454e44454400000000000000000000000000000000000000604482015260640161045f565b6000600555600d80547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660031790556040513381527f71b8d288b6b795cd40378095d6a9c6466eb4a081c0238dfd691b0b1f5868f1809060200160405180910390a16007546040517f8b24259b00000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff90911690638b24259b90602401600060405180830381600087803b15801561101457600080fd5b505af1158015611028573d6000803e3d6000fd5b50505050565b6000600d5460ff166003811115611047576110476148fa565b146110ae576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600b60248201527f4e4f545f50454e44494e47000000000000000000000000000000000000000000604482015260640161045f565b6110b9610e30611983565b61111f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4e4f545f4c495645000000000000000000000000000000000000000000000000604482015260640161045f565b611127612121565b565b60035460009073ffffffffffffffffffffffffffffffffffffffff16156111685760035473ffffffffffffffffffffffffffffffffffffffff16611196565b600380547fffffffffffffffffffffffff000000000000000000000000000000000000000016339081179091555b73ffffffffffffffffffffffffffffffffffffffff8116600090815260026020526040902054909150421015611228576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f434f4f4c444f574e000000000000000000000000000000000000000000000000604482015260640161045f565b60006001544261123891906149a1565b73ffffffffffffffffffffffffffffffffffffffff8316600081815260026020908152604091829020849055815192835282018390529192507fdd9ec76fd04aab7ee6b385c04a7bdf966620500e72b134bfc3f19654fae20f25910160405180910390a160026004541415611309576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015260640161045f565b60026004556040830151611379576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f305f4d494e494d554d0000000000000000000000000000000000000000000000604482015260640161045f565b8260600151836040015111156113eb576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f4d494e494d554d5f4f5645525f44455349524544000000000000000000000000604482015260640161045f565b60006113f5611983565b9050611400816120bb565b15611431576000600d5460ff16600381111561141e5761141e6148fa565b141561142c5761142c612121565b611458565b6001600d5460ff16600381111561144a5761144a6148fa565b141561145857611458612181565b6001600d5460ff166003811115611471576114716148fa565b146114d8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f4e4f545f41435449564500000000000000000000000000000000000000000000604482015260640161045f565b60006114f360055486606001516122d390919063ffffffff16565b905060008061150284846119e0565b9092509050600061151383856122d3565b90508760400151811015611583576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f494e53554646494349454e545f53544f434b0000000000000000000000000000604482015260640161045f565b87608001518211156115f1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f4d4158494d554d5f505249434500000000000000000000000000000000000000604482015260640161045f565b60006115fd8383612035565b6040805160a081018252601080548083528d5173ffffffffffffffffffffffffffffffffffffffff166020808501919091528e015193830193909352606082018690526080820187905292935091600061165683615049565b9091555050336000908152600f60209081526040808320905190929161167e91859101615082565b60405160208183030381529060405280519060200120815260200190815260200160002060008154809291906116b390615049565b90915550506020808b01518b5173ffffffffffffffffffffffffffffffffffffffff1660009081526011909252604082208054919290916116f59084906149a1565b92505081905550826005600082825461170e9190615008565b92505081905550816006600082825461172791906149a1565b9250508190555061176433308c602001518561174391906149a1565b60085473ffffffffffffffffffffffffffffffffffffffff1692919061205d565b6007546117889073ffffffffffffffffffffffffffffffffffffffff163385611a81565b7fde28bbdf409354cf811d2e1f52147a0a2a1b89be5848c4b5a41587f63b7cfa6a338b836040516117bb939291906150d1565b60405180910390a16117cc876120bb565b1561184657600c546005541015611841576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161045f9060208082526004908201527f4455535400000000000000000000000000000000000000000000000000000000604082015260600190565b61184e565b61184e612181565b505060016004555050600380547fffffffffffffffffffffffff0000000000000000000000000000000000000000169055505050505050565b6001600d5460ff1660038111156118a0576118a06148fa565b14611907576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f4e4f545f41435449564500000000000000000000000000000000000000000000604482015260640161045f565b611912610e30611983565b1561197b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161045f9060208082526004908201527f4c49564500000000000000000000000000000000000000000000000000000000604082015260600190565b611127612181565b6119b56040518060a0016040528060008152602001606081526020016060815260200160608152602001600081525090565b600a54610e35906119db9073ffffffffffffffffffffffffffffffffffffffff166122e9565b612317565b60408051602080825281830190925260009182918291602082018180368337019050509050836020820152611a1781866001612483565b506000808660200151600288600001510381518110611a3857611a386149b9565b60200260200101518760200151600189600001510381518110611a5d57611a5d6149b9565b602002602001015191509150611a738760009052565b9093509150505b9250929050565b60405173ffffffffffffffffffffffffffffffffffffffff8316602482015260448101829052610bd29084907fa9059cbb00000000000000000000000000000000000000000000000000000000906064015b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009093169290921790915261275a565b60008054610100900460ff1615611c0c578160ff166001148015611b785750303b155b611c04576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161045f565b506000919050565b60005460ff808416911610611ca3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161045f565b50600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660ff92909216919091179055600190565b919050565b60008111611d4a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f434f4f4c444f574e5f3000000000000000000000000000000000000000000000604482015260640161045f565b60015463ffffffff1015611dba576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f434f4f4c444f574e5f4d41580000000000000000000000000000000000000000604482015260640161045f565b60015415611dca57611dca615174565b600181905560408051338152602081018390527f6153539ba1c54ed4ef5b6f1fda4b7183eeaa1b5707c152abed56f61e09452521910160405180910390a150565b600080611e3683604051602001611e2291906151a3565b604051602081830303815290604052612866565b90508051602082016000f0915073ffffffffffffffffffffffffffffffffffffffff8216611e90576040517f08d4abb600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50919050565b60035460009073ffffffffffffffffffffffffffffffffffffffff1615611ed55760035473ffffffffffffffffffffffffffffffffffffffff16611f03565b600380547fffffffffffffffffffffffff000000000000000000000000000000000000000016339081179091555b73ffffffffffffffffffffffffffffffffffffffff8116600090815260026020526040902054909150421015611f95576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f434f4f4c444f574e000000000000000000000000000000000000000000000000604482015260640161045f565b600060015442611fa591906149a1565b73ffffffffffffffffffffffffffffffffffffffff8316600081815260026020908152604091829020849055815192835282018390529192507fdd9ec76fd04aab7ee6b385c04a7bdf966620500e72b134bfc3f19654fae20f25910160405180910390a15050600380547fffffffffffffffffffffffff0000000000000000000000000000000000000000169055565b6000670de0b6b3a764000061204a83856151c9565b6120549190615235565b90505b92915050565b60405173ffffffffffffffffffffffffffffffffffffffff808516602483015283166044820152606481018290526110289085907f23b872dd0000000000000000000000000000000000000000000000000000000090608401611ad3565b6000600160055410156120d057506000919050565b6120eb60405180602001604052806000815250836000612483565b50600080836020015160018560000151038151811061210c5761210c6149b9565b60200260200101511190506120578360009052565b600d80547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790556040513381527f84d0447ca38875fa61115673259a210915bc1dd53a3c112d6f0790f15956a9659060200160405180910390a1565b600b54600654101560008161219757600361219a565b60025b6000600555600d805491925082917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660018360038111156121de576121de6148fa565b02179055507f9aef4e6c636914c533cde859f632ab5e2b68cfd8f06b6a2e18f89783f00072cd3382604051612214929190615270565b60405180910390a16007546040517f8b24259b00000000000000000000000000000000000000000000000000000000815230600482015273ffffffffffffffffffffffffffffffffffffffff90911690638b24259b90602401600060405180830381600087803b15801561228757600080fd5b505af115801561229b573d6000803e3d6000fd5b5050505081156104ca576009546006546008546104ca9273ffffffffffffffffffffffffffffffffffffffff91821692911690611a81565b60008183106122e25781612054565b5090919050565b60606120578260017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61396c565b6123496040518060a0016040528060008152602001606081526020016060815260200160608152602001600081525090565b61237b6040518060a0016040528060008152602001606081526020016060815260200160608152602001600081525090565b60208301805160ff8082168352606084019290925290600882901c1667ffffffffffffffff8111156123af576123af614569565b6040519080825280602002602001820160405280156123d8578160200160208202803683370190505b50602083015260ff601082901c81166080840152601882901c16606060008267ffffffffffffffff81111561240f5761240f614569565b604051908082528060200260200182016040528015612438578160200160208202803683370190505b5090506020870151602002604001870160005b8481101561247257816020820260200184015281516020018201915060018101905061244b565b505060408501525091949350505050565b60208281015183516040850151848402018301518051606087015160a088015160009687968796879695948301938284019391820290920101906002015b84891015612740576003890198508886015180601f1a975061ffff8160081c1698505060068810156126b85787612506578660200284015182526020820191506126cb565b6001881415612523576020870283015182526020820191506126cb565b60028814156125b0578c518760200210612599576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f434f4e544558545f4c454e475448000000000000000000000000000000000000604482015260640161045f565b866020026020018d015182526020820191506126cb565b60038814156125f95760006125e7604080518082018252600080825260209182015281518083019092526005825260049082015290565b518801548352506020909101906126cb565b60048814156126155761260e8d8d848a613a54565b91506126cb565b606087612643578c60405160200161262d91906152d5565b60405160208183030381529060405290506126a2565b600188141561265c576126558d613bc4565b90506126a2565b6002881415612678576020808e015160405161262d92016153ab565b60038814156126a2578c516040805160208101929092520160405160208183030381529060405290505b8051156126b2576126b281613d01565b506126cb565b876126c7888463ffffffff8416565b9250505b60208c0151518c51111561273b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f535441434b5f4f564552464c4f57000000000000000000000000000000000000604482015260640161045f565b6124c1565b6020838303048c52509750505050505050505b9392505050565b60006127bc826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65648152508573ffffffffffffffffffffffffffffffffffffffff16613d939092919063ffffffff16565b805190915015610bd257808060200190518101906127da91906153e1565b610bd2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f74207375636365656400000000000000000000000000000000000000000000606482015260840161045f565b606081518260405160200161287c929190615403565b6040516020818303038152906040529050919050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920180516040517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff808316600483015292946000949390929185918416906370a08231906024015b602060405180830381865afa158015612955573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612979919061549a565b9093525092949350505050565b60008060006020840391508151905060008173ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156129e2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a06919061549a565b90925250919392505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0830180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0909401516040517f4ee2cd7e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff808716600483015260248201839052929560009594939092918691851690634ee2cd7e906044015b602060405180830381865afa158015612b01573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b25919061549a565b909452509395945050505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920180516040517f981b24d000000000000000000000000000000000000000000000000000000000815260048101829052919360009392909190849073ffffffffffffffffffffffffffffffffffffffff84169063981b24d090602401612938565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920180516040517f6352211e00000000000000000000000000000000000000000000000000000000815260048101829052919360009392909190849073ffffffffffffffffffffffffffffffffffffffff841690636352211e90602401602060405180830381865afa158015612c9d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612cc19190614e4f565b73ffffffffffffffffffffffffffffffffffffffff169093525092949350505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0830180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0909401516040517efdd58e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff80871660048301526024820183905292956000959493909291869185169062fdd58e90604401612ae4565b60008060008467ffffffffffffffff811115612dd657612dd6614569565b604051908082528060200260200182016040528015612dff578160200160208202803683370190505b50905060008567ffffffffffffffff811115612e1d57612e1d614569565b604051908082528060200260200182016040528015612e46578160200160208202803683370190505b506040870286037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018051909550919250602080890282019085015b81831015612e9b578251815260209283019201612e83565b5050602088028101602084015b81831015612ec0578251815260209283019201612ea8565b50506040517f4e1273f40000000000000000000000000000000000000000000000000000000081526000915073ffffffffffffffffffffffffffffffffffffffff831690634e1273f490612f1a90879087906004016154b3565b600060405180830381865afa158015612f37573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052612f7d9190810190615516565b9050846020820160208a0281015b80821015612fa6578151835260209283019290910190612f8b565b50909998505050505050505050565b438152602001919050565b338152602001919050565b308152602001919050565b428152602001919050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810180516000919082612a068287613da2565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920180519092600092918361297982613075858a613da2565b90613e23565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0909201805190926000929183612979826130db858a613da2565b90612035565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810180516000919082612a068287613e38565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810180516000919082612a068287613e83565b6000602083028203805b83811015613173578051801561316a578252613173565b50602001613153565b506020019392505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0810180511560200282017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc090810151909152018092915050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc09092018051909214909152919050565b6000602083028203805b838110156131735780516132505760008252613173565b602001613239565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0909201805192909211909152919050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018051159052919050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0909201805192909210909152919050565b6020828102820380516000928201835b858210801561337157507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83105b15613390575080516020909101906133898382613ee1565b9250613343565b505081526020019392505050565b6020828102820380516000928201835b85821080156133dc57507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83105b15613390575080516020909101906133f48382613f1c565b92506133ae565b6020828102820380516000928201835b858210801561341a5750826000105b15613390575080516020909101906134328382613f4b565b925061340b565b600060208302820380516000602083015b85811015613390578051830191508282101561346557600080fd5b909150819060200161344a565b600060208302820380516000602083015b8581101561339057805191508161349957600080fd5b9181900491602001613483565b6020828102820380516000928201835b85821015613390575080516020909101906134d181846156dc565b92506134b6565b6020828102820380516000928201835b8582101561339057508051828111156134ff578092505b6020820191506134e8565b6020828102820380516000928201835b858210156133905750805182811015613531578092505b60208201915061351a565b600060208302820380516000602083015b8581101561339057805191508161356357600080fd5b918190069160200161354d565b60006020830282038051600080602084015b868110156135b35783156135ab5780519250828402915082848304146135a757600080fd5b8193505b602001613582565b50505081526020019392505050565b600060208302820380516000602083015b8581101561339057805183039150828211156135ee57600080fd5b90915081906020016135d3565b8190037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920180518482526040517f88d686040000000000000000000000000000000000000000000000000000000081529193600093929091908590859073ffffffffffffffffffffffffffffffffffffffff8516906388d6860490612ae490869086906004016156e8565b8190037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08301517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090930180518582526040517fcaa0eb3b000000000000000000000000000000000000000000000000000000008152919460009493929091908690869073ffffffffffffffffffffffffffffffffffffffff86169063caa0eb3b9061378690879087908790600401615717565b602060405180830381865afa1580156137a3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137c7919061549a565b8652505060209093019695505050505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09092018051909260009291836129798383613f61565b6000600783901c6003600585901c16601f851683808267ffffffffffffffff81111561386457613864614569565b60405190808252806020026020018201604052801561388d578160200160208202803683370190505b509050600060206001850102880392506020840283018360005b828210156138c9578151816020018601526020820191506020810190506138a7565b505051905060006138dc83838989613fc0565b845250506020909101979650505050505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09092018051909260009291600f80871691600488901c909116908561395d85858585614110565b90955250949695505050505050565b6060833b8061398b575050604080516020810190915260008152612753565b808411156139a9575050604080516020810190915260008152612753565b838310156139f4576040517f2c4a89fa00000000000000000000000000000000000000000000000000000000815260048101829052602481018590526044810184905260640161045f565b8383038482036000828210613a095782613a0b565b815b60408051603f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168101909152818152955090508087602087018a3c505050509392505050565b600060078216600383811c16828082613a9357507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9050610100613ade565b8260011415613ab757506fffffffffffffffffffffffffffffffff90506080613ade565b8260021415613ad3575067ffffffffffffffff90506040613ade565b5063ffffffff905060205b6001600587901c0160008167ffffffffffffffff811115613b0157613b01614569565b604051908082528060200260200182016040528015613b2a578160200160208202803683370190505b50905060208082019083028a03815b8b821015613b51578151815260209182019101613b39565b505060608b015160808c015160209081029091010160005b610100811015613baf5760208502830182845b82811015613b98578051841c8a16825260209182019101613b7c565b505050613ba68e8e8b612483565b9b508501613b69565b508a985050505050505050505b949350505050565b606060008260600151905060006018846040015151901b60108560800151901b6008866020015151901b866060015151171717905060008160001b83604051602001613c1091906153ab565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815290829052613c4c929160200161574c565b604051602081830303815290604052905060005b856040015151811015613cf8578186604001518281518110613c8457613c846149b9565b60200260200101515160001b87604001518381518110613ca657613ca66149b9565b6020026020010151604051602001613cc093929190615772565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190529150600101613c60565b50949350505050565b613d9081604051602401613d1591906148e7565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f0be77f56000000000000000000000000000000000000000000000000000000001790526141b6565b50565b6060613bbc84846000856141d7565b6000808260121415613db75783915050612057565b8260121115613de357506012829003613dd181600a6156dc565b613ddb90856151c9565b915050612057565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee8201613e1281600a6156dc565b613ddb9085615235565b5092915050565b60008161204a670de0b6b3a7640000856151c9565b600081810b613e48575081612057565b60008260000b1315613e7057613e5f82600a6157a9565b613e6990846151c9565b9050612057565b60ff600083900316613e1281600a6156dc565b6000806012831415613e985783915050612057565b8260121115613eb257506012829003613e1281600a6156dc565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee8201613dd181600a6156dc565b6000828201838110613ef35780613bbc565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff949350505050565b600082613f2b57506000612057565b82820282848281613f3e57613f3e615206565b041415613ef35780613bbc565b6000818311613f5b576000612054565b50900390565b60008060015b60088111613fb8576000613f7b868361436d565b90506000613f89868461436d565b90506000613f978383613f4b565b9050613fa785600186038361441a565b94505060019092019150613f679050565b509392505050565b835160009081908190819060015b600881116141025760009250828761400757507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61400b565b5060005b60005b838110156140c0576140398c828151811061402b5761402b6149b9565b60200260200101518461436d565b95508a861161408b57886140585761405186836122d3565b9150614082565b600189141561406b5761405186836144a3565b600289148015614079575084155b15614082578591505b600194506140b8565b896140b8577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff91506140c0565b60010161400e565b50836140e957507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5b6140f786600184038361441a565b955050600101613fce565b509298975050505050505050565b600082600881111561417e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4d41585f54494552000000000000000000000000000000000000000000000000604482015260640161045f565b6000855b858110156141aa5763ffffffff6020820290811b199890981685891b17979150600101614182565b50959695505050505050565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b606082471015614269576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c0000000000000000000000000000000000000000000000000000606482015260840161045f565b73ffffffffffffffffffffffffffffffffffffffff85163b6142e7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161045f565b6000808673ffffffffffffffffffffffffffffffffffffffff16858760405161431091906157b8565b60006040518083038185875af1925050503d806000811461434d576040519150601f19603f3d011682016040523d82523d6000602084013e614352565b606091505b50915091506143628282866144b3565b979650505050505050565b60008160088111156143db576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4d41585f54494552000000000000000000000000000000000000000000000000604482015260640161045f565b826143e95760009150613e1c565b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff016020021c63ffffffff1690565b6000826008811115614488576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4d41585f54494552000000000000000000000000000000000000000000000000604482015260640161045f565b505063ffffffff602090920291821b199290921691901b1790565b6000818310156122e25781612054565b606083156144c2575081612753565b8251156144d25782518084602001fd5b816040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161045f91906148e7565b60006020828403121561451857600080fd5b5035919050565b73ffffffffffffffffffffffffffffffffffffffff81168114613d9057600080fd5b8035611cdb8161451f565b60006020828403121561455e57600080fd5b81356127538161451f565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516080810167ffffffffffffffff811182821017156145bb576145bb614569565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561460857614608614569565b604052919050565b600067ffffffffffffffff82111561462a5761462a614569565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b600082601f83011261466757600080fd5b813561467a61467582614610565b6145c1565b81815284602083860101111561468f57600080fd5b816020850160208301376000918101602001919091529392505050565b600080604083850312156146bf57600080fd5b823567ffffffffffffffff808211156146d757600080fd5b9084019060e082870312156146eb57600080fd5b9092506020840135908082111561470157600080fd5b908401906080828703121561471557600080fd5b61471d614598565b82358281111561472c57600080fd5b83016080818903121561473e57600080fd5b614746614598565b81358481111561475557600080fd5b6147618a828501614656565b82525060208201358481111561477657600080fd5b6147828a828501614656565b602083015250604082013593506147988461451f565b8360408201526060820135606082015280835250506147b960208401614541565b6020820152604083013560408201526147d460608401614541565b60608201528093505050509250929050565b600060a08284031215611e9057600080fd5b600060a0828403121561480a57600080fd5b60405160a0810181811067ffffffffffffffff8211171561482d5761482d614569565b604052823561483b8161451f565b80825250602083013560208201526040830135604082015260608301356060820152608083013560808201528091505092915050565b60005b8381101561488c578181015183820152602001614874565b838111156110285750506000910152565b600081518084526148b5816020860160208601614871565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000612054602083018461489d565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60048110614960577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b9052565b602081016120578284614929565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600082198211156149b4576149b4614972565b500190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1833603018112614a1c57600080fd5b9190910192915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112614a5b57600080fd5b830160208101925035905067ffffffffffffffff811115614a7b57600080fd5b8060051b3603831315611a7a57600080fd5b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b81835260007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff831115614b0857600080fd5b8260051b8083602087013760009401602001938452509192915050565b600060408301614b358384614a26565b604086528281845260608701905060608260051b88010193508260005b83811015614bff577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa089870301835281357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1863603018112614bb357600080fd5b85018035602067ffffffffffffffff821115614bce57600080fd5b813603881315614bdd57600080fd5b614bea8983838601614a8d565b98509485019493909301925050600101614b52565b5050505050614c116020840184614a26565b8583036020870152614c24838284614ad6565b9695505050505050565b6000606073ffffffffffffffffffffffffffffffffffffffff8616835260208181850152614c5e82850187614b25565b84810360408681019190915286518083528388019284019060005b81811015614ccf578451805184528681015187850152848101518585015287810151888501526080808201519085015260a0808201519085015260c090810151908401529385019360e090920191600101614c79565b50909a9950505050505050505050565b600060208284031215614cf157600080fd5b815167ffffffffffffffff811115614d0857600080fd5b8201601f81018413614d1957600080fd5b8051614d2761467582614610565b818152856020838501011115614d3c57600080fd5b614d4d826020830160208601614871565b95945050505050565b60208152600073ffffffffffffffffffffffffffffffffffffffff808451166020840152602084015160a060408501528051608060c0860152614d9d61014086018261489d565b905060208201517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff408683030160e0870152614dd8828261489d565b91505082604083015116610100860152606082015161012086015260408601519250614e1c606086018473ffffffffffffffffffffffffffffffffffffffff169052565b6060860151608086015260808601519250614d4d60a086018473ffffffffffffffffffffffffffffffffffffffff169052565b600060208284031215614e6157600080fd5b81516127538161451f565b73ffffffffffffffffffffffffffffffffffffffff8416815260606020820152600083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1853603018112614ec057600080fd5b60e06060840152614ed76101408401868301614b25565b9050614ee560208601614541565b73ffffffffffffffffffffffffffffffffffffffff166080840152614f0c60408601614541565b73ffffffffffffffffffffffffffffffffffffffff811660a085015250606085013560c0840152608085013560e084015260a085013561010084015260c085013561012084015280915050613bbc604083018473ffffffffffffffffffffffffffffffffffffffff169052565b803582526020810135614f8b8161451f565b73ffffffffffffffffffffffffffffffffffffffff1660208301526040818101359083015260608082013590830152608090810135910152565b60a081016120578284614f79565b600081614fe257614fe2614972565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190565b60008282101561501a5761501a614972565b500390565b73ffffffffffffffffffffffffffffffffffffffff8316815260c081016127536020830184614f79565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82141561507b5761507b614972565b5060010190565b60a0810161205782848051825273ffffffffffffffffffffffffffffffffffffffff60208201511660208301526040810151604083015260608101516060830152608081015160808301525050565b60006101608201905073ffffffffffffffffffffffffffffffffffffffff808616835280855116602084015250602084015160408301526040840151606083015260608401516080830152608084015160a0830152613bbc60c08301848051825273ffffffffffffffffffffffffffffffffffffffff60208201511660208301526040810151604083015260608101516060830152608081015160808301525050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fd5b60008152600082516151bc816001850160208701614871565b9190910160010192915050565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561520157615201614972565b500290565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60008261526b577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b73ffffffffffffffffffffffffffffffffffffffff83168152604081016127536020830184614929565b600081518084526020808501945080840160005b838110156152ca578151875295820195908201906001016152ae565b509495945050505050565b600060208083528351818401528084015160a060408501526152fa60c085018261529a565b905060408501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0808684030160608701528282518085528585019150858160051b860101868501945060005b82811015615373578487830301845261536182875161489d565b95880195938801939150600101615347565b5060608a01519650838982030160808a015261538f818861529a565b9650505050505050608084015160a08401528091505092915050565b815160009082906020808601845b838110156153d5578151855293820193908201906001016153b9565b50929695505050505050565b6000602082840312156153f357600080fd5b8151801515811461275357600080fd5b7f630000000000000000000000000000000000000000000000000000000000000081527fffffffff000000000000000000000000000000000000000000000000000000008360e01b1660018201527f80600e6000396000f3000000000000000000000000000000000000000000000060058201526000825161548c81600e850160208701614871565b91909101600e019392505050565b6000602082840312156154ac57600080fd5b5051919050565b604080825283519082018190526000906020906060840190828701845b8281101561550257815173ffffffffffffffffffffffffffffffffffffffff16845292840192908401906001016154d0565b50505083810382850152614c24818661529a565b6000602080838503121561552957600080fd5b825167ffffffffffffffff8082111561554157600080fd5b818501915085601f83011261555557600080fd5b81518181111561556757615567614569565b8060051b91506155788483016145c1565b818152918301840191848101908884111561559257600080fd5b938501935b838510156155b057845182529385019390850190615597565b98975050505050505050565b600181815b8085111561561557817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048211156155fb576155fb614972565b8085161561560857918102915b93841c93908002906155c1565b509250929050565b60008261562c57506001612057565b8161563957506000612057565b816001811461564f576002811461565957615675565b6001915050612057565b60ff84111561566a5761566a614972565b50506001821b612057565b5060208310610133831016604e8410600b8410161715615698575081810a612057565b6156a283836155bc565b807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048211156156d4576156d4614972565b029392505050565b6000612054838361561d565b73ffffffffffffffffffffffffffffffffffffffff83168152604060208201526000613bbc604083018461529a565b73ffffffffffffffffffffffffffffffffffffffff84168152826020820152606060408201526000614d4d606083018461529a565b82815260008251615764816020850160208701614871565b919091016020019392505050565b60008451615784818460208901614871565b8201848152835161579c816020808501908801614871565b0160200195945050505050565b600061205460ff84168361561d565b60008251614a1c81846020870161487156fea264697066735822122078425b57b61d0cf4d634d2b8a85eec102266c7dbba468b3f65c1a8ebace070a364736f6c634300080a0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c80632ea72a491461004657806333504dad14610083578063fc91a89714610096575b600080fd5b6100596100543660046104e7565b6100df565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b610059610091366004610559565b61028d565b6100cf6100a43660046105fc565b73ffffffffffffffffffffffffffffffffffffffff1660009081526001602052604090205460ff1690565b604051901515815260200161007a565b600060026000541415610153576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064015b60405180910390fd5b600260009081556101648484610333565b73ffffffffffffffffffffffffffffffffffffffff811660009081526001602052604090205490915060ff16156101f7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f4455504c49434154455f4348494c440000000000000000000000000000000000604482015260640161014a565b73ffffffffffffffffffffffffffffffffffffffff811660008181526001602081815260409283902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169092179091558151338152908101929092527f7da70c4e5387d7038610b79ca7d304caaef815826e51e67cf247135387a79bce910160405180910390a160016000559392505050565b60003073ffffffffffffffffffffffffffffffffffffffff16632ea72a4984846040516020016102be92919061095e565b6040516020818303038152906040526040518263ffffffff1660e01b81526004016102e99190610aae565b6020604051808303816000875af1158015610308573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061032c9190610ac1565b9392505050565b6000808061034384860186610ed0565b9150915060006103727f0000000000000000000000000000000000000000000000000000000000000000610405565b6040517f278a6a6d00000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff82169063278a6a6d906103c99086908690600401611077565b600060405180830381600087803b1580156103e357600080fd5b505af11580156103f7573d6000803e3d6000fd5b509298975050505050505050565b60006040517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081528260601b60148201527f5af43d82803e903d91602b57fd5bf3000000000000000000000000000000000060288201526037816000f091505073ffffffffffffffffffffffffffffffffffffffff81166104e2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f455243313136373a20637265617465206661696c656400000000000000000000604482015260640161014a565b919050565b600080602083850312156104fa57600080fd5b823567ffffffffffffffff8082111561051257600080fd5b818501915085601f83011261052657600080fd5b81358181111561053557600080fd5b86602082850101111561054757600080fd5b60209290920196919550909350505050565b6000806040838503121561056c57600080fd5b823567ffffffffffffffff8082111561058457600080fd5b9084019060e0828703121561059857600080fd5b909250602084013590808211156105ae57600080fd5b508301608081860312156105c157600080fd5b809150509250929050565b73ffffffffffffffffffffffffffffffffffffffff811681146105ee57600080fd5b50565b80356104e2816105cc565b60006020828403121561060e57600080fd5b813561032c816105cc565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261064e57600080fd5b830160208101925035905067ffffffffffffffff81111561066e57600080fd5b8060051b360383131561068057600080fd5b9250929050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261070557600080fd5b830160208101925035905067ffffffffffffffff81111561072557600080fd5b80360383131561068057600080fd5b6000604083016107448384610619565b604086528281845260608701905060608260051b88010193508260005b838110156107bc577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa089870301835261079a82866106d0565b6107a5888284610687565b975050506020928301929190910190600101610761565b50505050506107ce6020840184610619565b85830360208701528083527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81111561080657600080fd5b60051b8082602085013760009201602001918252509392505050565b600081357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8183360301811261085657600080fd5b60808452820161086681806106d0565b60808087015261087b61010087018284610687565b91505061088b60208301836106d0565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808784030160a08801526108c0838284610687565b9250505060408201356108d2816105cc565b73ffffffffffffffffffffffffffffffffffffffff1660c0860152606082013560e0860152610903602085016105f1565b73ffffffffffffffffffffffffffffffffffffffff81166020870152915060408401356040860152610937606085016105f1565b73ffffffffffffffffffffffffffffffffffffffff8116606087015291505b949350505050565b60408152600083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc185360301811261099657600080fd5b60e060408401526109ad6101208401868301610734565b90506109bb602086016105f1565b73ffffffffffffffffffffffffffffffffffffffff1660608401526109e2604086016105f1565b73ffffffffffffffffffffffffffffffffffffffff8116608085015250606085013560a0840152608085013560c084015260a085013560e084015260c08501356101008401528281036020840152610a3a8185610822565b95945050505050565b6000815180845260005b81811015610a6957602081850181015186830182015201610a4d565b81811115610a7b576000602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b60208152600061032c6020830184610a43565b600060208284031215610ad357600080fd5b815161032c816105cc565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff81118282101715610b3057610b30610ade565b60405290565b6040516080810167ffffffffffffffff81118282101715610b3057610b30610ade565b60405160e0810167ffffffffffffffff81118282101715610b3057610b30610ade565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715610bc357610bc3610ade565b604052919050565b600067ffffffffffffffff821115610be557610be5610ade565b5060051b60200190565b600067ffffffffffffffff831115610c0957610c09610ade565b610c3a60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f86011601610b7c565b9050828152838383011115610c4e57600080fd5b828260208301376000602084830101529392505050565b600082601f830112610c7657600080fd5b81356020610c8b610c8683610bcb565b610b7c565b82815260059290921b84018101918181019086841115610caa57600080fd5b8286015b84811015610cc55780358352918301918301610cae565b509695505050505050565b60006040808385031215610ce357600080fd5b610ceb610b0d565b9150823567ffffffffffffffff80821115610d0557600080fd5b818501915085601f830112610d1957600080fd5b81356020610d29610c8683610bcb565b82815260059290921b84018101918181019089841115610d4857600080fd5b8286015b84811015610d9457803586811115610d645760008081fd5b8701603f81018c13610d765760008081fd5b610d868c868301358b8401610bef565b845250918301918301610d4c565b5087525086810135945082851115610dab57600080fd5b610db788868901610c65565b81870152505050505092915050565b600082601f830112610dd757600080fd5b61032c83833560208501610bef565b600060808284031215610df857600080fd5b610e00610b36565b9050813567ffffffffffffffff80821115610e1a57600080fd5b9083019060808286031215610e2e57600080fd5b610e36610b36565b823582811115610e4557600080fd5b610e5187828601610dc6565b825250602083013582811115610e6657600080fd5b610e7287828601610dc6565b60208301525060408301359150610e88826105cc565b81604082015260608301356060820152808452505050610eaa602083016105f1565b602082015260408201356040820152610ec5606083016105f1565b606082015292915050565b60008060408385031215610ee357600080fd5b823567ffffffffffffffff80821115610efb57600080fd5b9084019060e08287031215610f0f57600080fd5b610f17610b59565b823582811115610f2657600080fd5b610f3288828601610cd0565b825250610f41602084016105f1565b6020820152610f52604084016105f1565b6040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c0820152809450506020850135915080821115610f9757600080fd5b50610fa485828601610de6565b9150509250929050565b60008151608084528051608080860152610fcc610100860182610a43565b905060208201517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808683030160a08701526110078282610a43565b915050604082015173ffffffffffffffffffffffffffffffffffffffff80821660c0880152606084015160e088015280602087015116602088015250506040840151604086015260608401519150610956606086018373ffffffffffffffffffffffffffffffffffffffff169052565b604081526000835160e0604084015261016083018151604061012086015281815180845261018093508387019150838160051b88010193506020808401935060005b82811015611105577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe808987030184526110f3868651610a43565b955093810193928101926001016110b9565b50948501518785037ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee001610140890152805180865290860195600095810194509092505b828510156111695785518452948501946001949094019392830192611149565b8981015173ffffffffffffffffffffffffffffffffffffffff811660608a0152955060408a015173ffffffffffffffffffffffffffffffffffffffff811660808a0152955060608a015160a089015260808a015160c089015260a08a015160e089015260c08a0151610100890152878403818901525050506111eb8187610fae565b97965050505050505056fea2646970667358221220e3eef224e8797cb9b10ccecbe6ab8e1bb13cb6d44116f47500122da877eebdd264736f6c634300080a0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "createChild(bytes)": {
        "params": {
          "data_": "Encoded data to pass down to child contract constructor."
        },
        "returns": {
          "_0": "New child contract address."
        }
      },
      "createChildTyped(((bytes[],uint256[]),address,address,uint256,uint256,uint256,uint256),((string,string,address,uint256),address,uint256,address))": {
        "params": {
          "config_": "`SaleConfig` constructor configuration."
        },
        "returns": {
          "_0": "New `Sale` child contract."
        }
      },
      "isChild(address)": {
        "params": {
          "maybeChild_": "Address of child contract to look up."
        },
        "returns": {
          "_0": "Returns `true` if address is a contract created by this contract factory, otherwise `false`."
        }
      }
    },
    "title": "SaleFactory",
    "version": 1
  },
  "userdoc": {
    "events": {
      "Implementation(address,address)": {
        "notice": "Factories that clone a template contract MUST emit an event any time they set the implementation being cloned. Factories that deploy new contracts without cloning do NOT need to emit this."
      },
      "NewChild(address,address)": {
        "notice": "Whenever a new child contract is deployed, a `NewChild` event containing the new child contract address MUST be emitted."
      }
    },
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "Build the reference implementation to clone for each child."
      },
      "createChild(bytes)": {
        "notice": "Implements `IFactory`. Calls the `_createChild` hook that inheriting contracts must override. Registers child contract address such that `isChild` is `true`. Emits `NewChild` event."
      },
      "createChildTyped(((bytes[],uint256[]),address,address,uint256,uint256,uint256,uint256),((string,string,address,uint256),address,uint256,address))": {
        "notice": "Allows calling `createChild` with `SeedERC20Config` struct. Use original `Factory` `createChild` function signature if function parameters are already encoded."
      },
      "isChild(address)": {
        "notice": "Implements `IFactory`. Checks if address is registered as a child contract of this factory."
      }
    },
    "notice": "Factory for creating and deploying `Sale` contracts.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1830,
        "contract": "contracts/sale/SaleFactory.sol:SaleFactory",
        "label": "_status",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 9000,
        "contract": "contracts/sale/SaleFactory.sol:SaleFactory",
        "label": "contracts",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}