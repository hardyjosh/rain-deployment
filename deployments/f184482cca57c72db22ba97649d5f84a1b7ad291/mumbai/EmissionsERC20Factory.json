{
  "address": "0xaD24ef9Cfd990DFc567ffC5Ca7DBDCCbc8a4Ce10",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vmStateBuilder_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        }
      ],
      "name": "Implementation",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "child",
          "type": "address"
        }
      ],
      "name": "NewChild",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data_",
          "type": "bytes"
        }
      ],
      "name": "createChild",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bool",
              "name": "allowDelegatedClaims",
              "type": "bool"
            },
            {
              "components": [
                {
                  "internalType": "string",
                  "name": "name",
                  "type": "string"
                },
                {
                  "internalType": "string",
                  "name": "symbol",
                  "type": "string"
                },
                {
                  "internalType": "address",
                  "name": "distributor",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "initialSupply",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ERC20Config",
              "name": "erc20Config",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "bytes[]",
                  "name": "sources",
                  "type": "bytes[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "constants",
                  "type": "uint256[]"
                }
              ],
              "internalType": "struct StateConfig",
              "name": "vmStateConfig",
              "type": "tuple"
            }
          ],
          "internalType": "struct EmissionsERC20Config",
          "name": "config_",
          "type": "tuple"
        }
      ],
      "name": "createChildTyped",
      "outputs": [
        {
          "internalType": "contract EmissionsERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "implementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "maybeChild_",
          "type": "address"
        }
      ],
      "name": "isChild",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x3515d6eb492d4933f296b9abb0d963e958b2f0da8a4c39c04b12ac53c4cc39bb",
  "receipt": {
    "to": null,
    "from": "0xbF334f8BD1420a1CbFE15407f73919424934B1B3",
    "contractAddress": "0xaD24ef9Cfd990DFc567ffC5Ca7DBDCCbc8a4Ce10",
    "transactionIndex": 15,
    "gasUsed": "5044313",
    "logsBloom": "0x00000000000000020000000000000000000100000000002008000000800000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800010000000000000000100000000000000000000000200000000000000000000000000000000000080000000010000000000000000000000000000000000000000000000000000000000000000000000200000000000000020000000000000000001000000000000000000000000004000000000000000000001000000000000000000000000000080100040000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x9e1f72aca7d3427f83e2ec70aa36224e0e0706fd4f22a3c6341291045318c81a",
    "transactionHash": "0x3515d6eb492d4933f296b9abb0d963e958b2f0da8a4c39c04b12ac53c4cc39bb",
    "logs": [
      {
        "transactionIndex": 15,
        "blockNumber": 27020757,
        "transactionHash": "0x3515d6eb492d4933f296b9abb0d963e958b2f0da8a4c39c04b12ac53c4cc39bb",
        "address": "0xaD24ef9Cfd990DFc567ffC5Ca7DBDCCbc8a4Ce10",
        "topics": [
          "0x7fac34ecf0b1b374cd9659e3d17db602659d53f1162b1f20142e6c02694aed70"
        ],
        "data": "0x000000000000000000000000bf334f8bd1420a1cbfe15407f73919424934b1b300000000000000000000000057b9c28f17753609ed1d5c16c8497a3197f2dbb4",
        "logIndex": 35,
        "blockHash": "0x9e1f72aca7d3427f83e2ec70aa36224e0e0706fd4f22a3c6341291045318c81a"
      },
      {
        "transactionIndex": 15,
        "blockNumber": 27020757,
        "transactionHash": "0x3515d6eb492d4933f296b9abb0d963e958b2f0da8a4c39c04b12ac53c4cc39bb",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000bf334f8bd1420a1cbfe15407f73919424934b1b3",
          "0x000000000000000000000000c26880a0af2ea0c7e8130e6ec47af756465452e8"
        ],
        "data": "0x000000000000000000000000000000000000000000000000001478267c884bce000000000000000000000000000000000000000000000000b8e660fb65b6aea900000000000000000000000000000000000000000000100d5afa6e5394a179c4000000000000000000000000000000000000000000000000b8d1e8d4e92e62db00000000000000000000000000000000000000000000100d5b0ee67a1129c592",
        "logIndex": 36,
        "blockHash": "0x9e1f72aca7d3427f83e2ec70aa36224e0e0706fd4f22a3c6341291045318c81a"
      }
    ],
    "blockNumber": 27020757,
    "cumulativeGasUsed": "7716577",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x6D6aEda4Ba6687F7a5A040875b6ba2Ef0C468696"
  ],
  "numDeployments": 1,
  "solcInputHash": "055c200f462499c3452e24a9d9708423",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vmStateBuilder_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Implementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"child\",\"type\":\"address\"}],\"name\":\"NewChild\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"createChild\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"allowDelegatedClaims\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initialSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC20Config\",\"name\":\"erc20Config\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes[]\",\"name\":\"sources\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"internalType\":\"struct StateConfig\",\"name\":\"vmStateConfig\",\"type\":\"tuple\"}],\"internalType\":\"struct EmissionsERC20Config\",\"name\":\"config_\",\"type\":\"tuple\"}],\"name\":\"createChildTyped\",\"outputs\":[{\"internalType\":\"contract EmissionsERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"maybeChild_\",\"type\":\"address\"}],\"name\":\"isChild\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"createChild(bytes)\":{\"params\":{\"data_\":\"Encoded data to pass down to child contract constructor.\"},\"returns\":{\"_0\":\"New child contract address.\"}},\"createChildTyped((bool,(string,string,address,uint256),(bytes[],uint256[])))\":{\"params\":{\"config_\":\"`EmissionsERC20` constructor configuration.\"},\"returns\":{\"_0\":\"New `EmissionsERC20` child contract address.\"}},\"isChild(address)\":{\"params\":{\"maybeChild_\":\"Address of child contract to look up.\"},\"returns\":{\"_0\":\"Returns `true` if address is a contract created by this contract factory, otherwise `false`.\"}}},\"title\":\"EmissionsERC20Factory\",\"version\":1},\"userdoc\":{\"events\":{\"Implementation(address,address)\":{\"notice\":\"Factories that clone a template contract MUST emit an event any time they set the implementation being cloned. Factories that deploy new contracts without cloning do NOT need to emit this.\"},\"NewChild(address,address)\":{\"notice\":\"Whenever a new child contract is deployed, a `NewChild` event containing the new child contract address MUST be emitted.\"}},\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"Build the reference implementation to clone for each child.\"},\"createChild(bytes)\":{\"notice\":\"Implements `IFactory`. Calls the `_createChild` hook that inheriting contracts must override. Registers child contract address such that `isChild` is `true`. Emits `NewChild` event.\"},\"createChildTyped((bool,(string,string,address,uint256),(bytes[],uint256[])))\":{\"notice\":\"Allows calling `createChild` with `EmissionsERC20Config` struct. Use original `Factory` `createChild` function signature if function parameters are already encoded.\"},\"implementation()\":{\"notice\":\"Template contract to clone. Deployed by the constructor.\"},\"isChild(address)\":{\"notice\":\"Implements `IFactory`. Checks if address is registered as a child contract of this factory.\"}},\"notice\":\"Factory for deploying and registering `EmissionsERC20` contracts.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/claim/EmissionsERC20Factory.sol\":\"EmissionsERC20Factory\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = _setInitializedVersion(1);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        bool isTopLevelCall = _setInitializedVersion(version);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(version);\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        _setInitializedVersion(type(uint8).max);\\n    }\\n\\n    function _setInitializedVersion(uint8 version) private returns (bool) {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\\n        // of initializers, because in other contexts the contract may have been reentered.\\n        if (_initializing) {\\n            require(\\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\\n                \\\"Initializable: contract is already initialized\\\"\\n            );\\n            return false;\\n        } else {\\n            require(_initialized < version, \\\"Initializable: contract is already initialized\\\");\\n            _initialized = version;\\n            return true;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7454006cccb737612b00104d2f606d728e2818b778e7e55542f063c614ce46ba\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\",\"keccak256\":\"0xb71b875e7f1b8ad082eb6ff83bca4bfa7d050476cc98fd39295826b654edfb46\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4e733d3164f73f461eaf9d8087a7ad1ea180bdc8ba0d3d61b0e1ae16d8e63dff\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x605434219ebbe4653f703640f06969faa5a1d78f0bfef878e5ddbb1ca369ceeb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55cf2bd9fc76704ddcdc19834cd288b7de00fc0f298a40ea16a954ae8991db2d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x1cc0efb01cbf008b768fd7b334786a6e358809198bb7e67f1c530af4957c6a21\",\"license\":\"MIT\"},\"@openzeppelin/contracts/security/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x0e9621f60b2faabe65549f7ed0f24e8853a45c1b7990d47e8160e523683f3935\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x8e93de94c9062ebc94fb7e2e3929b0781ac6a2b7772e2f7a59045861c93e5be9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0xe0c8b625a79bac0fe80f17cfb521e072805cc9cef1c96a5caf45b264e74812fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/ERC20Snapshot.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"../../../utils/Arrays.sol\\\";\\nimport \\\"../../../utils/Counters.sol\\\";\\n\\n/**\\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\\n * total supply at the time are recorded for later access.\\n *\\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\\n * In naive implementations it's possible to perform a \\\"double spend\\\" attack by reusing the same balance from different\\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\\n * used to create an efficient ERC20 forking mechanism.\\n *\\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\\n * and the account address.\\n *\\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\\n * return `block.number` will trigger the creation of snapshot at the beginning of each new block. When overriding this\\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\\n *\\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\\n * alternative consider {ERC20Votes}.\\n *\\n * ==== Gas Costs\\n *\\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\\n *\\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\\n * transfers will have normal cost until the next snapshot, and so on.\\n */\\n\\nabstract contract ERC20Snapshot is ERC20 {\\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\\n    // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\\n\\n    using Arrays for uint256[];\\n    using Counters for Counters.Counter;\\n\\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\\n    // Snapshot struct, but that would impede usage of functions that work on an array.\\n    struct Snapshots {\\n        uint256[] ids;\\n        uint256[] values;\\n    }\\n\\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\\n    Snapshots private _totalSupplySnapshots;\\n\\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\\n    Counters.Counter private _currentSnapshotId;\\n\\n    /**\\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\\n     */\\n    event Snapshot(uint256 id);\\n\\n    /**\\n     * @dev Creates a new snapshot and returns its snapshot id.\\n     *\\n     * Emits a {Snapshot} event that contains the same id.\\n     *\\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\\n     *\\n     * [WARNING]\\n     * ====\\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\\n     * you must consider that it can potentially be used by attackers in two ways.\\n     *\\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\\n     * section above.\\n     *\\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\\n     * ====\\n     */\\n    function _snapshot() internal virtual returns (uint256) {\\n        _currentSnapshotId.increment();\\n\\n        uint256 currentId = _getCurrentSnapshotId();\\n        emit Snapshot(currentId);\\n        return currentId;\\n    }\\n\\n    /**\\n     * @dev Get the current snapshotId\\n     */\\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\\n        return _currentSnapshotId.current();\\n    }\\n\\n    /**\\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\\n     */\\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\\n\\n        return snapshotted ? value : balanceOf(account);\\n    }\\n\\n    /**\\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\\n     */\\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\\n\\n        return snapshotted ? value : totalSupply();\\n    }\\n\\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        if (from == address(0)) {\\n            // mint\\n            _updateAccountSnapshot(to);\\n            _updateTotalSupplySnapshot();\\n        } else if (to == address(0)) {\\n            // burn\\n            _updateAccountSnapshot(from);\\n            _updateTotalSupplySnapshot();\\n        } else {\\n            // transfer\\n            _updateAccountSnapshot(from);\\n            _updateAccountSnapshot(to);\\n        }\\n    }\\n\\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\\n        require(snapshotId > 0, \\\"ERC20Snapshot: id is 0\\\");\\n        require(snapshotId <= _getCurrentSnapshotId(), \\\"ERC20Snapshot: nonexistent id\\\");\\n\\n        // When a valid snapshot is queried, there are three possibilities:\\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\\n        //  to this id is the current one.\\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\\n        //  requested id, and its value is the one to return.\\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\\n        //  larger than the requested one.\\n        //\\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\\n        // exactly this.\\n\\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\\n\\n        if (index == snapshots.ids.length) {\\n            return (false, 0);\\n        } else {\\n            return (true, snapshots.values[index]);\\n        }\\n    }\\n\\n    function _updateAccountSnapshot(address account) private {\\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\\n    }\\n\\n    function _updateTotalSupplySnapshot() private {\\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\\n    }\\n\\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\\n        uint256 currentId = _getCurrentSnapshotId();\\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\\n            snapshots.ids.push(currentId);\\n            snapshots.values.push(currentValue);\\n        }\\n    }\\n\\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\\n        if (ids.length == 0) {\\n            return 0;\\n        } else {\\n            return ids[ids.length - 1];\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x29f7bc7f4d461a2a2698052f71b29344baf0cb7bdb31ca66e4b534a5fc5e844e\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x0d4de01fe5360c38b4ad2b0822a12722958428f5138a7ff47c1720eb6fa52bba\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Arrays.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Arrays.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to array types.\\n */\\nlibrary Arrays {\\n    /**\\n     * @dev Searches a sorted `array` and returns the first index that contains\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\n     * values in the array are strictly less than `element`), the array length is\\n     * returned. Time complexity O(log n).\\n     *\\n     * `array` is expected to be sorted in ascending order, and to contain no\\n     * repeated elements.\\n     */\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        if (array.length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds down (it does integer division with truncation).\\n            if (array[mid] > element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low > 0 && array[low - 1] == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa7bc891be2bc5948340a8fb14ad36c8846230c9086269e37f3febf0dc239c9f7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Counters.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\",\"keccak256\":\"0xf0018c2440fbe238dd3a8732fa8e17a0f9dce84d31451dc8a32f6d62b349c9f1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\",\"keccak256\":\"0xc995bddbca1ae19788db9f8b61e63385edd3fddf89693b612d5abd1a275974d2\",\"license\":\"MIT\"},\"contracts/claim/EmissionsERC20.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../tier/libraries/TierConstants.sol\\\";\\nimport {ERC20Config} from \\\"../erc20/ERC20Config.sol\\\";\\nimport \\\"./IClaim.sol\\\";\\nimport \\\"../tier/TierV2.sol\\\";\\nimport \\\"../tier/libraries/TierReport.sol\\\";\\nimport {VMStateBuilder, StateConfig, Bounds} from \\\"../vm/VMStateBuilder.sol\\\";\\nimport \\\"../vm/RainVM.sol\\\";\\nimport {AllStandardOps} from \\\"../vm/ops/AllStandardOps.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\\\";\\nimport \\\"../sstore2/SSTORE2.sol\\\";\\n\\n/// Constructor config.\\n/// @param allowDelegatedClaims True if accounts can call `claim` on behalf of\\n/// another account.\\n/// @param Constructor config for the ERC20 token minted according to emissions\\n/// schedule in `claim`.\\n/// @param Constructor config for the `ImmutableSource` that defines the\\n/// emissions schedule for claiming.\\nstruct EmissionsERC20Config {\\n    bool allowDelegatedClaims;\\n    ERC20Config erc20Config;\\n    StateConfig vmStateConfig;\\n}\\n\\n/// @dev Source index for VM eval.\\nuint256 constant ENTRYPOINT = 0;\\nuint256 constant MIN_FINAL_STACK_INDEX = 1;\\n\\n/// @title EmissionsERC20\\n/// @notice Mints itself according to some predefined schedule. The schedule is\\n/// expressed as a rainVM script and the `claim` function is world-callable.\\n/// Intended behaviour is to avoid sybils infinitely minting by putting the\\n/// claim functionality behind a `TierV2` contract. The emissions contract\\n/// itself implements `ReadOnlyTier` and every time a claim is processed it\\n/// logs the block number of the claim against every tier claimed. So the block\\n/// numbers in the tier report for `EmissionsERC20` are the last time that tier\\n/// was claimed against this contract. The simplest way to make use of this\\n/// information is to take the max block for the underlying tier and the last\\n/// claim and then diff it against the current block number.\\n/// See `test/Claim/EmissionsERC20.sol.ts` for examples, including providing\\n/// staggered rewards where more tokens are minted for higher tier accounts.\\ncontract EmissionsERC20 is\\n    TierV2,\\n    Initializable,\\n    RainVM,\\n    ERC20Upgradeable,\\n    IClaim\\n{\\n    /// Contract has initialized.\\n    /// @param sender `msg.sender` initializing the contract (factory).\\n    /// @param config All initialized config.\\n    event Initialize(address sender, EmissionsERC20Config config);\\n\\n    address private immutable self;\\n    address private immutable vmStateBuilder;\\n\\n    /// Address of the immutable rain script deployed as a `VMState`.\\n    address private vmStatePointer;\\n\\n    /// Whether the claimant must be the caller of `claim`. If `false` then\\n    /// accounts other than claimant can claim. This may or may not be\\n    /// desirable depending on the emissions schedule. For example, a linear\\n    /// schedule will produce the same end result for the claimant regardless\\n    /// of who calls `claim` or when but an exponential schedule is more\\n    /// profitable if the claimant waits longer between claims. In the\\n    /// non-linear case delegated claims would be inappropriate as third\\n    /// party accounts could grief claimants by claiming \\\"early\\\", thus forcing\\n    /// opportunity cost on claimants who would have preferred to wait.\\n    bool public allowDelegatedClaims;\\n\\n    /// Each claim is modelled as a report so that the claim report can be\\n    /// diffed against the upstream report from a tier based emission scheme.\\n    mapping(address => uint256) private reports;\\n\\n    constructor(address vmStateBuilder_) {\\n        self = address(this);\\n        vmStateBuilder = vmStateBuilder_;\\n    }\\n\\n    /// @param config_ source and token config. Also controls delegated claims.\\n    function initialize(EmissionsERC20Config calldata config_)\\n        external\\n        initializer\\n    {\\n        __ERC20_init(config_.erc20Config.name, config_.erc20Config.symbol);\\n        _mint(\\n            config_.erc20Config.distributor,\\n            config_.erc20Config.initialSupply\\n        );\\n\\n        Bounds memory bounds_;\\n        bounds_.entrypoint = ENTRYPOINT;\\n        bounds_.minFinalStackIndex = MIN_FINAL_STACK_INDEX;\\n        Bounds[] memory boundss_ = new Bounds[](1);\\n        boundss_[0] = bounds_;\\n\\n        bytes memory vmStateBytes_ = VMStateBuilder(vmStateBuilder).buildState(\\n            self,\\n            config_.vmStateConfig,\\n            boundss_\\n        );\\n        vmStatePointer = SSTORE2.write(vmStateBytes_);\\n\\n        /// Log some deploy state for use by claim/opcodes.\\n        allowDelegatedClaims = config_.allowDelegatedClaims;\\n\\n        emit Initialize(msg.sender, config_);\\n    }\\n\\n    /// @inheritdoc ITierV2\\n    function report(address account_, uint256[] memory)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return reports[account_];\\n    }\\n\\n    /// @inheritdoc ITierV2\\n    function reportTimeForTier(\\n        address account_,\\n        uint256 tier_,\\n        uint256[] calldata\\n    ) external view returns (uint256) {\\n        return TierReport.reportTimeForTier(reports[account_], tier_);\\n    }\\n\\n    /// @inheritdoc RainVM\\n    function fnPtrs() public pure override returns (bytes memory) {\\n        return AllStandardOps.fnPtrs();\\n    }\\n\\n    /// Calculates the claim without processing it.\\n    /// Read only method that may be useful downstream both onchain and\\n    /// offchain if a claimant wants to check the claim amount before deciding\\n    /// whether to process it.\\n    /// As this is read only there are no checks against delegated claims. It\\n    /// is possible to return a value from `calculateClaim` and to not be able\\n    /// to process the claim with `claim` if `msg.sender` is not the\\n    /// `claimant_`.\\n    /// @param claimant_ Address to calculate current claim for.\\n    function calculateClaim(address claimant_) public view returns (uint256) {\\n        State memory state_ = LibState.fromBytesPacked(\\n            SSTORE2.read(vmStatePointer)\\n        );\\n        bytes memory context_ = new bytes(0x20);\\n        uint256 claimantContext_ = uint256(uint160(claimant_));\\n        assembly {\\n            mstore(add(context_, 0x20), claimantContext_)\\n        }\\n        eval(context_, state_, ENTRYPOINT);\\n        return state_.stack[state_.stackIndex - 1];\\n    }\\n\\n    /// Processes the claim for `claimant_`.\\n    /// - Enforces `allowDelegatedClaims` if it is `true` so that `msg.sender`\\n    /// must also be `claimant_`.\\n    /// - Takes the return from `calculateClaim` and mints for `claimant_`.\\n    /// - Records the current block as the claim-tier for this contract.\\n    /// - emits a `Claim` event as per `IClaim`.\\n    /// @param claimant_ address receiving minted tokens. MUST be `msg.sender`\\n    /// if `allowDelegatedClaims` is `false`.\\n    /// @param data_ NOT used onchain. Forwarded to `Claim` event for potential\\n    /// additional offchain processing.\\n    /// @inheritdoc IClaim\\n    function claim(address claimant_, bytes calldata data_) external {\\n        // Disallow delegated claims if appropriate.\\n        if (!allowDelegatedClaims) {\\n            require(msg.sender == claimant_, \\\"DELEGATED_CLAIM\\\");\\n        }\\n\\n        // Mint the claim.\\n        uint256 amount_ = calculateClaim(claimant_);\\n        _mint(claimant_, amount_);\\n\\n        // Record the current block as the latest claim.\\n        // This can be diffed/combined with external reports in future claim\\n        // calculations.\\n        reports[claimant_] = TierReport.updateTimesForTierRange(\\n            TierConstants.NEVER_REPORT,\\n            TierConstants.TIER_ZERO,\\n            TierConstants.TIER_EIGHT,\\n            block.timestamp\\n        );\\n        emit Claim(msg.sender, claimant_, data_);\\n    }\\n}\\n\",\"keccak256\":\"0xf2ccbf89d00d982c825b2502d94cece3ecf471b89fc2f2dd27800eb0f1b62002\",\"license\":\"CAL\"},\"contracts/claim/EmissionsERC20Factory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {Factory} from \\\"../factory/Factory.sol\\\";\\nimport {EmissionsERC20, EmissionsERC20Config} from \\\"./EmissionsERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\n\\n/// @title EmissionsERC20Factory\\n/// @notice Factory for deploying and registering `EmissionsERC20` contracts.\\ncontract EmissionsERC20Factory is Factory {\\n    /// Template contract to clone.\\n    /// Deployed by the constructor.\\n    address public immutable implementation;\\n\\n    /// Build the reference implementation to clone for each child.\\n    constructor(address vmStateBuilder_) {\\n        address implementation_ = address(new EmissionsERC20(vmStateBuilder_));\\n        emit Implementation(msg.sender, implementation_);\\n        implementation = implementation_;\\n    }\\n\\n    /// @inheritdoc Factory\\n    function _createChild(bytes calldata data_)\\n        internal\\n        virtual\\n        override\\n        returns (address)\\n    {\\n        EmissionsERC20Config memory config_ = abi.decode(\\n            data_,\\n            (EmissionsERC20Config)\\n        );\\n        address clone_ = Clones.clone(implementation);\\n        EmissionsERC20(clone_).initialize(config_);\\n        return clone_;\\n    }\\n\\n    /// Allows calling `createChild` with `EmissionsERC20Config` struct.\\n    /// Use original `Factory` `createChild` function signature if function\\n    /// parameters are already encoded.\\n    ///\\n    /// @param config_ `EmissionsERC20` constructor configuration.\\n    /// @return New `EmissionsERC20` child contract address.\\n    function createChildTyped(EmissionsERC20Config calldata config_)\\n        external\\n        returns (EmissionsERC20)\\n    {\\n        return EmissionsERC20(this.createChild(abi.encode(config_)));\\n    }\\n}\\n\",\"keccak256\":\"0x6acbbc6aa53a039e52b42adea35225eec7759eab5af7a3d65d77e50b2df08c04\",\"license\":\"CAL\"},\"contracts/claim/IClaim.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// @title IClaim\\n/// @notice Embodies the idea of processing a claim for some kind of reward.\\ninterface IClaim {\\n    /// `Claim` is emitted whenever `claim` is called to signify that the claim\\n    /// has been processed. Makes no assumptions about what is being claimed,\\n    /// not even requiring an \\\"amount\\\" or similar. Instead there is a generic\\n    /// `data` field where contextual information can be logged for offchain\\n    /// processing.\\n    /// @param sender `msg.sender` authorizing the claim.\\n    /// @param claimant The claimant receiving the `Claim`.\\n    /// @param data Associated data for the claim call.\\n    event Claim(address sender, address claimant, bytes data);\\n\\n    /// Process a claim for `claimant`.\\n    /// It is up to the implementing contract to define what a \\\"claim\\\" is, but\\n    /// broadly it is expected to be some kind of reward.\\n    /// Implementing contracts MAY allow addresses other than `claimant` to\\n    /// process a claim but be careful if doing so to avoid griefing!\\n    /// Implementing contracts MAY allow `claim` to be called arbitrarily many\\n    /// times, or restrict themselves to a single or several calls only.\\n    /// @param claimant The address that will receive the result of this claim.\\n    function claim(address claimant, bytes calldata data) external;\\n}\\n\",\"keccak256\":\"0x83c5a9ad78a586198260f442695e48c4004dbf9e3036650582541c6ff0412df5\",\"license\":\"CAL\"},\"contracts/erc20/ERC20Config.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// Constructor config for standard Open Zeppelin ERC20.\\n/// @param name Name as defined by Open Zeppelin ERC20.\\n/// @param symbol Symbol as defined by Open Zeppelin ERC20.\\n/// @param distributor Distributor address of the initial supply.\\n/// MAY be zero.\\n/// @param initialSupply Initial supply to mint.\\n/// MAY be zero.\\nstruct ERC20Config {\\n    string name;\\n    string symbol;\\n    address distributor;\\n    uint256 initialSupply;\\n}\\n\",\"keccak256\":\"0xd71c17e9354e155991a6d315fc38050377f65f4a7770b146ba0070819e99c3f0\",\"license\":\"CAL\"},\"contracts/factory/Factory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {IFactory} from \\\"./IFactory.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\n/// @title Factory\\n/// @notice Base contract for deploying and registering child contracts.\\nabstract contract Factory is IFactory, ReentrancyGuard {\\n    /// @dev state to track each deployed contract address. A `Factory` will\\n    /// never lie about deploying a child, unless `isChild` is overridden to do\\n    /// so.\\n    mapping(address => bool) private contracts;\\n\\n    /// Implements `IFactory`.\\n    ///\\n    /// `_createChild` hook must be overridden to actually create child\\n    /// contract.\\n    ///\\n    /// Implementers may want to overload this function with a typed equivalent\\n    /// to expose domain specific structs etc. to the compiled ABI consumed by\\n    /// tooling and other scripts. To minimise gas costs for deployment it is\\n    /// expected that the tooling will consume the typed ABI, then encode the\\n    /// arguments and pass them to this function directly.\\n    ///\\n    /// @param data_ ABI encoded data to pass to child contract constructor.\\n    function _createChild(bytes calldata data_)\\n        internal\\n        virtual\\n        returns (address);\\n\\n    /// Implements `IFactory`.\\n    ///\\n    /// Calls the `_createChild` hook that inheriting contracts must override.\\n    /// Registers child contract address such that `isChild` is `true`.\\n    /// Emits `NewChild` event.\\n    ///\\n    /// @param data_ Encoded data to pass down to child contract constructor.\\n    /// @return New child contract address.\\n    function createChild(bytes calldata data_)\\n        external\\n        virtual\\n        override\\n        nonReentrant\\n        returns (address)\\n    {\\n        // Create child contract using hook.\\n        address child_ = _createChild(data_);\\n        // Ensure the child at this address has not previously been deployed.\\n        require(!contracts[child_], \\\"DUPLICATE_CHILD\\\");\\n        // Register child contract address to `contracts` mapping.\\n        contracts[child_] = true;\\n        // Emit `NewChild` event with child contract address.\\n        emit IFactory.NewChild(msg.sender, child_);\\n        return child_;\\n    }\\n\\n    /// Implements `IFactory`.\\n    ///\\n    /// Checks if address is registered as a child contract of this factory.\\n    ///\\n    /// @param maybeChild_ Address of child contract to look up.\\n    /// @return Returns `true` if address is a contract created by this\\n    /// contract factory, otherwise `false`.\\n    function isChild(address maybeChild_)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return contracts[maybeChild_];\\n    }\\n}\\n\",\"keccak256\":\"0xbf45bbfb39b88c9adcfc25ad278928a495c16a75b3dd179baa33ca3298a85fd5\",\"license\":\"CAL\"},\"contracts/factory/IFactory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\ninterface IFactory {\\n    /// Whenever a new child contract is deployed, a `NewChild` event\\n    /// containing the new child contract address MUST be emitted.\\n    /// @param sender `msg.sender` that deployed the contract (factory).\\n    /// @param child address of the newly deployed child.\\n    event NewChild(address sender, address child);\\n\\n    /// Factories that clone a template contract MUST emit an event any time\\n    /// they set the implementation being cloned. Factories that deploy new\\n    /// contracts without cloning do NOT need to emit this.\\n    /// @param sender `msg.sender` that deployed the implementation (factory).\\n    /// @param implementation address of the implementation contract that will\\n    /// be used for future clones if relevant.\\n    event Implementation(address sender, address implementation);\\n\\n    /// Creates a new child contract.\\n    ///\\n    /// @param data_ Domain specific data for the child contract constructor.\\n    /// @return New child contract address.\\n    function createChild(bytes calldata data_) external returns (address);\\n\\n    /// Checks if address is registered as a child contract of this factory.\\n    ///\\n    /// Addresses that were not deployed by `createChild` MUST NOT return\\n    /// `true` from `isChild`. This is CRITICAL to the security guarantees for\\n    /// any contract implementing `IFactory`.\\n    ///\\n    /// @param maybeChild_ Address to check registration for.\\n    /// @return `true` if address was deployed by this contract factory,\\n    /// otherwise `false`.\\n    function isChild(address maybeChild_) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x3e9ca6613b0c19d98c4e19a7586d4109e498db2cf7d6e38e34fc2d2c0dbc32e2\",\"license\":\"CAL\"},\"contracts/math/FixedPointMath.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @dev The scale of all fixed point math. This is adopting the conventions of\\n/// both ETH (wei) and most ERC20 tokens, so is hopefully uncontroversial.\\nuint256 constant FP_DECIMALS = 18;\\n/// @dev The number `1` in the standard fixed point math scaling. Most of the\\n/// differences between fixed point math and regular math is multiplying or\\n/// dividing by `ONE` after the appropriate scaling has been applied.\\nuint256 constant FP_ONE = 1e18;\\n\\n/// @title FixedPointMath\\n/// @notice Sometimes we want to do math with decimal values but all we have\\n/// are integers, typically uint256 integers. Floats are very complex so we\\n/// don't attempt to simulate them. Instead we provide a standard definition of\\n/// \\\"one\\\" as 10 ** 18 and scale everything up/down to this as fixed point math.\\n/// Overflows are errors as per Solidity.\\nlibrary FixedPointMath {\\n    /// Scale a fixed point decimal of some scale factor to match `DECIMALS`.\\n    /// @param a_ Some fixed point decimal value.\\n    /// @param aDecimals_ The number of fixed decimals of `a_`.\\n    /// @return `a_` scaled to match `DECIMALS`.\\n    function scale18(uint256 a_, uint256 aDecimals_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 decimals_;\\n        if (FP_DECIMALS == aDecimals_) {\\n            return a_;\\n        } else if (FP_DECIMALS > aDecimals_) {\\n            unchecked {\\n                decimals_ = FP_DECIMALS - aDecimals_;\\n            }\\n            return a_ * 10**decimals_;\\n        } else {\\n            unchecked {\\n                decimals_ = aDecimals_ - FP_DECIMALS;\\n            }\\n            return a_ / 10**decimals_;\\n        }\\n    }\\n\\n    /// Scale a fixed point decimals of `DECIMALS` to some other scale.\\n    /// @param a_ A `DECIMALS` fixed point decimals.\\n    /// @param targetDecimals_ The new scale of `a_`.\\n    /// @return `a_` rescaled from `DECIMALS` to `targetDecimals_`.\\n    function scaleN(uint256 a_, uint256 targetDecimals_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 decimals_;\\n        if (targetDecimals_ == FP_DECIMALS) {\\n            return a_;\\n        } else if (FP_DECIMALS > targetDecimals_) {\\n            unchecked {\\n                decimals_ = FP_DECIMALS - targetDecimals_;\\n            }\\n            return a_ / 10**decimals_;\\n        } else {\\n            unchecked {\\n                decimals_ = targetDecimals_ - FP_DECIMALS;\\n            }\\n            return a_ * 10**decimals_;\\n        }\\n    }\\n\\n    /// Scale a fixed point up or down by `scaleBy_` orders of magnitude.\\n    /// The caller MUST ensure the end result matches `DECIMALS` if other\\n    /// functions in this library are to work correctly.\\n    /// Notably `scaleBy` is a SIGNED integer so scaling down by negative OOMS\\n    /// is supported.\\n    /// @param a_ Some integer of any scale.\\n    /// @param scaleBy_ OOMs to scale `a_` up or down by.\\n    /// @return `a_` rescaled according to `scaleBy_`.\\n    function scaleBy(uint256 a_, int8 scaleBy_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (scaleBy_ == 0) {\\n            return a_;\\n        } else if (scaleBy_ > 0) {\\n            return a_ * 10**uint8(scaleBy_);\\n        } else {\\n            uint256 posScaleDownBy_;\\n            unchecked {\\n                posScaleDownBy_ = uint8(-1 * scaleBy_);\\n            }\\n            return a_ / 10**posScaleDownBy_;\\n        }\\n    }\\n\\n    /// Fixed point multiplication in native scale decimals.\\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return `a_` multiplied by `b_` to `DECIMALS` fixed point decimals.\\n    function fixedPointMul(uint256 a_, uint256 b_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return (a_ * b_) / FP_ONE;\\n    }\\n\\n    /// Fixed point division in native scale decimals.\\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return `a_` divided by `b_` to `DECIMALS` fixed point decimals.\\n    function fixedPointDiv(uint256 a_, uint256 b_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return (a_ * FP_ONE) / b_;\\n    }\\n}\\n\",\"keccak256\":\"0xf2ac4d2307fb5b32d6c9a428b9704d14c93aa71f171f04215176a611d61aef9c\",\"license\":\"CAL\"},\"contracts/math/SaturatingMath.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title SaturatingMath\\n/// @notice Sometimes we neither want math operations to error nor wrap around\\n/// on an overflow or underflow. In the case of transferring assets an error\\n/// may cause assets to be locked in an irretrievable state within the erroring\\n/// contract, e.g. due to a tiny rounding/calculation error. We also can't have\\n/// assets underflowing and attempting to approve/transfer \\\"infinity\\\" when we\\n/// wanted \\\"almost or exactly zero\\\" but some calculation bug underflowed zero.\\n/// Ideally there are no calculation mistakes, but in guarding against bugs it\\n/// may be safer pragmatically to saturate arithmatic at the numeric bounds.\\n/// Note that saturating div is not supported because 0/0 is undefined.\\nlibrary SaturatingMath {\\n    /// Saturating addition.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return Minimum of a_ + b_ and max uint256.\\n    function saturatingAdd(uint256 a_, uint256 b_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        unchecked {\\n            uint256 c_ = a_ + b_;\\n            return c_ < a_ ? type(uint256).max : c_;\\n        }\\n    }\\n\\n    /// Saturating subtraction.\\n    /// @param a_ Minuend.\\n    /// @param b_ Subtrahend.\\n    /// @return Maximum of a_ - b_ and 0.\\n    function saturatingSub(uint256 a_, uint256 b_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        unchecked {\\n            return a_ > b_ ? a_ - b_ : 0;\\n        }\\n    }\\n\\n    /// Saturating multiplication.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return Minimum of a_ * b_ and max uint256.\\n    function saturatingMul(uint256 a_, uint256 b_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being\\n            // zero, but the benefit is lost if 'b' is also tested.\\n            // https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a_ == 0) return 0;\\n            uint256 c_ = a_ * b_;\\n            return c_ / a_ != b_ ? type(uint256).max : c_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9078a23bd04812d8a57e26ef51ddc7f2c6b0c65d8c7cfc2f2ebf40e6642fff88\",\"license\":\"CAL\"},\"contracts/sstore2/SSTORE2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\n\\nimport \\\"./utils/Bytecode.sol\\\";\\n\\n/**\\n  @title A key-value storage with auto-generated keys for storing chunks of\\n  data with a lower write & read cost.\\n  @author Agustin Aguilar <aa@horizon.io>\\n\\n  Readme: https://github.com/0xsequence/sstore2#readme\\n*/\\nlibrary SSTORE2 {\\n    error WriteError();\\n\\n    /**\\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\\n    @dev The pointer is a contract address with `_data` as code\\n    @param _data to be written\\n    @return pointer Pointer to the written `_data`\\n  */\\n    function write(bytes memory _data) internal returns (address pointer) {\\n        // Append 00 to _data so contract can't be called\\n        // Build init code\\n        bytes memory code = Bytecode.creationCodeFor(\\n            abi.encodePacked(hex\\\"00\\\", _data)\\n        );\\n\\n        // Deploy contract using create\\n        assembly {\\n            pointer := create(0, add(code, 32), mload(code))\\n        }\\n\\n        // Address MUST be non-zero\\n        if (pointer == address(0)) revert WriteError();\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first\\n    byte\\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @return data read from `_pointer` contract\\n  */\\n    function read(address _pointer) internal view returns (bytes memory) {\\n        return Bytecode.codeAt(_pointer, 1, type(uint256).max);\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first\\n    byte\\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @param _start number of bytes to skip\\n    @return data read from `_pointer` contract\\n  */\\n    function read(address _pointer, uint256 _start)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first\\n    byte\\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @param _start number of bytes to skip\\n    @param _end index before which to end extraction\\n    @return data read from `_pointer` contract\\n  */\\n    function read(\\n        address _pointer,\\n        uint256 _start,\\n        uint256 _end\\n    ) internal view returns (bytes memory) {\\n        return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\\n    }\\n}\\n\",\"keccak256\":\"0x233f8e9ad3717999efbf17923c0f16aaf910f79064aff273485237b4f2a1ef2f\",\"license\":\"MIT\"},\"contracts/sstore2/utils/Bytecode.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.10;\\n\\nlibrary Bytecode {\\n    error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\\n\\n    /**\\n    @notice Generate a creation code that results on a contract with `_code` as\\n    bytecode\\n    @param _code The returning value of the resulting `creationCode`\\n    @return creationCode (constructor) for new contract\\n  */\\n    function creationCodeFor(bytes memory _code)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        /*\\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\\n      0x01    0x80         0x80        DUP1                size size\\n      0x02    0x60         0x600e      PUSH1 14            14 size size\\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\\n      0x04    0x39         0x39        CODECOPY            size\\n      0x05    0x60         0x6000      PUSH1 00            0 size\\n      0x06    0xf3         0xf3        RETURN\\n      <CODE>\\n    */\\n\\n        return\\n            abi.encodePacked(\\n                hex\\\"63\\\",\\n                uint32(_code.length),\\n                hex\\\"80_60_0E_60_00_39_60_00_F3\\\",\\n                _code\\n            );\\n    }\\n\\n    /**\\n    @notice Returns the size of the code on a given address\\n    @param _addr Address that may or may not contain code\\n    @return size of the code on the given `_addr`\\n  */\\n    function codeSize(address _addr) internal view returns (uint256 size) {\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n    }\\n\\n    /**\\n    @notice Returns the code of a given address\\n    @dev It will fail if `_end < _start`\\n    @param _addr Address that may or may not contain code\\n    @param _start number of bytes of code to skip on read\\n    @param _end index before which to end extraction\\n    @return oCode read from `_addr` deployed bytecode\\n\\n    Forked: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\\n  */\\n    function codeAt(\\n        address _addr,\\n        uint256 _start,\\n        uint256 _end\\n    ) internal view returns (bytes memory oCode) {\\n        uint256 csize = codeSize(_addr);\\n        if (csize == 0) return bytes(\\\"\\\");\\n\\n        if (_start > csize) return bytes(\\\"\\\");\\n        if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end);\\n\\n        unchecked {\\n            uint256 reqSize = _end - _start;\\n            uint256 maxSize = csize - _start;\\n\\n            uint256 size = maxSize < reqSize ? maxSize : reqSize;\\n\\n            assembly {\\n                // allocate output byte array - this could also be done without\\n                // assembly\\n                // by using o_code = new bytes(size)\\n                oCode := mload(0x40)\\n                // new \\\"memory end\\\" including padding\\n                mstore(\\n                    0x40,\\n                    add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f)))\\n                )\\n                // store length in memory\\n                mstore(oCode, size)\\n                // actually retrieve the code, this needs assembly\\n                extcodecopy(_addr, add(oCode, 0x20), _start, size)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb113974373d234e70f518f0f7c3f34162c008031c168ba3b8ed12f438d5e7145\",\"license\":\"MIT\"},\"contracts/tier/ITierV2.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// @title ITierV2\\n/// @notice `ITierV2` is a simple interface that contracts can implement to\\n/// provide membership lists for other contracts.\\n///\\n/// There are many use-cases for a time-preserving conditional membership list.\\n///\\n/// Some examples include:\\n///\\n/// - Self-serve whitelist to participate in fundraising\\n/// - Lists of users who can claim airdrops and perks\\n/// - Pooling resources with implied governance/reward tiers\\n/// - POAP style attendance proofs allowing access to future exclusive events\\n///\\n/// @dev Standard interface to a tiered membership.\\n///\\n/// A \\\"membership\\\" can represent many things:\\n/// - Exclusive access.\\n/// - Participation in some event or process.\\n/// - KYC completion.\\n/// - Combination of sub-memberships.\\n/// - Etc.\\n///\\n/// The high level requirements for a contract implementing `ITierV2`:\\n/// - MUST represent held tiers as a `uint`.\\n/// - MUST implement `report`.\\n///   - The report is a `uint256` that SHOULD represent the time each tier has\\n///     been continuously held since encoded as `uint32`.\\n///   - The encoded tiers start at `1`; Tier `0` is implied if no tier has ever\\n///     been held.\\n///   - Tier `0` is NOT encoded in the report, it is simply the fallback value.\\n///   - If a tier is lost the time data is erased for that tier and will be\\n///     set if/when the tier is regained to the new time.\\n///   - If a tier is held but the historical time information is not available\\n///     the report MAY return `0x00000000` for all held tiers.\\n///   - Tiers that are lost or have never been held MUST return `0xFFFFFFFF`.\\n///   - Context can be a list of numbers that MAY pairwise define tiers such as\\n///     minimum thresholds, or MAY simply provide global context such as a\\n///     relevant NFT ID for example.\\n/// - MUST implement `reportTimeForTier`\\n///   - Functions exactly as `report` but only returns a single time for a\\n///     single tier\\n///   - MUST return the same time value `report` would for any given tier and\\n///     context combination.\\n///\\n/// So the four possible states and report values are:\\n/// - Tier is held and time is known: Timestamp is in the report\\n/// - Tier is held but time is NOT known: `0` is in the report\\n/// - Tier is NOT held: `0xFF..` is in the report\\n/// - Tier is unknown: `0xFF..` is in the report\\n///\\n/// The reason `context` is specified as a list of values rather than arbitrary\\n/// bytes is to allow clear and efficient compatibility with VM stacks. Some N\\n/// values can be taken from a VM stack and used directly as a context, which\\n/// would be difficult or impossible to ensure is safe for arbitrary bytes.\\ninterface ITierV2 {\\n    /// Same as report but only returns the time for a single tier.\\n    /// Often the implementing contract can calculate a single tier more\\n    /// efficiently than all 8 tiers. If the consumer only needs one or a few\\n    /// tiers it MAY be much cheaper to request only those tiers individually.\\n    /// This DOES NOT apply to all contracts, an obvious example is token\\n    /// balance based tiers which always return `ALWAYS` or `NEVER` for all\\n    /// tiers so no efficiency is gained.\\n    /// The return value is a `uint256` for gas efficiency but the values will\\n    /// be bounded by `type(uint32).max` as no single tier can report a value\\n    /// higher than this.\\n    function reportTimeForTier(\\n        address account,\\n        uint256 tier,\\n        uint256[] calldata context\\n    ) external view returns (uint256 time);\\n\\n    /// Same as `ITier` but with a list of values for `context` which allows a\\n    /// single underlying state to present many different reports dynamically.\\n    ///\\n    /// For example:\\n    /// - Staking ledgers can calculate different tier thresholds\\n    /// - NFTs can give different tiers based on different IDs\\n    /// - Snapshot ERC20s can give different reports based on snapshot ID\\n    ///\\n    /// `context` supercedes `setTier` function and `TierChange` event from\\n    /// `ITier` at the interface level. Implementing contracts are free to\\n    /// inherit both `ITier` and `ITierV2` if the old behaviour is desired.\\n    function report(address account, uint256[] calldata context)\\n        external\\n        view\\n        returns (uint256 report);\\n}\\n\",\"keccak256\":\"0xdc851fc7cd82f9752a2bc96dfe3914257af6a970f514a0a7ed50a7b327c4d035\",\"license\":\"CAL\"},\"contracts/tier/TierV2.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"./ITierV2.sol\\\";\\n\\nabstract contract TierV2 is ITierV2, ERC165 {\\n    function supportsInterface(bytes4 interfaceId_)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceId_ == type(ITierV2).interfaceId ||\\n            super.supportsInterface(interfaceId_);\\n    }\\n}\\n\",\"keccak256\":\"0x0dbc43be311bc27af8c8489a197cf2ec055266105e9c364ae4bddd02845a4f0d\",\"license\":\"CAL\"},\"contracts/tier/libraries/TierConstants.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title TierConstants\\n/// @notice Constants for use with tier logic.\\nlibrary TierConstants {\\n    /// NEVER is 0xFF.. as it is infinitely in the future.\\n    /// NEVER for an entire report.\\n    uint256 internal constant NEVER_REPORT = type(uint256).max;\\n    /// NEVER for a single tier time.\\n    uint32 internal constant NEVER_TIME = type(uint32).max;\\n\\n    /// Always is 0 as it is the genesis block.\\n    /// Tiers can't predate the chain but they can predate an `ITierV2`\\n    /// contract.\\n    uint256 internal constant ALWAYS = 0;\\n\\n    /// Account has never held a tier.\\n    uint256 internal constant TIER_ZERO = 0;\\n\\n    /// Magic number for tier one.\\n    uint256 internal constant TIER_ONE = 1;\\n    /// Magic number for tier two.\\n    uint256 internal constant TIER_TWO = 2;\\n    /// Magic number for tier three.\\n    uint256 internal constant TIER_THREE = 3;\\n    /// Magic number for tier four.\\n    uint256 internal constant TIER_FOUR = 4;\\n    /// Magic number for tier five.\\n    uint256 internal constant TIER_FIVE = 5;\\n    /// Magic number for tier six.\\n    uint256 internal constant TIER_SIX = 6;\\n    /// Magic number for tier seven.\\n    uint256 internal constant TIER_SEVEN = 7;\\n    /// Magic number for tier eight.\\n    uint256 internal constant TIER_EIGHT = 8;\\n    /// Maximum tier is `TIER_EIGHT`.\\n    uint256 internal constant MAX_TIER = TIER_EIGHT;\\n}\\n\",\"keccak256\":\"0x4d73c7a5d50d7dddfd0a6cacaf5a366f99b80199dc9f9e8aa9ba77e2736a19e5\",\"license\":\"CAL\"},\"contracts/tier/libraries/TierReport.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {ITierV2} from \\\"../ITierV2.sol\\\";\\nimport \\\"./TierConstants.sol\\\";\\n\\n/// @title TierReport\\n/// @notice `TierReport` implements several pure functions that can be\\n/// used to interface with reports.\\n/// - `tierAtTimeFromReport`: Returns the highest status achieved relative to\\n/// a block timestamp and report. Statuses gained after that block are ignored.\\n/// - `tierTime`: Returns the timestamp that a given tier has been held\\n/// since according to a report.\\n/// - `truncateTiersAbove`: Resets all the tiers above the reference tier.\\n/// - `updateTimesForTierRange`: Updates a report with a timestamp for every\\n///    tier in a range.\\n/// - `updateReportWithTierAtTime`: Updates a report to a new tier.\\n/// @dev Utilities to consistently read, write and manipulate tiers in reports.\\n/// The low-level bit shifting can be difficult to get right so this\\n/// factors that out.\\nlibrary TierReport {\\n    /// Enforce upper limit on tiers so we can do unchecked math.\\n    /// @param tier_ The tier to enforce bounds on.\\n    modifier maxTier(uint256 tier_) {\\n        require(tier_ <= TierConstants.MAX_TIER, \\\"MAX_TIER\\\");\\n        _;\\n    }\\n\\n    /// Returns the highest tier achieved relative to a block timestamp\\n    /// and report.\\n    ///\\n    /// Note that typically the report will be from the _current_ contract\\n    /// state, i.e. `block.timestamp` but not always. Tiers gained after the\\n    /// reference time are ignored.\\n    ///\\n    /// When the `report` comes from a later block than the `timestamp_` this\\n    /// means the user must have held the tier continuously from `timestamp_`\\n    /// _through_ to the report block.\\n    /// I.e. NOT a snapshot.\\n    ///\\n    /// @param report_ A report as per `ITierV2`.\\n    /// @param timestamp_ The timestamp to check the tiers against.\\n    /// @return tier_ The highest tier held since `timestamp_` as per `report`.\\n    function tierAtTimeFromReport(uint256 report_, uint256 timestamp_)\\n        internal\\n        pure\\n        returns (uint256 tier_)\\n    {\\n        unchecked {\\n            for (tier_ = 0; tier_ < 8; tier_++) {\\n                if (uint32(uint256(report_ >> (tier_ * 32))) > timestamp_) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// Returns the timestamp that a given tier has been held since from a\\n    /// report.\\n    ///\\n    /// The report MUST encode \\\"never\\\" as 0xFFFFFFFF. This ensures\\n    /// compatibility with `tierAtTimeFromReport`.\\n    ///\\n    /// @param report_ The report to read a timestamp from.\\n    /// @param tier_ The Tier to read the timestamp for.\\n    /// @return timestamp_ The timestamp the tier has been held since.\\n    function reportTimeForTier(uint256 report_, uint256 tier_)\\n        internal\\n        pure\\n        maxTier(tier_)\\n        returns (uint256 timestamp_)\\n    {\\n        unchecked {\\n            // ZERO is a special case. Everyone has always been at least ZERO,\\n            // since block 0.\\n            if (tier_ == 0) {\\n                return 0;\\n            }\\n\\n            uint256 offset_ = (tier_ - 1) * 32;\\n            timestamp_ = uint256(uint32(uint256(report_ >> offset_)));\\n        }\\n    }\\n\\n    /// Resets all the tiers above the reference tier to 0xFFFFFFFF.\\n    ///\\n    /// @param report_ Report to truncate with high bit 1s.\\n    /// @param tier_ Tier to truncate above (exclusive).\\n    /// @return Truncated report.\\n    function truncateTiersAbove(uint256 report_, uint256 tier_)\\n        internal\\n        pure\\n        maxTier(tier_)\\n        returns (uint256)\\n    {\\n        unchecked {\\n            uint256 offset_ = tier_ * 32;\\n            uint256 mask_ = (TierConstants.NEVER_REPORT >> offset_) << offset_;\\n            return report_ | mask_;\\n        }\\n    }\\n\\n    /// Updates a report with a timestamp for a given tier.\\n    /// More gas efficient than `updateTimesForTierRange` if only a single\\n    /// tier is being modified.\\n    /// The tier at/above the given tier is updated. E.g. tier `0` will update\\n    /// the time for tier `1`.\\n    /// @param report_ Report to use as the baseline for the updated report.\\n    /// @param tier_ The tier level to update.\\n    /// @param timestamp_ The new block number for `tier_`.\\n    /// @return updatedReport_ The newly updated `report_`.\\n    function updateTimeAtTier(\\n        uint256 report_,\\n        uint256 tier_,\\n        uint256 timestamp_\\n    ) internal pure maxTier(tier_) returns (uint256 updatedReport_) {\\n        unchecked {\\n            uint256 offset_ = tier_ * 32;\\n            updatedReport_ =\\n                (report_ &\\n                    ~uint256(uint256(TierConstants.NEVER_TIME) << offset_)) |\\n                uint256(timestamp_ << offset_);\\n        }\\n    }\\n\\n    /// Updates a report with a block number for every tier in a range.\\n    ///\\n    /// Does nothing if the end status is equal or less than the start tier.\\n    /// @param report_ The report to update.\\n    /// @param startTier_ The tier at the start of the range (exclusive).\\n    /// @param endTier_ The tier at the end of the range (inclusive).\\n    /// @param timestamp_ The timestamp to set for every tier in the range.\\n    /// @return updatedReport_ The updated report.\\n    function updateTimesForTierRange(\\n        uint256 report_,\\n        uint256 startTier_,\\n        uint256 endTier_,\\n        uint256 timestamp_\\n    ) internal pure maxTier(endTier_) returns (uint256 updatedReport_) {\\n        unchecked {\\n            uint256 offset_;\\n            for (uint256 i_ = startTier_; i_ < endTier_; i_++) {\\n                offset_ = i_ * 32;\\n                report_ =\\n                    (report_ &\\n                        ~uint256(\\n                            uint256(TierConstants.NEVER_TIME) << offset_\\n                        )) |\\n                    uint256(timestamp_ << offset_);\\n            }\\n            updatedReport_ = report_;\\n        }\\n    }\\n\\n    /// Updates a report to a new status.\\n    ///\\n    /// Internally dispatches to `truncateTiersAbove` and\\n    /// `updateBlocksForTierRange`.\\n    /// The dispatch is based on whether the new tier is above or below the\\n    /// current tier.\\n    /// The `startTier_` MUST match the result of `tierAtBlockFromReport`.\\n    /// It is expected the caller will know the current tier when\\n    /// calling this function and need to do other things in the calling scope\\n    /// with it.\\n    ///\\n    /// @param report_ The report to update.\\n    /// @param startTier_ The tier to start updating relative to. Data above\\n    /// this tier WILL BE LOST so probably should be the current tier.\\n    /// @param endTier_ The new highest tier held, at the given block number.\\n    /// @param timestamp_ The timestamp_ to update the highest tier to, and\\n    /// intermediate tiers from `startTier_`.\\n    /// @return updatedReport_ The updated report.\\n    function updateReportWithTierAtTime(\\n        uint256 report_,\\n        uint256 startTier_,\\n        uint256 endTier_,\\n        uint256 timestamp_\\n    ) internal pure returns (uint256 updatedReport_) {\\n        updatedReport_ = endTier_ < startTier_\\n            ? truncateTiersAbove(report_, endTier_)\\n            : updateTimesForTierRange(\\n                report_,\\n                startTier_,\\n                endTier_,\\n                timestamp_\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x814ae8971bdddb4a0c8b3e460d1c338bc03a43c0e27452f5338816408519115e\",\"license\":\"CAL\"},\"contracts/tier/libraries/TierwiseCombine.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"./TierReport.sol\\\";\\nimport \\\"../../math/SaturatingMath.sol\\\";\\n\\nlibrary TierwiseCombine {\\n    using Math for uint256;\\n    using SaturatingMath for uint256;\\n\\n    /// Every lte check in `selectLte` must pass.\\n    uint256 internal constant LOGIC_EVERY = 0;\\n    /// Only one lte check in `selectLte` must pass.\\n    uint256 internal constant LOGIC_ANY = 1;\\n\\n    /// Select the minimum block number from passing blocks in `selectLte`.\\n    uint256 internal constant MODE_MIN = 0;\\n    /// Select the maximum block number from passing blocks in `selectLte`.\\n    uint256 internal constant MODE_MAX = 1;\\n    /// Select the first block number that passes in `selectLte`.\\n    uint256 internal constant MODE_FIRST = 2;\\n\\n    /// Performs a tierwise saturating subtraction of two reports.\\n    /// Intepret as \\\"# of blocks older report was held before newer report\\\".\\n    /// If older report is in fact newer then `0` will be returned.\\n    /// i.e. the diff cannot be negative, older report as simply spent 0 blocks\\n    /// existing before newer report, if it is in truth the newer report.\\n    /// @param newerReport_ Block to subtract from.\\n    /// @param olderReport_ Block to subtract.\\n    function saturatingSub(uint256 newerReport_, uint256 olderReport_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        unchecked {\\n            uint256 ret_;\\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\\n                uint256 newerBlock_ = TierReport.reportTimeForTier(\\n                    newerReport_,\\n                    tier_\\n                );\\n                uint256 olderBlock_ = TierReport.reportTimeForTier(\\n                    olderReport_,\\n                    tier_\\n                );\\n                uint256 diff_ = newerBlock_.saturatingSub(olderBlock_);\\n                ret_ = TierReport.updateTimeAtTier(ret_, tier_ - 1, diff_);\\n            }\\n            return ret_;\\n        }\\n    }\\n\\n    /// Given a list of reports, selects the best tier in a tierwise fashion.\\n    /// The \\\"best\\\" criteria can be configured by `logic_` and `mode_`.\\n    /// Logic can be \\\"every\\\" or \\\"any\\\", which means that the reports for a given\\n    /// tier must either all or any be less than or equal to the reference\\n    /// `blockNumber_`.\\n    /// Mode can be \\\"min\\\", \\\"max\\\", \\\"first\\\" which selects between all the block\\n    /// numbers for a given tier that meet the lte criteria.\\n    /// IMPORTANT: If the output of `selectLte` is used to write to storage\\n    /// care must be taken to ensure that \\\"upcoming\\\" tiers relative to the\\n    /// `blockNumber_` are not overwritten inappropriately. Typically this\\n    /// function should be used as a filter over reads only from an upstream\\n    /// source of truth.\\n    /// @param reports_ The list of reports to select over.\\n    /// @param blockNumber_ The block number that tier blocks must be lte.\\n    /// @param logic_ `LOGIC_EVERY` or `LOGIC_ANY`.\\n    /// @param mode_ `MODE_MIN`, `MODE_MAX` or `MODE_FIRST`.\\n    function selectLte(\\n        uint256[] memory reports_,\\n        uint256 blockNumber_,\\n        uint256 logic_,\\n        uint256 mode_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 ret_;\\n            uint256 block_;\\n            bool anyLte_;\\n            uint256 length_ = reports_.length;\\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\\n                uint256 accumulator_;\\n                // Nothing lte the reference block for this tier yet.\\n                anyLte_ = false;\\n\\n                // Initialize the accumulator for this tier.\\n                if (mode_ == MODE_MIN) {\\n                    accumulator_ = TierConstants.NEVER_REPORT;\\n                } else {\\n                    accumulator_ = 0;\\n                }\\n\\n                // Filter all the blocks at the current tier from all the\\n                // reports against the reference tier and each other.\\n                for (uint256 i_ = 0; i_ < length_; i_++) {\\n                    block_ = TierReport.reportTimeForTier(reports_[i_], tier_);\\n\\n                    if (block_ <= blockNumber_) {\\n                        // Min and max need to compare current value against\\n                        // the accumulator.\\n                        if (mode_ == MODE_MIN) {\\n                            accumulator_ = block_.min(accumulator_);\\n                        } else if (mode_ == MODE_MAX) {\\n                            accumulator_ = block_.max(accumulator_);\\n                        } else if (mode_ == MODE_FIRST && !anyLte_) {\\n                            accumulator_ = block_;\\n                        }\\n                        anyLte_ = true;\\n                    } else if (logic_ == LOGIC_EVERY) {\\n                        // Can short circuit for an \\\"every\\\" check.\\n                        accumulator_ = TierConstants.NEVER_REPORT;\\n                        break;\\n                    }\\n                }\\n                if (!anyLte_) {\\n                    accumulator_ = TierConstants.NEVER_REPORT;\\n                }\\n                ret_ = TierReport.updateTimeAtTier(\\n                    ret_,\\n                    tier_ - 1,\\n                    accumulator_\\n                );\\n            }\\n            return ret_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc2fc43f70f19af29a6b08f0de69ebde9ccdb6f1e360f22747071c5076a11a69c\",\"license\":\"CAL\"},\"contracts/vm/RainVM.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../math/SaturatingMath.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// Everything required to evaluate and track the state of a rain script.\\n/// As this is a struct it will be in memory when passed to `RainVM` and so\\n/// will be modified by reference internally. This is important for gas\\n/// efficiency; the stack, arguments and stackIndex will likely be mutated by\\n/// the running script.\\n/// @param stackIndex Opcodes write to the stack at the stack index and can\\n/// consume from the stack by decrementing the index and reading between the\\n/// old and new stack index.\\n/// IMPORANT: The stack is never zeroed out so the index must be used to\\n/// find the \\\"top\\\" of the stack as the result of an `eval`.\\n/// @param stack Stack is the general purpose runtime state that opcodes can\\n/// read from and write to according to their functionality.\\n/// @param sources Sources available to be executed by `eval`.\\n/// Notably `ZIPMAP` can also select a source to execute by index.\\n/// @param constants Constants that can be copied to the stack by index by\\n/// `VAL`.\\n/// @param arguments `ZIPMAP` populates arguments which can be copied to the\\n/// stack by `VAL`.\\nstruct State {\\n    uint256 stackIndex;\\n    uint256[] stack;\\n    bytes[] ptrSources;\\n    uint256[] constants;\\n    /// `ZIPMAP` populates arguments into constants which can be copied to the\\n    /// stack by `VAL` as usual, starting from this index. This copying is\\n    /// destructive so it is recommended to leave space in the constants array.\\n    uint256 argumentsIndex;\\n}\\n\\nstruct StorageOpcodesRange {\\n    uint256 pointer;\\n    uint256 length;\\n}\\n\\nlibrary LibState {\\n    /// Put the state back to a freshly eval-able value. The same state can be\\n    /// run more than once (e.g. two different entrypoints) to yield different\\n    /// stacks, as long as all the sources are VALID and reset is called\\n    /// between each eval call.\\n    /// Generally this should be called whenever eval is run over a state that\\n    /// is exposed to the calling context (e.g. it is an argument) so that the\\n    /// caller may safely eval multiple times on any state it has in scope.\\n    function reset(State memory state_) internal pure {\\n        state_.stackIndex = 0;\\n    }\\n\\n    function toBytesDebug(State memory state_)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return abi.encode(state_);\\n    }\\n\\n    function fromBytesPacked(bytes memory stateBytes_)\\n        internal\\n        pure\\n        returns (State memory)\\n    {\\n        unchecked {\\n            State memory state_;\\n            uint256 indexes_;\\n            assembly {\\n                // Load indexes from state bytes.\\n                indexes_ := mload(add(stateBytes_, 0x20))\\n                // mask out everything but the constants length from state\\n                // bytes.\\n                mstore(add(stateBytes_, 0x20), and(indexes_, 0xFF))\\n                // point state constants at state bytes\\n                mstore(add(state_, 0x60), add(stateBytes_, 0x20))\\n            }\\n            // Stack index 0 is implied.\\n            state_.stack = new uint256[]((indexes_ >> 8) & 0xFF);\\n            state_.argumentsIndex = (indexes_ >> 16) & 0xFF;\\n            uint256 sourcesLen_ = (indexes_ >> 24) & 0xFF;\\n            bytes[] memory ptrSources_;\\n            uint256[] memory ptrSourcesPtrs_ = new uint256[](sourcesLen_);\\n\\n            assembly {\\n                let sourcesStart_ := add(\\n                    stateBytes_,\\n                    add(\\n                        // 0x40 for constants and state array length\\n                        0x40,\\n                        // skip over length of constants\\n                        mul(0x20, mload(add(stateBytes_, 0x20)))\\n                    )\\n                )\\n                let cursor_ := sourcesStart_\\n\\n                for {\\n                    let i_ := 0\\n                } lt(i_, sourcesLen_) {\\n                    i_ := add(i_, 1)\\n                } {\\n                    // sources_ is a dynamic array so it is a list of\\n                    // pointers that can be set literally to the cursor_\\n                    mstore(\\n                        add(ptrSourcesPtrs_, add(0x20, mul(i_, 0x20))),\\n                        cursor_\\n                    )\\n                    // move the cursor by the length of the source in bytes\\n                    cursor_ := add(cursor_, add(0x20, mload(cursor_)))\\n                }\\n                // point state at sources_ rather than clone in memory\\n                ptrSources_ := ptrSourcesPtrs_\\n                mstore(add(state_, 0x40), ptrSources_)\\n            }\\n            return state_;\\n        }\\n    }\\n\\n    function toBytesPacked(State memory state_)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        unchecked {\\n            // indexes + constants\\n            uint256[] memory constants_ = state_.constants;\\n            // constants is first so we can literally use it on the other end\\n            uint256 indexes_ = state_.constants.length |\\n                (state_.stack.length << 8) |\\n                (state_.argumentsIndex << 16) |\\n                (state_.ptrSources.length << 24);\\n            bytes memory ret_ = bytes.concat(\\n                bytes32(indexes_),\\n                abi.encodePacked(constants_)\\n            );\\n            for (uint256 i_ = 0; i_ < state_.ptrSources.length; i_++) {\\n                ret_ = bytes.concat(\\n                    ret_,\\n                    bytes32(state_.ptrSources[i_].length),\\n                    state_.ptrSources[i_]\\n                );\\n            }\\n            return ret_;\\n        }\\n    }\\n}\\n\\n/// @dev Copies a value either off `constants` to the top of the stack.\\nuint256 constant OPCODE_CONSTANT = 0;\\n/// @dev Duplicates any value in the stack to the top of the stack. The operand\\n/// specifies the index to copy from.\\nuint256 constant OPCODE_STACK = 1;\\nuint256 constant OPCODE_CONTEXT = 2;\\nuint256 constant OPCODE_STORAGE = 3;\\n/// @dev Takes N values off the stack, interprets them as an array then zips\\n/// and maps a source from `sources` over them.\\nuint256 constant OPCODE_ZIPMAP = 4;\\n/// @dev ABI encodes the entire stack and logs it to the hardhat console.\\nuint256 constant OPCODE_DEBUG = 5;\\n/// @dev Number of provided opcodes for `RainVM`.\\nuint256 constant RAIN_VM_OPS_LENGTH = 6;\\n\\nuint256 constant DEBUG_STATE_ABI = 0;\\nuint256 constant DEBUG_STATE_PACKED = 1;\\nuint256 constant DEBUG_STACK = 2;\\nuint256 constant DEBUG_STACK_INDEX = 3;\\n\\n/// @title RainVM\\n/// @notice micro VM for implementing and executing custom contract DSLs.\\n/// Libraries and contracts map opcodes to `view` functionality then RainVM\\n/// runs rain scripts using these opcodes. Rain scripts dispatch as pairs of\\n/// bytes. The first byte is an opcode to run and the second byte is a value\\n/// the opcode can use contextually to inform how to run. Typically opcodes\\n/// will read/write to the stack to produce some meaningful final state after\\n/// all opcodes have been dispatched.\\n///\\n/// The only thing required to run a rain script is a `State` struct to pass\\n/// to `eval`, and the index of the source to run. Additional context can\\n/// optionally be provided to be used by opcodes. For example, an `ITierV2`\\n/// contract can take the input of `report`, abi encode it as context, then\\n/// expose a local opcode that copies this account to the stack. The state will\\n/// be mutated by reference rather than returned by `eval`, this is to make it\\n/// very clear to implementers that the inline mutation is occurring.\\n///\\n/// Rain scripts run \\\"top to bottom\\\", i.e. \\\"left to right\\\".\\n/// See the tests for examples on how to construct rain script in JavaScript\\n/// then pass to `ImmutableSource` contracts deployed by a factory that then\\n/// run `eval` to produce a final value.\\n///\\n/// There are only 4 \\\"core\\\" opcodes for `RainVM`:\\n/// - `0`: Copy value from either `constants` at index `operand` to the top of\\n///   the stack.\\n/// - `1`: Duplicates the value at stack index `operand_` to the top of the\\n///   stack.\\n/// - `2`: Zipmap takes N values from the stack, interprets each as an array of\\n///   configurable length, then zips them into `arguments` and maps a source\\n///   from `sources` over these. See `zipmap` for more details.\\n/// - `3`: Debug prints the state to the console log as per hardhat.\\n///\\n/// To do anything useful the contract that inherits `RainVM` needs to provide\\n/// opcodes to build up an internal DSL. This may sound complex but it only\\n/// requires mapping opcode integers to functions to call, and reading/writing\\n/// values to the stack as input/output for these functions. Further, opcode\\n/// packs are provided in rain that any inheriting contract can use as a normal\\n/// solidity library. See `MathOps.sol` opcode pack and the\\n/// `CalculatorTest.sol` test contract for an example of how to dispatch\\n/// opcodes and handle the results in a wrapping contract.\\n///\\n/// RainVM natively has no concept of branching logic such as `if` or loops.\\n/// An opcode pack could implement these similar to the core zipmap by lazily\\n/// evaluating a source from `sources` based on some condition, etc. Instead\\n/// some simpler, eagerly evaluated selection tools such as `min` and `max` in\\n/// the `MathOps` opcode pack are provided. Future versions of `RainVM` MAY\\n/// implement lazy `if` and other similar patterns.\\n///\\n/// The `eval` function is `view` because rain scripts are expected to compute\\n/// results only without modifying any state. The contract wrapping the VM is\\n/// free to mutate as usual. This model encourages exposing only read-only\\n/// functionality to end-user deployers who provide scripts to a VM factory.\\n/// Removing all writes removes a lot of potential foot-guns for rain script\\n/// authors and allows VM contract authors to reason more clearly about the\\n/// input/output of the wrapping solidity code.\\n///\\n/// Internally `RainVM` makes heavy use of unchecked math and assembly logic\\n/// as the opcode dispatch logic runs on a tight loop and so gas costs can ramp\\n/// up very quickly. Implementing contracts and opcode packs SHOULD require\\n/// that opcodes they receive do not exceed the codes they are expecting.\\nabstract contract RainVM {\\n    using Math for uint256;\\n    using SaturatingMath for uint256;\\n\\n    /// Default is to disallow all storage access to opcodes.\\n    function storageOpcodesRange()\\n        public\\n        pure\\n        virtual\\n        returns (StorageOpcodesRange memory)\\n    {\\n        return StorageOpcodesRange(0, 0);\\n    }\\n\\n    function fnPtrs() public pure virtual returns (bytes memory);\\n\\n    /// Zipmap is rain script's native looping construct.\\n    /// N values are taken from the stack as `uint256` then split into `uintX`\\n    /// values where X is configurable by `operand_`. Each 1 increment in the\\n    /// operand size config doubles the number of items in the implied arrays.\\n    /// For example, size 0 is 1 `uint256` value, size 1 is\\n    /// `2x `uint128` values, size 2 is 4x `uint64` values and so on.\\n    ///\\n    /// The implied arrays are zipped and then copied into `arguments` and\\n    /// mapped over with a source from `sources`. Each iteration of the mapping\\n    /// copies values into `arguments` from index `0` but there is no attempt\\n    /// to zero out any values that may already be in the `arguments` array.\\n    /// It is the callers responsibility to ensure that the `arguments` array\\n    /// is correctly sized and populated for the mapped source.\\n    ///\\n    /// The `operand_` for the zipmap opcode is split into 3 components:\\n    /// - 3 low bits: The index of the source to use from `sources`.\\n    /// - 2 middle bits: The size of the loop, where 0 is 1 iteration\\n    /// - 3 high bits: The number of vals to be zipped from the stack where 0\\n    ///   is 1 value to be zipped.\\n    ///\\n    /// This is a separate function to avoid blowing solidity compile stack.\\n    /// In the future it may be moved inline to `eval` for gas efficiency.\\n    ///\\n    /// See https://en.wikipedia.org/wiki/Zipping_(computer_science)\\n    /// See https://en.wikipedia.org/wiki/Map_(higher-order_function)\\n    /// @param context_ Domain specific context the wrapping contract can\\n    /// provide to passthrough back to its own opcodes.\\n    /// @param state_ The execution state of the VM.\\n    /// @param operand_ The operand_ associated with this dispatch to zipmap.\\n    function zipmap(\\n        bytes memory context_,\\n        State memory state_,\\n        uint256 stackTopLocation_,\\n        uint256 operand_\\n    ) internal view returns (uint256) {\\n        unchecked {\\n            uint256 sourceIndex_ = operand_ & 0x07;\\n            uint256 loopSize_ = (operand_ >> 3) & 0x03;\\n            uint256 mask_;\\n            uint256 stepSize_;\\n            if (loopSize_ == 0) {\\n                mask_ = type(uint256).max;\\n                stepSize_ = 0x100;\\n            } else if (loopSize_ == 1) {\\n                mask_ = type(uint128).max;\\n                stepSize_ = 0x80;\\n            } else if (loopSize_ == 2) {\\n                mask_ = type(uint64).max;\\n                stepSize_ = 0x40;\\n            } else {\\n                mask_ = type(uint32).max;\\n                stepSize_ = 0x20;\\n            }\\n            uint256 valLength_ = (operand_ >> 5) + 1;\\n\\n            // Set aside base values so they can't be clobbered during eval\\n            // as the stack changes on each loop.\\n            uint256[] memory baseVals_ = new uint256[](valLength_);\\n            uint256 baseValsBottom_;\\n            {\\n                assembly {\\n                    baseValsBottom_ := add(baseVals_, 0x20)\\n                    for {\\n                        let cursor_ := sub(\\n                            stackTopLocation_,\\n                            mul(valLength_, 0x20)\\n                        )\\n                        let baseValsCursor_ := baseValsBottom_\\n                    } lt(cursor_, stackTopLocation_) {\\n                        cursor_ := add(cursor_, 0x20)\\n                        baseValsCursor_ := add(baseValsCursor_, 0x20)\\n                    } {\\n                        mstore(baseValsCursor_, mload(cursor_))\\n                    }\\n                }\\n            }\\n\\n            uint256 argumentsBottomLocation_;\\n            assembly {\\n                let constantsBottomLocation_ := add(\\n                    mload(add(state_, 0x60)),\\n                    0x20\\n                )\\n                argumentsBottomLocation_ := add(\\n                    constantsBottomLocation_,\\n                    mul(\\n                        0x20,\\n                        mload(\\n                            // argumentsIndex\\n                            add(state_, 0x80)\\n                        )\\n                    )\\n                )\\n            }\\n\\n            for (uint256 step_ = 0; step_ < 0x100; step_ += stepSize_) {\\n                // Prepare arguments.\\n                {\\n                    // max cursor is in this scope to avoid stack overflow from\\n                    // solidity.\\n                    uint256 maxCursor_ = baseValsBottom_ + (valLength_ * 0x20);\\n                    uint256 argumentsCursor_ = argumentsBottomLocation_;\\n                    uint256 cursor_ = baseValsBottom_;\\n                    while (cursor_ < maxCursor_) {\\n                        assembly {\\n                            mstore(\\n                                argumentsCursor_,\\n                                and(shr(step_, mload(cursor_)), mask_)\\n                            )\\n                            cursor_ := add(cursor_, 0x20)\\n                            argumentsCursor_ := add(argumentsCursor_, 0x20)\\n                        }\\n                    }\\n                }\\n                stackTopLocation_ = eval(context_, state_, sourceIndex_);\\n            }\\n            return stackTopLocation_;\\n        }\\n    }\\n\\n    /// Evaluates a rain script.\\n    /// The main workhorse of the rain VM, `eval` runs any core opcodes and\\n    /// dispatches anything it is unaware of to the implementing contract.\\n    /// For a script to be useful the implementing contract must override\\n    /// `applyOp` and dispatch non-core opcodes to domain specific logic. This\\n    /// could be mathematical operations for a calculator, tier reports for\\n    /// a membership combinator, entitlements for a minting curve, etc.\\n    ///\\n    /// Everything required to coordinate the execution of a rain script to\\n    /// completion is contained in the `State`. The context and source index\\n    /// are provided so the caller can provide additional data and kickoff the\\n    /// opcode dispatch from the correct source in `sources`.\\n    function eval(\\n        bytes memory context_,\\n        State memory state_,\\n        uint256 sourceIndex_\\n    ) internal view returns (uint256) {\\n        unchecked {\\n            uint256 pc_ = 0;\\n            uint256 opcode_;\\n            uint256 operand_;\\n            uint256 sourceLocation_;\\n            uint256 sourceLen_;\\n            uint256 constantsBottomLocation_;\\n            uint256 stackBottomLocation_;\\n            uint256 stackTopLocation_;\\n            uint256 firstFnPtrLocation_;\\n\\n            assembly {\\n                let stackLocation_ := mload(add(state_, 0x20))\\n                stackBottomLocation_ := add(stackLocation_, 0x20)\\n                stackTopLocation_ := add(\\n                    stackBottomLocation_,\\n                    // Add stack index offset.\\n                    mul(mload(state_), 0x20)\\n                )\\n                sourceLocation_ := mload(\\n                    add(\\n                        mload(add(state_, 0x40)),\\n                        add(0x20, mul(sourceIndex_, 0x20))\\n                    )\\n                )\\n                sourceLen_ := mload(sourceLocation_)\\n                constantsBottomLocation_ := add(mload(add(state_, 0x60)), 0x20)\\n                // first fn pointer is seen if we move two bytes into the data.\\n                firstFnPtrLocation_ := add(mload(add(state_, 0xA0)), 0x02)\\n            }\\n\\n            // Loop until complete.\\n            while (pc_ < sourceLen_) {\\n                assembly {\\n                    pc_ := add(pc_, 3)\\n                    let op_ := mload(add(sourceLocation_, pc_))\\n                    operand_ := byte(31, op_)\\n                    opcode_ := and(shr(8, op_), 0xFFFF)\\n                }\\n\\n                if (opcode_ < RAIN_VM_OPS_LENGTH) {\\n                    if (opcode_ == OPCODE_CONSTANT) {\\n                        assembly {\\n                            mstore(\\n                                stackTopLocation_,\\n                                mload(\\n                                    add(\\n                                        constantsBottomLocation_,\\n                                        mul(0x20, operand_)\\n                                    )\\n                                )\\n                            )\\n                            stackTopLocation_ := add(stackTopLocation_, 0x20)\\n                        }\\n                    } else if (opcode_ == OPCODE_STACK) {\\n                        assembly {\\n                            mstore(\\n                                stackTopLocation_,\\n                                mload(\\n                                    add(\\n                                        stackBottomLocation_,\\n                                        mul(operand_, 0x20)\\n                                    )\\n                                )\\n                            )\\n                            stackTopLocation_ := add(stackTopLocation_, 0x20)\\n                        }\\n                    } else if (opcode_ == OPCODE_CONTEXT) {\\n                        // This is the only runtime integrity check that we do\\n                        // as it is not possible to know how long context might\\n                        // be in general until runtime.\\n                        require(\\n                            operand_ * 0x20 < context_.length,\\n                            \\\"CONTEXT_LENGTH\\\"\\n                        );\\n                        assembly {\\n                            mstore(\\n                                stackTopLocation_,\\n                                mload(\\n                                    add(\\n                                        context_,\\n                                        add(0x20, mul(0x20, operand_))\\n                                    )\\n                                )\\n                            )\\n                            stackTopLocation_ := add(stackTopLocation_, 0x20)\\n                        }\\n                    } else if (opcode_ == OPCODE_STORAGE) {\\n                        StorageOpcodesRange\\n                            memory storageOpcodesRange_ = storageOpcodesRange();\\n                        assembly {\\n                            mstore(\\n                                stackTopLocation_,\\n                                sload(\\n                                    add(operand_, mload(storageOpcodesRange_))\\n                                )\\n                            )\\n                            stackTopLocation_ := add(stackTopLocation_, 0x20)\\n                        }\\n                    } else if (opcode_ == OPCODE_ZIPMAP) {\\n                        stackTopLocation_ = zipmap(\\n                            context_,\\n                            state_,\\n                            stackTopLocation_,\\n                            operand_\\n                        );\\n                    } else {\\n                        bytes memory debug_;\\n                        if (operand_ == DEBUG_STATE_ABI) {\\n                            debug_ = abi.encode(state_);\\n                        } else if (operand_ == DEBUG_STATE_PACKED) {\\n                            debug_ = LibState.toBytesPacked(state_);\\n                        } else if (operand_ == DEBUG_STACK) {\\n                            debug_ = abi.encodePacked(state_.stack);\\n                        } else if (operand_ == DEBUG_STACK_INDEX) {\\n                            debug_ = abi.encodePacked(state_.stackIndex);\\n                        }\\n                        if (debug_.length > 0) {\\n                            console.logBytes(debug_);\\n                        }\\n                    }\\n                } else {\\n                    function(uint256, uint256) view returns (uint256) fn_;\\n                    assembly {\\n                        fn_ := opcode_\\n                    }\\n                    stackTopLocation_ = fn_(operand_, stackTopLocation_);\\n                }\\n                // The stack index may be the same as the length as this means\\n                // the stack is full. But we cannot write past the end of the\\n                // stack. This also catches a stack index that underflows due\\n                // to unchecked or assembly math. This check MAY be redundant\\n                // with standard OOB checks on the stack array due to indexing\\n                // into it, but is a required guard in the case of VM assembly.\\n                // Future versions of the VM will precalculate all stack\\n                // movements at deploy time rather than runtime as this kind of\\n                // accounting adds nontrivial gas across longer scripts that\\n                // include many opcodes.\\n                // Note: This check would NOT be safe in the case that some\\n                // opcode used assembly in a way that can underflow the stack\\n                // as this would allow a malicious rain script to write to the\\n                // stack length and/or the stack index.\\n                require(\\n                    state_.stackIndex <= state_.stack.length,\\n                    \\\"STACK_OVERFLOW\\\"\\n                );\\n            }\\n            state_.stackIndex =\\n                (stackTopLocation_ - stackBottomLocation_) /\\n                0x20;\\n            return stackTopLocation_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7c75c1fcfaa98a06d194a9476fc36df803b2bba3ca74912c6137660684b0e2ef\",\"license\":\"CAL\"},\"contracts/vm/VMStateBuilder.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\nimport \\\"./RainVM.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../sstore2/SSTORE2.sol\\\";\\n\\n/// Config required to build a new `State`.\\n/// @param sources Sources verbatim.\\n/// @param constants Constants verbatim.\\nstruct StateConfig {\\n    bytes[] sources;\\n    uint256[] constants;\\n}\\n\\n/// @param stackIndex The current stack index as the state builder moves\\n/// through each opcode and applies the appropriate pops and pushes.\\n/// @param stackLength The maximum length of the stack seen so far due to stack\\n/// index movements. If the stack index underflows this will be close to\\n/// uint256 max and will ultimately error. It will also error if it overflows\\n/// MAX_STACK_LENGTH.\\n/// @param argumentsLength The maximum length of arguments seen so far due to\\n/// zipmap calls. Will be 0 if there are no zipmap calls.\\n/// @param storageLength The VM contract MUST specify which range of storage\\n/// slots can be read by VM scripts as [0, storageLength). If the storageLength\\n/// is 0 then no storage slots may be read by opcodes. In practise opcodes are\\n/// uint8 so storage slots beyond 255 cannot be read, notably all mappings will\\n/// be inaccessible.\\n/// @param opcodesLength The VM contract MUST specify how many valid opcodes\\n/// there are, where a valid opcode is one with a corresponding valid function\\n/// pointer in the array returned by `fnPtrs`. If this is not set correctly\\n/// then an attacker may specify an opcode that points to data beyond the valid\\n/// fnPtrs, which has undefined and therefore possibly catastrophic behaviour\\n/// for the implementing contract, up to and including total funds loss.\\nstruct Bounds {\\n    uint256 entrypoint;\\n    uint256 minFinalStackIndex;\\n    uint256 stackIndex;\\n    uint256 stackLength;\\n    uint256 argumentsLength;\\n    uint256 storageLength;\\n    uint256 opcodesLength;\\n}\\n\\nuint256 constant MAX_STACK_LENGTH = type(uint8).max;\\n\\ncontract VMStateBuilder {\\n    using Math for uint256;\\n\\n    address private immutable _stackPopsFnPtrs;\\n    address private immutable _stackPushesFnPtrs;\\n    mapping(address => address) private ptrCache;\\n\\n    constructor() {\\n        _stackPopsFnPtrs = SSTORE2.write(stackPopsFnPtrs());\\n        _stackPushesFnPtrs = SSTORE2.write(stackPushesFnPtrs());\\n    }\\n\\n    function _packedFnPtrs(address vm_) private returns (bytes memory) {\\n        unchecked {\\n            bytes memory packedPtrs_ = SSTORE2.read(ptrCache[vm_]);\\n            if (packedPtrs_.length == 0) {\\n                ptrCache[vm_] = SSTORE2.write(packFnPtrs(RainVM(vm_).fnPtrs()));\\n                return _packedFnPtrs(vm_);\\n            }\\n            return packedPtrs_;\\n        }\\n    }\\n\\n    /// Builds a new `State` bytes from `StateConfig`.\\n    /// Empty stack and arguments with stack index 0.\\n    /// @param config_ State config to build the new `State`.\\n    function buildState(\\n        address vm_,\\n        StateConfig memory config_,\\n        Bounds[] memory boundss_\\n    ) external returns (bytes memory) {\\n        unchecked {\\n            bytes memory packedFnPtrs_ = _packedFnPtrs(vm_);\\n            uint256 storageLength_ = RainVM(vm_).storageOpcodesRange().length;\\n            uint256 argumentsLength_ = 0;\\n            uint256 stackLength_ = 0;\\n\\n            for (uint256 b_ = 0; b_ < boundss_.length; b_++) {\\n                boundss_[b_].storageLength = storageLength_;\\n\\n                // Opcodes are 1 byte and fnPtrs are 2 bytes so we halve the\\n                // length to get the valid opcodes length.\\n                boundss_[b_].opcodesLength = packedFnPtrs_.length / 2;\\n                ensureIntegrity(config_, boundss_[b_]);\\n                argumentsLength_ = argumentsLength_.max(\\n                    boundss_[b_].argumentsLength\\n                );\\n                stackLength_ = stackLength_.max(boundss_[b_].stackLength);\\n                // Stack needs to be high enough to read from after eval.\\n                require(\\n                    boundss_[b_].stackIndex >= boundss_[b_].minFinalStackIndex,\\n                    \\\"FINAL_STACK_INDEX\\\"\\n                );\\n            }\\n\\n            // build a new constants array with space for the arguments.\\n            uint256[] memory constants_ = new uint256[](\\n                config_.constants.length + argumentsLength_\\n            );\\n            for (uint256 i_ = 0; i_ < config_.constants.length; i_++) {\\n                constants_[i_] = config_.constants[i_];\\n            }\\n\\n            bytes[] memory ptrSources_ = new bytes[](config_.sources.length);\\n            for (uint256 i_ = 0; i_ < config_.sources.length; i_++) {\\n                ptrSources_[i_] = ptrSource(packedFnPtrs_, config_.sources[i_]);\\n            }\\n\\n            return\\n                LibState.toBytesPacked(\\n                    State(\\n                        0,\\n                        new uint256[](stackLength_),\\n                        ptrSources_,\\n                        constants_,\\n                        config_.constants.length\\n                    )\\n                );\\n        }\\n    }\\n\\n    function ptrSource(bytes memory packedFnPtrs_, bytes memory source_)\\n        public\\n        pure\\n        returns (bytes memory)\\n    {\\n        unchecked {\\n            uint256 sourceLen_ = source_.length;\\n            require(sourceLen_ % 2 == 0, \\\"ODD_SOURCE_LENGTH\\\");\\n\\n            bytes memory ptrSource_ = new bytes((sourceLen_ * 3) / 2);\\n\\n            uint256 rainVMOpsLength_ = RAIN_VM_OPS_LENGTH;\\n            assembly {\\n                let start_ := 1\\n                let end_ := add(sourceLen_, 1)\\n                for {\\n                    let i_ := start_\\n                    let o_ := 0\\n                } lt(i_, end_) {\\n                    i_ := add(i_, 1)\\n                } {\\n                    let op_ := byte(31, mload(add(source_, i_)))\\n                    // is opcode\\n                    if mod(i_, 2) {\\n                        // core ops simply zero pad.\\n                        if lt(op_, rainVMOpsLength_) {\\n                            o_ := add(o_, 1)\\n                            mstore8(add(ptrSource_, add(0x20, o_)), op_)\\n                        }\\n                        if iszero(lt(op_, rainVMOpsLength_)) {\\n                            let fn_ := mload(\\n                                add(packedFnPtrs_, add(0x2, mul(op_, 0x2)))\\n                            )\\n                            mstore8(\\n                                add(ptrSource_, add(0x20, o_)),\\n                                byte(30, fn_)\\n                            )\\n                            o_ := add(o_, 1)\\n                            mstore8(\\n                                add(ptrSource_, add(0x20, o_)),\\n                                byte(31, fn_)\\n                            )\\n                        }\\n                    }\\n                    // is operand\\n                    if iszero(mod(i_, 2)) {\\n                        mstore8(add(ptrSource_, add(0x20, o_)), op_)\\n                    }\\n                    o_ := add(o_, 1)\\n                }\\n            }\\n            return ptrSource_;\\n        }\\n    }\\n\\n    function packFnPtrs(bytes memory fnPtrs_)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        unchecked {\\n            require(fnPtrs_.length % 0x20 == 0, \\\"BAD_FN_PTRS_LENGTH\\\");\\n            bytes memory fnPtrsPacked_ = new bytes(fnPtrs_.length / 0x10);\\n            assembly {\\n                for {\\n                    let i_ := 0\\n                    let o_ := 0x02\\n                } lt(i_, mload(fnPtrs_)) {\\n                    i_ := add(i_, 0x20)\\n                    o_ := add(o_, 0x02)\\n                } {\\n                    let location_ := add(fnPtrsPacked_, o_)\\n                    let old_ := mload(location_)\\n                    let new_ := or(old_, mload(add(fnPtrs_, add(0x20, i_))))\\n                    mstore(location_, new_)\\n                }\\n            }\\n            return fnPtrsPacked_;\\n        }\\n    }\\n\\n    function _ensureIntegrityZipmap(\\n        StateConfig memory stateConfig_,\\n        Bounds memory bounds_,\\n        uint256 operand_\\n    ) private view {\\n        unchecked {\\n            uint256 valLength_ = (operand_ >> 5) + 1;\\n            // read underflow here will show up as an OOB max later.\\n            bounds_.stackIndex -= valLength_;\\n            bounds_.stackLength = bounds_.stackLength.max(bounds_.stackIndex);\\n            bounds_.argumentsLength = bounds_.argumentsLength.max(valLength_);\\n            uint256 loopTimes_ = 1 << ((operand_ >> 3) & 0x03);\\n            uint256 outerEntrypoint_ = bounds_.entrypoint;\\n            uint256 innerEntrypoint_ = operand_ & 0x07;\\n            bounds_.entrypoint = innerEntrypoint_;\\n            for (uint256 n_ = 0; n_ < loopTimes_; n_++) {\\n                ensureIntegrity(stateConfig_, bounds_);\\n            }\\n            bounds_.entrypoint = outerEntrypoint_;\\n        }\\n    }\\n\\n    function ensureIntegrity(\\n        StateConfig memory stateConfig_,\\n        Bounds memory bounds_\\n    ) public view {\\n        unchecked {\\n            uint256 entrypoint_ = bounds_.entrypoint;\\n            require(stateConfig_.sources.length > entrypoint_, \\\"MIN_SOURCES\\\");\\n            bytes memory stackPopsFns_ = SSTORE2.read(_stackPopsFnPtrs);\\n            bytes memory stackPushesFns_ = SSTORE2.read(_stackPushesFnPtrs);\\n            uint256 i_ = 0;\\n            uint256 sourceLen_;\\n            uint256 opcode_;\\n            uint256 operand_;\\n            uint256 sourceLocation_;\\n\\n            assembly {\\n                sourceLocation_ := mload(\\n                    add(mload(stateConfig_), add(0x20, mul(entrypoint_, 0x20)))\\n                )\\n\\n                sourceLen_ := mload(sourceLocation_)\\n            }\\n\\n            while (i_ < sourceLen_) {\\n                assembly {\\n                    i_ := add(i_, 2)\\n                    let op_ := mload(add(sourceLocation_, i_))\\n                    opcode_ := byte(30, op_)\\n                    operand_ := byte(31, op_)\\n                }\\n\\n                // Additional integrity checks for core opcodes.\\n                if (opcode_ < RAIN_VM_OPS_LENGTH) {\\n                    if (opcode_ == OPCODE_CONSTANT) {\\n                        // trying to read past the end of the constants array.\\n                        // note that it is possible for a script to reach into\\n                        // arguments space after a zipmap has completed. While\\n                        // this is almost certainly a critical bug for the\\n                        // script it doesn't expose the ability to read past\\n                        // the constants array in memory so we allow it here.\\n                        require(\\n                            operand_ <\\n                                (bounds_.argumentsLength +\\n                                    stateConfig_.constants.length)\\n                        );\\n                        bounds_.stackIndex++;\\n                    } else if (opcode_ == OPCODE_STACK) {\\n                        // trying to read past the current stack top.\\n                        require(operand_ < bounds_.stackIndex);\\n                        bounds_.stackIndex++;\\n                    } else if (opcode_ == OPCODE_CONTEXT) {\\n                        // Note that context length check is handled at runtime\\n                        // because we don't know how long context should be at\\n                        // this point.\\n                        bounds_.stackIndex++;\\n                    } else if (opcode_ == OPCODE_STORAGE) {\\n                        // trying to read past allowed storage slots.\\n                        require(operand_ < bounds_.storageLength);\\n                        bounds_.stackIndex++;\\n                    }\\n                    if (opcode_ == OPCODE_ZIPMAP) {\\n                        _ensureIntegrityZipmap(stateConfig_, bounds_, operand_);\\n                    }\\n                } else {\\n                    // Opcodes can't exceed the bounds of valid fn pointers.\\n                    require(opcode_ < bounds_.opcodesLength, \\\"MAX_OPCODE\\\");\\n                    function(uint256) pure returns (uint256) popsFn_;\\n                    function(uint256) pure returns (uint256) pushesFn_;\\n                    assembly {\\n                        popsFn_ := mload(\\n                            add(stackPopsFns_, add(0x20, mul(opcode_, 0x20)))\\n                        )\\n                        pushesFn_ := mload(\\n                            add(stackPushesFns_, add(0x20, mul(opcode_, 0x20)))\\n                        )\\n                    }\\n\\n                    // This will catch popping/reading from underflowing the\\n                    // stack as it will show up as an overflow on the stack\\n                    // length below.\\n                    bounds_.stackIndex -= popsFn_(operand_);\\n                    bounds_.stackLength = bounds_.stackLength.max(\\n                        bounds_.stackIndex\\n                    );\\n\\n                    bounds_.stackIndex += pushesFn_(operand_);\\n                }\\n\\n                bounds_.stackLength = bounds_.stackLength.max(\\n                    bounds_.stackIndex\\n                );\\n            }\\n            // Both an overflow or underflow in uint256 space will show up as\\n            // an upper bound exceeding the uint8 space.\\n            require(bounds_.stackLength <= MAX_STACK_LENGTH, \\\"MAX_STACK\\\");\\n        }\\n    }\\n\\n    function stackPopsFnPtrs() public pure virtual returns (bytes memory) {}\\n\\n    function stackPushesFnPtrs() public pure virtual returns (bytes memory) {}\\n}\\n\",\"keccak256\":\"0xd60dd0ce86eb167d04e2514130fc53cb1d0911d15bdbf29fd82be84b29320f72\",\"license\":\"CAL\"},\"contracts/vm/ops/AllStandardOps.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../RainVM.sol\\\";\\nimport \\\"./erc20/OpERC20BalanceOf.sol\\\";\\nimport \\\"./erc20/OpERC20TotalSupply.sol\\\";\\nimport \\\"./erc20/snapshot/OpERC20SnapshotBalanceOfAt.sol\\\";\\nimport \\\"./erc20/snapshot/OpERC20SnapshotTotalSupplyAt.sol\\\";\\nimport \\\"./erc721/OpERC721BalanceOf.sol\\\";\\nimport \\\"./erc721/OpERC721OwnerOf.sol\\\";\\nimport \\\"./erc1155/OpERC1155BalanceOf.sol\\\";\\nimport \\\"./erc1155/OpERC1155BalanceOfBatch.sol\\\";\\nimport \\\"./evm/OpBlockNumber.sol\\\";\\nimport \\\"./evm/OpCaller.sol\\\";\\nimport \\\"./evm/OpThisAddress.sol\\\";\\nimport \\\"./evm/OpTimestamp.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScale18.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScale18Div.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScale18Mul.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScaleBy.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScaleN.sol\\\";\\nimport \\\"./math/logic/OpAny.sol\\\";\\nimport \\\"./math/logic/OpEagerIf.sol\\\";\\nimport \\\"./math/logic/OpEqualTo.sol\\\";\\nimport \\\"./math/logic/OpEvery.sol\\\";\\nimport \\\"./math/logic/OpGreaterThan.sol\\\";\\nimport \\\"./math/logic/OpIsZero.sol\\\";\\nimport \\\"./math/logic/OpLessThan.sol\\\";\\nimport \\\"./math/saturating/OpSaturatingAdd.sol\\\";\\nimport \\\"./math/saturating/OpSaturatingMul.sol\\\";\\nimport \\\"./math/saturating/OpSaturatingSub.sol\\\";\\nimport \\\"./math/OpAdd.sol\\\";\\nimport \\\"./math/OpDiv.sol\\\";\\nimport \\\"./math/OpExp.sol\\\";\\nimport \\\"./math/OpMax.sol\\\";\\nimport \\\"./math/OpMin.sol\\\";\\nimport \\\"./math/OpMod.sol\\\";\\nimport \\\"./math/OpMul.sol\\\";\\nimport \\\"./math/OpSub.sol\\\";\\nimport \\\"./tier/OpITierV2Report.sol\\\";\\nimport \\\"./tier/OpITierV2ReportTimeForTier.sol\\\";\\nimport \\\"./tier/OpSaturatingDiff.sol\\\";\\nimport \\\"./tier/OpSelectLte.sol\\\";\\nimport \\\"./tier/OpUpdateTimesForTierRange.sol\\\";\\n\\nuint256 constant ALL_STANDARD_OPS_LENGTH = RAIN_VM_OPS_LENGTH + 40;\\n\\n/// @title AllStandardOps\\n/// @notice RainVM opcode pack to expose all other packs.\\nlibrary AllStandardOps {\\n    function zero(uint256) internal pure returns (uint256) {\\n        return 0;\\n    }\\n\\n    function one(uint256) internal pure returns (uint256) {\\n        return 1;\\n    }\\n\\n    function two(uint256) internal pure returns (uint256) {\\n        return 2;\\n    }\\n\\n    function three(uint256) internal pure returns (uint256) {\\n        return 3;\\n    }\\n\\n    function nonzeroOperandN(uint256 operand_) internal pure returns (uint256) {\\n        require(operand_ > 0, \\\"0_OPERAND\\\");\\n        return operand_;\\n    }\\n\\n    function stackPopsFnPtrs() internal pure returns (bytes memory) {\\n        unchecked {\\n            uint256 lenBytes_ = ALL_STANDARD_OPS_LENGTH * 0x20;\\n            function(uint256) pure returns (uint256) zeroFn_;\\n            assembly {\\n                // using zero bytes in the fnPtrs array may save gas in certain\\n                // contexts.\\n                zeroFn_ := 0\\n            }\\n            function(uint256) pure returns (uint256)[ALL_STANDARD_OPS_LENGTH +\\n                1]\\n                memory fns_ = [\\n                    // will be overriden with length\\n                    zeroFn_,\\n                    // constant placeholder\\n                    zeroFn_,\\n                    // stack placeholder\\n                    zeroFn_,\\n                    // context placeholder\\n                    zeroFn_,\\n                    // storage placeholder\\n                    zeroFn_,\\n                    // zipmap placeholder\\n                    zeroFn_,\\n                    // debug placeholder\\n                    zeroFn_,\\n                    // erc20 balance of\\n                    two,\\n                    // erc20 total supply\\n                    one,\\n                    // erc20 snapshot balance of at\\n                    three,\\n                    // erc20 snapshot total supply at\\n                    two,\\n                    // erc721 balance of\\n                    two,\\n                    // erc721 owner of\\n                    two,\\n                    // erc1155 balance of\\n                    three,\\n                    // erc1155 balance of batch\\n                    OpERC1155BalanceOfBatch.stackPops,\\n                    // block number\\n                    zero,\\n                    // caller\\n                    zero,\\n                    // this address\\n                    zero,\\n                    // timestamp\\n                    zero,\\n                    // scale18\\n                    one,\\n                    // scale18 div\\n                    two,\\n                    // scale18 mul\\n                    two,\\n                    // scaleBy\\n                    one,\\n                    // scaleN\\n                    one,\\n                    // any\\n                    nonzeroOperandN,\\n                    // eager if\\n                    three,\\n                    // equal to\\n                    two,\\n                    // every\\n                    nonzeroOperandN,\\n                    // greater than\\n                    two,\\n                    // iszero\\n                    one,\\n                    // less than\\n                    two,\\n                    // saturating add\\n                    nonzeroOperandN,\\n                    // saturating mul\\n                    nonzeroOperandN,\\n                    // saturating sub\\n                    nonzeroOperandN,\\n                    // add\\n                    nonzeroOperandN,\\n                    // div\\n                    nonzeroOperandN,\\n                    // exp\\n                    nonzeroOperandN,\\n                    // max\\n                    nonzeroOperandN,\\n                    // min\\n                    nonzeroOperandN,\\n                    // mod\\n                    nonzeroOperandN,\\n                    // mul\\n                    nonzeroOperandN,\\n                    // sub\\n                    nonzeroOperandN,\\n                    // tier report\\n                    OpITierV2Report.stackPops,\\n                    // tier report time for tier\\n                    OpITierV2ReportTimeForTier.stackPops,\\n                    // tier saturating diff\\n                    two,\\n                    // select lte\\n                    OpSelectLte.stackPops,\\n                    // update times for tier range\\n                    two\\n                ];\\n            bytes memory ret_;\\n            assembly {\\n                mstore(fns_, lenBytes_)\\n                ret_ := fns_\\n            }\\n            return ret_;\\n        }\\n    }\\n\\n    function stackPushesFnPtrs() internal pure returns (bytes memory) {\\n        unchecked {\\n            uint256 lenBytes_ = ALL_STANDARD_OPS_LENGTH * 0x20;\\n            function(uint256) pure returns (uint256) zeroFn_;\\n            assembly {\\n                // using zero bytes in the fnPtrs array may save gas in certain\\n                // contexts.\\n                zeroFn_ := 0\\n            }\\n            function(uint256) pure returns (uint256)[ALL_STANDARD_OPS_LENGTH +\\n                1]\\n                memory fns_ = [\\n                    // will be overriden with length\\n                    zeroFn_,\\n                    // constant placeholder\\n                    zeroFn_,\\n                    // stack placeholder\\n                    zeroFn_,\\n                    // context placeholder\\n                    zeroFn_,\\n                    // storage placeholder\\n                    zeroFn_,\\n                    // zipmap placeholder\\n                    zeroFn_,\\n                    // debug placeholder\\n                    zeroFn_,\\n                    // erc20 balance of\\n                    one,\\n                    // erc20 total supply\\n                    one,\\n                    // erc20 snapshot balance of at\\n                    one,\\n                    // erc20 snapshot total supply at\\n                    one,\\n                    // erc721 balance of\\n                    one,\\n                    // erc721 owner of\\n                    one,\\n                    // erc1155 balance of\\n                    one,\\n                    // erc1155 balance of batch\\n                    nonzeroOperandN,\\n                    // block number\\n                    one,\\n                    // caller\\n                    one,\\n                    // this address\\n                    one,\\n                    // timestamp\\n                    one,\\n                    // scale18\\n                    one,\\n                    // scale18 div\\n                    one,\\n                    // scale18 mul\\n                    one,\\n                    // scaleBy\\n                    one,\\n                    // scaleN\\n                    one,\\n                    // any\\n                    one,\\n                    // eager if\\n                    one,\\n                    // equal to\\n                    one,\\n                    // every\\n                    one,\\n                    // greater than\\n                    one,\\n                    // iszero\\n                    one,\\n                    // less than\\n                    one,\\n                    // saturating add\\n                    one,\\n                    // saturating mul\\n                    one,\\n                    // saturating sub\\n                    one,\\n                    // add\\n                    one,\\n                    // div\\n                    one,\\n                    // exp\\n                    one,\\n                    // max\\n                    one,\\n                    // min\\n                    one,\\n                    // mod\\n                    one,\\n                    // mul\\n                    one,\\n                    // sub\\n                    one,\\n                    // tier report\\n                    one,\\n                    // tier report time for tier\\n                    one,\\n                    // tier saturating diff\\n                    one,\\n                    // select lte\\n                    one,\\n                    // update times for tier range\\n                    one\\n                ];\\n            bytes memory ret_;\\n            assembly {\\n                mstore(fns_, lenBytes_)\\n                ret_ := fns_\\n            }\\n            return ret_;\\n        }\\n    }\\n\\n    function fnPtrs() internal pure returns (bytes memory) {\\n        unchecked {\\n            uint256 lenBytes_ = ALL_STANDARD_OPS_LENGTH * 0x20;\\n            function(uint256, uint256) view returns (uint256) zeroFn_;\\n            assembly {\\n                // using zero bytes in the fnPtrs array may save gas in certain\\n                // contexts.\\n                zeroFn_ := 0\\n            }\\n            function(uint256, uint256)\\n                view\\n                returns (uint256)[ALL_STANDARD_OPS_LENGTH + 1]\\n                memory fns_ = [\\n                    // will be overridden with length\\n                    zeroFn_,\\n                    // placeholders for core ops\\n                    // constant\\n                    zeroFn_,\\n                    // stack\\n                    zeroFn_,\\n                    // context\\n                    zeroFn_,\\n                    // storage\\n                    zeroFn_,\\n                    // zipmap\\n                    zeroFn_,\\n                    // debug\\n                    zeroFn_,\\n                    // dispatchable ops\\n                    OpERC20BalanceOf.balanceOf,\\n                    OpERC20TotalSupply.totalSupply,\\n                    OpERC20SnapshotBalanceOfAt.balanceOfAt,\\n                    OpERC20SnapshotTotalSupplyAt.totalSupplyAt,\\n                    OpERC721BalanceOf.balanceOf,\\n                    OpERC721OwnerOf.ownerOf,\\n                    OpERC1155BalanceOf.balanceOf,\\n                    OpERC1155BalanceOfBatch.balanceOfBatch,\\n                    OpBlockNumber.blockNumber,\\n                    OpCaller.caller,\\n                    OpThisAddress.thisAddress,\\n                    OpTimestamp.timestamp,\\n                    OpFixedPointScale18.scale18,\\n                    OpFixedPointScale18Div.scale18Div,\\n                    OpFixedPointScale18Mul.scale18Mul,\\n                    OpFixedPointScaleBy.scaleBy,\\n                    OpFixedPointScaleN.scaleN,\\n                    OpAny.any,\\n                    OpEagerIf.eagerIf,\\n                    OpEqualTo.equalTo,\\n                    OpEvery.every,\\n                    OpGreaterThan.greaterThan,\\n                    OpIsZero.isZero,\\n                    OpLessThan.lessThan,\\n                    OpSaturatingAdd.saturatingAdd,\\n                    OpSaturatingMul.saturatingMul,\\n                    OpSaturatingSub.saturatingSub,\\n                    OpAdd.add,\\n                    OpDiv.div,\\n                    OpExp.exp,\\n                    OpMax.max,\\n                    OpMin.min,\\n                    OpMod.mod,\\n                    OpMul.mul,\\n                    OpSub.sub,\\n                    OpITierV2Report.report,\\n                    OpITierV2ReportTimeForTier.reportTimeForTier,\\n                    OpSaturatingDiff.saturatingDiff,\\n                    OpSelectLte.selectLte,\\n                    OpUpdateTimesForTierRange.updateTimesForTierRange\\n                ];\\n            bytes memory ret_;\\n            assembly {\\n                mstore(fns_, lenBytes_)\\n                ret_ := fns_\\n            }\\n            return ret_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc3b7cd0d079e0d7c530ff2c7af8156763644e3e20103a4025161ede57ad0ab1e\",\"license\":\"CAL\"},\"contracts/vm/ops/erc1155/OpERC1155BalanceOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\n/// @title OpERC1155BalanceOf\\n/// @notice Opcode for getting the current erc1155 balance of an account.\\nlibrary OpERC1155BalanceOf {\\n    // Stack the return of `balanceOf`.\\n    function balanceOf(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 token_;\\n        uint256 account_;\\n        uint256 id_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, 0x60)\\n            stackTopLocation_ := add(location_, 0x20)\\n            token_ := mload(location_)\\n            account_ := mload(stackTopLocation_)\\n            id_ := mload(add(location_, 0x40))\\n        }\\n        uint256 result_ = IERC1155(address(uint160(token_))).balanceOf(\\n            address(uint160(account_)),\\n            id_\\n        );\\n        assembly {\\n            mstore(location_, result_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x501ddca2cd98e596eaa6f85c0c76881250c9092beb2eaff40193786873b6f02b\",\"license\":\"CAL\"},\"contracts/vm/ops/erc1155/OpERC1155BalanceOfBatch.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\n/// @title OpERC1155BalanceOfBatch\\n/// @notice Opcode for getting the current erc1155 balance of an accounts batch.\\nlibrary OpERC1155BalanceOfBatch {\\n    function stackPops(uint256 operand_) internal pure returns (uint256) {\\n        unchecked {\\n            require(operand_ > 0, \\\"0_OPERAND\\\");\\n            return (operand_ * 2) + 1;\\n        }\\n    }\\n\\n    // Stack the return of `balanceOfBatch`.\\n    // Operand will be the length\\n    function balanceOfBatch(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        address[] memory addresses_ = new address[](operand_);\\n        uint256[] memory ids_ = new uint256[](operand_);\\n        uint256 token_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, add(0x20, mul(operand_, 0x40)))\\n            token_ := mload(location_)\\n            let cursor_ := add(location_, 0x20)\\n\\n            for {\\n                let maxCursor_ := add(cursor_, mul(operand_, 0x20))\\n                let addressesCursor_ := add(addresses_, 0x20)\\n            } lt(cursor_, maxCursor_) {\\n                cursor_ := add(cursor_, 0x20)\\n                addressesCursor_ := add(addressesCursor_, 0x20)\\n            } {\\n                mstore(addressesCursor_, mload(cursor_))\\n            }\\n\\n            for {\\n                let maxCursor_ := add(cursor_, mul(operand_, 0x20))\\n                let idsCursor_ := add(ids_, 0x20)\\n            } lt(cursor_, maxCursor_) {\\n                cursor_ := add(cursor_, 0x20)\\n                idsCursor_ := add(idsCursor_, 0x20)\\n            } {\\n                mstore(idsCursor_, mload(cursor_))\\n            }\\n        }\\n        uint256[] memory balances_ = IERC1155(address(uint160(token_)))\\n            .balanceOfBatch(addresses_, ids_);\\n\\n        assembly {\\n            let cursor_ := location_\\n            for {\\n                let balancesCursor_ := add(balances_, 0x20)\\n                let balancesCursorMax_ := add(\\n                    balancesCursor_,\\n                    mul(operand_, 0x20)\\n                )\\n            } lt(balancesCursor_, balancesCursorMax_) {\\n                cursor_ := add(cursor_, 0x20)\\n                balancesCursor_ := add(balancesCursor_, 0x20)\\n            } {\\n                mstore(cursor_, mload(balancesCursor_))\\n            }\\n            stackTopLocation_ := cursor_\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xedb0ce4945d3798ac92ea91daffefeee7e48e469a2750ffbc54f31022c54c950\",\"license\":\"CAL\"},\"contracts/vm/ops/erc20/OpERC20BalanceOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title OpERC20BalanceOf\\n/// @notice Opcode for ERC20 `balanceOf`.\\nlibrary OpERC20BalanceOf {\\n    /// Stack `balanceOf`.\\n    function balanceOf(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 token_;\\n        uint256 account_;\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            token_ := mload(location_)\\n            account_ := mload(stackTopLocation_)\\n        }\\n        uint256 balance_ = IERC20(address(uint160(token_))).balanceOf(\\n            address(uint160(account_))\\n        );\\n        assembly {\\n            mstore(location_, balance_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xc0100ed667adafe60d73f92acb3fabfa23ca400c15f1d1fbb6e680a9ff42206f\",\"license\":\"CAL\"},\"contracts/vm/ops/erc20/OpERC20TotalSupply.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title OpERC20TotalSupply\\n/// @notice Opcode for ERC20 `totalSupply`.\\nlibrary OpERC20TotalSupply {\\n    // Stack the return of `totalSupply`.\\n    function totalSupply(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 token_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, 0x20)\\n            token_ := mload(location_)\\n        }\\n        uint256 supply_ = IERC20(address(uint160(token_))).totalSupply();\\n        assembly {\\n            mstore(location_, supply_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x136befcb6391498835a5f63016b5fa5f0a714902b0887ce806ac60dea6f17cf7\",\"license\":\"CAL\"},\"contracts/vm/ops/erc20/snapshot/OpERC20SnapshotBalanceOfAt.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\\\";\\n\\n/// @title OpERC20SnapshotBalanceOfAt\\n/// @notice Opcode for Open Zeppelin `ERC20Snapshot.balanceOfAt`.\\n/// https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20Snapshot\\nlibrary OpERC20SnapshotBalanceOfAt {\\n    /// Stack `balanceOfAt`.\\n    function balanceOfAt(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 token_;\\n        uint256 account_;\\n        uint256 snapshotId_;\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x40)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            token_ := mload(location_)\\n            account_ := mload(stackTopLocation_)\\n            snapshotId_ := mload(add(stackTopLocation_, 0x20))\\n        }\\n        uint256 balance_ = ERC20Snapshot(address(uint160(token_))).balanceOfAt(\\n            address(uint160(account_)),\\n            snapshotId_\\n        );\\n        assembly {\\n            mstore(location_, balance_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x8d62ba45986e5585ef20e6526f44132a28b48dc927c1479f6befc331ec582b5b\",\"license\":\"CAL\"},\"contracts/vm/ops/erc20/snapshot/OpERC20SnapshotTotalSupplyAt.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\\\";\\n\\n/// @title OpERC20SnapshotTotalSupplyAt\\n/// @notice Opcode for Open Zeppelin `ERC20Snapshot.totalSupplyAt`.\\n/// https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20Snapshot\\nlibrary OpERC20SnapshotTotalSupplyAt {\\n    /// Stack `totalSupplyAt`.\\n    function totalSupplyAt(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 token_;\\n        uint256 snapshotId_;\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            token_ := mload(location_)\\n            snapshotId_ := mload(stackTopLocation_)\\n        }\\n        uint256 totalSupply_ = ERC20Snapshot(address(uint160(token_)))\\n            .totalSupplyAt(snapshotId_);\\n        assembly {\\n            mstore(location_, totalSupply_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x8528b1dd51723768595d35537141a1997cb3b322aa0f70d5dc736e8014142428\",\"license\":\"CAL\"},\"contracts/vm/ops/erc721/OpERC721BalanceOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n/// @title OpERC721BalanceOf\\n/// @notice Opcode for getting the current erc721 balance of an account.\\nlibrary OpERC721BalanceOf {\\n    // Stack the return of `balanceOf`.\\n    function balanceOf(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 token_;\\n        uint256 account_;\\n\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            token_ := mload(location_)\\n            account_ := mload(stackTopLocation_)\\n        }\\n        uint256 balance_ = IERC721(address(uint160(token_))).balanceOf(\\n            address(uint160(account_))\\n        );\\n\\n        assembly {\\n            mstore(location_, balance_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xeded12fa887be8e6d1358823d59078bfe55ff845feff02fe835f05dcb561c6a5\",\"license\":\"CAL\"},\"contracts/vm/ops/erc721/OpERC721OwnerOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n/// @title OpERC721OwnerOf\\n/// @notice Opcode for getting the current erc721 owner of an account.\\nlibrary OpERC721OwnerOf {\\n    // Stack the return of `ownerOf`.\\n    function ownerOf(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 token_;\\n        uint256 id_;\\n\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            token_ := mload(location_)\\n            id_ := mload(stackTopLocation_)\\n        }\\n        uint256 owner_ = uint256(\\n            uint160(IERC721(address(uint160(token_))).ownerOf(id_))\\n        );\\n        assembly {\\n            mstore(location_, owner_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xf1401b6f6cd8e5d861e75c9dc75e82ac7c9453f5e054422b7bef99e16b43b41e\",\"license\":\"CAL\"},\"contracts/vm/ops/evm/OpBlockNumber.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpBlockNumber\\n/// @notice Opcode for getting the current block number.\\nlibrary OpBlockNumber {\\n    function blockNumber(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        assembly {\\n            mstore(stackTopLocation_, number())\\n            stackTopLocation_ := add(stackTopLocation_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x838009d0b58ca254de3451dba393ba9d4da35179da51296dc631c72dfb8ce646\",\"license\":\"CAL\"},\"contracts/vm/ops/evm/OpCaller.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpCaller\\n/// @notice Opcode for getting the current caller.\\nlibrary OpCaller {\\n    function caller(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        assembly {\\n            mstore(stackTopLocation_, caller())\\n            stackTopLocation_ := add(stackTopLocation_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x60e8410815291d4e6e5d17077156ee4f7a7651b58e7993cc88e8f46432ac1380\",\"license\":\"CAL\"},\"contracts/vm/ops/evm/OpThisAddress.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpThisAddress\\n/// @notice Opcode for getting the address of the current contract.\\nlibrary OpThisAddress {\\n    function thisAddress(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        assembly {\\n            mstore(stackTopLocation_, address())\\n            stackTopLocation_ := add(stackTopLocation_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xd9599f95ad49825fcf48a91a248bacbdc9c58e831cb83228d6d2b5016969b411\",\"license\":\"CAL\"},\"contracts/vm/ops/evm/OpTimestamp.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpTimestamp\\n/// @notice Opcode for getting the current timestamp.\\nlibrary OpTimestamp {\\n    function timestamp(uint256, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        assembly {\\n            mstore(stackTopLocation_, timestamp())\\n            stackTopLocation_ := add(stackTopLocation_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xd8e1d955accbaf86289e7706550ee751ed8e0cf60205c81821a0bbd2eb30ceb5\",\"license\":\"CAL\"},\"contracts/vm/ops/math/OpAdd.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpAdd\\n/// @notice Opcode for adding N numbers.\\nlibrary OpAdd {\\n    function add(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            let accumulator_ := mload(location_)\\n            let intermediate_\\n            for {\\n                let cursor_ := add(location_, 0x20)\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                intermediate_ := add(accumulator_, mload(cursor_))\\n                // Adapted from Open Zeppelin safe math.\\n                if lt(intermediate_, accumulator_) {\\n                    revert(0, 0)\\n                }\\n                accumulator_ := intermediate_\\n            }\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x1a3e8c6f7a4b8e9001b3f9566968887ba0215b7a14638bd3f1a64b3bf0be1e69\",\"license\":\"CAL\"},\"contracts/vm/ops/math/OpDiv.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpDiv\\n/// @notice Opcode for dividing N numbers.\\nlibrary OpDiv {\\n    function div(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            let accumulator_ := mload(location_)\\n            let item_\\n            for {\\n                let cursor_ := add(location_, 0x20)\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                item_ := mload(cursor_)\\n                // Adapted from Open Zeppelin safe math.\\n                if iszero(item_) {\\n                    revert(0, 0)\\n                }\\n                accumulator_ := div(accumulator_, item_)\\n            }\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x7f9c5376a6d9820d20029928063a3c4d9ab24c021c8bd9bdeb964d6194a7316b\",\"license\":\"CAL\"},\"contracts/vm/ops/math/OpExp.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpExp\\n/// @notice Opcode to exponentiate N numbers.\\nlibrary OpExp {\\n    function exp(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 accumulator_;\\n        uint256 cursor_;\\n        uint256 item_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            accumulator_ := mload(location_)\\n            cursor_ := add(location_, 0x20)\\n        }\\n        while (cursor_ < stackTopLocation_) {\\n            assembly {\\n                item_ := mload(cursor_)\\n                cursor_ := add(cursor_, 0x20)\\n            }\\n            // This is NOT in assembly so that we get overflow safety.\\n            accumulator_ = accumulator_**item_;\\n        }\\n        assembly {\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x31be9d92aa9b7cd0db1a4780449ae801f4c7837df4f30a12f91615df257bf853\",\"license\":\"CAL\"},\"contracts/vm/ops/math/OpMax.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpMax\\n/// @notice Opcode to stack the maximum of N numbers.\\nlibrary OpMax {\\n    function max(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            let accumulator_ := mload(location_)\\n            let cursor_ := add(location_, 0x20)\\n            let item_\\n            for {\\n                cursor_ := add(location_, 0x20)\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                item_ := mload(cursor_)\\n                if gt(item_, accumulator_) {\\n                    accumulator_ := item_\\n                }\\n            }\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x3bdac5580e6117380789512b72b18cd339c2c80b703706287c8d6956a19a823b\",\"license\":\"CAL\"},\"contracts/vm/ops/math/OpMin.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpMin\\n/// @notice Opcode to stack the minimum of N numbers.\\nlibrary OpMin {\\n    function min(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            let accumulator_ := mload(location_)\\n            let cursor_ := add(location_, 0x20)\\n            let item_\\n            for {\\n                cursor_ := add(location_, 0x20)\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                item_ := mload(cursor_)\\n                if lt(item_, accumulator_) {\\n                    accumulator_ := item_\\n                }\\n            }\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x8fb9b180e85064de4f80619c105e4b611a0a649fb0f51ba07af23a3f7a9e14ce\",\"license\":\"CAL\"},\"contracts/vm/ops/math/OpMod.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpMod\\n/// @notice Opcode to mod N numbers.\\nlibrary OpMod {\\n    function mod(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            let accumulator_ := mload(location_)\\n            let item_\\n            for {\\n                let cursor_ := add(location_, 0x20)\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                item_ := mload(cursor_)\\n                // Adapted from Open Zeppelin safe math.\\n                if iszero(item_) {\\n                    revert(0, 0)\\n                }\\n                accumulator_ := mod(accumulator_, item_)\\n            }\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x9b49b493b5cd292bca88c381527b6ef958dd25a269862f27e5cb71bdf25998a1\",\"license\":\"CAL\"},\"contracts/vm/ops/math/OpMul.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpMul\\n/// @notice Opcode for multiplying N numbers.\\nlibrary OpMul {\\n    function mul(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            let accumulator_ := mload(location_)\\n            let item_\\n            let intermediate_\\n            for {\\n                let cursor_ := add(location_, 0x20)\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                if gt(accumulator_, 0) {\\n                    item_ := mload(cursor_)\\n                    intermediate_ := mul(accumulator_, item_)\\n                    // Adapted from Open Zeppelin safe math.\\n                    if iszero(eq(div(intermediate_, accumulator_), item_)) {\\n                        revert(0, 0)\\n                    }\\n                    accumulator_ := intermediate_\\n                }\\n            }\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xabf7186f7ced156af756cb4dd1628d65bb6f309b91a16b17f36a525ecff04f18\",\"license\":\"CAL\"},\"contracts/vm/ops/math/OpSub.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpSub\\n/// @notice Opcode for subtracting N numbers.\\nlibrary OpSub {\\n    function sub(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            let accumulator_ := mload(location_)\\n            let intermediate_\\n            for {\\n                let cursor_ := add(location_, 0x20)\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                intermediate_ := sub(accumulator_, mload(cursor_))\\n                // Adapted from Open Zeppelin safe math.\\n                if gt(intermediate_, accumulator_) {\\n                    revert(0, 0)\\n                }\\n                accumulator_ := intermediate_\\n            }\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x36065096154959455e85ac7fb43012d6c8ce0f179e6ad3155bf3953c7863d889\",\"license\":\"CAL\"},\"contracts/vm/ops/math/fixedPoint/OpFixedPointScale18.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\n\\n/// @title OpFixedPointScale18\\n/// @notice Opcode for scaling a number to 18 fixed point.\\nlibrary OpFixedPointScale18 {\\n    using FixedPointMath for uint256;\\n\\n    function scale18(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 a_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        uint256 b_ = a_.scale18(operand_);\\n        assembly {\\n            mstore(location_, b_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xe4e12a77b98ad57b090d62c02f232dc0a5797dc8b4470046f4b67e631ca14b58\",\"license\":\"CAL\"},\"contracts/vm/ops/math/fixedPoint/OpFixedPointScale18Div.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\n\\n/// @title OpFixedPointScale18Div\\n/// @notice Opcode for performing scale 18 fixed point division.\\nlibrary OpFixedPointScale18Div {\\n    using FixedPointMath for uint256;\\n\\n    function scale18Div(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 a_;\\n        uint256 b_;\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTopLocation_)\\n        }\\n        uint256 c_ = a_.scale18(operand_).fixedPointDiv(b_);\\n        assembly {\\n            mstore(location_, c_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x38cf55ac6dd8798ca462a102cdab3def122d9f9a2dfe74f49ec8d88a8ab785f1\",\"license\":\"CAL\"},\"contracts/vm/ops/math/fixedPoint/OpFixedPointScale18Mul.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\n\\n/// @title OpFixedPointScale18Mul\\n/// @notice Opcode for performing scale 18 fixed point multiplication.\\nlibrary OpFixedPointScale18Mul {\\n    using FixedPointMath for uint256;\\n\\n    function scale18Mul(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 a_;\\n        uint256 b_;\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTopLocation_)\\n        }\\n        uint256 c_ = a_.scale18(operand_).fixedPointMul(b_);\\n        assembly {\\n            mstore(location_, c_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x7c8149000e8ba541968b1822f1d716f4022a4ddc547ed7d661c6e06856f5f1c2\",\"license\":\"CAL\"},\"contracts/vm/ops/math/fixedPoint/OpFixedPointScaleBy.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\n\\n/// @title OpFixedPointScaleBy\\n/// @notice Opcode for scaling a number by some OOMs.\\nlibrary OpFixedPointScaleBy {\\n    using FixedPointMath for uint256;\\n\\n    function scaleBy(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 a_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        uint256 b_ = a_.scaleBy(int8(uint8(operand_)));\\n        assembly {\\n            mstore(location_, b_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x540c088d27152e8198f26e8ec00489562b7e77fe2d4e47b23ba701b31b16f5b4\",\"license\":\"CAL\"},\"contracts/vm/ops/math/fixedPoint/OpFixedPointScaleN.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\n\\n/// @title OpFixedPointScaleN\\n/// @notice Opcode for scaling a number to N fixed point.\\nlibrary OpFixedPointScaleN {\\n    using FixedPointMath for uint256;\\n\\n    function scaleN(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 a_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        uint256 b_ = a_.scaleN(operand_);\\n        assembly {\\n            mstore(location_, b_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xc6305a7fcc903e8f94c341d9c948469646e66b8e44ec74f7e15ce601944d49a7\",\"license\":\"CAL\"},\"contracts/vm/ops/math/logic/OpAny.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpAny\\n/// @notice Opcode to compare the top N stack values.\\nlibrary OpAny {\\n    // ANY\\n    // ANY is the first nonzero item, else 0.\\n    // operand_ id the length of items to check.\\n    function any(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            for {\\n                let cursor_ := location_\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                // If anything is NOT zero then ANY is a successful\\n                // check and can short-circuit.\\n                let item_ := mload(cursor_)\\n                if iszero(iszero(item_)) {\\n                    // Write the usable value to the top of the stack.\\n                    mstore(location_, item_)\\n                    break\\n                }\\n            }\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x0645452cc4b1fb710ad9457e11053c4b0e571d1a09925eafcb10675db4af490e\",\"license\":\"CAL\"},\"contracts/vm/ops/math/logic/OpEagerIf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpEagerIf\\n/// @notice Opcode for selecting a value based on a condition.\\nlibrary OpEagerIf {\\n    /// Eager because BOTH x_ and y_ must be eagerly evaluated\\n    /// before EAGER_IF will select one of them. If both x_ and y_\\n    /// are cheap (e.g. constant values) then this may also be the\\n    /// simplest and cheapest way to select one of them.\\n    function eagerIf(uint256, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, 0x60)\\n            stackTopLocation_ := add(location_, 0x20)\\n            // false => use second value\\n            // true => use first value\\n            mstore(\\n                location_,\\n                mload(\\n                    add(stackTopLocation_, mul(0x20, iszero(mload(location_))))\\n                )\\n            )\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xe969feef10104d8581d1eb951e6991a0dbed423f4e556c4815352f539c554458\",\"license\":\"CAL\"},\"contracts/vm/ops/math/logic/OpEqualTo.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpEqualTo\\n/// @notice Opcode to compare the top two stack values.\\nlibrary OpEqualTo {\\n    function equalTo(uint256, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            let location_ := sub(stackTopLocation_, 0x20)\\n            mstore(location_, eq(mload(location_), mload(stackTopLocation_)))\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x82f291dbd5982b4f42961720ff4e35ca3ee4a85f07ae501a2a31b08f96c89f4c\",\"license\":\"CAL\"},\"contracts/vm/ops/math/logic/OpEvery.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpEvery\\n/// @notice Opcode to compare the top N stack values.\\nlibrary OpEvery {\\n    // EVERY\\n    // EVERY is either the first item if every item is nonzero, else 0.\\n    // operand_ is the length of items to check.\\n    function every(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            for {\\n                let cursor_ := location_\\n            } lt(cursor_, stackTopLocation_) {\\n                cursor_ := add(cursor_, 0x20)\\n            } {\\n                // If anything is zero then EVERY is a failed check.\\n                if iszero(mload(cursor_)) {\\n                    mstore(location_, 0)\\n                    break\\n                }\\n            }\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x8a1c1c3f52e8cf9258a9ec041a67246e847316b8b5c6642e99f996f2a36eaee1\",\"license\":\"CAL\"},\"contracts/vm/ops/math/logic/OpGreaterThan.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpGreaterThan\\n/// @notice Opcode to compare the top two stack values.\\nlibrary OpGreaterThan {\\n    function greaterThan(uint256, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            let location_ := sub(stackTopLocation_, 0x20)\\n            mstore(location_, gt(mload(location_), mload(stackTopLocation_)))\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x70b58ac456f24f0047bdfeb1137f465dc3801ce6cba4006ab94bd3e1956105dd\",\"license\":\"CAL\"},\"contracts/vm/ops/math/logic/OpIsZero.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpIsZero\\n/// @notice Opcode for checking if the stack top is zero.\\nlibrary OpIsZero {\\n    function isZero(uint256, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            // The index doesn't change for iszero as there is\\n            // one input and output.\\n            let location_ := sub(stackTopLocation_, 0x20)\\n            mstore(location_, iszero(mload(location_)))\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x4fd2f15a887de7eb8355138abce5acb6d5d808ba78d360066ea29c8e743862d2\",\"license\":\"CAL\"},\"contracts/vm/ops/math/logic/OpLessThan.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\n/// @title OpLessThan\\n/// @notice Opcode to compare the top two stack values.\\nlibrary OpLessThan {\\n    function lessThan(uint256, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            let location_ := sub(stackTopLocation_, 0x20)\\n            mstore(location_, lt(mload(location_), mload(stackTopLocation_)))\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x0a7df0155ff30495631aa1e466832cc53d2dd2c0fe2600386c12a2602ad9febd\",\"license\":\"CAL\"},\"contracts/vm/ops/math/saturating/OpSaturatingAdd.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../../math/SaturatingMath.sol\\\";\\n\\n/// @title OpSaturatingAdd\\n/// @notice Opcode for adding N numbers with saturating addition.\\nlibrary OpSaturatingAdd {\\n    using SaturatingMath for uint256;\\n\\n    function saturatingAdd(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 accumulator_;\\n        uint256 cursor_;\\n        uint256 item_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            accumulator_ := mload(location_)\\n            cursor_ := add(location_, 0x20)\\n        }\\n        while (\\n            cursor_ < stackTopLocation_ && accumulator_ < type(uint256).max\\n        ) {\\n            assembly {\\n                item_ := mload(cursor_)\\n                cursor_ := add(cursor_, 0x20)\\n            }\\n            accumulator_ = accumulator_.saturatingAdd(item_);\\n        }\\n        assembly {\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xd16cccb69cccb50c837ade18cbebd82df3ac6352bedb354f5b0c722bfad07702\",\"license\":\"CAL\"},\"contracts/vm/ops/math/saturating/OpSaturatingMul.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../../math/SaturatingMath.sol\\\";\\n\\n/// @title OpSaturatingMul\\n/// @notice Opcode for multiplying N numbers with saturating multiplication.\\nlibrary OpSaturatingMul {\\n    using SaturatingMath for uint256;\\n\\n    function saturatingMul(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 accumulator_;\\n        uint256 cursor_;\\n        uint256 item_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            accumulator_ := mload(location_)\\n            cursor_ := add(location_, 0x20)\\n        }\\n        while (\\n            cursor_ < stackTopLocation_ && accumulator_ < type(uint256).max\\n        ) {\\n            assembly {\\n                item_ := mload(cursor_)\\n                cursor_ := add(cursor_, 0x20)\\n            }\\n            accumulator_ = accumulator_.saturatingMul(item_);\\n        }\\n        assembly {\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x2ad362e8b053e7a2023ddac1ae84c591d2cf944e5bc4891b7cffba6033c29f92\",\"license\":\"CAL\"},\"contracts/vm/ops/math/saturating/OpSaturatingSub.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../../math/SaturatingMath.sol\\\";\\n\\n/// @title OpSaturatingSub\\n/// @notice Opcode for subtracting N numbers with saturating subtraction.\\nlibrary OpSaturatingSub {\\n    using SaturatingMath for uint256;\\n\\n    function saturatingSub(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 accumulator_;\\n        uint256 cursor_;\\n        uint256 item_;\\n        assembly {\\n            location_ := sub(stackTopLocation_, mul(operand_, 0x20))\\n            accumulator_ := mload(location_)\\n            cursor_ := add(location_, 0x20)\\n        }\\n        while (cursor_ < stackTopLocation_ && 0 < accumulator_) {\\n            assembly {\\n                item_ := mload(cursor_)\\n                cursor_ := add(cursor_, 0x20)\\n            }\\n            accumulator_ = accumulator_.saturatingSub(item_);\\n        }\\n        assembly {\\n            mstore(location_, accumulator_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xcb9885a02bed8efab382734cdf2022424b208052e662881433b1cabf0b07b922\",\"license\":\"CAL\"},\"contracts/vm/ops/tier/OpITierV2Report.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../tier/ITierV2.sol\\\";\\n\\n/// @title OpITierV2Report\\n/// @notice Exposes `ITierV2.report` as an opcode.\\nlibrary OpITierV2Report {\\n    function stackPops(uint256 operand_)\\n        internal\\n        pure\\n        returns (uint256 reportsLength_)\\n    {\\n        unchecked {\\n            reportsLength_ = operand_ + 2;\\n        }\\n    }\\n\\n    // Stack the `report` returned by an `ITierV2` contract.\\n    function report(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 tierContract_;\\n        uint256 account_;\\n        uint256[] memory context_;\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, add(0x20, operand_))\\n            location_ := sub(stackTopLocation_, 0x20)\\n            tierContract_ := mload(location_)\\n            account_ := mload(stackTopLocation_)\\n            // we can reuse the account_ as the length for context_\\n            // and achieve a near zero-cost bytes array to send to `report`.\\n            mstore(stackTopLocation_, operand_)\\n            context_ := stackTopLocation_\\n        }\\n        uint256 report_ = ITierV2(address(uint160(tierContract_))).report(\\n            address(uint160(account_)),\\n            context_\\n        );\\n        assembly {\\n            mstore(location_, report_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xcdb73c4531a175ffbecb2b2ea9787abe37d2082a5553f59aa8dacec82d0bf553\",\"license\":\"CAL\"},\"contracts/vm/ops/tier/OpITierV2ReportTimeForTier.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../tier/ITierV2.sol\\\";\\n\\n/// @title OpITierV2Report\\n/// @notice Exposes `ITierV2.reportTimeForTier` as an opcode.\\nlibrary OpITierV2ReportTimeForTier {\\n    function stackPops(uint256 operand_)\\n        internal\\n        pure\\n        returns (uint256 reportsLength_)\\n    {\\n        unchecked {\\n            reportsLength_ = operand_ + 3;\\n        }\\n    }\\n\\n    // Stack the `reportTimeForTier` returned by an `ITierV2` contract.\\n    function reportTimeForTier(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 tierContract_;\\n        uint256 account_;\\n        uint256 tier_;\\n        uint256[] memory context_;\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, add(0x20, operand_))\\n            location_ := sub(stackTopLocation_, 0x40)\\n            tierContract_ := mload(location_)\\n            account_ := mload(add(location_, 0x20))\\n            tier_ := mload(stackTopLocation_)\\n            // we can reuse the tier_ as the length for context_ and achieve a\\n            // near zero-cost bytes array to send to `reportTimeForTier`.\\n            mstore(stackTopLocation_, operand_)\\n            context_ := stackTopLocation_\\n        }\\n        uint256 reportTime_ = ITierV2(address(uint160(tierContract_)))\\n            .reportTimeForTier(address(uint160(account_)), tier_, context_);\\n        assembly {\\n            mstore(location_, reportTime_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x76c5ba4e00479285677779ee220e8d8a190decce447914055024effddc682fc7\",\"license\":\"CAL\"},\"contracts/vm/ops/tier/OpSaturatingDiff.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../tier/libraries/TierwiseCombine.sol\\\";\\n\\nlibrary OpSaturatingDiff {\\n    // Stack the tierwise saturating subtraction of two reports.\\n    // If the older report is newer than newer report the result will\\n    // be `0`, else a tierwise diff in blocks will be obtained.\\n    // The older and newer report are taken from the stack.\\n    function saturatingDiff(uint256, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 location_;\\n        uint256 newerReport_;\\n        uint256 olderReport_;\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            newerReport_ := mload(location_)\\n            olderReport_ := mload(stackTopLocation_)\\n        }\\n        uint256 result_ = TierwiseCombine.saturatingSub(\\n            newerReport_,\\n            olderReport_\\n        );\\n        assembly {\\n            mstore(location_, result_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0xc3426d11ef4b2090ece900ddfa2e802e4af8a539b336e32e4e7a9aac71af445b\",\"license\":\"CAL\"},\"contracts/vm/ops/tier/OpSelectLte.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../tier/libraries/TierwiseCombine.sol\\\";\\n\\n/// @title OpSelectLte\\n/// @notice Exposes `TierwiseCombine.selectLte` as an opcode.\\nlibrary OpSelectLte {\\n    function stackPops(uint256 operand_) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 reportsLength_ = operand_ & 0x1F; // & 00011111\\n            require(reportsLength_ > 0, \\\"BAD_OPERAND\\\");\\n            return reportsLength_;\\n        }\\n    }\\n\\n    // Stacks the result of a `selectLte` combinator.\\n    // All `selectLte` share the same stack and argument handling.\\n    // Takes the `logic_` and `mode_` from the `operand_` high bits.\\n    // `logic_` is the highest bit.\\n    // `mode_` is the 2 highest bits after `logic_`.\\n    // The other bits specify how many values to take from the stack\\n    // as reports to compare against each other and the block number.\\n    function selectLte(uint256 operand_, uint256 stackTopLocation_)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 logic_ = operand_ >> 7;\\n        uint256 mode_ = (operand_ >> 5) & 0x3; // & 00000011\\n        uint256 reportsLength_ = operand_ & 0x1F; // & 00011111\\n\\n        uint256 location_;\\n        uint256[] memory reports_ = new uint256[](reportsLength_);\\n        uint256 time_;\\n        assembly {\\n            location_ := sub(\\n                stackTopLocation_,\\n                mul(add(reportsLength_, 1), 0x20)\\n            )\\n            let maxCursor_ := add(location_, mul(reportsLength_, 0x20))\\n            for {\\n                let cursor_ := location_\\n                let i_ := 0\\n            } lt(cursor_, maxCursor_) {\\n                cursor_ := add(cursor_, 0x20)\\n                i_ := add(i_, 0x20)\\n            } {\\n                mstore(add(reports_, add(0x20, i_)), mload(cursor_))\\n            }\\n            time_ := mload(maxCursor_)\\n        }\\n\\n        uint256 result_ = TierwiseCombine.selectLte(\\n            reports_,\\n            time_,\\n            logic_,\\n            mode_\\n        );\\n        assembly {\\n            mstore(location_, result_)\\n            stackTopLocation_ := add(location_, 0x20)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x5ddbf756632e07e8c94dd00b90fb2e4db954b2105abefba3cf5fc97222451e78\",\"license\":\"CAL\"},\"contracts/vm/ops/tier/OpUpdateTimesForTierRange.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.10;\\n\\nimport \\\"../../../tier/libraries/TierReport.sol\\\";\\n\\nlibrary OpUpdateTimesForTierRange {\\n    // Stacks a report with updated times over tier range.\\n    // The start and end tier are taken from the low and high bits of\\n    // the `operand_` respectively.\\n    // The report to update and timestamp to update to are both\\n    // taken from the stack.\\n    function updateTimesForTierRange(\\n        uint256 operand_,\\n        uint256 stackTopLocation_\\n    ) internal pure returns (uint256) {\\n        uint256 location_;\\n        uint256 report_;\\n        uint256 startTier_ = operand_ & 0x0f; // & 00001111\\n        uint256 endTier_ = (operand_ >> 4) & 0x0f; // & 00001111\\n        uint256 timestamp_;\\n\\n        assembly {\\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\\n            location_ := sub(stackTopLocation_, 0x20)\\n            report_ := mload(location_)\\n            timestamp_ := mload(stackTopLocation_)\\n        }\\n\\n        uint256 result_ = TierReport.updateTimesForTierRange(\\n            report_,\\n            startTier_,\\n            endTier_,\\n            timestamp_\\n        );\\n\\n        assembly {\\n            mstore(location_, result_)\\n        }\\n        return stackTopLocation_;\\n    }\\n}\\n\",\"keccak256\":\"0x34aeb29dd80c3589ba83dbc5b6e6becf145990b605471cde925f97eb268166dc\",\"license\":\"CAL\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405162005b4838038062005b48833981016040819052610031916100d7565b600160009081556040518290610046906100c9565b6001600160a01b039091168152602001604051809103906000f080158015610072573d6000803e3d6000fd5b50604080513381526001600160a01b03831660208201529192507f7fac34ecf0b1b374cd9659e3d17db602659d53f1162b1f20142e6c02694aed70910160405180910390a16001600160a01b031660805250610107565b614a03806200114583390190565b6000602082840312156100e957600080fd5b81516001600160a01b038116811461010057600080fd5b9392505050565b60805161101c620001296000396000818160a6015261037a015261101c6000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c80632c6afc68146100515780632ea72a491461008e5780635c60da1b146100a1578063fc91a897146100c8575b600080fd5b61006461005f366004610510565b610111565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b61006461009c366004610552565b6101b4565b6100647f000000000000000000000000000000000000000000000000000000000000000081565b6101016100d63660046105e9565b73ffffffffffffffffffffffffffffffffffffffff1660009081526001602052604090205460ff1690565b6040519015158152602001610085565b60003073ffffffffffffffffffffffffffffffffffffffff16632ea72a4983604051602001610140919061085c565b6040516020818303038152906040526040518263ffffffff1660e01b815260040161016b9190610a02565b6020604051808303816000875af115801561018a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ae9190610a15565b92915050565b600060026000541415610228576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064015b60405180910390fd5b600260009081556102398484610362565b73ffffffffffffffffffffffffffffffffffffffff811660009081526001602052604090205490915060ff16156102cc576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f4455504c49434154455f4348494c440000000000000000000000000000000000604482015260640161021f565b73ffffffffffffffffffffffffffffffffffffffff811660008181526001602081815260409283902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169092179091558151338152908101929092527f7da70c4e5387d7038610b79ca7d304caaef815826e51e67cf247135387a79bce910160405180910390a160016000559392505050565b60008061037183850185610d3a565b9050600061039e7f000000000000000000000000000000000000000000000000000000000000000061042e565b6040517f9a8d2ac800000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff821690639a8d2ac8906103f3908590600401610f12565b600060405180830381600087803b15801561040d57600080fd5b505af1158015610421573d6000803e3d6000fd5b5092979650505050505050565b60006040517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081528260601b60148201527f5af43d82803e903d91602b57fd5bf3000000000000000000000000000000000060288201526037816000f091505073ffffffffffffffffffffffffffffffffffffffff811661050b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f455243313136373a20637265617465206661696c656400000000000000000000604482015260640161021f565b919050565b60006020828403121561052257600080fd5b813567ffffffffffffffff81111561053957600080fd5b82016060818503121561054b57600080fd5b9392505050565b6000806020838503121561056557600080fd5b823567ffffffffffffffff8082111561057d57600080fd5b818501915085601f83011261059157600080fd5b8135818111156105a057600080fd5b8660208285010111156105b257600080fd5b60209290920196919550909350505050565b73ffffffffffffffffffffffffffffffffffffffff811681146105e657600080fd5b50565b6000602082840312156105fb57600080fd5b813561054b816105c4565b8035801515811461050b57600080fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261064b57600080fd5b830160208101925035905067ffffffffffffffff81111561066b57600080fd5b80360383131561067a57600080fd5b9250929050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc18336030181126106fe57600080fd5b90910192915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261073c57600080fd5b830160208101925035905067ffffffffffffffff81111561075c57600080fd5b8060051b360383131561067a57600080fd5b60006040830161077e8384610707565b604086528281845260608701905060608260051b88010193508260005b838110156107f6577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa08987030183526107d48286610616565b6107df888284610681565b97505050602092830192919091019060010161079b565b50505050506108086020840184610707565b85830360208701528083527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81111561084057600080fd5b60051b8082602085013760009201602001918252509392505050565b6020815261086982610606565b15156020820152600060208301357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff818436030181126108a757600080fd5b6060604084015283016108ba8180610616565b6080808601526108cf61010086018284610681565b9150506108df6020830183610616565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808684030160a0870152610914838284610681565b925050506040820135610926816105c4565b73ffffffffffffffffffffffffffffffffffffffff1660c0850152606082013560e085015261095860408601866106ca565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe084820301606085015261098e818361076e565b95945050505050565b6000815180845260005b818110156109bd576020818501810151868301820152016109a1565b818111156109cf576000602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b60208152600061054b6020830184610997565b600060208284031215610a2757600080fd5b815161054b816105c4565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff81118282101715610a8457610a84610a32565b60405290565b6040516060810167ffffffffffffffff81118282101715610a8457610a84610a32565b6040516080810167ffffffffffffffff81118282101715610a8457610a84610a32565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715610b1757610b17610a32565b604052919050565b600067ffffffffffffffff831115610b3957610b39610a32565b610b6a60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f86011601610ad0565b9050828152838383011115610b7e57600080fd5b828260208301376000602084830101529392505050565b600082601f830112610ba657600080fd5b61054b83833560208501610b1f565b600067ffffffffffffffff821115610bcf57610bcf610a32565b5060051b60200190565b600082601f830112610bea57600080fd5b81356020610bff610bfa83610bb5565b610ad0565b82815260059290921b84018101918181019086841115610c1e57600080fd5b8286015b84811015610c395780358352918301918301610c22565b509695505050505050565b60006040808385031215610c5757600080fd5b610c5f610a61565b9150823567ffffffffffffffff80821115610c7957600080fd5b818501915085601f830112610c8d57600080fd5b81356020610c9d610bfa83610bb5565b82815260059290921b84018101918181019089841115610cbc57600080fd5b8286015b84811015610d0857803586811115610cd85760008081fd5b8701603f81018c13610cea5760008081fd5b610cfa8c868301358b8401610b1f565b845250918301918301610cc0565b5087525086810135945082851115610d1f57600080fd5b610d2b88868901610bd9565b81870152505050505092915050565b600060208284031215610d4c57600080fd5b813567ffffffffffffffff80821115610d6457600080fd5b9083019060608286031215610d7857600080fd5b610d80610a8a565b610d8983610606565b8152602083013582811115610d9d57600080fd5b830160808188031215610daf57600080fd5b610db7610aad565b813584811115610dc657600080fd5b610dd289828501610b95565b825250602082013584811115610de757600080fd5b610df389828501610b95565b6020830152506040820135610e07816105c4565b80604083015250606082013560608201528060208401525050604083013582811115610e3257600080fd5b610e3e87828601610c44565b60408301525095945050505050565b60006040830182516040855281815180845260608701915060608160051b88010193506020808401935060005b82811015610ec6577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0898703018452610eb4868651610997565b95509381019392810192600101610e7a565b508681015188860389830152805180875290820195600095508201935091505b81841015610f065784518352938401936001939093019291820191610ee6565b50909695505050505050565b6020815281511515602082015260006020830151606060408401528051608080850152610f43610100850182610997565b905060208201517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808583030160a0860152610f7e8282610997565b91505073ffffffffffffffffffffffffffffffffffffffff60408301511660c0850152606082015160e0850152604085015191507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe084820301606085015261098e8183610e4d56fea264697066735822122035cd70ba92b0361856385d86d44cc9b6b0befa242681f7c398c5a947ef3d715064736f6c634300080a003360c06040523480156200001157600080fd5b5060405162004a0338038062004a0383398101604081905262000034916200004a565b306080526001600160a01b031660a0526200007c565b6000602082840312156200005d57600080fd5b81516001600160a01b03811681146200007557600080fd5b9392505050565b60805160a051614961620000a2600039600061090a0152600061093101526149616000f3fe608060405234801561001057600080fd5b506004361061016c5760003560e01c806395d89b41116100cd578063caa0eb3b11610081578063e0419ae311610066578063e0419ae314610349578063ea34554014610381578063f2cd6c081461039457600080fd5b8063caa0eb3b146102f0578063dd62ed3e1461030357600080fd5b8063a457c2d7116100b2578063a457c2d7146102b7578063a9059cbb146102ca578063bb1757cf146102dd57600080fd5b806395d89b411461029a5780639a8d2ac8146102a257600080fd5b8063313ce5671161012457806367676b111161010957806367676b111461020857806370a082311461022d57806388d686041461026357600080fd5b8063313ce567146101e657806339509351146101f557600080fd5b8063095ea7b311610155578063095ea7b3146101ae57806318160ddd146101c157806323b872dd146101d357600080fd5b806301ffc9a71461017157806306fdde0314610199575b600080fd5b61018461017f366004613814565b61053c565b60405190151581526020015b60405180910390f35b6101a16105d5565b60405161019091906138cc565b6101846101bc366004613901565b610667565b6035545b604051908152602001610190565b6101846101e136600461392d565b61067f565b60405160128152602001610190565b610184610203366004613901565b6106a5565b6065546101849074010000000000000000000000000000000000000000900460ff1681565b6101c561023b36600461396e565b73ffffffffffffffffffffffffffffffffffffffff1660009081526033602052604090205490565b6101c5610271366004613a2d565b5073ffffffffffffffffffffffffffffffffffffffff1660009081526066602052604090205490565b6101a16106f1565b6102b56102b0366004613ad8565b610700565b005b6101846102c5366004613901565b610b2a565b6101846102d8366004613901565b610c0b565b6102b56102eb366004613b13565b610c19565b6101c56102fe366004613b98565b610d6c565b6101c5610311366004613c24565b73ffffffffffffffffffffffffffffffffffffffff918216600090815260346020908152604080832093909416825291909152205490565b604080518082018252600080825260209182018190528251808401845281815282018181528351918252519181019190915201610190565b6101c561038f36600461396e565b610da5565b604080516105e081018252600060208201819052918101829052606081018290526080810182905260a0810182905260c081019190915261224a60e0820181905261233e6101008301526123ca6101208301526124eb61014083015261016082015261259461018082015261269c6101a08201526127706101c082015261296d6101e082015261297861020082015261298361022082015261298e6102408201526129996102608201526129cd610280820152612a336102a0820152612a996102c0820152612acd6102e0820152612b01610300820152612b36610320820152612b91610340820152612be7610360820152612c10610380820152612c676103a0820152612c946103c0820152612ceb6103e0820152612d56610400820152612db3610420820152612df1610440820152612e2a610460820152612e5e610480820152612e906104a0820152612ec26104c0820152612ef46104e0820152612f28610500820152612f7a610520820152612fb36105408201526130656105608201526131926105808201526131ee6105a08201526132a86105c08083019190915281526101a1565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f42766d3f0000000000000000000000000000000000000000000000000000000014806105cf57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b6060603680546105e490613c5d565b80601f016020809104026020016040519081016040528092919081815260200182805461061090613c5d565b801561065d5780601f106106325761010080835404028352916020019161065d565b820191906000526020600020905b81548152906001019060200180831161064057829003601f168201915b5050505050905090565b600033610675818585610e5a565b5060019392505050565b60003361068d85828561100d565b6106988585856110e4565b60019150505b9392505050565b33600081815260346020908152604080832073ffffffffffffffffffffffffffffffffffffffff8716845290915281205490919061067590829086906106ec908790613cda565b610e5a565b6060603780546105e490613c5d565b600061070c6001611397565b9050801561074157600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff166101001790555b6107e56107516020840184613cf2565b61075b9080613d30565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061079d925050506020850185613cf2565b6107ab906020810190613d30565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061152292505050565b61081c6107f56020840184613cf2565b61080690606081019060400161396e565b6108136020850185613cf2565b606001356115c3565b61085c6040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b60008082526001602083018190526040805182815280820190915290816020015b6108bd6040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b81526020019060019003908161087d57905050905081816000815181106108e6576108e6613d9c565b6020908102919091010152600073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000166317376ae07f000000000000000000000000000000000000000000000000000000000000000061095d6040890189613dcb565b856040518463ffffffff1660e01b815260040161097c93929190614001565b6000604051808303816000875af115801561099b573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682016040526109e191908101906140b2565b90506109ec816116e3565b606580547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055610a3e602086018661416b565b6065805491151574010000000000000000000000000000000000000000027fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff9092169190911790556040517f39167a2b716c846f73cd233f111d8d7376ca92d22fe661e2be793179a430e16690610ab890339088906141c3565b60405180910390a15050508015610b2657600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5050565b33600081815260346020908152604080832073ffffffffffffffffffffffffffffffffffffffff8716845290915281205490919083811015610bf3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f7760448201527f207a65726f00000000000000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b610c008286868403610e5a565b506001949350505050565b6000336106758185856110e4565b60655474010000000000000000000000000000000000000000900460ff16610cba573373ffffffffffffffffffffffffffffffffffffffff841614610cba576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f44454c4547415445445f434c41494d00000000000000000000000000000000006044820152606401610bea565b6000610cc584610da5565b9050610cd184826115c3565b610cff7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600060084261176e565b73ffffffffffffffffffffffffffffffffffffffff85166000908152606660205260409081902091909155517fbf9d4a3962ab35e7ce8f88984952a416a31b61587fa229030e059141a2646f4390610d5e90339087908790879061430a565b60405180910390a150505050565b73ffffffffffffffffffffffffffffffffffffffff8416600090815260666020526040812054610d9c9085611814565b95945050505050565b6065546000908190610dd590610dd09073ffffffffffffffffffffffffffffffffffffffff166118c9565b6118f7565b6040805160208082528183019092529192506000919060208201818036833750505073ffffffffffffffffffffffffffffffffffffffff851660208201819052909150610e2482846000611a63565b5060208301518351610e389060019061434e565b81518110610e4857610e48613d9c565b60200260200101519350505050919050565b73ffffffffffffffffffffffffffffffffffffffff8316610efc576040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f2061646460448201527f72657373000000000000000000000000000000000000000000000000000000006064820152608401610bea565b73ffffffffffffffffffffffffffffffffffffffff8216610f9f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f20616464726560448201527f73730000000000000000000000000000000000000000000000000000000000006064820152608401610bea565b73ffffffffffffffffffffffffffffffffffffffff83811660008181526034602090815260408083209487168084529482529182902085905590518481527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a3505050565b73ffffffffffffffffffffffffffffffffffffffff8381166000908152603460209081526040808320938616835292905220547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81146110de57818110156110d1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f45524332303a20696e73756666696369656e7420616c6c6f77616e63650000006044820152606401610bea565b6110de8484848403610e5a565b50505050565b73ffffffffffffffffffffffffffffffffffffffff8316611187576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f45524332303a207472616e736665722066726f6d20746865207a65726f20616460448201527f64726573730000000000000000000000000000000000000000000000000000006064820152608401610bea565b73ffffffffffffffffffffffffffffffffffffffff821661122a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602360248201527f45524332303a207472616e7366657220746f20746865207a65726f206164647260448201527f65737300000000000000000000000000000000000000000000000000000000006064820152608401610bea565b73ffffffffffffffffffffffffffffffffffffffff8316600090815260336020526040902054818110156112e0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f45524332303a207472616e7366657220616d6f756e742065786365656473206260448201527f616c616e636500000000000000000000000000000000000000000000000000006064820152608401610bea565b73ffffffffffffffffffffffffffffffffffffffff808516600090815260336020526040808220858503905591851681529081208054849290611324908490613cda565b925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8460405161138a91815260200190565b60405180910390a36110de565b60008054610100900460ff161561144e578160ff1660011480156113ba5750303b155b611446576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152608401610bea565b506000919050565b60005460ff8084169116106114e5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152608401610bea565b50600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660ff92909216919091179055600190565b919050565b600054610100900460ff166115b9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152608401610bea565b610b268282611d3c565b73ffffffffffffffffffffffffffffffffffffffff8216611640576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f45524332303a206d696e7420746f20746865207a65726f2061646472657373006044820152606401610bea565b80603560008282546116529190613cda565b909155505073ffffffffffffffffffffffffffffffffffffffff82166000908152603360205260408120805483929061168c908490613cda565b909155505060405181815273ffffffffffffffffffffffffffffffffffffffff8316906000907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9060200160405180910390a35050565b60008061170e836040516020016116fa9190614365565b604051602081830303815290604052611dfa565b90508051602082016000f0915073ffffffffffffffffffffffffffffffffffffffff8216611768576040517f08d4abb600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50919050565b60008260088111156117dc576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4d41585f544945520000000000000000000000000000000000000000000000006044820152606401610bea565b6000855b858110156118085763ffffffff6020820290811b199890981685891b179791506001016117e0565b50959695505050505050565b6000816008811115611882576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4d41585f544945520000000000000000000000000000000000000000000000006044820152606401610bea565b8261189057600091506118c2565b63ffffffff60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff85010285901c1691505b5092915050565b60606105cf8260017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff611e26565b6119296040518060a0016040528060008152602001606081526020016060815260200160608152602001600081525090565b61195b6040518060a0016040528060008152602001606081526020016060815260200160608152602001600081525090565b60208301805160ff8082168352606084019290925290600882901c1667ffffffffffffffff81111561198f5761198f61398b565b6040519080825280602002602001820160405280156119b8578160200160208202803683370190505b50602083015260ff601082901c81166080840152601882901c16606060008267ffffffffffffffff8111156119ef576119ef61398b565b604051908082528060200260200182016040528015611a18578160200160208202803683370190505b5090506020870151602002604001870160005b84811015611a52578160208202602001840152815160200182019150600181019050611a2b565b505060408501525091949350505050565b60208281015183516040850151848402018301518051606087015160a088015160009687968796879695948301938284019391820290920101906002015b84891015611d1f576003890198508886015180601f1a975061ffff8160081c169850506006881015611c975787611ae657866020028401518252602082019150611caa565b6001881415611b0357602087028301518252602082019150611caa565b6002881415611b90578c518760200210611b79576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f434f4e544558545f4c454e4754480000000000000000000000000000000000006044820152606401610bea565b866020026020018d01518252602082019150611caa565b6003881415611bd8576000611bc66040805180820182526000808252602091820181905282518084019093528083529082015290565b51880154835250602090910190611caa565b6004881415611bf457611bed8d8d848a611f0e565b9150611caa565b606087611c22578c604051602001611c0c91906143c6565b6040516020818303038152906040529050611c81565b6001881415611c3b57611c348d61207b565b9050611c81565b6002881415611c57576020808e0151604051611c0c920161449c565b6003881415611c81578c516040805160208101929092520160405160208183030381529060405290505b805115611c9157611c91816121b8565b50611caa565b87611ca6888463ffffffff8416565b9250505b60208c0151518c511115611d1a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f535441434b5f4f564552464c4f570000000000000000000000000000000000006044820152606401610bea565b611aa1565b602083830304909b529b9a5050505050505050505050565b505050565b600054610100900460ff16611dd3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152608401610bea565b8151611de690603690602085019061377b565b508051611d3790603790602084019061377b565b6060815182604051602001611e10929190614501565b6040516020818303038152906040529050919050565b6060833b80611e4557505060408051602081019091526000815261069e565b80841115611e6357505060408051602081019091526000815261069e565b83831015611eae576040517f2c4a89fa000000000000000000000000000000000000000000000000000000008152600481018290526024810185905260448101849052606401610bea565b8383038482036000828210611ec35782611ec5565b815b60408051603f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168101909152818152955090508087602087018a3c505050509392505050565b600060078216600383811c16828082611f4d57507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9050610100611f98565b8260011415611f7157506fffffffffffffffffffffffffffffffff90506080611f98565b8260021415611f8d575067ffffffffffffffff90506040611f98565b5063ffffffff905060205b6001600587901c0160008167ffffffffffffffff811115611fbb57611fbb61398b565b604051908082528060200260200182016040528015611fe4578160200160208202803683370190505b50905060208082019083028a03815b8b82101561200b578151815260209182019101611ff3565b505060608b015160808c015160209081029091010160005b6101008110156120695760208502830182845b82811015612052578051841c8a16825260209182019101612036565b5050506120608e8e8b611a63565b9b508501612023565b50999c9b505050505050505050505050565b606060008260600151905060006018846040015151901b60108560800151901b6008866020015151901b866060015151171717905060008160001b836040516020016120c7919061449c565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152908290526121039291602001614598565b604051602081830303815290604052905060005b8560400151518110156121af57818660400151828151811061213b5761213b613d9c565b60200260200101515160001b8760400151838151811061215d5761215d613d9c565b6020026020010151604051602001612177939291906145be565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190529150600101612117565b50949350505050565b612247816040516024016121cc91906138cc565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f0be77f5600000000000000000000000000000000000000000000000000000000179052613324565b50565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920180516040517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff808316600483015292946000949390929185918416906370a08231906024015b602060405180830381865afa15801561230d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061233191906145f5565b9093525092949350505050565b60008060006020840391508151905060008173ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561239a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123be91906145f5565b90925250919392505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0830180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0909401516040517f4ee2cd7e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff808716600483015260248201839052929560009594939092918691851690634ee2cd7e906044015b602060405180830381865afa1580156124b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124dd91906145f5565b909452509395945050505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920180516040517f981b24d000000000000000000000000000000000000000000000000000000000815260048101829052919360009392909190849073ffffffffffffffffffffffffffffffffffffffff84169063981b24d0906024016122f0565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920180516040517f6352211e00000000000000000000000000000000000000000000000000000000815260048101829052919360009392909190849073ffffffffffffffffffffffffffffffffffffffff841690636352211e90602401602060405180830381865afa158015612655573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612679919061460e565b73ffffffffffffffffffffffffffffffffffffffff169093525092949350505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0830180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0909401516040517efdd58e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff80871660048301526024820183905292956000959493909291869185169062fdd58e9060440161249c565b60008060008467ffffffffffffffff81111561278e5761278e61398b565b6040519080825280602002602001820160405280156127b7578160200160208202803683370190505b50905060008567ffffffffffffffff8111156127d5576127d561398b565b6040519080825280602002602001820160405280156127fe578160200160208202803683370190505b506040870286037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018051909550919250602080890282019085015b8183101561285357825181526020928301920161283b565b5050602088028101602084015b81831015612878578251815260209283019201612860565b50506040517f4e1273f40000000000000000000000000000000000000000000000000000000081526000915073ffffffffffffffffffffffffffffffffffffffff831690634e1273f4906128d2908790879060040161462b565b600060405180830381865afa1580156128ef573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052612935919081019061468e565b9050846020820160208a0281015b8082101561295e578151835260209283019290910190612943565b50909998505050505050505050565b438152602001919050565b338152602001919050565b308152602001919050565b428152602001919050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101805160009190826123be8287613345565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920180519092600092918361233182612a2d858a613345565b906133bf565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920180519092600092918361233182612a93858a613345565b906133de565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101805160009190826123be82876133f3565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101805160009190826123be828761343e565b6000602083028203805b83811015612b2b5780518015612b22578252612b2b565b50602001612b0b565b506020019392505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0810180511560200282017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc090810151909152018092915050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc09092018051909214909152919050565b6000602083028203805b83811015612b2b578051612c085760008252612b2b565b602001612bf1565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0909201805192909211909152919050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081018051159052919050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0909201805192909210909152919050565b6020828102820380516000928201835b8582108015612d2957507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83105b15612d4857508051602090910190612d41838261349c565b9250612cfb565b505081526020019392505050565b6020828102820380516000928201835b8582108015612d9457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83105b15612d4857508051602090910190612dac83826134d8565b9250612d66565b6020828102820380516000928201835b8582108015612dd25750826000105b15612d4857508051602090910190612dea8382613507565b9250612dc3565b600060208302820380516000602083015b85811015612d485780518301915082821015612e1d57600080fd5b9091508190602001612e02565b600060208302820380516000602083015b85811015612d48578051915081612e5157600080fd5b9181900491602001612e3b565b6020828102820380516000928201835b85821015612d4857508051602090910190612e898184614834565b9250612e6e565b6020828102820380516000928201835b85821015612d485750805182811115612eb7578092505b602082019150612ea0565b6020828102820380516000928201835b85821015612d485750805182811015612ee9578092505b602082019150612ed2565b600060208302820380516000602083015b85811015612d48578051915081612f1b57600080fd5b9181900691602001612f05565b60006020830282038051600080602084015b86811015612f6b578315612f63578051925082840291508284830414612f5f57600080fd5b8193505b602001612f3a565b50505081526020019392505050565b600060208302820380516000602083015b85811015612d485780518303915082821115612fa657600080fd5b9091508190602001612f8b565b8190037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920180518482526040517f88d686040000000000000000000000000000000000000000000000000000000081529193600093929091908590859073ffffffffffffffffffffffffffffffffffffffff8516906388d686049061249c9086908690600401614840565b8190037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08301517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090930180518582526040517fcaa0eb3b000000000000000000000000000000000000000000000000000000008152919460009493929091908690869073ffffffffffffffffffffffffffffffffffffffff86169063caa0eb3b9061313e9087908790879060040161486f565b602060405180830381865afa15801561315b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061317f91906145f5565b8652505060209093019695505050505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0909201805190926000929183612331838361351d565b6000600783901c6003600585901c16601f851683808267ffffffffffffffff81111561321c5761321c61398b565b604051908082528060200260200182016040528015613245578160200160208202803683370190505b509050600060206001850102880392506020840283018360005b828210156132815781518160200186015260208201915060208101905061325f565b505051905060006132948383898961357c565b845250506020909101979650505050505050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0810180517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09092018051909260009291600f80871691600488901c90911690856133158585858561176e565b90955250949695505050505050565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b600080826012141561335a57839150506105cf565b82601211156133865750601282900361337481600a614834565b61337e90856148a4565b9150506105cf565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee82016133b581600a614834565b61337e90856148e1565b6000816133d4670de0b6b3a7640000856148a4565b61069e91906148e1565b6000670de0b6b3a76400006133d483856148a4565b600081810b6134035750816105cf565b60008260000b131561342b5761341a82600a61491c565b61342490846148a4565b90506105cf565b60ff6000839003166133b581600a614834565b600080601283141561345357839150506105cf565b826012111561346d575060128290036133b581600a614834565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee820161337481600a614834565b60008282018381106134ae57806134d0565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5b949350505050565b6000826134e7575060006105cf565b828202828482816134fa576134fa6144d2565b0414156134ae57806134d0565b600081831161351757600061069e565b50900390565b60008060015b600881116135745760006135378683611814565b905060006135458684611814565b905060006135538383613507565b90506135638560018603836136cc565b945050600190920191506135239050565b509392505050565b835160009081908190819060015b600881116136be576000925082876135c357507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6135c7565b5060005b60005b8381101561367c576135f58c82815181106135e7576135e7613d9c565b602002602001015184611814565b95508a861161364757886136145761360d8683613755565b915061363e565b60018914156136275761360d868361376b565b600289148015613635575084155b1561363e578591505b60019450613674565b89613674577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff915061367c565b6001016135ca565b50836136a557507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5b6136b38660018403836136cc565b95505060010161358a565b509298975050505050505050565b600082600881111561373a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4d41585f544945520000000000000000000000000000000000000000000000006044820152606401610bea565b505063ffffffff602090920291821b199290921691901b1790565b6000818310613764578161069e565b5090919050565b600081831015613764578161069e565b82805461378790613c5d565b90600052602060002090601f0160209004810192826137a957600085556137ef565b82601f106137c257805160ff19168380011785556137ef565b828001600101855582156137ef579182015b828111156137ef5782518255916020019190600101906137d4565b506137fb9291506137ff565b5090565b5b808211156137fb5760008155600101613800565b60006020828403121561382657600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461069e57600080fd5b60005b83811015613871578181015183820152602001613859565b838111156110de5750506000910152565b6000815180845261389a816020860160208601613856565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b60208152600061069e6020830184613882565b73ffffffffffffffffffffffffffffffffffffffff8116811461224757600080fd5b6000806040838503121561391457600080fd5b823561391f816138df565b946020939093013593505050565b60008060006060848603121561394257600080fd5b833561394d816138df565b9250602084013561395d816138df565b929592945050506040919091013590565b60006020828403121561398057600080fd5b813561069e816138df565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715613a0157613a0161398b565b604052919050565b600067ffffffffffffffff821115613a2357613a2361398b565b5060051b60200190565b60008060408385031215613a4057600080fd5b8235613a4b816138df565b915060208381013567ffffffffffffffff811115613a6857600080fd5b8401601f81018613613a7957600080fd5b8035613a8c613a8782613a09565b6139ba565b81815260059190911b82018301908381019088831115613aab57600080fd5b928401925b82841015613ac957833582529284019290840190613ab0565b80955050505050509250929050565b600060208284031215613aea57600080fd5b813567ffffffffffffffff811115613b0157600080fd5b82016060818503121561069e57600080fd5b600080600060408486031215613b2857600080fd5b8335613b33816138df565b9250602084013567ffffffffffffffff80821115613b5057600080fd5b818601915086601f830112613b6457600080fd5b813581811115613b7357600080fd5b876020828501011115613b8557600080fd5b6020830194508093505050509250925092565b60008060008060608587031215613bae57600080fd5b8435613bb9816138df565b935060208501359250604085013567ffffffffffffffff80821115613bdd57600080fd5b818701915087601f830112613bf157600080fd5b813581811115613c0057600080fd5b8860208260051b8501011115613c1557600080fd5b95989497505060200194505050565b60008060408385031215613c3757600080fd5b8235613c42816138df565b91506020830135613c52816138df565b809150509250929050565b600181811c90821680613c7157607f821691505b60208210811415611768577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60008219821115613ced57613ced613cab565b500190565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81833603018112613d2657600080fd5b9190910192915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112613d6557600080fd5b83018035915067ffffffffffffffff821115613d8057600080fd5b602001915036819003821315613d9557600080fd5b9250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1833603018112613d2657600080fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112613e3457600080fd5b830160208101925035905067ffffffffffffffff811115613e5457600080fd5b8060051b3603831315613d9557600080fd5b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112613ee457600080fd5b830160208101925035905067ffffffffffffffff811115613f0457600080fd5b803603831315613d9557600080fd5b600060408301613f238384613dff565b604086528281845260608701905060608260051b88010193508260005b83811015613f9b577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0898703018352613f798286613eaf565b613f84888284613e66565b975050506020928301929190910190600101613f40565b5050505050613fad6020840184613dff565b85830360208701528083527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff811115613fe557600080fd5b60051b8082602085013760009201602001918252509392505050565b6000606073ffffffffffffffffffffffffffffffffffffffff861683526020818185015261403182850187613f13565b84810360408681019190915286518083528388019284019060005b818110156140a2578451805184528681015187850152848101518585015287810151888501526080808201519085015260a0808201519085015260c090810151908401529385019360e09092019160010161404c565b50909a9950505050505050505050565b6000602082840312156140c457600080fd5b815167ffffffffffffffff808211156140dc57600080fd5b818401915084601f8301126140f057600080fd5b8151818111156141025761410261398b565b61413360207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116016139ba565b915080825285602082850101111561414a57600080fd5b6121af816020840160208601613856565b8035801515811461151d57600080fd5b60006020828403121561417d57600080fd5b61069e8261415b565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc18336030181126141ba57600080fd5b90910192915050565b600073ffffffffffffffffffffffffffffffffffffffff8085168352604060208401526141ef8461415b565b1515604084015260208401357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8185360301811261422b57600080fd5b606084810152840161423d8180613eaf565b608060a087015261425361012087018284613e66565b9150506142636020830183613eaf565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff608784030160c0880152614298838284613e66565b9250505060408201356142aa816138df565b831660e086015260608201356101008601526142c96040870187614186565b92507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08582030160808601526142ff8184613f13565b979650505050505050565b600073ffffffffffffffffffffffffffffffffffffffff808716835280861660208401525060606040830152614344606083018486613e66565b9695505050505050565b60008282101561436057614360613cab565b500390565b600081526000825161437e816001850160208701613856565b9190910160010192915050565b600081518084526020808501945080840160005b838110156143bb5781518752958201959082019060010161439f565b509495945050505050565b600060208083528351818401528084015160a060408501526143eb60c085018261438b565b905060408501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0808684030160608701528282518085528585019150858160051b860101868501945060005b828110156144645784878303018452614452828751613882565b95880195938801939150600101614438565b5060608a01519650838982030160808a0152614480818861438b565b9650505050505050608084015160a08401528091505092915050565b815160009082906020808601845b838110156144c6578151855293820193908201906001016144aa565b50929695505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7f630000000000000000000000000000000000000000000000000000000000000081527fffffffff000000000000000000000000000000000000000000000000000000008360e01b1660018201527f80600e6000396000f3000000000000000000000000000000000000000000000060058201526000825161458a81600e850160208701613856565b91909101600e019392505050565b828152600082516145b0816020850160208701613856565b919091016020019392505050565b600084516145d0818460208901613856565b820184815283516145e8816020808501908801613856565b0160200195945050505050565b60006020828403121561460757600080fd5b5051919050565b60006020828403121561462057600080fd5b815161069e816138df565b604080825283519082018190526000906020906060840190828701845b8281101561467a57815173ffffffffffffffffffffffffffffffffffffffff1684529284019290840190600101614648565b50505083810382850152614344818661438b565b600060208083850312156146a157600080fd5b825167ffffffffffffffff8111156146b857600080fd5b8301601f810185136146c957600080fd5b80516146d7613a8782613a09565b81815260059190911b820183019083810190878311156146f657600080fd5b928401925b828410156142ff578351825292840192908401906146fb565b600181815b8085111561476d57817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0482111561475357614753613cab565b8085161561476057918102915b93841c9390800290614719565b509250929050565b600082614784575060016105cf565b81614791575060006105cf565b81600181146147a757600281146147b1576147cd565b60019150506105cf565b60ff8411156147c2576147c2613cab565b50506001821b6105cf565b5060208310610133831016604e8410600b84101617156147f0575081810a6105cf565b6147fa8383614714565b807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0482111561482c5761482c613cab565b029392505050565b600061069e8383614775565b73ffffffffffffffffffffffffffffffffffffffff831681526040602082015260006134d0604083018461438b565b73ffffffffffffffffffffffffffffffffffffffff84168152826020820152606060408201526000610d9c606083018461438b565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156148dc576148dc613cab565b500290565b600082614917577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b600061069e60ff84168361477556fea26469706673582212205d92d2ff6027c75bd5d5bd6649dd86bdd6ab4dab7ab584f5989fd4865e81be9264736f6c634300080a0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c80632c6afc68146100515780632ea72a491461008e5780635c60da1b146100a1578063fc91a897146100c8575b600080fd5b61006461005f366004610510565b610111565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b61006461009c366004610552565b6101b4565b6100647f000000000000000000000000000000000000000000000000000000000000000081565b6101016100d63660046105e9565b73ffffffffffffffffffffffffffffffffffffffff1660009081526001602052604090205460ff1690565b6040519015158152602001610085565b60003073ffffffffffffffffffffffffffffffffffffffff16632ea72a4983604051602001610140919061085c565b6040516020818303038152906040526040518263ffffffff1660e01b815260040161016b9190610a02565b6020604051808303816000875af115801561018a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ae9190610a15565b92915050565b600060026000541415610228576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064015b60405180910390fd5b600260009081556102398484610362565b73ffffffffffffffffffffffffffffffffffffffff811660009081526001602052604090205490915060ff16156102cc576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f4455504c49434154455f4348494c440000000000000000000000000000000000604482015260640161021f565b73ffffffffffffffffffffffffffffffffffffffff811660008181526001602081815260409283902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169092179091558151338152908101929092527f7da70c4e5387d7038610b79ca7d304caaef815826e51e67cf247135387a79bce910160405180910390a160016000559392505050565b60008061037183850185610d3a565b9050600061039e7f000000000000000000000000000000000000000000000000000000000000000061042e565b6040517f9a8d2ac800000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff821690639a8d2ac8906103f3908590600401610f12565b600060405180830381600087803b15801561040d57600080fd5b505af1158015610421573d6000803e3d6000fd5b5092979650505050505050565b60006040517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081528260601b60148201527f5af43d82803e903d91602b57fd5bf3000000000000000000000000000000000060288201526037816000f091505073ffffffffffffffffffffffffffffffffffffffff811661050b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f455243313136373a20637265617465206661696c656400000000000000000000604482015260640161021f565b919050565b60006020828403121561052257600080fd5b813567ffffffffffffffff81111561053957600080fd5b82016060818503121561054b57600080fd5b9392505050565b6000806020838503121561056557600080fd5b823567ffffffffffffffff8082111561057d57600080fd5b818501915085601f83011261059157600080fd5b8135818111156105a057600080fd5b8660208285010111156105b257600080fd5b60209290920196919550909350505050565b73ffffffffffffffffffffffffffffffffffffffff811681146105e657600080fd5b50565b6000602082840312156105fb57600080fd5b813561054b816105c4565b8035801515811461050b57600080fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261064b57600080fd5b830160208101925035905067ffffffffffffffff81111561066b57600080fd5b80360383131561067a57600080fd5b9250929050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc18336030181126106fe57600080fd5b90910192915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261073c57600080fd5b830160208101925035905067ffffffffffffffff81111561075c57600080fd5b8060051b360383131561067a57600080fd5b60006040830161077e8384610707565b604086528281845260608701905060608260051b88010193508260005b838110156107f6577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa08987030183526107d48286610616565b6107df888284610681565b97505050602092830192919091019060010161079b565b50505050506108086020840184610707565b85830360208701528083527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81111561084057600080fd5b60051b8082602085013760009201602001918252509392505050565b6020815261086982610606565b15156020820152600060208301357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff818436030181126108a757600080fd5b6060604084015283016108ba8180610616565b6080808601526108cf61010086018284610681565b9150506108df6020830183610616565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808684030160a0870152610914838284610681565b925050506040820135610926816105c4565b73ffffffffffffffffffffffffffffffffffffffff1660c0850152606082013560e085015261095860408601866106ca565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe084820301606085015261098e818361076e565b95945050505050565b6000815180845260005b818110156109bd576020818501810151868301820152016109a1565b818111156109cf576000602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b60208152600061054b6020830184610997565b600060208284031215610a2757600080fd5b815161054b816105c4565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff81118282101715610a8457610a84610a32565b60405290565b6040516060810167ffffffffffffffff81118282101715610a8457610a84610a32565b6040516080810167ffffffffffffffff81118282101715610a8457610a84610a32565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715610b1757610b17610a32565b604052919050565b600067ffffffffffffffff831115610b3957610b39610a32565b610b6a60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f86011601610ad0565b9050828152838383011115610b7e57600080fd5b828260208301376000602084830101529392505050565b600082601f830112610ba657600080fd5b61054b83833560208501610b1f565b600067ffffffffffffffff821115610bcf57610bcf610a32565b5060051b60200190565b600082601f830112610bea57600080fd5b81356020610bff610bfa83610bb5565b610ad0565b82815260059290921b84018101918181019086841115610c1e57600080fd5b8286015b84811015610c395780358352918301918301610c22565b509695505050505050565b60006040808385031215610c5757600080fd5b610c5f610a61565b9150823567ffffffffffffffff80821115610c7957600080fd5b818501915085601f830112610c8d57600080fd5b81356020610c9d610bfa83610bb5565b82815260059290921b84018101918181019089841115610cbc57600080fd5b8286015b84811015610d0857803586811115610cd85760008081fd5b8701603f81018c13610cea5760008081fd5b610cfa8c868301358b8401610b1f565b845250918301918301610cc0565b5087525086810135945082851115610d1f57600080fd5b610d2b88868901610bd9565b81870152505050505092915050565b600060208284031215610d4c57600080fd5b813567ffffffffffffffff80821115610d6457600080fd5b9083019060608286031215610d7857600080fd5b610d80610a8a565b610d8983610606565b8152602083013582811115610d9d57600080fd5b830160808188031215610daf57600080fd5b610db7610aad565b813584811115610dc657600080fd5b610dd289828501610b95565b825250602082013584811115610de757600080fd5b610df389828501610b95565b6020830152506040820135610e07816105c4565b80604083015250606082013560608201528060208401525050604083013582811115610e3257600080fd5b610e3e87828601610c44565b60408301525095945050505050565b60006040830182516040855281815180845260608701915060608160051b88010193506020808401935060005b82811015610ec6577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0898703018452610eb4868651610997565b95509381019392810192600101610e7a565b508681015188860389830152805180875290820195600095508201935091505b81841015610f065784518352938401936001939093019291820191610ee6565b50909695505050505050565b6020815281511515602082015260006020830151606060408401528051608080850152610f43610100850182610997565b905060208201517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808583030160a0860152610f7e8282610997565b91505073ffffffffffffffffffffffffffffffffffffffff60408301511660c0850152606082015160e0850152604085015191507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe084820301606085015261098e8183610e4d56fea264697066735822122035cd70ba92b0361856385d86d44cc9b6b0befa242681f7c398c5a947ef3d715064736f6c634300080a0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "createChild(bytes)": {
        "params": {
          "data_": "Encoded data to pass down to child contract constructor."
        },
        "returns": {
          "_0": "New child contract address."
        }
      },
      "createChildTyped((bool,(string,string,address,uint256),(bytes[],uint256[])))": {
        "params": {
          "config_": "`EmissionsERC20` constructor configuration."
        },
        "returns": {
          "_0": "New `EmissionsERC20` child contract address."
        }
      },
      "isChild(address)": {
        "params": {
          "maybeChild_": "Address of child contract to look up."
        },
        "returns": {
          "_0": "Returns `true` if address is a contract created by this contract factory, otherwise `false`."
        }
      }
    },
    "title": "EmissionsERC20Factory",
    "version": 1
  },
  "userdoc": {
    "events": {
      "Implementation(address,address)": {
        "notice": "Factories that clone a template contract MUST emit an event any time they set the implementation being cloned. Factories that deploy new contracts without cloning do NOT need to emit this."
      },
      "NewChild(address,address)": {
        "notice": "Whenever a new child contract is deployed, a `NewChild` event containing the new child contract address MUST be emitted."
      }
    },
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "Build the reference implementation to clone for each child."
      },
      "createChild(bytes)": {
        "notice": "Implements `IFactory`. Calls the `_createChild` hook that inheriting contracts must override. Registers child contract address such that `isChild` is `true`. Emits `NewChild` event."
      },
      "createChildTyped((bool,(string,string,address,uint256),(bytes[],uint256[])))": {
        "notice": "Allows calling `createChild` with `EmissionsERC20Config` struct. Use original `Factory` `createChild` function signature if function parameters are already encoded."
      },
      "implementation()": {
        "notice": "Template contract to clone. Deployed by the constructor."
      },
      "isChild(address)": {
        "notice": "Implements `IFactory`. Checks if address is registered as a child contract of this factory."
      }
    },
    "notice": "Factory for deploying and registering `EmissionsERC20` contracts.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1830,
        "contract": "contracts/claim/EmissionsERC20Factory.sol:EmissionsERC20Factory",
        "label": "_status",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 9000,
        "contract": "contracts/claim/EmissionsERC20Factory.sol:EmissionsERC20Factory",
        "label": "contracts",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}