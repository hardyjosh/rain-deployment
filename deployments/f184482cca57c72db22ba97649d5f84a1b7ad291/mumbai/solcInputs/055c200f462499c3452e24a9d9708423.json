{
  "language": "Solidity",
  "sources": {
    "contracts/claim/EmissionsERC20.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../tier/libraries/TierConstants.sol\";\nimport {ERC20Config} from \"../erc20/ERC20Config.sol\";\nimport \"./IClaim.sol\";\nimport \"../tier/TierV2.sol\";\nimport \"../tier/libraries/TierReport.sol\";\nimport {VMStateBuilder, StateConfig, Bounds} from \"../vm/VMStateBuilder.sol\";\nimport \"../vm/RainVM.sol\";\nimport {AllStandardOps} from \"../vm/ops/AllStandardOps.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"../sstore2/SSTORE2.sol\";\n\n/// Constructor config.\n/// @param allowDelegatedClaims True if accounts can call `claim` on behalf of\n/// another account.\n/// @param Constructor config for the ERC20 token minted according to emissions\n/// schedule in `claim`.\n/// @param Constructor config for the `ImmutableSource` that defines the\n/// emissions schedule for claiming.\nstruct EmissionsERC20Config {\n    bool allowDelegatedClaims;\n    ERC20Config erc20Config;\n    StateConfig vmStateConfig;\n}\n\n/// @dev Source index for VM eval.\nuint256 constant ENTRYPOINT = 0;\nuint256 constant MIN_FINAL_STACK_INDEX = 1;\n\n/// @title EmissionsERC20\n/// @notice Mints itself according to some predefined schedule. The schedule is\n/// expressed as a rainVM script and the `claim` function is world-callable.\n/// Intended behaviour is to avoid sybils infinitely minting by putting the\n/// claim functionality behind a `TierV2` contract. The emissions contract\n/// itself implements `ReadOnlyTier` and every time a claim is processed it\n/// logs the block number of the claim against every tier claimed. So the block\n/// numbers in the tier report for `EmissionsERC20` are the last time that tier\n/// was claimed against this contract. The simplest way to make use of this\n/// information is to take the max block for the underlying tier and the last\n/// claim and then diff it against the current block number.\n/// See `test/Claim/EmissionsERC20.sol.ts` for examples, including providing\n/// staggered rewards where more tokens are minted for higher tier accounts.\ncontract EmissionsERC20 is\n    TierV2,\n    Initializable,\n    RainVM,\n    ERC20Upgradeable,\n    IClaim\n{\n    /// Contract has initialized.\n    /// @param sender `msg.sender` initializing the contract (factory).\n    /// @param config All initialized config.\n    event Initialize(address sender, EmissionsERC20Config config);\n\n    address private immutable self;\n    address private immutable vmStateBuilder;\n\n    /// Address of the immutable rain script deployed as a `VMState`.\n    address private vmStatePointer;\n\n    /// Whether the claimant must be the caller of `claim`. If `false` then\n    /// accounts other than claimant can claim. This may or may not be\n    /// desirable depending on the emissions schedule. For example, a linear\n    /// schedule will produce the same end result for the claimant regardless\n    /// of who calls `claim` or when but an exponential schedule is more\n    /// profitable if the claimant waits longer between claims. In the\n    /// non-linear case delegated claims would be inappropriate as third\n    /// party accounts could grief claimants by claiming \"early\", thus forcing\n    /// opportunity cost on claimants who would have preferred to wait.\n    bool public allowDelegatedClaims;\n\n    /// Each claim is modelled as a report so that the claim report can be\n    /// diffed against the upstream report from a tier based emission scheme.\n    mapping(address => uint256) private reports;\n\n    constructor(address vmStateBuilder_) {\n        self = address(this);\n        vmStateBuilder = vmStateBuilder_;\n    }\n\n    /// @param config_ source and token config. Also controls delegated claims.\n    function initialize(EmissionsERC20Config calldata config_)\n        external\n        initializer\n    {\n        __ERC20_init(config_.erc20Config.name, config_.erc20Config.symbol);\n        _mint(\n            config_.erc20Config.distributor,\n            config_.erc20Config.initialSupply\n        );\n\n        Bounds memory bounds_;\n        bounds_.entrypoint = ENTRYPOINT;\n        bounds_.minFinalStackIndex = MIN_FINAL_STACK_INDEX;\n        Bounds[] memory boundss_ = new Bounds[](1);\n        boundss_[0] = bounds_;\n\n        bytes memory vmStateBytes_ = VMStateBuilder(vmStateBuilder).buildState(\n            self,\n            config_.vmStateConfig,\n            boundss_\n        );\n        vmStatePointer = SSTORE2.write(vmStateBytes_);\n\n        /// Log some deploy state for use by claim/opcodes.\n        allowDelegatedClaims = config_.allowDelegatedClaims;\n\n        emit Initialize(msg.sender, config_);\n    }\n\n    /// @inheritdoc ITierV2\n    function report(address account_, uint256[] memory)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return reports[account_];\n    }\n\n    /// @inheritdoc ITierV2\n    function reportTimeForTier(\n        address account_,\n        uint256 tier_,\n        uint256[] calldata\n    ) external view returns (uint256) {\n        return TierReport.reportTimeForTier(reports[account_], tier_);\n    }\n\n    /// @inheritdoc RainVM\n    function fnPtrs() public pure override returns (bytes memory) {\n        return AllStandardOps.fnPtrs();\n    }\n\n    /// Calculates the claim without processing it.\n    /// Read only method that may be useful downstream both onchain and\n    /// offchain if a claimant wants to check the claim amount before deciding\n    /// whether to process it.\n    /// As this is read only there are no checks against delegated claims. It\n    /// is possible to return a value from `calculateClaim` and to not be able\n    /// to process the claim with `claim` if `msg.sender` is not the\n    /// `claimant_`.\n    /// @param claimant_ Address to calculate current claim for.\n    function calculateClaim(address claimant_) public view returns (uint256) {\n        State memory state_ = LibState.fromBytesPacked(\n            SSTORE2.read(vmStatePointer)\n        );\n        bytes memory context_ = new bytes(0x20);\n        uint256 claimantContext_ = uint256(uint160(claimant_));\n        assembly {\n            mstore(add(context_, 0x20), claimantContext_)\n        }\n        eval(context_, state_, ENTRYPOINT);\n        return state_.stack[state_.stackIndex - 1];\n    }\n\n    /// Processes the claim for `claimant_`.\n    /// - Enforces `allowDelegatedClaims` if it is `true` so that `msg.sender`\n    /// must also be `claimant_`.\n    /// - Takes the return from `calculateClaim` and mints for `claimant_`.\n    /// - Records the current block as the claim-tier for this contract.\n    /// - emits a `Claim` event as per `IClaim`.\n    /// @param claimant_ address receiving minted tokens. MUST be `msg.sender`\n    /// if `allowDelegatedClaims` is `false`.\n    /// @param data_ NOT used onchain. Forwarded to `Claim` event for potential\n    /// additional offchain processing.\n    /// @inheritdoc IClaim\n    function claim(address claimant_, bytes calldata data_) external {\n        // Disallow delegated claims if appropriate.\n        if (!allowDelegatedClaims) {\n            require(msg.sender == claimant_, \"DELEGATED_CLAIM\");\n        }\n\n        // Mint the claim.\n        uint256 amount_ = calculateClaim(claimant_);\n        _mint(claimant_, amount_);\n\n        // Record the current block as the latest claim.\n        // This can be diffed/combined with external reports in future claim\n        // calculations.\n        reports[claimant_] = TierReport.updateTimesForTierRange(\n            TierConstants.NEVER_REPORT,\n            TierConstants.TIER_ZERO,\n            TierConstants.TIER_EIGHT,\n            block.timestamp\n        );\n        emit Claim(msg.sender, claimant_, data_);\n    }\n}\n"
    },
    "contracts/tier/libraries/TierConstants.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title TierConstants\n/// @notice Constants for use with tier logic.\nlibrary TierConstants {\n    /// NEVER is 0xFF.. as it is infinitely in the future.\n    /// NEVER for an entire report.\n    uint256 internal constant NEVER_REPORT = type(uint256).max;\n    /// NEVER for a single tier time.\n    uint32 internal constant NEVER_TIME = type(uint32).max;\n\n    /// Always is 0 as it is the genesis block.\n    /// Tiers can't predate the chain but they can predate an `ITierV2`\n    /// contract.\n    uint256 internal constant ALWAYS = 0;\n\n    /// Account has never held a tier.\n    uint256 internal constant TIER_ZERO = 0;\n\n    /// Magic number for tier one.\n    uint256 internal constant TIER_ONE = 1;\n    /// Magic number for tier two.\n    uint256 internal constant TIER_TWO = 2;\n    /// Magic number for tier three.\n    uint256 internal constant TIER_THREE = 3;\n    /// Magic number for tier four.\n    uint256 internal constant TIER_FOUR = 4;\n    /// Magic number for tier five.\n    uint256 internal constant TIER_FIVE = 5;\n    /// Magic number for tier six.\n    uint256 internal constant TIER_SIX = 6;\n    /// Magic number for tier seven.\n    uint256 internal constant TIER_SEVEN = 7;\n    /// Magic number for tier eight.\n    uint256 internal constant TIER_EIGHT = 8;\n    /// Maximum tier is `TIER_EIGHT`.\n    uint256 internal constant MAX_TIER = TIER_EIGHT;\n}\n"
    },
    "contracts/erc20/ERC20Config.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// Constructor config for standard Open Zeppelin ERC20.\n/// @param name Name as defined by Open Zeppelin ERC20.\n/// @param symbol Symbol as defined by Open Zeppelin ERC20.\n/// @param distributor Distributor address of the initial supply.\n/// MAY be zero.\n/// @param initialSupply Initial supply to mint.\n/// MAY be zero.\nstruct ERC20Config {\n    string name;\n    string symbol;\n    address distributor;\n    uint256 initialSupply;\n}\n"
    },
    "contracts/claim/IClaim.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// @title IClaim\n/// @notice Embodies the idea of processing a claim for some kind of reward.\ninterface IClaim {\n    /// `Claim` is emitted whenever `claim` is called to signify that the claim\n    /// has been processed. Makes no assumptions about what is being claimed,\n    /// not even requiring an \"amount\" or similar. Instead there is a generic\n    /// `data` field where contextual information can be logged for offchain\n    /// processing.\n    /// @param sender `msg.sender` authorizing the claim.\n    /// @param claimant The claimant receiving the `Claim`.\n    /// @param data Associated data for the claim call.\n    event Claim(address sender, address claimant, bytes data);\n\n    /// Process a claim for `claimant`.\n    /// It is up to the implementing contract to define what a \"claim\" is, but\n    /// broadly it is expected to be some kind of reward.\n    /// Implementing contracts MAY allow addresses other than `claimant` to\n    /// process a claim but be careful if doing so to avoid griefing!\n    /// Implementing contracts MAY allow `claim` to be called arbitrarily many\n    /// times, or restrict themselves to a single or several calls only.\n    /// @param claimant The address that will receive the result of this claim.\n    function claim(address claimant, bytes calldata data) external;\n}\n"
    },
    "contracts/tier/TierV2.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"./ITierV2.sol\";\n\nabstract contract TierV2 is ITierV2, ERC165 {\n    function supportsInterface(bytes4 interfaceId_)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceId_ == type(ITierV2).interfaceId ||\n            super.supportsInterface(interfaceId_);\n    }\n}\n"
    },
    "contracts/tier/libraries/TierReport.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {ITierV2} from \"../ITierV2.sol\";\nimport \"./TierConstants.sol\";\n\n/// @title TierReport\n/// @notice `TierReport` implements several pure functions that can be\n/// used to interface with reports.\n/// - `tierAtTimeFromReport`: Returns the highest status achieved relative to\n/// a block timestamp and report. Statuses gained after that block are ignored.\n/// - `tierTime`: Returns the timestamp that a given tier has been held\n/// since according to a report.\n/// - `truncateTiersAbove`: Resets all the tiers above the reference tier.\n/// - `updateTimesForTierRange`: Updates a report with a timestamp for every\n///    tier in a range.\n/// - `updateReportWithTierAtTime`: Updates a report to a new tier.\n/// @dev Utilities to consistently read, write and manipulate tiers in reports.\n/// The low-level bit shifting can be difficult to get right so this\n/// factors that out.\nlibrary TierReport {\n    /// Enforce upper limit on tiers so we can do unchecked math.\n    /// @param tier_ The tier to enforce bounds on.\n    modifier maxTier(uint256 tier_) {\n        require(tier_ <= TierConstants.MAX_TIER, \"MAX_TIER\");\n        _;\n    }\n\n    /// Returns the highest tier achieved relative to a block timestamp\n    /// and report.\n    ///\n    /// Note that typically the report will be from the _current_ contract\n    /// state, i.e. `block.timestamp` but not always. Tiers gained after the\n    /// reference time are ignored.\n    ///\n    /// When the `report` comes from a later block than the `timestamp_` this\n    /// means the user must have held the tier continuously from `timestamp_`\n    /// _through_ to the report block.\n    /// I.e. NOT a snapshot.\n    ///\n    /// @param report_ A report as per `ITierV2`.\n    /// @param timestamp_ The timestamp to check the tiers against.\n    /// @return tier_ The highest tier held since `timestamp_` as per `report`.\n    function tierAtTimeFromReport(uint256 report_, uint256 timestamp_)\n        internal\n        pure\n        returns (uint256 tier_)\n    {\n        unchecked {\n            for (tier_ = 0; tier_ < 8; tier_++) {\n                if (uint32(uint256(report_ >> (tier_ * 32))) > timestamp_) {\n                    break;\n                }\n            }\n        }\n    }\n\n    /// Returns the timestamp that a given tier has been held since from a\n    /// report.\n    ///\n    /// The report MUST encode \"never\" as 0xFFFFFFFF. This ensures\n    /// compatibility with `tierAtTimeFromReport`.\n    ///\n    /// @param report_ The report to read a timestamp from.\n    /// @param tier_ The Tier to read the timestamp for.\n    /// @return timestamp_ The timestamp the tier has been held since.\n    function reportTimeForTier(uint256 report_, uint256 tier_)\n        internal\n        pure\n        maxTier(tier_)\n        returns (uint256 timestamp_)\n    {\n        unchecked {\n            // ZERO is a special case. Everyone has always been at least ZERO,\n            // since block 0.\n            if (tier_ == 0) {\n                return 0;\n            }\n\n            uint256 offset_ = (tier_ - 1) * 32;\n            timestamp_ = uint256(uint32(uint256(report_ >> offset_)));\n        }\n    }\n\n    /// Resets all the tiers above the reference tier to 0xFFFFFFFF.\n    ///\n    /// @param report_ Report to truncate with high bit 1s.\n    /// @param tier_ Tier to truncate above (exclusive).\n    /// @return Truncated report.\n    function truncateTiersAbove(uint256 report_, uint256 tier_)\n        internal\n        pure\n        maxTier(tier_)\n        returns (uint256)\n    {\n        unchecked {\n            uint256 offset_ = tier_ * 32;\n            uint256 mask_ = (TierConstants.NEVER_REPORT >> offset_) << offset_;\n            return report_ | mask_;\n        }\n    }\n\n    /// Updates a report with a timestamp for a given tier.\n    /// More gas efficient than `updateTimesForTierRange` if only a single\n    /// tier is being modified.\n    /// The tier at/above the given tier is updated. E.g. tier `0` will update\n    /// the time for tier `1`.\n    /// @param report_ Report to use as the baseline for the updated report.\n    /// @param tier_ The tier level to update.\n    /// @param timestamp_ The new block number for `tier_`.\n    /// @return updatedReport_ The newly updated `report_`.\n    function updateTimeAtTier(\n        uint256 report_,\n        uint256 tier_,\n        uint256 timestamp_\n    ) internal pure maxTier(tier_) returns (uint256 updatedReport_) {\n        unchecked {\n            uint256 offset_ = tier_ * 32;\n            updatedReport_ =\n                (report_ &\n                    ~uint256(uint256(TierConstants.NEVER_TIME) << offset_)) |\n                uint256(timestamp_ << offset_);\n        }\n    }\n\n    /// Updates a report with a block number for every tier in a range.\n    ///\n    /// Does nothing if the end status is equal or less than the start tier.\n    /// @param report_ The report to update.\n    /// @param startTier_ The tier at the start of the range (exclusive).\n    /// @param endTier_ The tier at the end of the range (inclusive).\n    /// @param timestamp_ The timestamp to set for every tier in the range.\n    /// @return updatedReport_ The updated report.\n    function updateTimesForTierRange(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 timestamp_\n    ) internal pure maxTier(endTier_) returns (uint256 updatedReport_) {\n        unchecked {\n            uint256 offset_;\n            for (uint256 i_ = startTier_; i_ < endTier_; i_++) {\n                offset_ = i_ * 32;\n                report_ =\n                    (report_ &\n                        ~uint256(\n                            uint256(TierConstants.NEVER_TIME) << offset_\n                        )) |\n                    uint256(timestamp_ << offset_);\n            }\n            updatedReport_ = report_;\n        }\n    }\n\n    /// Updates a report to a new status.\n    ///\n    /// Internally dispatches to `truncateTiersAbove` and\n    /// `updateBlocksForTierRange`.\n    /// The dispatch is based on whether the new tier is above or below the\n    /// current tier.\n    /// The `startTier_` MUST match the result of `tierAtBlockFromReport`.\n    /// It is expected the caller will know the current tier when\n    /// calling this function and need to do other things in the calling scope\n    /// with it.\n    ///\n    /// @param report_ The report to update.\n    /// @param startTier_ The tier to start updating relative to. Data above\n    /// this tier WILL BE LOST so probably should be the current tier.\n    /// @param endTier_ The new highest tier held, at the given block number.\n    /// @param timestamp_ The timestamp_ to update the highest tier to, and\n    /// intermediate tiers from `startTier_`.\n    /// @return updatedReport_ The updated report.\n    function updateReportWithTierAtTime(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 timestamp_\n    ) internal pure returns (uint256 updatedReport_) {\n        updatedReport_ = endTier_ < startTier_\n            ? truncateTiersAbove(report_, endTier_)\n            : updateTimesForTierRange(\n                report_,\n                startTier_,\n                endTier_,\n                timestamp_\n            );\n    }\n}\n"
    },
    "contracts/vm/VMStateBuilder.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\nimport \"./RainVM.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../sstore2/SSTORE2.sol\";\n\n/// Config required to build a new `State`.\n/// @param sources Sources verbatim.\n/// @param constants Constants verbatim.\nstruct StateConfig {\n    bytes[] sources;\n    uint256[] constants;\n}\n\n/// @param stackIndex The current stack index as the state builder moves\n/// through each opcode and applies the appropriate pops and pushes.\n/// @param stackLength The maximum length of the stack seen so far due to stack\n/// index movements. If the stack index underflows this will be close to\n/// uint256 max and will ultimately error. It will also error if it overflows\n/// MAX_STACK_LENGTH.\n/// @param argumentsLength The maximum length of arguments seen so far due to\n/// zipmap calls. Will be 0 if there are no zipmap calls.\n/// @param storageLength The VM contract MUST specify which range of storage\n/// slots can be read by VM scripts as [0, storageLength). If the storageLength\n/// is 0 then no storage slots may be read by opcodes. In practise opcodes are\n/// uint8 so storage slots beyond 255 cannot be read, notably all mappings will\n/// be inaccessible.\n/// @param opcodesLength The VM contract MUST specify how many valid opcodes\n/// there are, where a valid opcode is one with a corresponding valid function\n/// pointer in the array returned by `fnPtrs`. If this is not set correctly\n/// then an attacker may specify an opcode that points to data beyond the valid\n/// fnPtrs, which has undefined and therefore possibly catastrophic behaviour\n/// for the implementing contract, up to and including total funds loss.\nstruct Bounds {\n    uint256 entrypoint;\n    uint256 minFinalStackIndex;\n    uint256 stackIndex;\n    uint256 stackLength;\n    uint256 argumentsLength;\n    uint256 storageLength;\n    uint256 opcodesLength;\n}\n\nuint256 constant MAX_STACK_LENGTH = type(uint8).max;\n\ncontract VMStateBuilder {\n    using Math for uint256;\n\n    address private immutable _stackPopsFnPtrs;\n    address private immutable _stackPushesFnPtrs;\n    mapping(address => address) private ptrCache;\n\n    constructor() {\n        _stackPopsFnPtrs = SSTORE2.write(stackPopsFnPtrs());\n        _stackPushesFnPtrs = SSTORE2.write(stackPushesFnPtrs());\n    }\n\n    function _packedFnPtrs(address vm_) private returns (bytes memory) {\n        unchecked {\n            bytes memory packedPtrs_ = SSTORE2.read(ptrCache[vm_]);\n            if (packedPtrs_.length == 0) {\n                ptrCache[vm_] = SSTORE2.write(packFnPtrs(RainVM(vm_).fnPtrs()));\n                return _packedFnPtrs(vm_);\n            }\n            return packedPtrs_;\n        }\n    }\n\n    /// Builds a new `State` bytes from `StateConfig`.\n    /// Empty stack and arguments with stack index 0.\n    /// @param config_ State config to build the new `State`.\n    function buildState(\n        address vm_,\n        StateConfig memory config_,\n        Bounds[] memory boundss_\n    ) external returns (bytes memory) {\n        unchecked {\n            bytes memory packedFnPtrs_ = _packedFnPtrs(vm_);\n            uint256 storageLength_ = RainVM(vm_).storageOpcodesRange().length;\n            uint256 argumentsLength_ = 0;\n            uint256 stackLength_ = 0;\n\n            for (uint256 b_ = 0; b_ < boundss_.length; b_++) {\n                boundss_[b_].storageLength = storageLength_;\n\n                // Opcodes are 1 byte and fnPtrs are 2 bytes so we halve the\n                // length to get the valid opcodes length.\n                boundss_[b_].opcodesLength = packedFnPtrs_.length / 2;\n                ensureIntegrity(config_, boundss_[b_]);\n                argumentsLength_ = argumentsLength_.max(\n                    boundss_[b_].argumentsLength\n                );\n                stackLength_ = stackLength_.max(boundss_[b_].stackLength);\n                // Stack needs to be high enough to read from after eval.\n                require(\n                    boundss_[b_].stackIndex >= boundss_[b_].minFinalStackIndex,\n                    \"FINAL_STACK_INDEX\"\n                );\n            }\n\n            // build a new constants array with space for the arguments.\n            uint256[] memory constants_ = new uint256[](\n                config_.constants.length + argumentsLength_\n            );\n            for (uint256 i_ = 0; i_ < config_.constants.length; i_++) {\n                constants_[i_] = config_.constants[i_];\n            }\n\n            bytes[] memory ptrSources_ = new bytes[](config_.sources.length);\n            for (uint256 i_ = 0; i_ < config_.sources.length; i_++) {\n                ptrSources_[i_] = ptrSource(packedFnPtrs_, config_.sources[i_]);\n            }\n\n            return\n                LibState.toBytesPacked(\n                    State(\n                        0,\n                        new uint256[](stackLength_),\n                        ptrSources_,\n                        constants_,\n                        config_.constants.length\n                    )\n                );\n        }\n    }\n\n    function ptrSource(bytes memory packedFnPtrs_, bytes memory source_)\n        public\n        pure\n        returns (bytes memory)\n    {\n        unchecked {\n            uint256 sourceLen_ = source_.length;\n            require(sourceLen_ % 2 == 0, \"ODD_SOURCE_LENGTH\");\n\n            bytes memory ptrSource_ = new bytes((sourceLen_ * 3) / 2);\n\n            uint256 rainVMOpsLength_ = RAIN_VM_OPS_LENGTH;\n            assembly {\n                let start_ := 1\n                let end_ := add(sourceLen_, 1)\n                for {\n                    let i_ := start_\n                    let o_ := 0\n                } lt(i_, end_) {\n                    i_ := add(i_, 1)\n                } {\n                    let op_ := byte(31, mload(add(source_, i_)))\n                    // is opcode\n                    if mod(i_, 2) {\n                        // core ops simply zero pad.\n                        if lt(op_, rainVMOpsLength_) {\n                            o_ := add(o_, 1)\n                            mstore8(add(ptrSource_, add(0x20, o_)), op_)\n                        }\n                        if iszero(lt(op_, rainVMOpsLength_)) {\n                            let fn_ := mload(\n                                add(packedFnPtrs_, add(0x2, mul(op_, 0x2)))\n                            )\n                            mstore8(\n                                add(ptrSource_, add(0x20, o_)),\n                                byte(30, fn_)\n                            )\n                            o_ := add(o_, 1)\n                            mstore8(\n                                add(ptrSource_, add(0x20, o_)),\n                                byte(31, fn_)\n                            )\n                        }\n                    }\n                    // is operand\n                    if iszero(mod(i_, 2)) {\n                        mstore8(add(ptrSource_, add(0x20, o_)), op_)\n                    }\n                    o_ := add(o_, 1)\n                }\n            }\n            return ptrSource_;\n        }\n    }\n\n    function packFnPtrs(bytes memory fnPtrs_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        unchecked {\n            require(fnPtrs_.length % 0x20 == 0, \"BAD_FN_PTRS_LENGTH\");\n            bytes memory fnPtrsPacked_ = new bytes(fnPtrs_.length / 0x10);\n            assembly {\n                for {\n                    let i_ := 0\n                    let o_ := 0x02\n                } lt(i_, mload(fnPtrs_)) {\n                    i_ := add(i_, 0x20)\n                    o_ := add(o_, 0x02)\n                } {\n                    let location_ := add(fnPtrsPacked_, o_)\n                    let old_ := mload(location_)\n                    let new_ := or(old_, mload(add(fnPtrs_, add(0x20, i_))))\n                    mstore(location_, new_)\n                }\n            }\n            return fnPtrsPacked_;\n        }\n    }\n\n    function _ensureIntegrityZipmap(\n        StateConfig memory stateConfig_,\n        Bounds memory bounds_,\n        uint256 operand_\n    ) private view {\n        unchecked {\n            uint256 valLength_ = (operand_ >> 5) + 1;\n            // read underflow here will show up as an OOB max later.\n            bounds_.stackIndex -= valLength_;\n            bounds_.stackLength = bounds_.stackLength.max(bounds_.stackIndex);\n            bounds_.argumentsLength = bounds_.argumentsLength.max(valLength_);\n            uint256 loopTimes_ = 1 << ((operand_ >> 3) & 0x03);\n            uint256 outerEntrypoint_ = bounds_.entrypoint;\n            uint256 innerEntrypoint_ = operand_ & 0x07;\n            bounds_.entrypoint = innerEntrypoint_;\n            for (uint256 n_ = 0; n_ < loopTimes_; n_++) {\n                ensureIntegrity(stateConfig_, bounds_);\n            }\n            bounds_.entrypoint = outerEntrypoint_;\n        }\n    }\n\n    function ensureIntegrity(\n        StateConfig memory stateConfig_,\n        Bounds memory bounds_\n    ) public view {\n        unchecked {\n            uint256 entrypoint_ = bounds_.entrypoint;\n            require(stateConfig_.sources.length > entrypoint_, \"MIN_SOURCES\");\n            bytes memory stackPopsFns_ = SSTORE2.read(_stackPopsFnPtrs);\n            bytes memory stackPushesFns_ = SSTORE2.read(_stackPushesFnPtrs);\n            uint256 i_ = 0;\n            uint256 sourceLen_;\n            uint256 opcode_;\n            uint256 operand_;\n            uint256 sourceLocation_;\n\n            assembly {\n                sourceLocation_ := mload(\n                    add(mload(stateConfig_), add(0x20, mul(entrypoint_, 0x20)))\n                )\n\n                sourceLen_ := mload(sourceLocation_)\n            }\n\n            while (i_ < sourceLen_) {\n                assembly {\n                    i_ := add(i_, 2)\n                    let op_ := mload(add(sourceLocation_, i_))\n                    opcode_ := byte(30, op_)\n                    operand_ := byte(31, op_)\n                }\n\n                // Additional integrity checks for core opcodes.\n                if (opcode_ < RAIN_VM_OPS_LENGTH) {\n                    if (opcode_ == OPCODE_CONSTANT) {\n                        // trying to read past the end of the constants array.\n                        // note that it is possible for a script to reach into\n                        // arguments space after a zipmap has completed. While\n                        // this is almost certainly a critical bug for the\n                        // script it doesn't expose the ability to read past\n                        // the constants array in memory so we allow it here.\n                        require(\n                            operand_ <\n                                (bounds_.argumentsLength +\n                                    stateConfig_.constants.length)\n                        );\n                        bounds_.stackIndex++;\n                    } else if (opcode_ == OPCODE_STACK) {\n                        // trying to read past the current stack top.\n                        require(operand_ < bounds_.stackIndex);\n                        bounds_.stackIndex++;\n                    } else if (opcode_ == OPCODE_CONTEXT) {\n                        // Note that context length check is handled at runtime\n                        // because we don't know how long context should be at\n                        // this point.\n                        bounds_.stackIndex++;\n                    } else if (opcode_ == OPCODE_STORAGE) {\n                        // trying to read past allowed storage slots.\n                        require(operand_ < bounds_.storageLength);\n                        bounds_.stackIndex++;\n                    }\n                    if (opcode_ == OPCODE_ZIPMAP) {\n                        _ensureIntegrityZipmap(stateConfig_, bounds_, operand_);\n                    }\n                } else {\n                    // Opcodes can't exceed the bounds of valid fn pointers.\n                    require(opcode_ < bounds_.opcodesLength, \"MAX_OPCODE\");\n                    function(uint256) pure returns (uint256) popsFn_;\n                    function(uint256) pure returns (uint256) pushesFn_;\n                    assembly {\n                        popsFn_ := mload(\n                            add(stackPopsFns_, add(0x20, mul(opcode_, 0x20)))\n                        )\n                        pushesFn_ := mload(\n                            add(stackPushesFns_, add(0x20, mul(opcode_, 0x20)))\n                        )\n                    }\n\n                    // This will catch popping/reading from underflowing the\n                    // stack as it will show up as an overflow on the stack\n                    // length below.\n                    bounds_.stackIndex -= popsFn_(operand_);\n                    bounds_.stackLength = bounds_.stackLength.max(\n                        bounds_.stackIndex\n                    );\n\n                    bounds_.stackIndex += pushesFn_(operand_);\n                }\n\n                bounds_.stackLength = bounds_.stackLength.max(\n                    bounds_.stackIndex\n                );\n            }\n            // Both an overflow or underflow in uint256 space will show up as\n            // an upper bound exceeding the uint8 space.\n            require(bounds_.stackLength <= MAX_STACK_LENGTH, \"MAX_STACK\");\n        }\n    }\n\n    function stackPopsFnPtrs() public pure virtual returns (bytes memory) {}\n\n    function stackPushesFnPtrs() public pure virtual returns (bytes memory) {}\n}\n"
    },
    "contracts/vm/RainVM.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../math/SaturatingMath.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// Everything required to evaluate and track the state of a rain script.\n/// As this is a struct it will be in memory when passed to `RainVM` and so\n/// will be modified by reference internally. This is important for gas\n/// efficiency; the stack, arguments and stackIndex will likely be mutated by\n/// the running script.\n/// @param stackIndex Opcodes write to the stack at the stack index and can\n/// consume from the stack by decrementing the index and reading between the\n/// old and new stack index.\n/// IMPORANT: The stack is never zeroed out so the index must be used to\n/// find the \"top\" of the stack as the result of an `eval`.\n/// @param stack Stack is the general purpose runtime state that opcodes can\n/// read from and write to according to their functionality.\n/// @param sources Sources available to be executed by `eval`.\n/// Notably `ZIPMAP` can also select a source to execute by index.\n/// @param constants Constants that can be copied to the stack by index by\n/// `VAL`.\n/// @param arguments `ZIPMAP` populates arguments which can be copied to the\n/// stack by `VAL`.\nstruct State {\n    uint256 stackIndex;\n    uint256[] stack;\n    bytes[] ptrSources;\n    uint256[] constants;\n    /// `ZIPMAP` populates arguments into constants which can be copied to the\n    /// stack by `VAL` as usual, starting from this index. This copying is\n    /// destructive so it is recommended to leave space in the constants array.\n    uint256 argumentsIndex;\n}\n\nstruct StorageOpcodesRange {\n    uint256 pointer;\n    uint256 length;\n}\n\nlibrary LibState {\n    /// Put the state back to a freshly eval-able value. The same state can be\n    /// run more than once (e.g. two different entrypoints) to yield different\n    /// stacks, as long as all the sources are VALID and reset is called\n    /// between each eval call.\n    /// Generally this should be called whenever eval is run over a state that\n    /// is exposed to the calling context (e.g. it is an argument) so that the\n    /// caller may safely eval multiple times on any state it has in scope.\n    function reset(State memory state_) internal pure {\n        state_.stackIndex = 0;\n    }\n\n    function toBytesDebug(State memory state_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(state_);\n    }\n\n    function fromBytesPacked(bytes memory stateBytes_)\n        internal\n        pure\n        returns (State memory)\n    {\n        unchecked {\n            State memory state_;\n            uint256 indexes_;\n            assembly {\n                // Load indexes from state bytes.\n                indexes_ := mload(add(stateBytes_, 0x20))\n                // mask out everything but the constants length from state\n                // bytes.\n                mstore(add(stateBytes_, 0x20), and(indexes_, 0xFF))\n                // point state constants at state bytes\n                mstore(add(state_, 0x60), add(stateBytes_, 0x20))\n            }\n            // Stack index 0 is implied.\n            state_.stack = new uint256[]((indexes_ >> 8) & 0xFF);\n            state_.argumentsIndex = (indexes_ >> 16) & 0xFF;\n            uint256 sourcesLen_ = (indexes_ >> 24) & 0xFF;\n            bytes[] memory ptrSources_;\n            uint256[] memory ptrSourcesPtrs_ = new uint256[](sourcesLen_);\n\n            assembly {\n                let sourcesStart_ := add(\n                    stateBytes_,\n                    add(\n                        // 0x40 for constants and state array length\n                        0x40,\n                        // skip over length of constants\n                        mul(0x20, mload(add(stateBytes_, 0x20)))\n                    )\n                )\n                let cursor_ := sourcesStart_\n\n                for {\n                    let i_ := 0\n                } lt(i_, sourcesLen_) {\n                    i_ := add(i_, 1)\n                } {\n                    // sources_ is a dynamic array so it is a list of\n                    // pointers that can be set literally to the cursor_\n                    mstore(\n                        add(ptrSourcesPtrs_, add(0x20, mul(i_, 0x20))),\n                        cursor_\n                    )\n                    // move the cursor by the length of the source in bytes\n                    cursor_ := add(cursor_, add(0x20, mload(cursor_)))\n                }\n                // point state at sources_ rather than clone in memory\n                ptrSources_ := ptrSourcesPtrs_\n                mstore(add(state_, 0x40), ptrSources_)\n            }\n            return state_;\n        }\n    }\n\n    function toBytesPacked(State memory state_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        unchecked {\n            // indexes + constants\n            uint256[] memory constants_ = state_.constants;\n            // constants is first so we can literally use it on the other end\n            uint256 indexes_ = state_.constants.length |\n                (state_.stack.length << 8) |\n                (state_.argumentsIndex << 16) |\n                (state_.ptrSources.length << 24);\n            bytes memory ret_ = bytes.concat(\n                bytes32(indexes_),\n                abi.encodePacked(constants_)\n            );\n            for (uint256 i_ = 0; i_ < state_.ptrSources.length; i_++) {\n                ret_ = bytes.concat(\n                    ret_,\n                    bytes32(state_.ptrSources[i_].length),\n                    state_.ptrSources[i_]\n                );\n            }\n            return ret_;\n        }\n    }\n}\n\n/// @dev Copies a value either off `constants` to the top of the stack.\nuint256 constant OPCODE_CONSTANT = 0;\n/// @dev Duplicates any value in the stack to the top of the stack. The operand\n/// specifies the index to copy from.\nuint256 constant OPCODE_STACK = 1;\nuint256 constant OPCODE_CONTEXT = 2;\nuint256 constant OPCODE_STORAGE = 3;\n/// @dev Takes N values off the stack, interprets them as an array then zips\n/// and maps a source from `sources` over them.\nuint256 constant OPCODE_ZIPMAP = 4;\n/// @dev ABI encodes the entire stack and logs it to the hardhat console.\nuint256 constant OPCODE_DEBUG = 5;\n/// @dev Number of provided opcodes for `RainVM`.\nuint256 constant RAIN_VM_OPS_LENGTH = 6;\n\nuint256 constant DEBUG_STATE_ABI = 0;\nuint256 constant DEBUG_STATE_PACKED = 1;\nuint256 constant DEBUG_STACK = 2;\nuint256 constant DEBUG_STACK_INDEX = 3;\n\n/// @title RainVM\n/// @notice micro VM for implementing and executing custom contract DSLs.\n/// Libraries and contracts map opcodes to `view` functionality then RainVM\n/// runs rain scripts using these opcodes. Rain scripts dispatch as pairs of\n/// bytes. The first byte is an opcode to run and the second byte is a value\n/// the opcode can use contextually to inform how to run. Typically opcodes\n/// will read/write to the stack to produce some meaningful final state after\n/// all opcodes have been dispatched.\n///\n/// The only thing required to run a rain script is a `State` struct to pass\n/// to `eval`, and the index of the source to run. Additional context can\n/// optionally be provided to be used by opcodes. For example, an `ITierV2`\n/// contract can take the input of `report`, abi encode it as context, then\n/// expose a local opcode that copies this account to the stack. The state will\n/// be mutated by reference rather than returned by `eval`, this is to make it\n/// very clear to implementers that the inline mutation is occurring.\n///\n/// Rain scripts run \"top to bottom\", i.e. \"left to right\".\n/// See the tests for examples on how to construct rain script in JavaScript\n/// then pass to `ImmutableSource` contracts deployed by a factory that then\n/// run `eval` to produce a final value.\n///\n/// There are only 4 \"core\" opcodes for `RainVM`:\n/// - `0`: Copy value from either `constants` at index `operand` to the top of\n///   the stack.\n/// - `1`: Duplicates the value at stack index `operand_` to the top of the\n///   stack.\n/// - `2`: Zipmap takes N values from the stack, interprets each as an array of\n///   configurable length, then zips them into `arguments` and maps a source\n///   from `sources` over these. See `zipmap` for more details.\n/// - `3`: Debug prints the state to the console log as per hardhat.\n///\n/// To do anything useful the contract that inherits `RainVM` needs to provide\n/// opcodes to build up an internal DSL. This may sound complex but it only\n/// requires mapping opcode integers to functions to call, and reading/writing\n/// values to the stack as input/output for these functions. Further, opcode\n/// packs are provided in rain that any inheriting contract can use as a normal\n/// solidity library. See `MathOps.sol` opcode pack and the\n/// `CalculatorTest.sol` test contract for an example of how to dispatch\n/// opcodes and handle the results in a wrapping contract.\n///\n/// RainVM natively has no concept of branching logic such as `if` or loops.\n/// An opcode pack could implement these similar to the core zipmap by lazily\n/// evaluating a source from `sources` based on some condition, etc. Instead\n/// some simpler, eagerly evaluated selection tools such as `min` and `max` in\n/// the `MathOps` opcode pack are provided. Future versions of `RainVM` MAY\n/// implement lazy `if` and other similar patterns.\n///\n/// The `eval` function is `view` because rain scripts are expected to compute\n/// results only without modifying any state. The contract wrapping the VM is\n/// free to mutate as usual. This model encourages exposing only read-only\n/// functionality to end-user deployers who provide scripts to a VM factory.\n/// Removing all writes removes a lot of potential foot-guns for rain script\n/// authors and allows VM contract authors to reason more clearly about the\n/// input/output of the wrapping solidity code.\n///\n/// Internally `RainVM` makes heavy use of unchecked math and assembly logic\n/// as the opcode dispatch logic runs on a tight loop and so gas costs can ramp\n/// up very quickly. Implementing contracts and opcode packs SHOULD require\n/// that opcodes they receive do not exceed the codes they are expecting.\nabstract contract RainVM {\n    using Math for uint256;\n    using SaturatingMath for uint256;\n\n    /// Default is to disallow all storage access to opcodes.\n    function storageOpcodesRange()\n        public\n        pure\n        virtual\n        returns (StorageOpcodesRange memory)\n    {\n        return StorageOpcodesRange(0, 0);\n    }\n\n    function fnPtrs() public pure virtual returns (bytes memory);\n\n    /// Zipmap is rain script's native looping construct.\n    /// N values are taken from the stack as `uint256` then split into `uintX`\n    /// values where X is configurable by `operand_`. Each 1 increment in the\n    /// operand size config doubles the number of items in the implied arrays.\n    /// For example, size 0 is 1 `uint256` value, size 1 is\n    /// `2x `uint128` values, size 2 is 4x `uint64` values and so on.\n    ///\n    /// The implied arrays are zipped and then copied into `arguments` and\n    /// mapped over with a source from `sources`. Each iteration of the mapping\n    /// copies values into `arguments` from index `0` but there is no attempt\n    /// to zero out any values that may already be in the `arguments` array.\n    /// It is the callers responsibility to ensure that the `arguments` array\n    /// is correctly sized and populated for the mapped source.\n    ///\n    /// The `operand_` for the zipmap opcode is split into 3 components:\n    /// - 3 low bits: The index of the source to use from `sources`.\n    /// - 2 middle bits: The size of the loop, where 0 is 1 iteration\n    /// - 3 high bits: The number of vals to be zipped from the stack where 0\n    ///   is 1 value to be zipped.\n    ///\n    /// This is a separate function to avoid blowing solidity compile stack.\n    /// In the future it may be moved inline to `eval` for gas efficiency.\n    ///\n    /// See https://en.wikipedia.org/wiki/Zipping_(computer_science)\n    /// See https://en.wikipedia.org/wiki/Map_(higher-order_function)\n    /// @param context_ Domain specific context the wrapping contract can\n    /// provide to passthrough back to its own opcodes.\n    /// @param state_ The execution state of the VM.\n    /// @param operand_ The operand_ associated with this dispatch to zipmap.\n    function zipmap(\n        bytes memory context_,\n        State memory state_,\n        uint256 stackTopLocation_,\n        uint256 operand_\n    ) internal view returns (uint256) {\n        unchecked {\n            uint256 sourceIndex_ = operand_ & 0x07;\n            uint256 loopSize_ = (operand_ >> 3) & 0x03;\n            uint256 mask_;\n            uint256 stepSize_;\n            if (loopSize_ == 0) {\n                mask_ = type(uint256).max;\n                stepSize_ = 0x100;\n            } else if (loopSize_ == 1) {\n                mask_ = type(uint128).max;\n                stepSize_ = 0x80;\n            } else if (loopSize_ == 2) {\n                mask_ = type(uint64).max;\n                stepSize_ = 0x40;\n            } else {\n                mask_ = type(uint32).max;\n                stepSize_ = 0x20;\n            }\n            uint256 valLength_ = (operand_ >> 5) + 1;\n\n            // Set aside base values so they can't be clobbered during eval\n            // as the stack changes on each loop.\n            uint256[] memory baseVals_ = new uint256[](valLength_);\n            uint256 baseValsBottom_;\n            {\n                assembly {\n                    baseValsBottom_ := add(baseVals_, 0x20)\n                    for {\n                        let cursor_ := sub(\n                            stackTopLocation_,\n                            mul(valLength_, 0x20)\n                        )\n                        let baseValsCursor_ := baseValsBottom_\n                    } lt(cursor_, stackTopLocation_) {\n                        cursor_ := add(cursor_, 0x20)\n                        baseValsCursor_ := add(baseValsCursor_, 0x20)\n                    } {\n                        mstore(baseValsCursor_, mload(cursor_))\n                    }\n                }\n            }\n\n            uint256 argumentsBottomLocation_;\n            assembly {\n                let constantsBottomLocation_ := add(\n                    mload(add(state_, 0x60)),\n                    0x20\n                )\n                argumentsBottomLocation_ := add(\n                    constantsBottomLocation_,\n                    mul(\n                        0x20,\n                        mload(\n                            // argumentsIndex\n                            add(state_, 0x80)\n                        )\n                    )\n                )\n            }\n\n            for (uint256 step_ = 0; step_ < 0x100; step_ += stepSize_) {\n                // Prepare arguments.\n                {\n                    // max cursor is in this scope to avoid stack overflow from\n                    // solidity.\n                    uint256 maxCursor_ = baseValsBottom_ + (valLength_ * 0x20);\n                    uint256 argumentsCursor_ = argumentsBottomLocation_;\n                    uint256 cursor_ = baseValsBottom_;\n                    while (cursor_ < maxCursor_) {\n                        assembly {\n                            mstore(\n                                argumentsCursor_,\n                                and(shr(step_, mload(cursor_)), mask_)\n                            )\n                            cursor_ := add(cursor_, 0x20)\n                            argumentsCursor_ := add(argumentsCursor_, 0x20)\n                        }\n                    }\n                }\n                stackTopLocation_ = eval(context_, state_, sourceIndex_);\n            }\n            return stackTopLocation_;\n        }\n    }\n\n    /// Evaluates a rain script.\n    /// The main workhorse of the rain VM, `eval` runs any core opcodes and\n    /// dispatches anything it is unaware of to the implementing contract.\n    /// For a script to be useful the implementing contract must override\n    /// `applyOp` and dispatch non-core opcodes to domain specific logic. This\n    /// could be mathematical operations for a calculator, tier reports for\n    /// a membership combinator, entitlements for a minting curve, etc.\n    ///\n    /// Everything required to coordinate the execution of a rain script to\n    /// completion is contained in the `State`. The context and source index\n    /// are provided so the caller can provide additional data and kickoff the\n    /// opcode dispatch from the correct source in `sources`.\n    function eval(\n        bytes memory context_,\n        State memory state_,\n        uint256 sourceIndex_\n    ) internal view returns (uint256) {\n        unchecked {\n            uint256 pc_ = 0;\n            uint256 opcode_;\n            uint256 operand_;\n            uint256 sourceLocation_;\n            uint256 sourceLen_;\n            uint256 constantsBottomLocation_;\n            uint256 stackBottomLocation_;\n            uint256 stackTopLocation_;\n            uint256 firstFnPtrLocation_;\n\n            assembly {\n                let stackLocation_ := mload(add(state_, 0x20))\n                stackBottomLocation_ := add(stackLocation_, 0x20)\n                stackTopLocation_ := add(\n                    stackBottomLocation_,\n                    // Add stack index offset.\n                    mul(mload(state_), 0x20)\n                )\n                sourceLocation_ := mload(\n                    add(\n                        mload(add(state_, 0x40)),\n                        add(0x20, mul(sourceIndex_, 0x20))\n                    )\n                )\n                sourceLen_ := mload(sourceLocation_)\n                constantsBottomLocation_ := add(mload(add(state_, 0x60)), 0x20)\n                // first fn pointer is seen if we move two bytes into the data.\n                firstFnPtrLocation_ := add(mload(add(state_, 0xA0)), 0x02)\n            }\n\n            // Loop until complete.\n            while (pc_ < sourceLen_) {\n                assembly {\n                    pc_ := add(pc_, 3)\n                    let op_ := mload(add(sourceLocation_, pc_))\n                    operand_ := byte(31, op_)\n                    opcode_ := and(shr(8, op_), 0xFFFF)\n                }\n\n                if (opcode_ < RAIN_VM_OPS_LENGTH) {\n                    if (opcode_ == OPCODE_CONSTANT) {\n                        assembly {\n                            mstore(\n                                stackTopLocation_,\n                                mload(\n                                    add(\n                                        constantsBottomLocation_,\n                                        mul(0x20, operand_)\n                                    )\n                                )\n                            )\n                            stackTopLocation_ := add(stackTopLocation_, 0x20)\n                        }\n                    } else if (opcode_ == OPCODE_STACK) {\n                        assembly {\n                            mstore(\n                                stackTopLocation_,\n                                mload(\n                                    add(\n                                        stackBottomLocation_,\n                                        mul(operand_, 0x20)\n                                    )\n                                )\n                            )\n                            stackTopLocation_ := add(stackTopLocation_, 0x20)\n                        }\n                    } else if (opcode_ == OPCODE_CONTEXT) {\n                        // This is the only runtime integrity check that we do\n                        // as it is not possible to know how long context might\n                        // be in general until runtime.\n                        require(\n                            operand_ * 0x20 < context_.length,\n                            \"CONTEXT_LENGTH\"\n                        );\n                        assembly {\n                            mstore(\n                                stackTopLocation_,\n                                mload(\n                                    add(\n                                        context_,\n                                        add(0x20, mul(0x20, operand_))\n                                    )\n                                )\n                            )\n                            stackTopLocation_ := add(stackTopLocation_, 0x20)\n                        }\n                    } else if (opcode_ == OPCODE_STORAGE) {\n                        StorageOpcodesRange\n                            memory storageOpcodesRange_ = storageOpcodesRange();\n                        assembly {\n                            mstore(\n                                stackTopLocation_,\n                                sload(\n                                    add(operand_, mload(storageOpcodesRange_))\n                                )\n                            )\n                            stackTopLocation_ := add(stackTopLocation_, 0x20)\n                        }\n                    } else if (opcode_ == OPCODE_ZIPMAP) {\n                        stackTopLocation_ = zipmap(\n                            context_,\n                            state_,\n                            stackTopLocation_,\n                            operand_\n                        );\n                    } else {\n                        bytes memory debug_;\n                        if (operand_ == DEBUG_STATE_ABI) {\n                            debug_ = abi.encode(state_);\n                        } else if (operand_ == DEBUG_STATE_PACKED) {\n                            debug_ = LibState.toBytesPacked(state_);\n                        } else if (operand_ == DEBUG_STACK) {\n                            debug_ = abi.encodePacked(state_.stack);\n                        } else if (operand_ == DEBUG_STACK_INDEX) {\n                            debug_ = abi.encodePacked(state_.stackIndex);\n                        }\n                        if (debug_.length > 0) {\n                            console.logBytes(debug_);\n                        }\n                    }\n                } else {\n                    function(uint256, uint256) view returns (uint256) fn_;\n                    assembly {\n                        fn_ := opcode_\n                    }\n                    stackTopLocation_ = fn_(operand_, stackTopLocation_);\n                }\n                // The stack index may be the same as the length as this means\n                // the stack is full. But we cannot write past the end of the\n                // stack. This also catches a stack index that underflows due\n                // to unchecked or assembly math. This check MAY be redundant\n                // with standard OOB checks on the stack array due to indexing\n                // into it, but is a required guard in the case of VM assembly.\n                // Future versions of the VM will precalculate all stack\n                // movements at deploy time rather than runtime as this kind of\n                // accounting adds nontrivial gas across longer scripts that\n                // include many opcodes.\n                // Note: This check would NOT be safe in the case that some\n                // opcode used assembly in a way that can underflow the stack\n                // as this would allow a malicious rain script to write to the\n                // stack length and/or the stack index.\n                require(\n                    state_.stackIndex <= state_.stack.length,\n                    \"STACK_OVERFLOW\"\n                );\n            }\n            state_.stackIndex =\n                (stackTopLocation_ - stackBottomLocation_) /\n                0x20;\n            return stackTopLocation_;\n        }\n    }\n}\n"
    },
    "contracts/vm/ops/AllStandardOps.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../RainVM.sol\";\nimport \"./erc20/OpERC20BalanceOf.sol\";\nimport \"./erc20/OpERC20TotalSupply.sol\";\nimport \"./erc20/snapshot/OpERC20SnapshotBalanceOfAt.sol\";\nimport \"./erc20/snapshot/OpERC20SnapshotTotalSupplyAt.sol\";\nimport \"./erc721/OpERC721BalanceOf.sol\";\nimport \"./erc721/OpERC721OwnerOf.sol\";\nimport \"./erc1155/OpERC1155BalanceOf.sol\";\nimport \"./erc1155/OpERC1155BalanceOfBatch.sol\";\nimport \"./evm/OpBlockNumber.sol\";\nimport \"./evm/OpCaller.sol\";\nimport \"./evm/OpThisAddress.sol\";\nimport \"./evm/OpTimestamp.sol\";\nimport \"./math/fixedPoint/OpFixedPointScale18.sol\";\nimport \"./math/fixedPoint/OpFixedPointScale18Div.sol\";\nimport \"./math/fixedPoint/OpFixedPointScale18Mul.sol\";\nimport \"./math/fixedPoint/OpFixedPointScaleBy.sol\";\nimport \"./math/fixedPoint/OpFixedPointScaleN.sol\";\nimport \"./math/logic/OpAny.sol\";\nimport \"./math/logic/OpEagerIf.sol\";\nimport \"./math/logic/OpEqualTo.sol\";\nimport \"./math/logic/OpEvery.sol\";\nimport \"./math/logic/OpGreaterThan.sol\";\nimport \"./math/logic/OpIsZero.sol\";\nimport \"./math/logic/OpLessThan.sol\";\nimport \"./math/saturating/OpSaturatingAdd.sol\";\nimport \"./math/saturating/OpSaturatingMul.sol\";\nimport \"./math/saturating/OpSaturatingSub.sol\";\nimport \"./math/OpAdd.sol\";\nimport \"./math/OpDiv.sol\";\nimport \"./math/OpExp.sol\";\nimport \"./math/OpMax.sol\";\nimport \"./math/OpMin.sol\";\nimport \"./math/OpMod.sol\";\nimport \"./math/OpMul.sol\";\nimport \"./math/OpSub.sol\";\nimport \"./tier/OpITierV2Report.sol\";\nimport \"./tier/OpITierV2ReportTimeForTier.sol\";\nimport \"./tier/OpSaturatingDiff.sol\";\nimport \"./tier/OpSelectLte.sol\";\nimport \"./tier/OpUpdateTimesForTierRange.sol\";\n\nuint256 constant ALL_STANDARD_OPS_LENGTH = RAIN_VM_OPS_LENGTH + 40;\n\n/// @title AllStandardOps\n/// @notice RainVM opcode pack to expose all other packs.\nlibrary AllStandardOps {\n    function zero(uint256) internal pure returns (uint256) {\n        return 0;\n    }\n\n    function one(uint256) internal pure returns (uint256) {\n        return 1;\n    }\n\n    function two(uint256) internal pure returns (uint256) {\n        return 2;\n    }\n\n    function three(uint256) internal pure returns (uint256) {\n        return 3;\n    }\n\n    function nonzeroOperandN(uint256 operand_) internal pure returns (uint256) {\n        require(operand_ > 0, \"0_OPERAND\");\n        return operand_;\n    }\n\n    function stackPopsFnPtrs() internal pure returns (bytes memory) {\n        unchecked {\n            uint256 lenBytes_ = ALL_STANDARD_OPS_LENGTH * 0x20;\n            function(uint256) pure returns (uint256) zeroFn_;\n            assembly {\n                // using zero bytes in the fnPtrs array may save gas in certain\n                // contexts.\n                zeroFn_ := 0\n            }\n            function(uint256) pure returns (uint256)[ALL_STANDARD_OPS_LENGTH +\n                1]\n                memory fns_ = [\n                    // will be overriden with length\n                    zeroFn_,\n                    // constant placeholder\n                    zeroFn_,\n                    // stack placeholder\n                    zeroFn_,\n                    // context placeholder\n                    zeroFn_,\n                    // storage placeholder\n                    zeroFn_,\n                    // zipmap placeholder\n                    zeroFn_,\n                    // debug placeholder\n                    zeroFn_,\n                    // erc20 balance of\n                    two,\n                    // erc20 total supply\n                    one,\n                    // erc20 snapshot balance of at\n                    three,\n                    // erc20 snapshot total supply at\n                    two,\n                    // erc721 balance of\n                    two,\n                    // erc721 owner of\n                    two,\n                    // erc1155 balance of\n                    three,\n                    // erc1155 balance of batch\n                    OpERC1155BalanceOfBatch.stackPops,\n                    // block number\n                    zero,\n                    // caller\n                    zero,\n                    // this address\n                    zero,\n                    // timestamp\n                    zero,\n                    // scale18\n                    one,\n                    // scale18 div\n                    two,\n                    // scale18 mul\n                    two,\n                    // scaleBy\n                    one,\n                    // scaleN\n                    one,\n                    // any\n                    nonzeroOperandN,\n                    // eager if\n                    three,\n                    // equal to\n                    two,\n                    // every\n                    nonzeroOperandN,\n                    // greater than\n                    two,\n                    // iszero\n                    one,\n                    // less than\n                    two,\n                    // saturating add\n                    nonzeroOperandN,\n                    // saturating mul\n                    nonzeroOperandN,\n                    // saturating sub\n                    nonzeroOperandN,\n                    // add\n                    nonzeroOperandN,\n                    // div\n                    nonzeroOperandN,\n                    // exp\n                    nonzeroOperandN,\n                    // max\n                    nonzeroOperandN,\n                    // min\n                    nonzeroOperandN,\n                    // mod\n                    nonzeroOperandN,\n                    // mul\n                    nonzeroOperandN,\n                    // sub\n                    nonzeroOperandN,\n                    // tier report\n                    OpITierV2Report.stackPops,\n                    // tier report time for tier\n                    OpITierV2ReportTimeForTier.stackPops,\n                    // tier saturating diff\n                    two,\n                    // select lte\n                    OpSelectLte.stackPops,\n                    // update times for tier range\n                    two\n                ];\n            bytes memory ret_;\n            assembly {\n                mstore(fns_, lenBytes_)\n                ret_ := fns_\n            }\n            return ret_;\n        }\n    }\n\n    function stackPushesFnPtrs() internal pure returns (bytes memory) {\n        unchecked {\n            uint256 lenBytes_ = ALL_STANDARD_OPS_LENGTH * 0x20;\n            function(uint256) pure returns (uint256) zeroFn_;\n            assembly {\n                // using zero bytes in the fnPtrs array may save gas in certain\n                // contexts.\n                zeroFn_ := 0\n            }\n            function(uint256) pure returns (uint256)[ALL_STANDARD_OPS_LENGTH +\n                1]\n                memory fns_ = [\n                    // will be overriden with length\n                    zeroFn_,\n                    // constant placeholder\n                    zeroFn_,\n                    // stack placeholder\n                    zeroFn_,\n                    // context placeholder\n                    zeroFn_,\n                    // storage placeholder\n                    zeroFn_,\n                    // zipmap placeholder\n                    zeroFn_,\n                    // debug placeholder\n                    zeroFn_,\n                    // erc20 balance of\n                    one,\n                    // erc20 total supply\n                    one,\n                    // erc20 snapshot balance of at\n                    one,\n                    // erc20 snapshot total supply at\n                    one,\n                    // erc721 balance of\n                    one,\n                    // erc721 owner of\n                    one,\n                    // erc1155 balance of\n                    one,\n                    // erc1155 balance of batch\n                    nonzeroOperandN,\n                    // block number\n                    one,\n                    // caller\n                    one,\n                    // this address\n                    one,\n                    // timestamp\n                    one,\n                    // scale18\n                    one,\n                    // scale18 div\n                    one,\n                    // scale18 mul\n                    one,\n                    // scaleBy\n                    one,\n                    // scaleN\n                    one,\n                    // any\n                    one,\n                    // eager if\n                    one,\n                    // equal to\n                    one,\n                    // every\n                    one,\n                    // greater than\n                    one,\n                    // iszero\n                    one,\n                    // less than\n                    one,\n                    // saturating add\n                    one,\n                    // saturating mul\n                    one,\n                    // saturating sub\n                    one,\n                    // add\n                    one,\n                    // div\n                    one,\n                    // exp\n                    one,\n                    // max\n                    one,\n                    // min\n                    one,\n                    // mod\n                    one,\n                    // mul\n                    one,\n                    // sub\n                    one,\n                    // tier report\n                    one,\n                    // tier report time for tier\n                    one,\n                    // tier saturating diff\n                    one,\n                    // select lte\n                    one,\n                    // update times for tier range\n                    one\n                ];\n            bytes memory ret_;\n            assembly {\n                mstore(fns_, lenBytes_)\n                ret_ := fns_\n            }\n            return ret_;\n        }\n    }\n\n    function fnPtrs() internal pure returns (bytes memory) {\n        unchecked {\n            uint256 lenBytes_ = ALL_STANDARD_OPS_LENGTH * 0x20;\n            function(uint256, uint256) view returns (uint256) zeroFn_;\n            assembly {\n                // using zero bytes in the fnPtrs array may save gas in certain\n                // contexts.\n                zeroFn_ := 0\n            }\n            function(uint256, uint256)\n                view\n                returns (uint256)[ALL_STANDARD_OPS_LENGTH + 1]\n                memory fns_ = [\n                    // will be overridden with length\n                    zeroFn_,\n                    // placeholders for core ops\n                    // constant\n                    zeroFn_,\n                    // stack\n                    zeroFn_,\n                    // context\n                    zeroFn_,\n                    // storage\n                    zeroFn_,\n                    // zipmap\n                    zeroFn_,\n                    // debug\n                    zeroFn_,\n                    // dispatchable ops\n                    OpERC20BalanceOf.balanceOf,\n                    OpERC20TotalSupply.totalSupply,\n                    OpERC20SnapshotBalanceOfAt.balanceOfAt,\n                    OpERC20SnapshotTotalSupplyAt.totalSupplyAt,\n                    OpERC721BalanceOf.balanceOf,\n                    OpERC721OwnerOf.ownerOf,\n                    OpERC1155BalanceOf.balanceOf,\n                    OpERC1155BalanceOfBatch.balanceOfBatch,\n                    OpBlockNumber.blockNumber,\n                    OpCaller.caller,\n                    OpThisAddress.thisAddress,\n                    OpTimestamp.timestamp,\n                    OpFixedPointScale18.scale18,\n                    OpFixedPointScale18Div.scale18Div,\n                    OpFixedPointScale18Mul.scale18Mul,\n                    OpFixedPointScaleBy.scaleBy,\n                    OpFixedPointScaleN.scaleN,\n                    OpAny.any,\n                    OpEagerIf.eagerIf,\n                    OpEqualTo.equalTo,\n                    OpEvery.every,\n                    OpGreaterThan.greaterThan,\n                    OpIsZero.isZero,\n                    OpLessThan.lessThan,\n                    OpSaturatingAdd.saturatingAdd,\n                    OpSaturatingMul.saturatingMul,\n                    OpSaturatingSub.saturatingSub,\n                    OpAdd.add,\n                    OpDiv.div,\n                    OpExp.exp,\n                    OpMax.max,\n                    OpMin.min,\n                    OpMod.mod,\n                    OpMul.mul,\n                    OpSub.sub,\n                    OpITierV2Report.report,\n                    OpITierV2ReportTimeForTier.reportTimeForTier,\n                    OpSaturatingDiff.saturatingDiff,\n                    OpSelectLte.selectLte,\n                    OpUpdateTimesForTierRange.updateTimesForTierRange\n                ];\n            bytes memory ret_;\n            assembly {\n                mstore(fns_, lenBytes_)\n                ret_ := fns_\n            }\n            return ret_;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/sstore2/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\nimport \"./utils/Bytecode.sol\";\n\n/**\n  @title A key-value storage with auto-generated keys for storing chunks of\n  data with a lower write & read cost.\n  @author Agustin Aguilar <aa@horizon.io>\n\n  Readme: https://github.com/0xsequence/sstore2#readme\n*/\nlibrary SSTORE2 {\n    error WriteError();\n\n    /**\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\n    @dev The pointer is a contract address with `_data` as code\n    @param _data to be written\n    @return pointer Pointer to the written `_data`\n  */\n    function write(bytes memory _data) internal returns (address pointer) {\n        // Append 00 to _data so contract can't be called\n        // Build init code\n        bytes memory code = Bytecode.creationCodeFor(\n            abi.encodePacked(hex\"00\", _data)\n        );\n\n        // Deploy contract using create\n        assembly {\n            pointer := create(0, add(code, 32), mload(code))\n        }\n\n        // Address MUST be non-zero\n        if (pointer == address(0)) revert WriteError();\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first\n    byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @return data read from `_pointer` contract\n  */\n    function read(address _pointer) internal view returns (bytes memory) {\n        return Bytecode.codeAt(_pointer, 1, type(uint256).max);\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first\n    byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @return data read from `_pointer` contract\n  */\n    function read(address _pointer, uint256 _start)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first\n    byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @param _end index before which to end extraction\n    @return data read from `_pointer` contract\n  */\n    function read(\n        address _pointer,\n        uint256 _start,\n        uint256 _end\n    ) internal view returns (bytes memory) {\n        return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/tier/ITierV2.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// @title ITierV2\n/// @notice `ITierV2` is a simple interface that contracts can implement to\n/// provide membership lists for other contracts.\n///\n/// There are many use-cases for a time-preserving conditional membership list.\n///\n/// Some examples include:\n///\n/// - Self-serve whitelist to participate in fundraising\n/// - Lists of users who can claim airdrops and perks\n/// - Pooling resources with implied governance/reward tiers\n/// - POAP style attendance proofs allowing access to future exclusive events\n///\n/// @dev Standard interface to a tiered membership.\n///\n/// A \"membership\" can represent many things:\n/// - Exclusive access.\n/// - Participation in some event or process.\n/// - KYC completion.\n/// - Combination of sub-memberships.\n/// - Etc.\n///\n/// The high level requirements for a contract implementing `ITierV2`:\n/// - MUST represent held tiers as a `uint`.\n/// - MUST implement `report`.\n///   - The report is a `uint256` that SHOULD represent the time each tier has\n///     been continuously held since encoded as `uint32`.\n///   - The encoded tiers start at `1`; Tier `0` is implied if no tier has ever\n///     been held.\n///   - Tier `0` is NOT encoded in the report, it is simply the fallback value.\n///   - If a tier is lost the time data is erased for that tier and will be\n///     set if/when the tier is regained to the new time.\n///   - If a tier is held but the historical time information is not available\n///     the report MAY return `0x00000000` for all held tiers.\n///   - Tiers that are lost or have never been held MUST return `0xFFFFFFFF`.\n///   - Context can be a list of numbers that MAY pairwise define tiers such as\n///     minimum thresholds, or MAY simply provide global context such as a\n///     relevant NFT ID for example.\n/// - MUST implement `reportTimeForTier`\n///   - Functions exactly as `report` but only returns a single time for a\n///     single tier\n///   - MUST return the same time value `report` would for any given tier and\n///     context combination.\n///\n/// So the four possible states and report values are:\n/// - Tier is held and time is known: Timestamp is in the report\n/// - Tier is held but time is NOT known: `0` is in the report\n/// - Tier is NOT held: `0xFF..` is in the report\n/// - Tier is unknown: `0xFF..` is in the report\n///\n/// The reason `context` is specified as a list of values rather than arbitrary\n/// bytes is to allow clear and efficient compatibility with VM stacks. Some N\n/// values can be taken from a VM stack and used directly as a context, which\n/// would be difficult or impossible to ensure is safe for arbitrary bytes.\ninterface ITierV2 {\n    /// Same as report but only returns the time for a single tier.\n    /// Often the implementing contract can calculate a single tier more\n    /// efficiently than all 8 tiers. If the consumer only needs one or a few\n    /// tiers it MAY be much cheaper to request only those tiers individually.\n    /// This DOES NOT apply to all contracts, an obvious example is token\n    /// balance based tiers which always return `ALWAYS` or `NEVER` for all\n    /// tiers so no efficiency is gained.\n    /// The return value is a `uint256` for gas efficiency but the values will\n    /// be bounded by `type(uint32).max` as no single tier can report a value\n    /// higher than this.\n    function reportTimeForTier(\n        address account,\n        uint256 tier,\n        uint256[] calldata context\n    ) external view returns (uint256 time);\n\n    /// Same as `ITier` but with a list of values for `context` which allows a\n    /// single underlying state to present many different reports dynamically.\n    ///\n    /// For example:\n    /// - Staking ledgers can calculate different tier thresholds\n    /// - NFTs can give different tiers based on different IDs\n    /// - Snapshot ERC20s can give different reports based on snapshot ID\n    ///\n    /// `context` supercedes `setTier` function and `TierChange` event from\n    /// `ITier` at the interface level. Implementing contracts are free to\n    /// inherit both `ITier` and `ITierV2` if the old behaviour is desired.\n    function report(address account, uint256[] calldata context)\n        external\n        view\n        returns (uint256 report);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/math/SaturatingMath.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title SaturatingMath\n/// @notice Sometimes we neither want math operations to error nor wrap around\n/// on an overflow or underflow. In the case of transferring assets an error\n/// may cause assets to be locked in an irretrievable state within the erroring\n/// contract, e.g. due to a tiny rounding/calculation error. We also can't have\n/// assets underflowing and attempting to approve/transfer \"infinity\" when we\n/// wanted \"almost or exactly zero\" but some calculation bug underflowed zero.\n/// Ideally there are no calculation mistakes, but in guarding against bugs it\n/// may be safer pragmatically to saturate arithmatic at the numeric bounds.\n/// Note that saturating div is not supported because 0/0 is undefined.\nlibrary SaturatingMath {\n    /// Saturating addition.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return Minimum of a_ + b_ and max uint256.\n    function saturatingAdd(uint256 a_, uint256 b_)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            uint256 c_ = a_ + b_;\n            return c_ < a_ ? type(uint256).max : c_;\n        }\n    }\n\n    /// Saturating subtraction.\n    /// @param a_ Minuend.\n    /// @param b_ Subtrahend.\n    /// @return Maximum of a_ - b_ and 0.\n    function saturatingSub(uint256 a_, uint256 b_)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            return a_ > b_ ? a_ - b_ : 0;\n        }\n    }\n\n    /// Saturating multiplication.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return Minimum of a_ * b_ and max uint256.\n    function saturatingMul(uint256 a_, uint256 b_)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being\n            // zero, but the benefit is lost if 'b' is also tested.\n            // https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a_ == 0) return 0;\n            uint256 c_ = a_ * b_;\n            return c_ / a_ != b_ ? type(uint256).max : c_;\n        }\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/sstore2/utils/Bytecode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\nlibrary Bytecode {\n    error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\n\n    /**\n    @notice Generate a creation code that results on a contract with `_code` as\n    bytecode\n    @param _code The returning value of the resulting `creationCode`\n    @return creationCode (constructor) for new contract\n  */\n    function creationCodeFor(bytes memory _code)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        /*\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\n      0x01    0x80         0x80        DUP1                size size\n      0x02    0x60         0x600e      PUSH1 14            14 size size\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\n      0x04    0x39         0x39        CODECOPY            size\n      0x05    0x60         0x6000      PUSH1 00            0 size\n      0x06    0xf3         0xf3        RETURN\n      <CODE>\n    */\n\n        return\n            abi.encodePacked(\n                hex\"63\",\n                uint32(_code.length),\n                hex\"80_60_0E_60_00_39_60_00_F3\",\n                _code\n            );\n    }\n\n    /**\n    @notice Returns the size of the code on a given address\n    @param _addr Address that may or may not contain code\n    @return size of the code on the given `_addr`\n  */\n    function codeSize(address _addr) internal view returns (uint256 size) {\n        assembly {\n            size := extcodesize(_addr)\n        }\n    }\n\n    /**\n    @notice Returns the code of a given address\n    @dev It will fail if `_end < _start`\n    @param _addr Address that may or may not contain code\n    @param _start number of bytes of code to skip on read\n    @param _end index before which to end extraction\n    @return oCode read from `_addr` deployed bytecode\n\n    Forked: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\n  */\n    function codeAt(\n        address _addr,\n        uint256 _start,\n        uint256 _end\n    ) internal view returns (bytes memory oCode) {\n        uint256 csize = codeSize(_addr);\n        if (csize == 0) return bytes(\"\");\n\n        if (_start > csize) return bytes(\"\");\n        if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end);\n\n        unchecked {\n            uint256 reqSize = _end - _start;\n            uint256 maxSize = csize - _start;\n\n            uint256 size = maxSize < reqSize ? maxSize : reqSize;\n\n            assembly {\n                // allocate output byte array - this could also be done without\n                // assembly\n                // by using o_code = new bytes(size)\n                oCode := mload(0x40)\n                // new \"memory end\" including padding\n                mstore(\n                    0x40,\n                    add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f)))\n                )\n                // store length in memory\n                mstore(oCode, size)\n                // actually retrieve the code, this needs assembly\n                extcodecopy(_addr, add(oCode, 0x20), _start, size)\n            }\n        }\n    }\n}\n"
    },
    "contracts/vm/ops/erc20/OpERC20BalanceOf.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title OpERC20BalanceOf\n/// @notice Opcode for ERC20 `balanceOf`.\nlibrary OpERC20BalanceOf {\n    /// Stack `balanceOf`.\n    function balanceOf(uint256, uint256 stackTopLocation_)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 token_;\n        uint256 account_;\n        assembly {\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\n            location_ := sub(stackTopLocation_, 0x20)\n            token_ := mload(location_)\n            account_ := mload(stackTopLocation_)\n        }\n        uint256 balance_ = IERC20(address(uint160(token_))).balanceOf(\n            address(uint160(account_))\n        );\n        assembly {\n            mstore(location_, balance_)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/erc20/OpERC20TotalSupply.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title OpERC20TotalSupply\n/// @notice Opcode for ERC20 `totalSupply`.\nlibrary OpERC20TotalSupply {\n    // Stack the return of `totalSupply`.\n    function totalSupply(uint256, uint256 stackTopLocation_)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 token_;\n        assembly {\n            location_ := sub(stackTopLocation_, 0x20)\n            token_ := mload(location_)\n        }\n        uint256 supply_ = IERC20(address(uint160(token_))).totalSupply();\n        assembly {\n            mstore(location_, supply_)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/erc20/snapshot/OpERC20SnapshotBalanceOfAt.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\";\n\n/// @title OpERC20SnapshotBalanceOfAt\n/// @notice Opcode for Open Zeppelin `ERC20Snapshot.balanceOfAt`.\n/// https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20Snapshot\nlibrary OpERC20SnapshotBalanceOfAt {\n    /// Stack `balanceOfAt`.\n    function balanceOfAt(uint256, uint256 stackTopLocation_)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 token_;\n        uint256 account_;\n        uint256 snapshotId_;\n        assembly {\n            stackTopLocation_ := sub(stackTopLocation_, 0x40)\n            location_ := sub(stackTopLocation_, 0x20)\n            token_ := mload(location_)\n            account_ := mload(stackTopLocation_)\n            snapshotId_ := mload(add(stackTopLocation_, 0x20))\n        }\n        uint256 balance_ = ERC20Snapshot(address(uint160(token_))).balanceOfAt(\n            address(uint160(account_)),\n            snapshotId_\n        );\n        assembly {\n            mstore(location_, balance_)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/erc20/snapshot/OpERC20SnapshotTotalSupplyAt.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\";\n\n/// @title OpERC20SnapshotTotalSupplyAt\n/// @notice Opcode for Open Zeppelin `ERC20Snapshot.totalSupplyAt`.\n/// https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20Snapshot\nlibrary OpERC20SnapshotTotalSupplyAt {\n    /// Stack `totalSupplyAt`.\n    function totalSupplyAt(uint256, uint256 stackTopLocation_)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 token_;\n        uint256 snapshotId_;\n        assembly {\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\n            location_ := sub(stackTopLocation_, 0x20)\n            token_ := mload(location_)\n            snapshotId_ := mload(stackTopLocation_)\n        }\n        uint256 totalSupply_ = ERC20Snapshot(address(uint160(token_)))\n            .totalSupplyAt(snapshotId_);\n        assembly {\n            mstore(location_, totalSupply_)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/erc721/OpERC721BalanceOf.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/// @title OpERC721BalanceOf\n/// @notice Opcode for getting the current erc721 balance of an account.\nlibrary OpERC721BalanceOf {\n    // Stack the return of `balanceOf`.\n    function balanceOf(uint256, uint256 stackTopLocation_)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 token_;\n        uint256 account_;\n\n        assembly {\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\n            location_ := sub(stackTopLocation_, 0x20)\n            token_ := mload(location_)\n            account_ := mload(stackTopLocation_)\n        }\n        uint256 balance_ = IERC721(address(uint160(token_))).balanceOf(\n            address(uint160(account_))\n        );\n\n        assembly {\n            mstore(location_, balance_)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/erc721/OpERC721OwnerOf.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n/// @title OpERC721OwnerOf\n/// @notice Opcode for getting the current erc721 owner of an account.\nlibrary OpERC721OwnerOf {\n    // Stack the return of `ownerOf`.\n    function ownerOf(uint256, uint256 stackTopLocation_)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 token_;\n        uint256 id_;\n\n        assembly {\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\n            location_ := sub(stackTopLocation_, 0x20)\n            token_ := mload(location_)\n            id_ := mload(stackTopLocation_)\n        }\n        uint256 owner_ = uint256(\n            uint160(IERC721(address(uint160(token_))).ownerOf(id_))\n        );\n        assembly {\n            mstore(location_, owner_)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/erc1155/OpERC1155BalanceOf.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\n/// @title OpERC1155BalanceOf\n/// @notice Opcode for getting the current erc1155 balance of an account.\nlibrary OpERC1155BalanceOf {\n    // Stack the return of `balanceOf`.\n    function balanceOf(uint256, uint256 stackTopLocation_)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 token_;\n        uint256 account_;\n        uint256 id_;\n        assembly {\n            location_ := sub(stackTopLocation_, 0x60)\n            stackTopLocation_ := add(location_, 0x20)\n            token_ := mload(location_)\n            account_ := mload(stackTopLocation_)\n            id_ := mload(add(location_, 0x40))\n        }\n        uint256 result_ = IERC1155(address(uint160(token_))).balanceOf(\n            address(uint160(account_)),\n            id_\n        );\n        assembly {\n            mstore(location_, result_)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/erc1155/OpERC1155BalanceOfBatch.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\n/// @title OpERC1155BalanceOfBatch\n/// @notice Opcode for getting the current erc1155 balance of an accounts batch.\nlibrary OpERC1155BalanceOfBatch {\n    function stackPops(uint256 operand_) internal pure returns (uint256) {\n        unchecked {\n            require(operand_ > 0, \"0_OPERAND\");\n            return (operand_ * 2) + 1;\n        }\n    }\n\n    // Stack the return of `balanceOfBatch`.\n    // Operand will be the length\n    function balanceOfBatch(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 location_;\n        address[] memory addresses_ = new address[](operand_);\n        uint256[] memory ids_ = new uint256[](operand_);\n        uint256 token_;\n        assembly {\n            location_ := sub(stackTopLocation_, add(0x20, mul(operand_, 0x40)))\n            token_ := mload(location_)\n            let cursor_ := add(location_, 0x20)\n\n            for {\n                let maxCursor_ := add(cursor_, mul(operand_, 0x20))\n                let addressesCursor_ := add(addresses_, 0x20)\n            } lt(cursor_, maxCursor_) {\n                cursor_ := add(cursor_, 0x20)\n                addressesCursor_ := add(addressesCursor_, 0x20)\n            } {\n                mstore(addressesCursor_, mload(cursor_))\n            }\n\n            for {\n                let maxCursor_ := add(cursor_, mul(operand_, 0x20))\n                let idsCursor_ := add(ids_, 0x20)\n            } lt(cursor_, maxCursor_) {\n                cursor_ := add(cursor_, 0x20)\n                idsCursor_ := add(idsCursor_, 0x20)\n            } {\n                mstore(idsCursor_, mload(cursor_))\n            }\n        }\n        uint256[] memory balances_ = IERC1155(address(uint160(token_)))\n            .balanceOfBatch(addresses_, ids_);\n\n        assembly {\n            let cursor_ := location_\n            for {\n                let balancesCursor_ := add(balances_, 0x20)\n                let balancesCursorMax_ := add(\n                    balancesCursor_,\n                    mul(operand_, 0x20)\n                )\n            } lt(balancesCursor_, balancesCursorMax_) {\n                cursor_ := add(cursor_, 0x20)\n                balancesCursor_ := add(balancesCursor_, 0x20)\n            } {\n                mstore(cursor_, mload(balancesCursor_))\n            }\n            stackTopLocation_ := cursor_\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/evm/OpBlockNumber.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpBlockNumber\n/// @notice Opcode for getting the current block number.\nlibrary OpBlockNumber {\n    function blockNumber(uint256, uint256 stackTopLocation_)\n        internal\n        view\n        returns (uint256)\n    {\n        assembly {\n            mstore(stackTopLocation_, number())\n            stackTopLocation_ := add(stackTopLocation_, 0x20)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/evm/OpCaller.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpCaller\n/// @notice Opcode for getting the current caller.\nlibrary OpCaller {\n    function caller(uint256, uint256 stackTopLocation_)\n        internal\n        view\n        returns (uint256)\n    {\n        assembly {\n            mstore(stackTopLocation_, caller())\n            stackTopLocation_ := add(stackTopLocation_, 0x20)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/evm/OpThisAddress.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpThisAddress\n/// @notice Opcode for getting the address of the current contract.\nlibrary OpThisAddress {\n    function thisAddress(uint256, uint256 stackTopLocation_)\n        internal\n        view\n        returns (uint256)\n    {\n        assembly {\n            mstore(stackTopLocation_, address())\n            stackTopLocation_ := add(stackTopLocation_, 0x20)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/evm/OpTimestamp.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpTimestamp\n/// @notice Opcode for getting the current timestamp.\nlibrary OpTimestamp {\n    function timestamp(uint256, uint256 stackTopLocation_)\n        internal\n        view\n        returns (uint256)\n    {\n        assembly {\n            mstore(stackTopLocation_, timestamp())\n            stackTopLocation_ := add(stackTopLocation_, 0x20)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/fixedPoint/OpFixedPointScale18.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../../../../math/FixedPointMath.sol\";\n\n/// @title OpFixedPointScale18\n/// @notice Opcode for scaling a number to 18 fixed point.\nlibrary OpFixedPointScale18 {\n    using FixedPointMath for uint256;\n\n    function scale18(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 a_;\n        assembly {\n            location_ := sub(stackTopLocation_, 0x20)\n            a_ := mload(location_)\n        }\n        uint256 b_ = a_.scale18(operand_);\n        assembly {\n            mstore(location_, b_)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/fixedPoint/OpFixedPointScale18Div.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../../../../math/FixedPointMath.sol\";\n\n/// @title OpFixedPointScale18Div\n/// @notice Opcode for performing scale 18 fixed point division.\nlibrary OpFixedPointScale18Div {\n    using FixedPointMath for uint256;\n\n    function scale18Div(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 a_;\n        uint256 b_;\n        assembly {\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\n            location_ := sub(stackTopLocation_, 0x20)\n            a_ := mload(location_)\n            b_ := mload(stackTopLocation_)\n        }\n        uint256 c_ = a_.scale18(operand_).fixedPointDiv(b_);\n        assembly {\n            mstore(location_, c_)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/fixedPoint/OpFixedPointScale18Mul.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../../../../math/FixedPointMath.sol\";\n\n/// @title OpFixedPointScale18Mul\n/// @notice Opcode for performing scale 18 fixed point multiplication.\nlibrary OpFixedPointScale18Mul {\n    using FixedPointMath for uint256;\n\n    function scale18Mul(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 a_;\n        uint256 b_;\n        assembly {\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\n            location_ := sub(stackTopLocation_, 0x20)\n            a_ := mload(location_)\n            b_ := mload(stackTopLocation_)\n        }\n        uint256 c_ = a_.scale18(operand_).fixedPointMul(b_);\n        assembly {\n            mstore(location_, c_)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/fixedPoint/OpFixedPointScaleBy.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../../../../math/FixedPointMath.sol\";\n\n/// @title OpFixedPointScaleBy\n/// @notice Opcode for scaling a number by some OOMs.\nlibrary OpFixedPointScaleBy {\n    using FixedPointMath for uint256;\n\n    function scaleBy(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 a_;\n        assembly {\n            location_ := sub(stackTopLocation_, 0x20)\n            a_ := mload(location_)\n        }\n        uint256 b_ = a_.scaleBy(int8(uint8(operand_)));\n        assembly {\n            mstore(location_, b_)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/fixedPoint/OpFixedPointScaleN.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../../../../math/FixedPointMath.sol\";\n\n/// @title OpFixedPointScaleN\n/// @notice Opcode for scaling a number to N fixed point.\nlibrary OpFixedPointScaleN {\n    using FixedPointMath for uint256;\n\n    function scaleN(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 a_;\n        assembly {\n            location_ := sub(stackTopLocation_, 0x20)\n            a_ := mload(location_)\n        }\n        uint256 b_ = a_.scaleN(operand_);\n        assembly {\n            mstore(location_, b_)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/logic/OpAny.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpAny\n/// @notice Opcode to compare the top N stack values.\nlibrary OpAny {\n    // ANY\n    // ANY is the first nonzero item, else 0.\n    // operand_ id the length of items to check.\n    function any(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        assembly {\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\n            for {\n                let cursor_ := location_\n            } lt(cursor_, stackTopLocation_) {\n                cursor_ := add(cursor_, 0x20)\n            } {\n                // If anything is NOT zero then ANY is a successful\n                // check and can short-circuit.\n                let item_ := mload(cursor_)\n                if iszero(iszero(item_)) {\n                    // Write the usable value to the top of the stack.\n                    mstore(location_, item_)\n                    break\n                }\n            }\n            stackTopLocation_ := add(location_, 0x20)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/logic/OpEagerIf.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpEagerIf\n/// @notice Opcode for selecting a value based on a condition.\nlibrary OpEagerIf {\n    /// Eager because BOTH x_ and y_ must be eagerly evaluated\n    /// before EAGER_IF will select one of them. If both x_ and y_\n    /// are cheap (e.g. constant values) then this may also be the\n    /// simplest and cheapest way to select one of them.\n    function eagerIf(uint256, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        assembly {\n            let location_ := sub(stackTopLocation_, 0x60)\n            stackTopLocation_ := add(location_, 0x20)\n            // false => use second value\n            // true => use first value\n            mstore(\n                location_,\n                mload(\n                    add(stackTopLocation_, mul(0x20, iszero(mload(location_))))\n                )\n            )\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/logic/OpEqualTo.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpEqualTo\n/// @notice Opcode to compare the top two stack values.\nlibrary OpEqualTo {\n    function equalTo(uint256, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        assembly {\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\n            let location_ := sub(stackTopLocation_, 0x20)\n            mstore(location_, eq(mload(location_), mload(stackTopLocation_)))\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/logic/OpEvery.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpEvery\n/// @notice Opcode to compare the top N stack values.\nlibrary OpEvery {\n    // EVERY\n    // EVERY is either the first item if every item is nonzero, else 0.\n    // operand_ is the length of items to check.\n    function every(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        assembly {\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\n            for {\n                let cursor_ := location_\n            } lt(cursor_, stackTopLocation_) {\n                cursor_ := add(cursor_, 0x20)\n            } {\n                // If anything is zero then EVERY is a failed check.\n                if iszero(mload(cursor_)) {\n                    mstore(location_, 0)\n                    break\n                }\n            }\n            stackTopLocation_ := add(location_, 0x20)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/logic/OpGreaterThan.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpGreaterThan\n/// @notice Opcode to compare the top two stack values.\nlibrary OpGreaterThan {\n    function greaterThan(uint256, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        assembly {\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\n            let location_ := sub(stackTopLocation_, 0x20)\n            mstore(location_, gt(mload(location_), mload(stackTopLocation_)))\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/logic/OpIsZero.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpIsZero\n/// @notice Opcode for checking if the stack top is zero.\nlibrary OpIsZero {\n    function isZero(uint256, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        assembly {\n            // The index doesn't change for iszero as there is\n            // one input and output.\n            let location_ := sub(stackTopLocation_, 0x20)\n            mstore(location_, iszero(mload(location_)))\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/logic/OpLessThan.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpLessThan\n/// @notice Opcode to compare the top two stack values.\nlibrary OpLessThan {\n    function lessThan(uint256, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        assembly {\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\n            let location_ := sub(stackTopLocation_, 0x20)\n            mstore(location_, lt(mload(location_), mload(stackTopLocation_)))\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/saturating/OpSaturatingAdd.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../../../../math/SaturatingMath.sol\";\n\n/// @title OpSaturatingAdd\n/// @notice Opcode for adding N numbers with saturating addition.\nlibrary OpSaturatingAdd {\n    using SaturatingMath for uint256;\n\n    function saturatingAdd(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 accumulator_;\n        uint256 cursor_;\n        uint256 item_;\n        assembly {\n            location_ := sub(stackTopLocation_, mul(operand_, 0x20))\n            accumulator_ := mload(location_)\n            cursor_ := add(location_, 0x20)\n        }\n        while (\n            cursor_ < stackTopLocation_ && accumulator_ < type(uint256).max\n        ) {\n            assembly {\n                item_ := mload(cursor_)\n                cursor_ := add(cursor_, 0x20)\n            }\n            accumulator_ = accumulator_.saturatingAdd(item_);\n        }\n        assembly {\n            mstore(location_, accumulator_)\n            stackTopLocation_ := add(location_, 0x20)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/saturating/OpSaturatingMul.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../../../../math/SaturatingMath.sol\";\n\n/// @title OpSaturatingMul\n/// @notice Opcode for multiplying N numbers with saturating multiplication.\nlibrary OpSaturatingMul {\n    using SaturatingMath for uint256;\n\n    function saturatingMul(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 accumulator_;\n        uint256 cursor_;\n        uint256 item_;\n        assembly {\n            location_ := sub(stackTopLocation_, mul(operand_, 0x20))\n            accumulator_ := mload(location_)\n            cursor_ := add(location_, 0x20)\n        }\n        while (\n            cursor_ < stackTopLocation_ && accumulator_ < type(uint256).max\n        ) {\n            assembly {\n                item_ := mload(cursor_)\n                cursor_ := add(cursor_, 0x20)\n            }\n            accumulator_ = accumulator_.saturatingMul(item_);\n        }\n        assembly {\n            mstore(location_, accumulator_)\n            stackTopLocation_ := add(location_, 0x20)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/saturating/OpSaturatingSub.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../../../../math/SaturatingMath.sol\";\n\n/// @title OpSaturatingSub\n/// @notice Opcode for subtracting N numbers with saturating subtraction.\nlibrary OpSaturatingSub {\n    using SaturatingMath for uint256;\n\n    function saturatingSub(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 accumulator_;\n        uint256 cursor_;\n        uint256 item_;\n        assembly {\n            location_ := sub(stackTopLocation_, mul(operand_, 0x20))\n            accumulator_ := mload(location_)\n            cursor_ := add(location_, 0x20)\n        }\n        while (cursor_ < stackTopLocation_ && 0 < accumulator_) {\n            assembly {\n                item_ := mload(cursor_)\n                cursor_ := add(cursor_, 0x20)\n            }\n            accumulator_ = accumulator_.saturatingSub(item_);\n        }\n        assembly {\n            mstore(location_, accumulator_)\n            stackTopLocation_ := add(location_, 0x20)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/OpAdd.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpAdd\n/// @notice Opcode for adding N numbers.\nlibrary OpAdd {\n    function add(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        assembly {\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\n            let accumulator_ := mload(location_)\n            let intermediate_\n            for {\n                let cursor_ := add(location_, 0x20)\n            } lt(cursor_, stackTopLocation_) {\n                cursor_ := add(cursor_, 0x20)\n            } {\n                intermediate_ := add(accumulator_, mload(cursor_))\n                // Adapted from Open Zeppelin safe math.\n                if lt(intermediate_, accumulator_) {\n                    revert(0, 0)\n                }\n                accumulator_ := intermediate_\n            }\n            mstore(location_, accumulator_)\n            stackTopLocation_ := add(location_, 0x20)\n        }\n\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/OpDiv.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpDiv\n/// @notice Opcode for dividing N numbers.\nlibrary OpDiv {\n    function div(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        assembly {\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\n            let accumulator_ := mload(location_)\n            let item_\n            for {\n                let cursor_ := add(location_, 0x20)\n            } lt(cursor_, stackTopLocation_) {\n                cursor_ := add(cursor_, 0x20)\n            } {\n                item_ := mload(cursor_)\n                // Adapted from Open Zeppelin safe math.\n                if iszero(item_) {\n                    revert(0, 0)\n                }\n                accumulator_ := div(accumulator_, item_)\n            }\n            mstore(location_, accumulator_)\n            stackTopLocation_ := add(location_, 0x20)\n        }\n\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/OpExp.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpExp\n/// @notice Opcode to exponentiate N numbers.\nlibrary OpExp {\n    function exp(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 accumulator_;\n        uint256 cursor_;\n        uint256 item_;\n        assembly {\n            location_ := sub(stackTopLocation_, mul(operand_, 0x20))\n            accumulator_ := mload(location_)\n            cursor_ := add(location_, 0x20)\n        }\n        while (cursor_ < stackTopLocation_) {\n            assembly {\n                item_ := mload(cursor_)\n                cursor_ := add(cursor_, 0x20)\n            }\n            // This is NOT in assembly so that we get overflow safety.\n            accumulator_ = accumulator_**item_;\n        }\n        assembly {\n            mstore(location_, accumulator_)\n            stackTopLocation_ := add(location_, 0x20)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/OpMax.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpMax\n/// @notice Opcode to stack the maximum of N numbers.\nlibrary OpMax {\n    function max(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        assembly {\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\n            let accumulator_ := mload(location_)\n            let cursor_ := add(location_, 0x20)\n            let item_\n            for {\n                cursor_ := add(location_, 0x20)\n            } lt(cursor_, stackTopLocation_) {\n                cursor_ := add(cursor_, 0x20)\n            } {\n                item_ := mload(cursor_)\n                if gt(item_, accumulator_) {\n                    accumulator_ := item_\n                }\n            }\n            mstore(location_, accumulator_)\n            stackTopLocation_ := add(location_, 0x20)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/OpMin.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpMin\n/// @notice Opcode to stack the minimum of N numbers.\nlibrary OpMin {\n    function min(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        assembly {\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\n            let accumulator_ := mload(location_)\n            let cursor_ := add(location_, 0x20)\n            let item_\n            for {\n                cursor_ := add(location_, 0x20)\n            } lt(cursor_, stackTopLocation_) {\n                cursor_ := add(cursor_, 0x20)\n            } {\n                item_ := mload(cursor_)\n                if lt(item_, accumulator_) {\n                    accumulator_ := item_\n                }\n            }\n            mstore(location_, accumulator_)\n            stackTopLocation_ := add(location_, 0x20)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/OpMod.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpMod\n/// @notice Opcode to mod N numbers.\nlibrary OpMod {\n    function mod(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        assembly {\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\n            let accumulator_ := mload(location_)\n            let item_\n            for {\n                let cursor_ := add(location_, 0x20)\n            } lt(cursor_, stackTopLocation_) {\n                cursor_ := add(cursor_, 0x20)\n            } {\n                item_ := mload(cursor_)\n                // Adapted from Open Zeppelin safe math.\n                if iszero(item_) {\n                    revert(0, 0)\n                }\n                accumulator_ := mod(accumulator_, item_)\n            }\n            mstore(location_, accumulator_)\n            stackTopLocation_ := add(location_, 0x20)\n        }\n\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/OpMul.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpMul\n/// @notice Opcode for multiplying N numbers.\nlibrary OpMul {\n    function mul(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        assembly {\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\n            let accumulator_ := mload(location_)\n            let item_\n            let intermediate_\n            for {\n                let cursor_ := add(location_, 0x20)\n            } lt(cursor_, stackTopLocation_) {\n                cursor_ := add(cursor_, 0x20)\n            } {\n                if gt(accumulator_, 0) {\n                    item_ := mload(cursor_)\n                    intermediate_ := mul(accumulator_, item_)\n                    // Adapted from Open Zeppelin safe math.\n                    if iszero(eq(div(intermediate_, accumulator_), item_)) {\n                        revert(0, 0)\n                    }\n                    accumulator_ := intermediate_\n                }\n            }\n            mstore(location_, accumulator_)\n            stackTopLocation_ := add(location_, 0x20)\n        }\n\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/math/OpSub.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title OpSub\n/// @notice Opcode for subtracting N numbers.\nlibrary OpSub {\n    function sub(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        assembly {\n            let location_ := sub(stackTopLocation_, mul(operand_, 0x20))\n            let accumulator_ := mload(location_)\n            let intermediate_\n            for {\n                let cursor_ := add(location_, 0x20)\n            } lt(cursor_, stackTopLocation_) {\n                cursor_ := add(cursor_, 0x20)\n            } {\n                intermediate_ := sub(accumulator_, mload(cursor_))\n                // Adapted from Open Zeppelin safe math.\n                if gt(intermediate_, accumulator_) {\n                    revert(0, 0)\n                }\n                accumulator_ := intermediate_\n            }\n            mstore(location_, accumulator_)\n            stackTopLocation_ := add(location_, 0x20)\n        }\n\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/tier/OpITierV2Report.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../../../tier/ITierV2.sol\";\n\n/// @title OpITierV2Report\n/// @notice Exposes `ITierV2.report` as an opcode.\nlibrary OpITierV2Report {\n    function stackPops(uint256 operand_)\n        internal\n        pure\n        returns (uint256 reportsLength_)\n    {\n        unchecked {\n            reportsLength_ = operand_ + 2;\n        }\n    }\n\n    // Stack the `report` returned by an `ITierV2` contract.\n    function report(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 tierContract_;\n        uint256 account_;\n        uint256[] memory context_;\n        assembly {\n            stackTopLocation_ := sub(stackTopLocation_, add(0x20, operand_))\n            location_ := sub(stackTopLocation_, 0x20)\n            tierContract_ := mload(location_)\n            account_ := mload(stackTopLocation_)\n            // we can reuse the account_ as the length for context_\n            // and achieve a near zero-cost bytes array to send to `report`.\n            mstore(stackTopLocation_, operand_)\n            context_ := stackTopLocation_\n        }\n        uint256 report_ = ITierV2(address(uint160(tierContract_))).report(\n            address(uint160(account_)),\n            context_\n        );\n        assembly {\n            mstore(location_, report_)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/tier/OpITierV2ReportTimeForTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../../../tier/ITierV2.sol\";\n\n/// @title OpITierV2Report\n/// @notice Exposes `ITierV2.reportTimeForTier` as an opcode.\nlibrary OpITierV2ReportTimeForTier {\n    function stackPops(uint256 operand_)\n        internal\n        pure\n        returns (uint256 reportsLength_)\n    {\n        unchecked {\n            reportsLength_ = operand_ + 3;\n        }\n    }\n\n    // Stack the `reportTimeForTier` returned by an `ITierV2` contract.\n    function reportTimeForTier(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 tierContract_;\n        uint256 account_;\n        uint256 tier_;\n        uint256[] memory context_;\n        assembly {\n            stackTopLocation_ := sub(stackTopLocation_, add(0x20, operand_))\n            location_ := sub(stackTopLocation_, 0x40)\n            tierContract_ := mload(location_)\n            account_ := mload(add(location_, 0x20))\n            tier_ := mload(stackTopLocation_)\n            // we can reuse the tier_ as the length for context_ and achieve a\n            // near zero-cost bytes array to send to `reportTimeForTier`.\n            mstore(stackTopLocation_, operand_)\n            context_ := stackTopLocation_\n        }\n        uint256 reportTime_ = ITierV2(address(uint160(tierContract_)))\n            .reportTimeForTier(address(uint160(account_)), tier_, context_);\n        assembly {\n            mstore(location_, reportTime_)\n            stackTopLocation_ := add(location_, 0x20)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/tier/OpSaturatingDiff.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../../../tier/libraries/TierwiseCombine.sol\";\n\nlibrary OpSaturatingDiff {\n    // Stack the tierwise saturating subtraction of two reports.\n    // If the older report is newer than newer report the result will\n    // be `0`, else a tierwise diff in blocks will be obtained.\n    // The older and newer report are taken from the stack.\n    function saturatingDiff(uint256, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 location_;\n        uint256 newerReport_;\n        uint256 olderReport_;\n        assembly {\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\n            location_ := sub(stackTopLocation_, 0x20)\n            newerReport_ := mload(location_)\n            olderReport_ := mload(stackTopLocation_)\n        }\n        uint256 result_ = TierwiseCombine.saturatingSub(\n            newerReport_,\n            olderReport_\n        );\n        assembly {\n            mstore(location_, result_)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/tier/OpSelectLte.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../../../tier/libraries/TierwiseCombine.sol\";\n\n/// @title OpSelectLte\n/// @notice Exposes `TierwiseCombine.selectLte` as an opcode.\nlibrary OpSelectLte {\n    function stackPops(uint256 operand_) internal pure returns (uint256) {\n        unchecked {\n            uint256 reportsLength_ = operand_ & 0x1F; // & 00011111\n            require(reportsLength_ > 0, \"BAD_OPERAND\");\n            return reportsLength_;\n        }\n    }\n\n    // Stacks the result of a `selectLte` combinator.\n    // All `selectLte` share the same stack and argument handling.\n    // Takes the `logic_` and `mode_` from the `operand_` high bits.\n    // `logic_` is the highest bit.\n    // `mode_` is the 2 highest bits after `logic_`.\n    // The other bits specify how many values to take from the stack\n    // as reports to compare against each other and the block number.\n    function selectLte(uint256 operand_, uint256 stackTopLocation_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 logic_ = operand_ >> 7;\n        uint256 mode_ = (operand_ >> 5) & 0x3; // & 00000011\n        uint256 reportsLength_ = operand_ & 0x1F; // & 00011111\n\n        uint256 location_;\n        uint256[] memory reports_ = new uint256[](reportsLength_);\n        uint256 time_;\n        assembly {\n            location_ := sub(\n                stackTopLocation_,\n                mul(add(reportsLength_, 1), 0x20)\n            )\n            let maxCursor_ := add(location_, mul(reportsLength_, 0x20))\n            for {\n                let cursor_ := location_\n                let i_ := 0\n            } lt(cursor_, maxCursor_) {\n                cursor_ := add(cursor_, 0x20)\n                i_ := add(i_, 0x20)\n            } {\n                mstore(add(reports_, add(0x20, i_)), mload(cursor_))\n            }\n            time_ := mload(maxCursor_)\n        }\n\n        uint256 result_ = TierwiseCombine.selectLte(\n            reports_,\n            time_,\n            logic_,\n            mode_\n        );\n        assembly {\n            mstore(location_, result_)\n            stackTopLocation_ := add(location_, 0x20)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "contracts/vm/ops/tier/OpUpdateTimesForTierRange.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../../../tier/libraries/TierReport.sol\";\n\nlibrary OpUpdateTimesForTierRange {\n    // Stacks a report with updated times over tier range.\n    // The start and end tier are taken from the low and high bits of\n    // the `operand_` respectively.\n    // The report to update and timestamp to update to are both\n    // taken from the stack.\n    function updateTimesForTierRange(\n        uint256 operand_,\n        uint256 stackTopLocation_\n    ) internal pure returns (uint256) {\n        uint256 location_;\n        uint256 report_;\n        uint256 startTier_ = operand_ & 0x0f; // & 00001111\n        uint256 endTier_ = (operand_ >> 4) & 0x0f; // & 00001111\n        uint256 timestamp_;\n\n        assembly {\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\n            location_ := sub(stackTopLocation_, 0x20)\n            report_ := mload(location_)\n            timestamp_ := mload(stackTopLocation_)\n        }\n\n        uint256 result_ = TierReport.updateTimesForTierRange(\n            report_,\n            startTier_,\n            endTier_,\n            timestamp_\n        );\n\n        assembly {\n            mstore(location_, result_)\n        }\n        return stackTopLocation_;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/ERC20Snapshot.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Arrays.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\n * total supply at the time are recorded for later access.\n *\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\n * In naive implementations it's possible to perform a \"double spend\" attack by reusing the same balance from different\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\n * used to create an efficient ERC20 forking mechanism.\n *\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\n * and the account address.\n *\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\n * return `block.number` will trigger the creation of snapshot at the beginning of each new block. When overriding this\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\n *\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\n * alternative consider {ERC20Votes}.\n *\n * ==== Gas Costs\n *\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\n *\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\n * transfers will have normal cost until the next snapshot, and so on.\n */\n\nabstract contract ERC20Snapshot is ERC20 {\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\n    // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\n\n    using Arrays for uint256[];\n    using Counters for Counters.Counter;\n\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\n    // Snapshot struct, but that would impede usage of functions that work on an array.\n    struct Snapshots {\n        uint256[] ids;\n        uint256[] values;\n    }\n\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\n    Snapshots private _totalSupplySnapshots;\n\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\n    Counters.Counter private _currentSnapshotId;\n\n    /**\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\n     */\n    event Snapshot(uint256 id);\n\n    /**\n     * @dev Creates a new snapshot and returns its snapshot id.\n     *\n     * Emits a {Snapshot} event that contains the same id.\n     *\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\n     *\n     * [WARNING]\n     * ====\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\n     * you must consider that it can potentially be used by attackers in two ways.\n     *\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\n     * section above.\n     *\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\n     * ====\n     */\n    function _snapshot() internal virtual returns (uint256) {\n        _currentSnapshotId.increment();\n\n        uint256 currentId = _getCurrentSnapshotId();\n        emit Snapshot(currentId);\n        return currentId;\n    }\n\n    /**\n     * @dev Get the current snapshotId\n     */\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\n        return _currentSnapshotId.current();\n    }\n\n    /**\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n     */\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\n\n        return snapshotted ? value : balanceOf(account);\n    }\n\n    /**\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\n     */\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\n\n        return snapshotted ? value : totalSupply();\n    }\n\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from == address(0)) {\n            // mint\n            _updateAccountSnapshot(to);\n            _updateTotalSupplySnapshot();\n        } else if (to == address(0)) {\n            // burn\n            _updateAccountSnapshot(from);\n            _updateTotalSupplySnapshot();\n        } else {\n            // transfer\n            _updateAccountSnapshot(from);\n            _updateAccountSnapshot(to);\n        }\n    }\n\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\n        require(snapshotId > 0, \"ERC20Snapshot: id is 0\");\n        require(snapshotId <= _getCurrentSnapshotId(), \"ERC20Snapshot: nonexistent id\");\n\n        // When a valid snapshot is queried, there are three possibilities:\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\n        //  to this id is the current one.\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\n        //  requested id, and its value is the one to return.\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\n        //  larger than the requested one.\n        //\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\n        // exactly this.\n\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\n\n        if (index == snapshots.ids.length) {\n            return (false, 0);\n        } else {\n            return (true, snapshots.values[index]);\n        }\n    }\n\n    function _updateAccountSnapshot(address account) private {\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\n    }\n\n    function _updateTotalSupplySnapshot() private {\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\n    }\n\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\n        uint256 currentId = _getCurrentSnapshotId();\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\n            snapshots.ids.push(currentId);\n            snapshots.values.push(currentValue);\n        }\n    }\n\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\n        if (ids.length == 0) {\n            return 0;\n        } else {\n            return ids[ids.length - 1];\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Arrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Arrays.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (array[mid] > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && array[low - 1] == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/math/FixedPointMath.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @dev The scale of all fixed point math. This is adopting the conventions of\n/// both ETH (wei) and most ERC20 tokens, so is hopefully uncontroversial.\nuint256 constant FP_DECIMALS = 18;\n/// @dev The number `1` in the standard fixed point math scaling. Most of the\n/// differences between fixed point math and regular math is multiplying or\n/// dividing by `ONE` after the appropriate scaling has been applied.\nuint256 constant FP_ONE = 1e18;\n\n/// @title FixedPointMath\n/// @notice Sometimes we want to do math with decimal values but all we have\n/// are integers, typically uint256 integers. Floats are very complex so we\n/// don't attempt to simulate them. Instead we provide a standard definition of\n/// \"one\" as 10 ** 18 and scale everything up/down to this as fixed point math.\n/// Overflows are errors as per Solidity.\nlibrary FixedPointMath {\n    /// Scale a fixed point decimal of some scale factor to match `DECIMALS`.\n    /// @param a_ Some fixed point decimal value.\n    /// @param aDecimals_ The number of fixed decimals of `a_`.\n    /// @return `a_` scaled to match `DECIMALS`.\n    function scale18(uint256 a_, uint256 aDecimals_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 decimals_;\n        if (FP_DECIMALS == aDecimals_) {\n            return a_;\n        } else if (FP_DECIMALS > aDecimals_) {\n            unchecked {\n                decimals_ = FP_DECIMALS - aDecimals_;\n            }\n            return a_ * 10**decimals_;\n        } else {\n            unchecked {\n                decimals_ = aDecimals_ - FP_DECIMALS;\n            }\n            return a_ / 10**decimals_;\n        }\n    }\n\n    /// Scale a fixed point decimals of `DECIMALS` to some other scale.\n    /// @param a_ A `DECIMALS` fixed point decimals.\n    /// @param targetDecimals_ The new scale of `a_`.\n    /// @return `a_` rescaled from `DECIMALS` to `targetDecimals_`.\n    function scaleN(uint256 a_, uint256 targetDecimals_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 decimals_;\n        if (targetDecimals_ == FP_DECIMALS) {\n            return a_;\n        } else if (FP_DECIMALS > targetDecimals_) {\n            unchecked {\n                decimals_ = FP_DECIMALS - targetDecimals_;\n            }\n            return a_ / 10**decimals_;\n        } else {\n            unchecked {\n                decimals_ = targetDecimals_ - FP_DECIMALS;\n            }\n            return a_ * 10**decimals_;\n        }\n    }\n\n    /// Scale a fixed point up or down by `scaleBy_` orders of magnitude.\n    /// The caller MUST ensure the end result matches `DECIMALS` if other\n    /// functions in this library are to work correctly.\n    /// Notably `scaleBy` is a SIGNED integer so scaling down by negative OOMS\n    /// is supported.\n    /// @param a_ Some integer of any scale.\n    /// @param scaleBy_ OOMs to scale `a_` up or down by.\n    /// @return `a_` rescaled according to `scaleBy_`.\n    function scaleBy(uint256 a_, int8 scaleBy_)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (scaleBy_ == 0) {\n            return a_;\n        } else if (scaleBy_ > 0) {\n            return a_ * 10**uint8(scaleBy_);\n        } else {\n            uint256 posScaleDownBy_;\n            unchecked {\n                posScaleDownBy_ = uint8(-1 * scaleBy_);\n            }\n            return a_ / 10**posScaleDownBy_;\n        }\n    }\n\n    /// Fixed point multiplication in native scale decimals.\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` multiplied by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointMul(uint256 a_, uint256 b_)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (a_ * b_) / FP_ONE;\n    }\n\n    /// Fixed point division in native scale decimals.\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` divided by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointDiv(uint256 a_, uint256 b_)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (a_ * FP_ONE) / b_;\n    }\n}\n"
    },
    "contracts/tier/libraries/TierwiseCombine.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./TierReport.sol\";\nimport \"../../math/SaturatingMath.sol\";\n\nlibrary TierwiseCombine {\n    using Math for uint256;\n    using SaturatingMath for uint256;\n\n    /// Every lte check in `selectLte` must pass.\n    uint256 internal constant LOGIC_EVERY = 0;\n    /// Only one lte check in `selectLte` must pass.\n    uint256 internal constant LOGIC_ANY = 1;\n\n    /// Select the minimum block number from passing blocks in `selectLte`.\n    uint256 internal constant MODE_MIN = 0;\n    /// Select the maximum block number from passing blocks in `selectLte`.\n    uint256 internal constant MODE_MAX = 1;\n    /// Select the first block number that passes in `selectLte`.\n    uint256 internal constant MODE_FIRST = 2;\n\n    /// Performs a tierwise saturating subtraction of two reports.\n    /// Intepret as \"# of blocks older report was held before newer report\".\n    /// If older report is in fact newer then `0` will be returned.\n    /// i.e. the diff cannot be negative, older report as simply spent 0 blocks\n    /// existing before newer report, if it is in truth the newer report.\n    /// @param newerReport_ Block to subtract from.\n    /// @param olderReport_ Block to subtract.\n    function saturatingSub(uint256 newerReport_, uint256 olderReport_)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            uint256 ret_;\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\n                uint256 newerBlock_ = TierReport.reportTimeForTier(\n                    newerReport_,\n                    tier_\n                );\n                uint256 olderBlock_ = TierReport.reportTimeForTier(\n                    olderReport_,\n                    tier_\n                );\n                uint256 diff_ = newerBlock_.saturatingSub(olderBlock_);\n                ret_ = TierReport.updateTimeAtTier(ret_, tier_ - 1, diff_);\n            }\n            return ret_;\n        }\n    }\n\n    /// Given a list of reports, selects the best tier in a tierwise fashion.\n    /// The \"best\" criteria can be configured by `logic_` and `mode_`.\n    /// Logic can be \"every\" or \"any\", which means that the reports for a given\n    /// tier must either all or any be less than or equal to the reference\n    /// `blockNumber_`.\n    /// Mode can be \"min\", \"max\", \"first\" which selects between all the block\n    /// numbers for a given tier that meet the lte criteria.\n    /// IMPORTANT: If the output of `selectLte` is used to write to storage\n    /// care must be taken to ensure that \"upcoming\" tiers relative to the\n    /// `blockNumber_` are not overwritten inappropriately. Typically this\n    /// function should be used as a filter over reads only from an upstream\n    /// source of truth.\n    /// @param reports_ The list of reports to select over.\n    /// @param blockNumber_ The block number that tier blocks must be lte.\n    /// @param logic_ `LOGIC_EVERY` or `LOGIC_ANY`.\n    /// @param mode_ `MODE_MIN`, `MODE_MAX` or `MODE_FIRST`.\n    function selectLte(\n        uint256[] memory reports_,\n        uint256 blockNumber_,\n        uint256 logic_,\n        uint256 mode_\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 ret_;\n            uint256 block_;\n            bool anyLte_;\n            uint256 length_ = reports_.length;\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\n                uint256 accumulator_;\n                // Nothing lte the reference block for this tier yet.\n                anyLte_ = false;\n\n                // Initialize the accumulator for this tier.\n                if (mode_ == MODE_MIN) {\n                    accumulator_ = TierConstants.NEVER_REPORT;\n                } else {\n                    accumulator_ = 0;\n                }\n\n                // Filter all the blocks at the current tier from all the\n                // reports against the reference tier and each other.\n                for (uint256 i_ = 0; i_ < length_; i_++) {\n                    block_ = TierReport.reportTimeForTier(reports_[i_], tier_);\n\n                    if (block_ <= blockNumber_) {\n                        // Min and max need to compare current value against\n                        // the accumulator.\n                        if (mode_ == MODE_MIN) {\n                            accumulator_ = block_.min(accumulator_);\n                        } else if (mode_ == MODE_MAX) {\n                            accumulator_ = block_.max(accumulator_);\n                        } else if (mode_ == MODE_FIRST && !anyLte_) {\n                            accumulator_ = block_;\n                        }\n                        anyLte_ = true;\n                    } else if (logic_ == LOGIC_EVERY) {\n                        // Can short circuit for an \"every\" check.\n                        accumulator_ = TierConstants.NEVER_REPORT;\n                        break;\n                    }\n                }\n                if (!anyLte_) {\n                    accumulator_ = TierConstants.NEVER_REPORT;\n                }\n                ret_ = TierReport.updateTimeAtTier(\n                    ret_,\n                    tier_ - 1,\n                    accumulator_\n                );\n            }\n            return ret_;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/claim/EmissionsERC20Factory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport {EmissionsERC20, EmissionsERC20Config} from \"./EmissionsERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\n/// @title EmissionsERC20Factory\n/// @notice Factory for deploying and registering `EmissionsERC20` contracts.\ncontract EmissionsERC20Factory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor(address vmStateBuilder_) {\n        address implementation_ = address(new EmissionsERC20(vmStateBuilder_));\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        EmissionsERC20Config memory config_ = abi.decode(\n            data_,\n            (EmissionsERC20Config)\n        );\n        address clone_ = Clones.clone(implementation);\n        EmissionsERC20(clone_).initialize(config_);\n        return clone_;\n    }\n\n    /// Allows calling `createChild` with `EmissionsERC20Config` struct.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `EmissionsERC20` constructor configuration.\n    /// @return New `EmissionsERC20` child contract address.\n    function createChildTyped(EmissionsERC20Config calldata config_)\n        external\n        returns (EmissionsERC20)\n    {\n        return EmissionsERC20(this.createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "contracts/factory/Factory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IFactory} from \"./IFactory.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title Factory\n/// @notice Base contract for deploying and registering child contracts.\nabstract contract Factory is IFactory, ReentrancyGuard {\n    /// @dev state to track each deployed contract address. A `Factory` will\n    /// never lie about deploying a child, unless `isChild` is overridden to do\n    /// so.\n    mapping(address => bool) private contracts;\n\n    /// Implements `IFactory`.\n    ///\n    /// `_createChild` hook must be overridden to actually create child\n    /// contract.\n    ///\n    /// Implementers may want to overload this function with a typed equivalent\n    /// to expose domain specific structs etc. to the compiled ABI consumed by\n    /// tooling and other scripts. To minimise gas costs for deployment it is\n    /// expected that the tooling will consume the typed ABI, then encode the\n    /// arguments and pass them to this function directly.\n    ///\n    /// @param data_ ABI encoded data to pass to child contract constructor.\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        returns (address);\n\n    /// Implements `IFactory`.\n    ///\n    /// Calls the `_createChild` hook that inheriting contracts must override.\n    /// Registers child contract address such that `isChild` is `true`.\n    /// Emits `NewChild` event.\n    ///\n    /// @param data_ Encoded data to pass down to child contract constructor.\n    /// @return New child contract address.\n    function createChild(bytes calldata data_)\n        external\n        virtual\n        override\n        nonReentrant\n        returns (address)\n    {\n        // Create child contract using hook.\n        address child_ = _createChild(data_);\n        // Ensure the child at this address has not previously been deployed.\n        require(!contracts[child_], \"DUPLICATE_CHILD\");\n        // Register child contract address to `contracts` mapping.\n        contracts[child_] = true;\n        // Emit `NewChild` event with child contract address.\n        emit IFactory.NewChild(msg.sender, child_);\n        return child_;\n    }\n\n    /// Implements `IFactory`.\n    ///\n    /// Checks if address is registered as a child contract of this factory.\n    ///\n    /// @param maybeChild_ Address of child contract to look up.\n    /// @return Returns `true` if address is a contract created by this\n    /// contract factory, otherwise `false`.\n    function isChild(address maybeChild_)\n        external\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return contracts[maybeChild_];\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/factory/IFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\ninterface IFactory {\n    /// Whenever a new child contract is deployed, a `NewChild` event\n    /// containing the new child contract address MUST be emitted.\n    /// @param sender `msg.sender` that deployed the contract (factory).\n    /// @param child address of the newly deployed child.\n    event NewChild(address sender, address child);\n\n    /// Factories that clone a template contract MUST emit an event any time\n    /// they set the implementation being cloned. Factories that deploy new\n    /// contracts without cloning do NOT need to emit this.\n    /// @param sender `msg.sender` that deployed the implementation (factory).\n    /// @param implementation address of the implementation contract that will\n    /// be used for future clones if relevant.\n    event Implementation(address sender, address implementation);\n\n    /// Creates a new child contract.\n    ///\n    /// @param data_ Domain specific data for the child contract constructor.\n    /// @return New child contract address.\n    function createChild(bytes calldata data_) external returns (address);\n\n    /// Checks if address is registered as a child contract of this factory.\n    ///\n    /// Addresses that were not deployed by `createChild` MUST NOT return\n    /// `true` from `isChild`. This is CRITICAL to the security guarantees for\n    /// any contract implementing `IFactory`.\n    ///\n    /// @param maybeChild_ Address to check registration for.\n    /// @return `true` if address was deployed by this contract factory,\n    /// otherwise `false`.\n    function isChild(address maybeChild_) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/verify/VerifyFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport {Verify, VerifyConfig} from \"./Verify.sol\";\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\n/// @title VerifyFactory\n/// @notice Factory for creating and deploying `Verify` contracts.\ncontract VerifyFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new Verify());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        VerifyConfig memory config_ = abi.decode(data_, (VerifyConfig));\n        address clone_ = Clones.clone(implementation);\n        Verify(clone_).initialize(config_);\n        return clone_;\n    }\n\n    /// Typed wrapper for `createChild` with admin address.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ Initialization config for the new `Verify` child.\n    /// @return New `Verify` child contract address.\n    function createChildTyped(VerifyConfig calldata config_)\n        external\n        returns (Verify)\n    {\n        return Verify(this.createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "contracts/verify/Verify.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"./IVerifyCallback.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./libraries/VerifyConstants.sol\";\n\n/// Records the time a verify session reaches each status.\n/// If a status is not reached it is left as UNINITIALIZED, i.e. 0xFFFFFFFF.\n/// Most accounts will never be banned so most accounts will never reach every\n/// status, which is a good thing.\n/// @param addedSince Time the address was added else 0xFFFFFFFF.\n/// @param approvedSince Time the address was approved else 0xFFFFFFFF.\n/// @param bannedSince Time the address was banned else 0xFFFFFFFF.\nstruct State {\n    uint32 addedSince;\n    uint32 approvedSince;\n    uint32 bannedSince;\n}\n\n/// Structure of arbitrary evidence to support any action taken.\n/// Priviledged roles are expected to provide evidence just as applicants as an\n/// audit trail will be preserved permanently in the logs.\n/// @param account The account this evidence is relevant to.\n/// @param data Arbitrary bytes representing evidence. MAY be e.g. a reference\n/// to a sufficiently decentralised external system such as an IPFS hash.\nstruct Evidence {\n    address account;\n    bytes data;\n}\n\n/// Config to initialize a Verify contract with.\n/// @param admin The address to ASSIGN ALL ADMIN ROLES to initially. This\n/// address is free and encouraged to delegate fine grained permissions to\n/// many other sub-admin addresses, then revoke it's own \"root\" access.\n/// @param callback The address of the `IVerifyCallback` contract if it exists.\n/// MAY be `address(0)` to signify that callbacks should NOT run.\nstruct VerifyConfig {\n    address admin;\n    address callback;\n}\n\n/// @title Verify\n/// Trust-minimised contract to record the state of some verification process.\n/// When some off-chain identity is to be reified on chain there is inherently\n/// some multi-party, multi-faceted trust relationship. For example, the DID\n/// (Decentralized Identifiers) specification from W3C outlines that the\n/// controller and the subject of an identity are two different entities.\n///\n/// This is because self-identification is always problematic to the point of\n/// being uselessly unbelievable.\n///\n/// For example, I can simply say \"I am the queen of England\" and what\n/// onchain mechanism could possibly check, let alone stop me?\n/// The same problem exists in any situation where some priviledge or right is\n/// associated with identity. Consider passports, driver's licenses,\n/// celebrity status, age, health, accredited investor, social media account,\n/// etc. etc.\n///\n/// Typically crypto can't and doesn't want to deal with this issue. The usual\n/// scenario is that some system demands personal information, which leads to:\n///\n/// - Data breaches that put individual's safety at risk. Consider the December\n///   2020 leak from Ledger that dumped 270 000 home addresses and phone\n///   numbers, and another million emails, of hardware wallet owners on a\n///   public forum.\n/// - Discriminatory access, undermining an individual's self-sovereign right\n///   to run a full node, self-host a GUI and broadcast transactions onchain.\n///   Consider the dydx airdrop of 2021 where metadata about a user's access\n///   patterns logged on a server were used to deny access to presumed\n///   Americans over regulatory fears.\n/// - An entrenched supply chain of centralized actors from regulators, to\n///   government databases, through KYC corporations, platforms, etc. each of\n///   which holds an effective monopoly over, and ability to manipulate user's\n///   \"own\" identity.\n///\n/// These examples and others are completely antithetical to and undermine the\n/// safety of an opt-in, permissionless system based on pseudonomous actors\n/// self-signing actions into a shared space.\n///\n/// That said, one can hardly expect a permissionless pseudonomous system\n/// founded on asynchronous value transfers to succeed without at least some\n/// concept of curation and reputation.\n///\n/// Anon, will you invest YOUR money in anon's project?\n///\n/// Clearly for every defi blue chip there are 10 000 scams and nothing onchain\n/// can stop a scam, this MUST happen at the social layer.\n///\n/// Rain protocol is agnostic to how this verification happens. A government\n/// regulator is going to want a government issued ID cross-referenced against\n/// international sanctions. A fan of some social media influencer wants to\n/// see a verified account on that platform. An open source software project\n/// should show a github profile. A security token may need evidence from an\n/// accountant showing accredited investor status. There are so many ways in\n/// which BOTH sides of a fundraise may need to verify something about\n/// themselves to each other via a THIRD PARTY that Rain cannot assume much.\n///\n/// The trust model and process for Rain verification is:\n///\n/// - There are many `Verify` contracts, each represents a specific\n///   verification method with a (hopefully large) set of possible reviewers.\n/// - The verifyee compiles some evidence that can be referenced in some\n///   relevant system. It could be a session ID in a KYC provider's database or\n///   a tweet from a verified account, etc. The evidence is passed to the\n///   `Verify` contract as raw bytes so it is opaque onchain, but visible as an\n///   event to verifiers.\n/// - The verifyee calls `add` _for themselves_ to initialize their state and\n///   emit the evidence for their account, after which they _cannot change_\n///   their submission without appealing to someone who can remove. This costs\n///   gas, so why don't we simply ask the user to sign something and have an\n///   approver verify the signed data? Because we want to leverage both the\n///   censorship resistance and asynchronous nature of the underlying\n///   blockchain. Assuming there are N possible approvers, we want ANY 1 of\n///   those N approvers to be able to review and approve an application. If the\n///   user is forced to submit their application directly to one SPECIFIC\n///   approver we lose this property. In the gasless model the user must then\n///   rely on their specific approver both being online and not to censor the\n///   request. It's also possible that many accounts add the same evidence,\n///   after all it will be public in the event logs, so it is important for\n///   approvers to verify the PAIRING between account and evidence.\n/// - ANY account with the `APPROVER` role can review the evidence by\n///   inspecting the event logs. IF the evidence is valid then the `approve`\n///   function should be called by the approver. Approvers MAY also approve and\n///   implicitly add any account atomically if the account did not previously\n///   add itself.\n/// - ANY account with the `BANNER` role can veto either an add OR a prior\n///   approval. In the case of a false positive, i.e. where an account was\n///   mistakenly approved, an appeal can be made to a banner to update the\n///   status. Bad accounts SHOULD BE BANNED NOT REMOVED. When an account is\n///   removed, its onchain state is once again open for the attacker to\n///   resubmit new fraudulent evidence and potentially be reapproved.\n///   Once an account is banned, any attempt by the account holder to change\n///   their status, or an approver to approve will be rejected. Downstream\n///   consumers of a `State` MUST check for an existing ban. Banners MAY ban\n///   and implicity add any account atomically if the account did not\n///   previously add itself.\n///   - ANY account with the `REMOVER` role can scrub the `State` from an\n///   account. Of course, this is a blockchain so the state changes are all\n///   still visible to full nodes and indexers in historical data, in both the\n///   onchain history and the event logs for each state change. This allows an\n///   account to appeal to a remover in the case of a MISTAKEN BAN or also in\n///   the case of a MISTAKEN ADD (e.g. mistake in evidence), effecting a\n///   \"hard reset\" at the contract storage level.\n///\n/// Banning some account with an invalid session is NOT required. It is\n/// harmless for an added session to remain as `Status.Added` indefinitely.\n/// For as long as no approver decides to approve some invalid added session it\n/// MUST be treated as equivalent to a ban by downstream contracts. This is\n/// important so that admins are only required to spend gas on useful actions.\n///\n/// In addition to `Approve`, `Ban`, `Remove` there are corresponding events\n/// `RequestApprove`, `RequestBan`, `RequestRemove` that allow for admins to be\n/// notified that some new evidence must be considered that may lead to each\n/// action. `RequestApprove` is automatically submitted as part of the `add`\n/// call, but `RequestBan` and `RequestRemove` must be manually called\n///\n/// Rain uses standard Open Zeppelin `AccessControl` and is agnostic to how the\n/// approver/remover/banner roles and associated admin roles are managed.\n/// Ideally the more credibly neutral qualified parties assigend to each role\n/// for each `Verify` contract the better. This improves the censorship\n/// resistance of the verification process and the responsiveness of the\n/// end-user experience.\n///\n/// Ideally the admin account assigned at deployment would renounce their admin\n/// rights after establishing a more granular and appropriate set of accounts\n/// with each specific role.\n///\n/// There is no requirement that any of the priviledged accounts with roles are\n/// a single-key EOA, they may be multisig accounts or even a DAO with formal\n/// governance processes mediated by a smart contract.\n///\n/// Every action emits an associated event and optionally calls an onchain\n/// callback on a `IVerifyCallback` contract set during initialize. As each\n/// action my be performed in bulk dupes are not rolled back, instead the\n/// events are emitted for every time the action is called and the callbacks\n/// and onchain state changes are deduped. For example, an approve may be\n/// called twice for a single account, but by different approvers, potentially\n/// submitting different evidence for each approval. In this case the time of\n/// the first approve will be used and the onchain callback will be called for\n/// the first transaction only, but BOTH approvals will emit an event. This\n/// logic is applied per-account, per-action across a batch of evidences.\ncontract Verify is AccessControl, Initializable {\n    /// Any state never held is UNINITIALIZED.\n    /// Note that as per default evm an unset state is 0 so always check the\n    /// `addedSince` time on a `State` before trusting an equality check on\n    /// any other time.\n    /// (i.e. removed or never added)\n    uint32 private constant UNINITIALIZED = type(uint32).max;\n\n    /// Emitted when the `Verify` contract is initialized.\n    event Initialize(address sender, VerifyConfig config);\n\n    /// Emitted when evidence is first submitted to approve an account.\n    /// The requestor is always the `msg.sender` of the user calling `add`.\n    /// @param sender The `msg.sender` that submitted its own evidence.\n    /// @param evidence The evidence to support an approval.\n    /// NOT written to contract storage.\n    event RequestApprove(address sender, Evidence evidence);\n    /// Emitted when a previously added account is approved.\n    /// @param sender The `msg.sender` that approved `account`.\n    /// @param evidence The approval data.\n    event Approve(address sender, Evidence evidence);\n\n    /// Currently approved accounts can request that any account be banned.\n    /// The requestor is expected to provide supporting data for the ban.\n    /// The requestor MAY themselves be banned if vexatious.\n    /// @param sender The `msg.sender` requesting a ban of `account`.\n    /// @param evidence Account + data the `requestor` feels will strengthen\n    /// its case for the ban. NOT written to contract storage.\n    event RequestBan(address sender, Evidence evidence);\n    /// Emitted when an added or approved account is banned.\n    /// @param sender The `msg.sender` that banned `account`.\n    /// @param evidence Account + the evidence to support a ban.\n    /// NOT written to contract storage.\n    event Ban(address sender, Evidence evidence);\n\n    /// Currently approved accounts can request that any account be removed.\n    /// The requestor is expected to provide supporting data for the removal.\n    /// The requestor MAY themselves be banned if vexatious.\n    /// @param sender The `msg.sender` requesting a removal of `account`.\n    /// @param evidence `Evidence` to justify a removal.\n    event RequestRemove(address sender, Evidence evidence);\n    /// Emitted when an account is scrubbed from blockchain state.\n    /// Historical logs still visible offchain of course.\n    /// @param sender The `msg.sender` that removed `account`.\n    /// @param evidence `Evidence` to justify the removal.\n    event Remove(address sender, Evidence evidence);\n\n    /// Admin role for `APPROVER`.\n    bytes32 public constant APPROVER_ADMIN = keccak256(\"APPROVER_ADMIN\");\n    /// Role for `APPROVER`.\n    bytes32 public constant APPROVER = keccak256(\"APPROVER\");\n\n    /// Admin role for `REMOVER`.\n    bytes32 public constant REMOVER_ADMIN = keccak256(\"REMOVER_ADMIN\");\n    /// Role for `REMOVER`.\n    bytes32 public constant REMOVER = keccak256(\"REMOVER\");\n\n    /// Admin role for `BANNER`.\n    bytes32 public constant BANNER_ADMIN = keccak256(\"BANNER_ADMIN\");\n    /// Role for `BANNER`.\n    bytes32 public constant BANNER = keccak256(\"BANNER\");\n\n    /// Account => State\n    mapping(address => State) private states;\n\n    /// Optional IVerifyCallback contract.\n    /// MAY be address 0.\n    IVerifyCallback public callback;\n\n    /// Initializes the `Verify` contract e.g. as cloned by a factory.\n    /// @param config_ The config required to initialize the contract.\n    function initialize(VerifyConfig calldata config_) external initializer {\n        require(config_.admin != address(0), \"0_ACCOUNT\");\n\n        // `APPROVER_ADMIN` can admin each other in addition to\n        // `APPROVER` addresses underneath.\n        _setRoleAdmin(APPROVER_ADMIN, APPROVER_ADMIN);\n        _setRoleAdmin(APPROVER, APPROVER_ADMIN);\n\n        // `REMOVER_ADMIN` can admin each other in addition to\n        // `REMOVER` addresses underneath.\n        _setRoleAdmin(REMOVER_ADMIN, REMOVER_ADMIN);\n        _setRoleAdmin(REMOVER, REMOVER_ADMIN);\n\n        // `BANNER_ADMIN` can admin each other in addition to\n        // `BANNER` addresses underneath.\n        _setRoleAdmin(BANNER_ADMIN, BANNER_ADMIN);\n        _setRoleAdmin(BANNER, BANNER_ADMIN);\n\n        // It is STRONGLY RECOMMENDED that the `admin_` delegates specific\n        // admin roles then revokes the `X_ADMIN` roles. From themselves.\n        // It is ALSO RECOMMENDED that each of the sub-`X_ADMIN` roles revokes\n        // their admin rights once sufficient approvers/removers/banners have\n        // been assigned, if possible. Admins can instantly/atomically assign\n        // and revoke admin priviledges from each other, so a compromised key\n        // can irreperably damage a `Verify` contract instance.\n        _grantRole(APPROVER_ADMIN, config_.admin);\n        _grantRole(REMOVER_ADMIN, config_.admin);\n        _grantRole(BANNER_ADMIN, config_.admin);\n\n        callback = IVerifyCallback(config_.callback);\n\n        emit Initialize(msg.sender, config_);\n    }\n\n    function _updateEvidenceRef(\n        uint256[] memory refs_,\n        Evidence memory evidence_,\n        uint256 refsIndex_\n    ) private pure {\n        uint256 ptr_;\n        assembly {\n            ptr_ := evidence_\n        }\n        refs_[refsIndex_] = ptr_;\n    }\n\n    function _resizeRefs(uint256[] memory refs_, uint256 newLength_)\n        private\n        pure\n    {\n        require(newLength_ <= refs_.length, \"BAD_RESIZE\");\n        assembly {\n            mstore(refs_, newLength_)\n        }\n    }\n\n    function _refsAsEvidences(uint256[] memory refs_)\n        private\n        pure\n        returns (Evidence[] memory)\n    {\n        Evidence[] memory evidences_;\n        assembly {\n            evidences_ := refs_\n        }\n        return evidences_;\n    }\n\n    /// Typed accessor into states.\n    /// @param account_ The account to return the current `State` for.\n    function state(address account_) external view returns (State memory) {\n        return states[account_];\n    }\n\n    /// Derives a single `Status` from a `State` and a reference timestamp.\n    /// @param state_ The raw `State` to reduce into a `Status`.\n    /// @param timestamp_ The timestamp to compare `State` against.\n    /// @return status_ The status in `State` given `timestamp_`.\n    function statusAtTime(State memory state_, uint256 timestamp_)\n        public\n        pure\n        returns (uint256 status_)\n    {\n        // The state hasn't even been added so is picking up time zero as the\n        // evm fallback value. In this case if we checked other times using\n        // a `<=` equality they would incorrectly return `true` always due to\n        // also having a `0` fallback value.\n        // Using `< 1` here to silence slither.\n        if (state_.addedSince < 1) {\n            status_ = VerifyConstants.STATUS_NIL;\n        }\n        // Banned takes priority over everything.\n        else if (state_.bannedSince <= timestamp_) {\n            status_ = VerifyConstants.STATUS_BANNED;\n        }\n        // Approved takes priority over added.\n        else if (state_.approvedSince <= timestamp_) {\n            status_ = VerifyConstants.STATUS_APPROVED;\n        }\n        // Added is lowest priority.\n        else if (state_.addedSince <= timestamp_) {\n            status_ = VerifyConstants.STATUS_ADDED;\n        }\n        // The `addedSince` time is after `timestamp_` so `Status` is nil\n        // relative to `timestamp_`.\n        else {\n            status_ = VerifyConstants.STATUS_NIL;\n        }\n    }\n\n    /// Requires that `msg.sender` is approved as at the current timestamp.\n    modifier onlyApproved() {\n        require(\n            statusAtTime(states[msg.sender], block.timestamp) ==\n                VerifyConstants.STATUS_APPROVED,\n            \"ONLY_APPROVED\"\n        );\n        _;\n    }\n\n    /// @dev Builds a new `State` for use by `add` and `approve`.\n    function newState() private view returns (State memory state_) {\n        state_ = State(uint32(block.timestamp), UNINITIALIZED, UNINITIALIZED);\n    }\n\n    /// An account adds their own verification evidence.\n    /// Internally `msg.sender` is used; delegated `add` is not supported.\n    /// @param data_ The evidence to support approving the `msg.sender`.\n    function add(bytes calldata data_) external {\n        State memory state_ = states[msg.sender];\n        uint256 currentStatus_ = statusAtTime(state_, block.timestamp);\n        require(\n            currentStatus_ != VerifyConstants.STATUS_APPROVED &&\n                currentStatus_ != VerifyConstants.STATUS_BANNED,\n            \"ALREADY_EXISTS\"\n        );\n        // An account that hasn't already been added need a new state.\n        // If an account has already been added but not approved or banned\n        // they can emit many `RequestApprove` events without changing\n        // their state. This facilitates multi-step workflows for the KYC\n        // provider, e.g. to implement a commit+reveal scheme or simply\n        // request additional evidence from the applicant before final\n        // verdict.\n        if (currentStatus_ == VerifyConstants.STATUS_NIL) {\n            states[msg.sender] = newState();\n        }\n        Evidence memory evidence_ = Evidence(msg.sender, data_);\n        emit RequestApprove(msg.sender, evidence_);\n\n        // Call the `afterAdd_` hook to allow inheriting contracts to enforce\n        // requirements.\n        // The inheriting contract MUST `require` or otherwise enforce its\n        // needs to rollback a bad add.\n        IVerifyCallback callback_ = callback;\n        if (address(callback_) != address(0)) {\n            Evidence[] memory evidences_ = new Evidence[](1);\n            evidences_[0] = evidence_;\n            callback_.afterAdd(msg.sender, evidences_);\n        }\n    }\n\n    /// An `APPROVER` can review added evidence and approve accounts.\n    /// Typically many approvals would be submitted in a single call which is\n    /// more convenient and gas efficient than sending individual transactions\n    /// for every approval. However, as there are many individual agents\n    /// acting concurrently and independently this requires that the approval\n    /// process be infallible so that no individual approval can rollback the\n    /// entire batch due to the actions of some other approver/banner. It is\n    /// possible to approve an already approved or banned account. The\n    /// `Approve` event will always emit but the approved time will only be\n    /// set if it was previously uninitialized. A banned account will always\n    /// be seen as banned when calling `statusAtTime` regardless of the\n    /// approval time, even if the approval is more recent than the ban. The\n    /// only way to reset a ban is to remove and reapprove the account.\n    /// @param evidences_ All evidence for all approvals.\n    function approve(Evidence[] memory evidences_) external onlyRole(APPROVER) {\n        unchecked {\n            State memory state_;\n            uint256[] memory addedRefs_ = new uint256[](evidences_.length);\n            uint256[] memory approvedRefs_ = new uint256[](evidences_.length);\n            uint256 additions_ = 0;\n            uint256 approvals_ = 0;\n\n            for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n                Evidence memory evidence_ = evidences_[i_];\n                state_ = states[evidence_.account];\n                // If the account hasn't been added an approver can still add\n                // and approve it on their behalf.\n                if (state_.addedSince < 1) {\n                    state_ = newState();\n\n                    _updateEvidenceRef(addedRefs_, evidence_, additions_);\n                    additions_++;\n                }\n                // If the account hasn't been approved we approve it. As there\n                // are many approvers operating independently and concurrently\n                // we do NOT `require` the approval be unique, but we also do\n                // NOT change the time as the oldest approval is most\n                // important. However we emit an event for every approval even\n                // if the state does not change.\n                // It is possible to approve a banned account but\n                // `statusAtTime` will ignore the approval time for any banned\n                // account and use the banned time only.\n                if (state_.approvedSince == UNINITIALIZED) {\n                    state_.approvedSince = uint32(block.timestamp);\n                    states[evidence_.account] = state_;\n\n                    _updateEvidenceRef(approvedRefs_, evidence_, approvals_);\n                    approvals_++;\n                }\n\n                // Always emit an `Approve` event even if we didn't write to\n                // storage. This ensures that supporting evidence hits the logs\n                // for offchain review.\n                emit Approve(msg.sender, evidence_);\n            }\n            IVerifyCallback callback_ = callback;\n            if (address(callback_) != address(0)) {\n                if (additions_ > 0) {\n                    _resizeRefs(addedRefs_, additions_);\n                    callback_.afterAdd(\n                        msg.sender,\n                        _refsAsEvidences(addedRefs_)\n                    );\n                }\n                if (approvals_ > 0) {\n                    _resizeRefs(approvedRefs_, approvals_);\n                    callback_.afterApprove(\n                        msg.sender,\n                        _refsAsEvidences(approvedRefs_)\n                    );\n                }\n            }\n        }\n    }\n\n    /// Any approved address can request some address be approved.\n    /// Frivolous requestors SHOULD expect to find themselves banned.\n    /// @param evidences_ Array of evidences to request approvals for.\n    function requestApprove(Evidence[] calldata evidences_)\n        external\n        onlyApproved\n    {\n        unchecked {\n            for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n                emit RequestApprove(msg.sender, evidences_[i_]);\n            }\n        }\n    }\n\n    /// A `BANNER` can ban an added OR approved account.\n    /// @param evidences_ All evidence appropriate for all bans.\n    function ban(Evidence[] calldata evidences_) external onlyRole(BANNER) {\n        unchecked {\n            State memory state_;\n            uint256[] memory addedRefs_ = new uint256[](evidences_.length);\n            uint256[] memory bannedRefs_ = new uint256[](evidences_.length);\n            uint256 additions_ = 0;\n            uint256 bans_ = 0;\n            for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n                Evidence memory evidence_ = evidences_[i_];\n                state_ = states[evidence_.account];\n\n                // There is no requirement that an account be formerly added\n                // before it is banned. For example some fraud may be detected\n                // in an affiliated `Verify` contract and the evidence can be\n                // used to ban the same address in the current contract. In\n                // this case the account will be added and banned in this call.\n                if (state_.addedSince < 1) {\n                    state_ = newState();\n\n                    _updateEvidenceRef(addedRefs_, evidence_, additions_);\n                    additions_++;\n                }\n                // Respect prior bans by leaving onchain storage as-is.\n                if (state_.bannedSince == UNINITIALIZED) {\n                    state_.bannedSince = uint32(block.timestamp);\n                    states[evidence_.account] = state_;\n\n                    _updateEvidenceRef(bannedRefs_, evidence_, bans_);\n                    bans_++;\n                }\n\n                // Always emit a `Ban` event even if we didn't write state. This\n                // ensures that supporting evidence hits the logs for offchain\n                // review.\n                emit Ban(msg.sender, evidence_);\n            }\n            IVerifyCallback callback_ = callback;\n            if (address(callback_) != address(0)) {\n                if (additions_ > 0) {\n                    _resizeRefs(addedRefs_, additions_);\n                    callback_.afterAdd(\n                        msg.sender,\n                        _refsAsEvidences(addedRefs_)\n                    );\n                }\n                if (bans_ > 0) {\n                    _resizeRefs(bannedRefs_, bans_);\n                    callback_.afterBan(\n                        msg.sender,\n                        _refsAsEvidences(bannedRefs_)\n                    );\n                }\n            }\n        }\n    }\n\n    /// Any approved address can request some address be banned.\n    /// Frivolous requestors SHOULD expect to find themselves banned.\n    /// @param evidences_ Array of evidences to request banning for.\n    function requestBan(Evidence[] calldata evidences_) external onlyApproved {\n        unchecked {\n            for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n                emit RequestBan(msg.sender, evidences_[i_]);\n            }\n        }\n    }\n\n    /// A `REMOVER` can scrub state mapping from an account.\n    /// A malicious account MUST be banned rather than removed.\n    /// Removal is useful to reset the whole process in case of some mistake.\n    /// @param evidences_ All evidence to suppor the removal.\n    function remove(Evidence[] memory evidences_) external onlyRole(REMOVER) {\n        unchecked {\n            State memory state_;\n            uint256[] memory removedRefs_ = new uint256[](evidences_.length);\n            uint256 removals_ = 0;\n            for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n                Evidence memory evidence_ = evidences_[i_];\n                state_ = states[evidences_[i_].account];\n                if (state_.addedSince > 0) {\n                    delete (states[evidence_.account]);\n                    _updateEvidenceRef(removedRefs_, evidence_, removals_);\n                    removals_++;\n                }\n                emit Remove(msg.sender, evidence_);\n            }\n            IVerifyCallback callback_ = callback;\n            if (address(callback_) != address(0)) {\n                if (removals_ > 0) {\n                    _resizeRefs(removedRefs_, removals_);\n                    callback_.afterRemove(\n                        msg.sender,\n                        _refsAsEvidences(removedRefs_)\n                    );\n                }\n            }\n        }\n    }\n\n    /// Any approved address can request some address be removed.\n    /// Frivolous requestors SHOULD expect to find themselves banned.\n    /// @param evidences_ Array of evidences to request removal of.\n    function requestRemove(Evidence[] calldata evidences_)\n        external\n        onlyApproved\n    {\n        unchecked {\n            for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n                emit RequestRemove(msg.sender, evidences_[i_]);\n            }\n        }\n    }\n}\n"
    },
    "contracts/verify/IVerifyCallback.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport {Evidence} from \"./Verify.sol\";\n\n/// Deployers of `Verify` contracts (e.g. via `VerifyFactory`) may want to\n/// apply additional processing and/or restrictions to each of the basic\n/// verification actions. Examples may be reading from onchain state or\n/// requiring token transfers to complete before allowing an add/approve to\n/// complete successfully. The reason this is an interface rather than\n/// implementors extending `Verify` directly is that it allows for more\n/// implementations to sit under a single `VerifyFactory` which in turn allows\n/// a more readily composed ecosystem of verified accounts.\n///\n/// There's no reentrancy concerns for external calls from the `Verify`\n/// contract to the `IVerifyCallback` contract because:\n/// - All the callbacks happen after state changes in `Verify`\n/// - All `Verify` actions are bound to the authority of the `msg.sender`\n/// The `IVerifyCallback` contract can and should rollback transactions if\n/// their restrictions/processing requirements are not met, but otherwise have\n/// no more authority over the `Verify` state than anon users.\n///\n/// The security model for platforms consuming `Verify` contracts is that they\n/// should index or otherwise filter children from the `VerifyFactory` down to\n/// those that also set a supported `IVerifyCallback` contract. The factory is\n/// completely agnostic to callback concerns and doesn't even require that a\n/// callback contract be set at all.\ninterface IVerifyCallback {\n    /// Additional processing after a batch of additions.\n    /// SHOULD revert/rollback transactions if processing fails.\n    /// @param adder_ The `msg.sender` that authorized the additions.\n    /// MAY be the addee without any specific role.\n    /// @param evidences_ All evidences associated with the additions.\n    function afterAdd(address adder_, Evidence[] calldata evidences_) external;\n\n    /// Additional processing after a batch of approvals.\n    /// SHOULD revert/rollback transactions if processing fails.\n    /// @param approver_ The `msg.sender` that authorized the approvals.\n    /// @param evidences_ All evidences associated with the approvals.\n    function afterApprove(address approver_, Evidence[] calldata evidences_)\n        external;\n\n    /// Additional processing after a batch of bannings.\n    /// SHOULD revert/rollback transactions if processing fails.\n    /// @param banner_ The `msg.sender` that authorized the bannings.\n    /// @param evidences_ All evidences associated with the bannings.\n    function afterBan(address banner_, Evidence[] calldata evidences_) external;\n\n    /// Additional processing after a batch of removals.\n    /// SHOULD revert/rollback transactions if processing fails.\n    /// @param remover_ The `msg.sender` that authorized the removals.\n    /// @param evidences_ All evidences associated with the removals.\n    function afterRemove(address remover_, Evidence[] calldata evidences_)\n        external;\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !Address.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "contracts/verify/libraries/VerifyConstants.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// Summary statuses derived from a `State` by comparing the `Since` times\n/// against a specific block number.\nlibrary VerifyConstants {\n    /// Account has not interacted with the system yet or was removed.\n    uint256 internal constant STATUS_NIL = 0;\n    /// Account has added evidence for themselves.\n    uint256 internal constant STATUS_ADDED = 1;\n    /// Approver has reviewed added/approve evidence and approved the account.\n    uint256 internal constant STATUS_APPROVED = 2;\n    /// Banner has reviewed a request to ban an account and banned it.\n    uint256 internal constant STATUS_BANNED = 3;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/tier/VerifyTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"./TierV2.sol\";\nimport \"../verify/libraries/VerifyConstants.sol\";\nimport {State, Verify} from \"../verify/Verify.sol\";\nimport \"./libraries/TierReport.sol\";\n\n/// @title VerifyTier\n///\n/// @dev A contract that is `VerifyTier` expects to derive tiers from the time\n/// the account was approved by the underlying `Verify` contract. The approval\n/// timestamps defer to `State.since` returned from `Verify.state`.\ncontract VerifyTier is TierV2, Initializable {\n    /// Result of initializing.\n    /// @param sender `msg.sender` that initialized the contract.\n    /// @param verify The `Verify` contract checked for reports.\n    event Initialize(address sender, address verify);\n    /// The contract to check to produce reports.\n    Verify private verify;\n\n    /// Sets the `verify` contract.\n    /// @param verify_ The contract to check to produce reports.\n    function initialize(address verify_) external initializer {\n        require(verify_ != address(0), \"0_ADDRESS\");\n        verify = Verify(verify_);\n        emit Initialize(msg.sender, verify_);\n    }\n\n    /// Every tier will be the `State.since` timestamp if `account_` is\n    /// approved otherwise every tier will be uninitialized.\n    /// @inheritdoc ITierV2\n    function report(address account_, uint256[] memory)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        State memory state_ = verify.state(account_);\n        if (\n            // This is comparing an enum variant so it must be equal.\n            // slither-disable-next-line incorrect-equality\n            verify.statusAtTime(state_, block.timestamp) ==\n            VerifyConstants.STATUS_APPROVED\n        ) {\n            return\n                TierReport.updateTimesForTierRange(\n                    TierConstants.NEVER_REPORT,\n                    TierConstants.TIER_ZERO,\n                    TierConstants.TIER_EIGHT,\n                    state_.approvedSince\n                );\n        } else {\n            return TierConstants.NEVER_REPORT;\n        }\n    }\n\n    /// @inheritdoc ITierV2\n    function reportTimeForTier(\n        address account_,\n        uint256,\n        uint256[] calldata\n    ) external view returns (uint256) {\n        State memory state_ = verify.state(account_);\n        if (\n            // This is comparing an enum variant so it must be equal.\n            // slither-disable-next-line incorrect-equality\n            verify.statusAtTime(state_, block.timestamp) ==\n            VerifyConstants.STATUS_APPROVED\n        ) {\n            return state_.approvedSince;\n        } else {\n            return TierConstants.NEVER_REPORT;\n        }\n    }\n}\n"
    },
    "contracts/tier/VerifyTierFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport {VerifyTier} from \"./VerifyTier.sol\";\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\n/// @title VerifyTierFactory\n/// @notice Factory for creating and deploying `VerifyTier` contracts.\ncontract VerifyTierFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new VerifyTier());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        address verify_ = abi.decode(data_, (address));\n        address clone_ = Clones.clone(implementation);\n        VerifyTier(clone_).initialize(verify_);\n        return clone_;\n    }\n\n    /// Typed wrapper for `createChild` with `Verify`.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param verify_ `Verify` of the `VerifyTier` logic.\n    /// @return New `VerifyTier` child contract address.\n    function createChildTyped(address verify_) external returns (VerifyTier) {\n        return VerifyTier(this.createChild(abi.encode(verify_)));\n    }\n}\n"
    },
    "contracts/tier/CombineTierFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {Factory} from \"../factory/Factory.sol\";\nimport {CombineTier, CombineTierConfig} from \"./CombineTier.sol\";\n\n/// @title CombineTierFactory\n/// @notice Factory for creating and deploying `CombineTier` contracts.\ncontract CombineTierFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor(address vmStateBuilder_) {\n        address implementation_ = address(new CombineTier(vmStateBuilder_));\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        CombineTierConfig memory config_ = abi.decode(\n            data_,\n            (CombineTierConfig)\n        );\n        address clone_ = Clones.clone(implementation);\n        CombineTier(clone_).initialize(config_);\n        return clone_;\n    }\n\n    /// Typed wrapper for `createChild` with Source.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @return New `CombineTier` child contract address.\n    function createChildTyped(CombineTierConfig calldata config_)\n        external\n        returns (CombineTier)\n    {\n        return CombineTier(this.createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "contracts/tier/CombineTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../vm/RainVM.sol\";\nimport {AllStandardOps} from \"../vm/ops/AllStandardOps.sol\";\nimport {TierwiseCombine} from \"./libraries/TierwiseCombine.sol\";\nimport {ITierV2} from \"./ITierV2.sol\";\nimport {TierV2} from \"./TierV2.sol\";\nimport \"../vm/VMStateBuilder.sol\";\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nuint256 constant REPORT_ENTRYPOINT = 0;\nuint256 constant REPORT_FOR_TIER_ENTRYPOINT = 1;\nuint256 constant MIN_FINAL_STACK_INDEX = 1;\n\n/// All config used during initialization of a CombineTier.\n/// @param combinedTiersLength The first N values in the constants array of the\n/// sourceConfig MUST be all the combined tiers that are known statically. Of\n/// course some tier addresses MAY only be known at runtime and so these cannot\n/// be included. For those that are included there will be additional deploy\n/// time checks to ensure compatibility with each other (i.e. reportUnits).\n/// @param sourceConfig Source to run for both report and reportForTier as\n/// sources 0 and 1 respectively.\nstruct CombineTierConfig {\n    uint256 combinedTiersLength;\n    StateConfig sourceConfig;\n}\n\n/// @title CombineTier\n/// @notice Allows combining the reports from any `ITierV2` contracts.\n/// The value at the top of the stack after executing the rain script will be\n/// used as the return of all `ITierV2` functions exposed by `CombineTier`.\ncontract CombineTier is TierV2, RainVM, Initializable {\n    event Initialize(address sender, CombineTierConfig config);\n\n    // This allows cloned contracts to forward the template contract to the VM\n    // state builder during initialization.\n    address private immutable self;\n    address private immutable vmStateBuilder;\n    address private vmStatePointer;\n\n    constructor(address vmStateBuilder_) {\n        self = address(this);\n        vmStateBuilder = vmStateBuilder_;\n    }\n\n    function initialize(CombineTierConfig calldata config_)\n        external\n        initializer\n    {\n        Bounds memory reportBounds_;\n        reportBounds_.entrypoint = REPORT_ENTRYPOINT;\n        reportBounds_.minFinalStackIndex = MIN_FINAL_STACK_INDEX;\n        Bounds memory reportForTierBounds_;\n        reportForTierBounds_.entrypoint = REPORT_FOR_TIER_ENTRYPOINT;\n        reportForTierBounds_.minFinalStackIndex = MIN_FINAL_STACK_INDEX;\n        Bounds[] memory boundss_ = new Bounds[](2);\n        boundss_[0] = reportBounds_;\n        boundss_[1] = reportForTierBounds_;\n        bytes memory stateBytes_ = VMStateBuilder(vmStateBuilder).buildState(\n            self,\n            config_.sourceConfig,\n            boundss_\n        );\n        vmStatePointer = SSTORE2.write(stateBytes_);\n\n        // Integrity check for all known combined tiers.\n        for (uint256 i_ = 0; i_ < config_.combinedTiersLength; i_++) {\n            require(\n                ERC165Checker.supportsInterface(\n                    address(uint160(config_.sourceConfig.constants[i_])),\n                    type(ITierV2).interfaceId\n                ),\n                \"ERC165_TIERV2\"\n            );\n        }\n\n        emit Initialize(msg.sender, config_);\n    }\n\n    /// @inheritdoc RainVM\n    function fnPtrs() public pure override returns (bytes memory) {\n        return AllStandardOps.fnPtrs();\n    }\n\n    /// @inheritdoc ITierV2\n    function report(address account_, uint256[] memory context_)\n        external\n        view\n        virtual\n        override\n        returns (uint256 report_)\n    {\n        State memory state_ = LibState.fromBytesPacked(\n            SSTORE2.read(vmStatePointer)\n        );\n        bytes memory evalContext_ = bytes.concat(\n            bytes32(uint256(uint160(account_))),\n            abi.encodePacked(context_)\n        );\n        eval(evalContext_, state_, REPORT_ENTRYPOINT);\n        report_ = state_.stack[state_.stackIndex - 1];\n    }\n\n    /// @inheritdoc ITierV2\n    function reportTimeForTier(\n        address account_,\n        uint256 tier_,\n        uint256[] calldata context_\n    ) external view returns (uint256 time_) {\n        State memory state_ = LibState.fromBytesPacked(\n            SSTORE2.read(vmStatePointer)\n        );\n        bytes memory evalContext_ = bytes.concat(\n            bytes32(uint256(uint160(account_))),\n            bytes32(tier_),\n            abi.encodePacked(context_)\n        );\n        eval(evalContext_, state_, REPORT_FOR_TIER_ENTRYPOINT);\n        time_ = state_.stack[state_.stackIndex - 1];\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\n        if (result.length < 32) return false;\n        return success && abi.decode(result, (bool));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\n/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n"
    },
    "contracts/test/ReserveTokenERC1155.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n// solhint-disable-next-line max-line-length\nimport {ERC1155Burnable} from \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol\";\n\n/// @title ReserveTokenERC1155\n// Extremely basic ERC1155 implementation for testing purposes.\ncontract ReserveTokenERC1155 is ERC1155, ERC1155Burnable {\n    // Stables such as USDT and USDC commonly have 6 decimals.\n    uint256 public constant DECIMALS = 6;\n    // One _billion_ dollars 👷😈.\n    uint256 public constant TOTAL_SUPPLY = 10**(DECIMALS + 9);\n\n    // Incremented token count for use as id for newly minted tokens.\n    uint256 public tokenCount;\n\n    /// Define and mint a erc1155 token.\n    constructor() ERC1155(\"\") {\n        tokenCount = 0;\n        _mint(msg.sender, tokenCount, TOTAL_SUPPLY, \"\");\n    }\n\n    function mintNewToken() external {\n        tokenCount++;\n        _mint(msg.sender, tokenCount, TOTAL_SUPPLY, \"\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/test/ReserveToken18.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport {ERC20Burnable} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\n/// @title ReserveToken18\n/// A test token that can be used as a reserve asset.\n/// On mainnet this would likely be some brand of stablecoin but can be\n/// anything.\n/// Notably mimics 18 decimals commonly used by ERC20.\ncontract ReserveToken18 is ERC20, ERC20Burnable {\n    /// Accounts to freeze during testing.\n    mapping(address => bool) public freezables;\n\n    // Stables such as USDT and USDC commonly have 18 decimals.\n    uint256 public constant DECIMALS = 18;\n    // One _billion_ dollars 👷😈.\n    uint256 public constant TOTAL_SUPPLY = 10**(DECIMALS + 9);\n\n    /// Define and mint the erc20 token.\n    constructor() ERC20(\"USD Classic\", \"USDCC\") {\n        _mint(msg.sender, TOTAL_SUPPLY);\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return uint8(DECIMALS);\n    }\n\n    /// Add an account to the freezables list.\n    /// @param account_ The account to freeze.\n    function addFreezable(address account_) external {\n        freezables[account_] = true;\n    }\n\n    /// Block any transfers to a frozen account.\n    /// @inheritdoc ERC20\n    function _beforeTokenTransfer(\n        address sender_,\n        address receiver_,\n        uint256 amount_\n    ) internal virtual override {\n        super._beforeTokenTransfer(sender_, receiver_, amount_);\n        require(!freezables[receiver_], \"FROZEN\");\n    }\n}\n"
    },
    "contracts/test/ReserveTokenTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/// @title ReserveTokenTest\n/// An example token that can be used as a reserve asset.\n/// On mainnet this would likely be some stablecoin but can be anything.\ncontract ReserveTokenTest is ERC20 {\n    /// How many tokens to mint initially.\n    // One _billion_ dollars 👷😈\n    uint256 public constant INITIAL_MINT = 10**9;\n\n    /// Test against frozen assets, for example USDC can do this.\n    mapping(address => bool) public freezables;\n\n    constructor() ERC20(\"USD Classic\", \"USDCC\") {\n        _mint(msg.sender, INITIAL_MINT * 10**18);\n    }\n\n    /// Anyone in the world can freeze any address on our test asset.\n    /// @param address_ The address to freeze.\n    function addFreezable(address address_) external {\n        freezables[address_] = true;\n    }\n\n    /// Anyone in the world can unfreeze any address on our test asset.\n    /// @param address_ The address to unfreeze.\n    function removeFreezable(address address_) external {\n        freezables[address_] = false;\n    }\n\n    /// Burns all tokens held by the sender.\n    function purge() external {\n        _burn(msg.sender, balanceOf(msg.sender));\n    }\n\n    /// Enforces the freeze list.\n    function _beforeTokenTransfer(\n        address,\n        address receiver_,\n        uint256\n    ) internal view override {\n        require(receiver_ == address(0) || !(freezables[receiver_]), \"FROZEN\");\n    }\n}\n"
    },
    "contracts/test/ReserveToken.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport {ERC20Burnable} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\n/// @title ReserveToken\n/// A test token that can be used as a reserve asset.\n/// On mainnet this would likely be some brand of stablecoin but can be\n/// anything.\n/// Notably mimics 6 decimals commonly used by stables in production.\ncontract ReserveToken is ERC20, ERC20Burnable {\n    /// Accounts to freeze during testing.\n    mapping(address => bool) public freezables;\n\n    // Stables such as USDT and USDC commonly have 6 decimals.\n    uint256 public constant DECIMALS = 6;\n    // One _billion_ dollars 👷😈.\n    uint256 public constant TOTAL_SUPPLY = 10**(DECIMALS + 9);\n\n    /// Define and mint the erc20 token.\n    constructor() ERC20(\"USD Classic\", \"USDCC\") {\n        _mint(msg.sender, TOTAL_SUPPLY);\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return uint8(DECIMALS);\n    }\n\n    /// Add an account to the freezables list.\n    /// @param account_ The account to freeze.\n    function addFreezable(address account_) external {\n        freezables[account_] = true;\n    }\n\n    /// Block any transfers to a frozen account.\n    /// @inheritdoc ERC20\n    function _beforeTokenTransfer(\n        address sender_,\n        address receiver_,\n        uint256 amount_\n    ) internal virtual override {\n        super._beforeTokenTransfer(sender_, receiver_, amount_);\n        require(!freezables[receiver_], \"FROZEN\");\n    }\n}\n"
    },
    "contracts/test/SaleReentrant.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {ReserveToken} from \"./ReserveToken.sol\";\nimport {Sale, BuyConfig} from \"../sale/Sale.sol\";\n\n/// @title SaleReentrant\n/// Test contract that attempts to call reentrant code on `Sale`.\n/// The calls MUST fail when driven by the test harness.\ncontract SaleReentrant is ReserveToken {\n    Sale private sale;\n    BuyConfig private buyConfig;\n\n    /// Configures the contract to attempt to reenter.\n    constructor() ReserveToken() {}\n\n    /// Set the contract to attempt to reenter.\n    /// @param sale_ Sale contract to reeenter.\n    /// @param config_ BuyConfig for reentrant buy call.\n    function addReentrantTarget(Sale sale_, BuyConfig calldata config_)\n        external\n    {\n        sale = sale_;\n        buyConfig = config_;\n    }\n\n    /// @inheritdoc ReserveToken\n    function _beforeTokenTransfer(\n        address sender_,\n        address receiver_,\n        uint256 amount_\n    ) internal virtual override {\n        super._beforeTokenTransfer(sender_, receiver_, amount_);\n        if (receiver_ != address(0) && receiver_ == address(sale)) {\n            // This call MUST fail.\n            sale.buy(buyConfig);\n        }\n    }\n}\n"
    },
    "contracts/sale/Sale.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Cooldown} from \"../cooldown/Cooldown.sol\";\n\nimport \"../math/FixedPointMath.sol\";\nimport \"../vm/RainVM.sol\";\nimport {AllStandardOps} from \"../vm/ops/AllStandardOps.sol\";\nimport {ERC20Config} from \"../erc20/ERC20Config.sol\";\nimport \"./ISale.sol\";\n//solhint-disable-next-line max-line-length\nimport {RedeemableERC20, RedeemableERC20Config} from \"../redeemableERC20/RedeemableERC20.sol\";\n//solhint-disable-next-line max-line-length\nimport {RedeemableERC20Factory} from \"../redeemableERC20/RedeemableERC20Factory.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n// solhint-disable-next-line max-line-length\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../sstore2/SSTORE2.sol\";\nimport \"../vm/VMStateBuilder.sol\";\n\n/// Everything required to construct a Sale (not initialize).\n/// @param maximumSaleTimeout The sale timeout set in initialize cannot exceed\n/// this. Avoids downstream escrows and similar trapping funds due to sales\n/// that never end, or perhaps never even start.\n/// @param maximumCooldownDuration The cooldown duration set in initialize\n/// cannot exceed this. Avoids the \"no refunds\" situation where someone sets an\n/// infinite cooldown, then accidentally or maliciously the sale ends up in a\n/// state where it cannot end (bad \"can end\" script), leading to trapped funds.\n/// @param redeemableERC20Factory The factory contract that creates redeemable\n/// erc20 tokens that the `Sale` can mint, sell and burn.\nstruct SaleConstructorConfig {\n    uint256 maximumSaleTimeout;\n    uint256 maximumCooldownDuration;\n    RedeemableERC20Factory redeemableERC20Factory;\n    address vmStateBuilder;\n}\n\n/// Everything required to configure (initialize) a Sale.\n/// @param canStartStateConfig State config for the script that allows a Sale\n/// to start.\n/// @param canEndStateConfig State config for the script that allows a Sale to\n/// end. IMPORTANT: A Sale can always end if/when its rTKN sells out,\n/// regardless of the result of this script.\n/// @param calculatePriceStateConfig State config for the script that defines\n/// the current price quoted by a Sale.\n/// @param recipient The recipient of the proceeds of a Sale, if/when the Sale\n/// is successful.\n/// @param reserve The reserve token the Sale is deonominated in.\n/// @param saleTimeout The number of seconds before this sale can timeout.\n/// SHOULD be well after the expected end time as a timeout will fail an active\n/// or pending sale regardless of any funds raised.\n/// @param cooldownDuration forwarded to `Cooldown` contract initialization.\n/// @param minimumRaise defines the amount of reserve required to raise that\n/// defines success/fail of the sale. Reaching the minimum raise DOES NOT cause\n/// the raise to end early (unless the \"can end\" script allows it of course).\n/// @param dustSize The minimum amount of rTKN that must remain in the Sale\n/// contract unless it is all purchased, clearing the raise to 0 stock and thus\n/// ending the raise.\nstruct SaleConfig {\n    StateConfig vmStateConfig;\n    address recipient;\n    address reserve;\n    uint256 saleTimeout;\n    uint256 cooldownDuration;\n    uint256 minimumRaise;\n    uint256 dustSize;\n}\n\n/// Forwarded config to RedeemableERC20 initialization.\nstruct SaleRedeemableERC20Config {\n    ERC20Config erc20Config;\n    address tier;\n    uint256 minimumTier;\n    address distributionEndForwardingAddress;\n}\n\n/// Defines a request to buy rTKN from an active sale.\n/// @param feeRecipient Optional recipient to send fees to. Intended to be a\n/// \"tip\" for the front-end client that the buyer is using to fund development,\n/// infrastructure, etc.\n/// @param fee Size of the optional fee to send to the recipient. Denominated\n/// in the reserve token of the `Sale` contract.\n/// @param minimumUnits The minimum size of the buy. If the sale is close to\n/// selling out then the buyer may not fulfill their entire order, so this sets\n/// the minimum units the buyer is willing to accept for their order. MAY be 0\n/// if the buyer is willing to accept any amount of tokens.\n/// @param desiredUnits The maximum and desired size of the buy. The sale will\n/// always attempt to fulfill the buy order to the maximum rTKN amount possible\n/// according to the unsold stock on hand. Typically all the desired units will\n/// clear but as the sale runs low on stock it may not be able to.\n/// @param maximumPrice As the price quoted by the sale is a programmable curve\n/// it may change rapidly between when the buyer submitted a transaction to the\n/// mempool and when it is mined. Setting a maximum price is akin to setting\n/// slippage on a traditional AMM. The transaction will revert if the sale\n/// price exceeds the buyer's maximum.\nstruct BuyConfig {\n    address feeRecipient;\n    uint256 fee;\n    uint256 minimumUnits;\n    uint256 desiredUnits;\n    uint256 maximumPrice;\n}\n\n/// Defines the receipt for a successful buy.\n/// The receipt includes the final units and price paid for rTKN, which are\n/// known as possible ranges in `BuyConfig`.\n/// Importantly a receipt allows a buy to be reversed for as long as the sale\n/// is active, subject to buyer cooldowns as per `Cooldown`. In the case of a\n/// finalized but failed sale, all buyers can immediately process refunds for\n/// their receipts without cooldown. As the receipt is crucial to the refund\n/// process every receipt is logged so it can be indexed and never lost, and\n/// unique IDs bound to the buyer in onchain storage prevent receipts from\n/// being used in a fraudulent context. The entire receipt including the id is\n/// hashed in the storage mapping that binds it to a buyer so that a buyer\n/// cannot change the receipt offchain to claim fraudulent refunds.\n/// Front-end fees are also tracked and refunded for each receipt, to prevent\n/// front end clients from gaming/abusing sale contracts.\n/// @param id Every receipt is assigned a sequential ID to ensure uniqueness\n/// across all receipts.\n/// @param feeRecipient as per `BuyConfig`.\n/// @param fee as per `BuyConfig`.\n/// @param units number of rTKN bought and refundable.\n/// @param price price paid per unit denominated and refundable in reserve.\nstruct Receipt {\n    uint256 id;\n    address feeRecipient;\n    uint256 fee;\n    uint256 units;\n    uint256 price;\n}\n\nuint256 constant CAN_LIVE_ENTRYPOINT = 0;\nuint256 constant CALCULATE_PRICE_ENTRYPOINT = 1;\n\nuint256 constant CAN_LIVE_MIN_FINAL_STACK_INDEX = 1;\nuint256 constant CALCULATE_PRICE_MIN_FINAL_STACK_INDEX = 2;\n\nuint256 constant STORAGE_OPCODES_LENGTH = 4;\n\n// solhint-disable-next-line max-states-count\ncontract Sale is Initializable, Cooldown, RainVM, ISale, ReentrancyGuard {\n    using Math for uint256;\n    using FixedPointMath for uint256;\n    using SafeERC20 for IERC20;\n    using LibState for State;\n\n    /// Contract is constructing.\n    /// @param sender `msg.sender` of the contract deployer.\n    event Construct(address sender, SaleConstructorConfig config);\n    /// Contract is initializing (being cloned by factory).\n    /// @param sender `msg.sender` of the contract initializer (cloner).\n    /// @param config All initialization config passed by the sender.\n    /// @param token The freshly deployed and minted rTKN for the sale.\n    event Initialize(address sender, SaleConfig config, address token);\n    /// Sale is started (moved to active sale state).\n    /// @param sender `msg.sender` that started the sale.\n    event Start(address sender);\n    /// Sale has ended (moved to success/fail sale state).\n    /// @param sender `msg.sender` that ended the sale.\n    /// @param saleStatus The final success/fail state of the sale.\n    event End(address sender, SaleStatus saleStatus);\n    /// Sale has failed due to a timeout (failed to even start/end).\n    /// @param sender `msg.sender` that timed out the sale.\n    event Timeout(address sender);\n    /// rTKN being bought.\n    /// Importantly includes the receipt that sender can use to apply for a\n    /// refund later if they wish.\n    /// @param sender `msg.sender` buying rTKN.\n    /// @param config All buy config passed by the sender.\n    /// @param receipt The purchase receipt, can be used to claim refunds.\n    event Buy(address sender, BuyConfig config, Receipt receipt);\n    /// rTKN being refunded.\n    /// Includes the receipt used to justify the refund.\n    event Refund(address sender, Receipt receipt);\n\n    address private immutable self;\n    address private immutable vmStateBuilder;\n\n    /// @dev the saleTimeout cannot exceed this. Prevents downstream contracts\n    /// that require a finalization such as escrows from getting permanently\n    /// stuck in a pending or active status due to buggy scripts.\n    uint256 private immutable maximumSaleTimeout;\n\n    /// *** STORAGE OPCODES START ***\n\n    /// @dev remaining rTKN units to sell. MAY NOT be the rTKN balance of the\n    /// Sale contract if rTKN has been sent directly to the sale contract\n    /// outside the standard buy/refund loop.\n    uint256 private _remainingUnits;\n\n    /// @dev total reserve taken in to the sale contract via. buys. Does NOT\n    /// include any reserve sent directly to the sale contract outside the\n    /// standard buy/refund loop.\n    uint256 private _totalReserveIn;\n\n    /// Minted rTKN for each sale.\n    /// Exposed via. `ISale.token()`.\n    /// Represented as uint NOT address so that it is VM safe.\n    uint256 private _token;\n\n    /// @dev as per `SaleConfig`.\n    /// Exposed via. `ISale.reserve()`.\n    /// Represented as uint NOT address so that it is VM safe.\n    uint256 private _reserve;\n\n    /// *** STORAGE OPCODES END ***\n\n    /// Factory responsible for minting rTKN.\n    RedeemableERC20Factory private immutable redeemableERC20Factory;\n\n    /// @dev as per `SaleConfig`.\n    address private recipient;\n    /// @dev as per `SaleConfig`.\n    address private vmStatePointer;\n    /// @dev as per `SaleConfig`.\n    uint256 private minimumRaise;\n    /// @dev as per `SaleConfig`.\n    uint256 private dustSize;\n\n    /// @dev the current sale status exposed as `ISale.saleStatus`.\n    SaleStatus private _saleStatus;\n    /// @dev the current sale can always end in failure at this time even if\n    /// it did not start. Provided it did not already end of course.\n    uint256 private saleTimeoutStamp;\n\n    /// @dev Binding buyers to receipt hashes to maybe a non-zero value.\n    /// A receipt will only be honoured if the mapping resolves to non-zero.\n    /// The receipt hashing ensures that receipts cannot be manipulated before\n    /// redemption. Each mapping is deleted if/when receipt is used for refund.\n    /// Buyer => keccak receipt => exists (1+ or 0).\n    mapping(address => mapping(bytes32 => uint256)) private receipts;\n    /// @dev simple incremental counter to keep all receipts unique so that\n    /// receipt hashes bound to buyers never collide.\n    uint256 private nextReceiptId;\n\n    /// @dev Tracks combined fees per recipient to be claimed if/when a sale\n    /// is successful.\n    /// Fee recipient => unclaimed fees.\n    mapping(address => uint256) private fees;\n\n    constructor(SaleConstructorConfig memory config_) {\n        self = address(this);\n        vmStateBuilder = config_.vmStateBuilder;\n        maximumSaleTimeout = config_.maximumSaleTimeout;\n\n        redeemableERC20Factory = config_.redeemableERC20Factory;\n\n        emit Construct(msg.sender, config_);\n    }\n\n    function initialize(\n        SaleConfig calldata config_,\n        SaleRedeemableERC20Config memory saleRedeemableERC20Config_\n    ) external initializer {\n        initializeCooldown(config_.cooldownDuration);\n\n        require(config_.saleTimeout <= maximumSaleTimeout, \"MAX_TIMEOUT\");\n        saleTimeoutStamp = block.timestamp + config_.saleTimeout;\n\n        // 0 minimum raise is ambiguous as to how it should be handled. It\n        // literally means \"the raise succeeds without any trades\", which\n        // doesn't have a clear way to move funds around as there are no\n        // recipients of potentially escrowed or redeemable funds. There needs\n        // to be at least 1 reserve token paid from 1 buyer in order to\n        // meaningfully process success logic.\n        require(config_.minimumRaise > 0, \"MIN_RAISE_0\");\n        minimumRaise = config_.minimumRaise;\n\n        Bounds memory canLiveBounds_;\n        canLiveBounds_.entrypoint = CAN_LIVE_ENTRYPOINT;\n        canLiveBounds_.minFinalStackIndex = CAN_LIVE_MIN_FINAL_STACK_INDEX;\n        Bounds memory calculatePriceBounds_;\n        calculatePriceBounds_.entrypoint = CALCULATE_PRICE_ENTRYPOINT;\n        calculatePriceBounds_\n            .minFinalStackIndex = CALCULATE_PRICE_MIN_FINAL_STACK_INDEX;\n        Bounds[] memory boundss_ = new Bounds[](2);\n        boundss_[0] = canLiveBounds_;\n        boundss_[1] = calculatePriceBounds_;\n        bytes memory vmStateBytes_ = VMStateBuilder(vmStateBuilder).buildState(\n            self,\n            config_.vmStateConfig,\n            boundss_\n        );\n        vmStatePointer = SSTORE2.write(vmStateBytes_);\n        recipient = config_.recipient;\n\n        dustSize = config_.dustSize;\n\n        // just making this explicit during initialization in case it ever\n        // takes a nonzero value somehow due to refactor.\n        _saleStatus = SaleStatus.Pending;\n\n        _reserve = uint256(uint160(config_.reserve));\n\n        // The distributor of the rTKN is always set to the sale contract.\n        // It is an error for the deployer to attempt to set the distributor.\n        require(\n            saleRedeemableERC20Config_.erc20Config.distributor == address(0),\n            \"DISTRIBUTOR_SET\"\n        );\n        saleRedeemableERC20Config_.erc20Config.distributor = address(this);\n\n        _remainingUnits = saleRedeemableERC20Config_.erc20Config.initialSupply;\n\n        address token_ = redeemableERC20Factory.createChild(\n            abi.encode(\n                RedeemableERC20Config(\n                    address(config_.reserve),\n                    saleRedeemableERC20Config_.erc20Config,\n                    saleRedeemableERC20Config_.tier,\n                    saleRedeemableERC20Config_.minimumTier,\n                    saleRedeemableERC20Config_.distributionEndForwardingAddress\n                )\n            )\n        );\n        _token = uint256(uint160(token_));\n\n        emit Initialize(msg.sender, config_, address(token_));\n    }\n\n    /// @inheritdoc RainVM\n    function storageOpcodesRange()\n        public\n        pure\n        override\n        returns (StorageOpcodesRange memory)\n    {\n        uint256 pointer_;\n        assembly {\n            pointer_ := _remainingUnits.slot\n        }\n        return StorageOpcodesRange(pointer_, STORAGE_OPCODES_LENGTH);\n    }\n\n    /// @inheritdoc ISale\n    function token() external view returns (address) {\n        return address(uint160(_token));\n    }\n\n    /// @inheritdoc ISale\n    function reserve() external view returns (address) {\n        return address(uint160(_reserve));\n    }\n\n    /// @inheritdoc ISale\n    function saleStatus() external view returns (SaleStatus) {\n        return _saleStatus;\n    }\n\n    function _loadState() internal view returns (State memory) {\n        return LibState.fromBytesPacked(SSTORE2.read(vmStatePointer));\n    }\n\n    /// Can the Sale live?\n    /// Evals the \"can live\" script.\n    /// If a non zero value is returned then the sale can move from pending to\n    /// active, or remain active.\n    /// If a zero value is returned the sale can remain pending or move from\n    /// active to a finalised status.\n    /// An out of stock (0 remaining units) WILL ALWAYS return `false` without\n    /// evaluating the script.\n    function _canLive(State memory state_) internal view returns (bool) {\n        unchecked {\n            if (_remainingUnits < 1) {\n                return false;\n            }\n            eval(\"\", state_, CAN_LIVE_ENTRYPOINT);\n            bool canLive_ = state_.stack[state_.stackIndex - 1] > 0;\n            state_.reset();\n            return canLive_;\n        }\n    }\n\n    /// Calculates the current reserve price quoted for 1 unit of rTKN.\n    /// Used internally to process `buy`.\n    /// @param targetUnits_ Amount of rTKN to quote a price and units for, will\n    /// be available to the price script from OPCODE_CURRENT_BUY_UNITS. When\n    /// `buy` executes the target units will be the smaller of the remaining\n    /// stock and the desired units set by the caller.\n    /// @return (maxUnits, price) The top two items on the stack are used for\n    /// the units and price. When `buy` executes the real purchase size will be\n    /// the smaller of the target units and the returned maximum units. If this\n    /// is below the buyer's minimum the buy will revert.\n    function _calculateBuy(State memory state_, uint256 targetUnits_)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        unchecked {\n            bytes memory context_ = new bytes(0x20);\n            assembly {\n                mstore(add(context_, 0x20), targetUnits_)\n            }\n            eval(context_, state_, CALCULATE_PRICE_ENTRYPOINT);\n\n            (uint256 maxUnits_, uint256 price_) = (\n                state_.stack[state_.stackIndex - 2],\n                state_.stack[state_.stackIndex - 1]\n            );\n            state_.reset();\n            return (maxUnits_, price_);\n        }\n    }\n\n    function _start() internal {\n        _saleStatus = SaleStatus.Active;\n        emit Start(msg.sender);\n    }\n\n    function _end() internal {\n        bool success_ = _totalReserveIn >= minimumRaise;\n        SaleStatus endStatus_ = success_ ? SaleStatus.Success : SaleStatus.Fail;\n\n        _remainingUnits = 0;\n        _saleStatus = endStatus_;\n        emit End(msg.sender, endStatus_);\n        RedeemableERC20(address(uint160(_token))).endDistribution(\n            address(this)\n        );\n\n        // Only send reserve to recipient if the raise is a success.\n        // If the raise is NOT a success then everyone can refund their reserve\n        // deposited individually.\n        if (success_) {\n            IERC20(address(uint160(_reserve))).safeTransfer(\n                recipient,\n                _totalReserveIn\n            );\n        }\n    }\n\n    function canLive() external view returns (bool) {\n        return _canLive(_loadState());\n    }\n\n    function calculateBuy(uint256 targetUnits_)\n        external\n        view\n        returns (uint256, uint256)\n    {\n        return _calculateBuy(_loadState(), targetUnits_);\n    }\n\n    /// Start the sale (move from pending to active).\n    /// This is also done automatically inline with each `buy` call so is\n    /// optional for anon to call outside of a purchase.\n    /// `canStart` MUST return true.\n    function start() external {\n        require(_saleStatus == SaleStatus.Pending, \"NOT_PENDING\");\n        require(_canLive(_loadState()), \"NOT_LIVE\");\n        _start();\n    }\n\n    /// End the sale (move from active to success or fail).\n    /// This is also done automatically inline with each `buy` call so is\n    /// optional for anon to call outside of a purchase.\n    /// `canEnd` MUST return true.\n    function end() external {\n        require(_saleStatus == SaleStatus.Active, \"NOT_ACTIVE\");\n        require(!_canLive(_loadState()), \"LIVE\");\n        _end();\n    }\n\n    /// Timeout the sale (move from pending or active to fail).\n    /// The ONLY condition for a timeout is that the `saleTimeout` block set\n    /// during initialize is in the past. This means that regardless of what\n    /// happens re: starting, ending, buying, etc. if the sale does NOT manage\n    /// to unambiguously end by the timeout block then it can timeout to a fail\n    /// state. This means that any downstream escrows or similar can always\n    /// expect that eventually they will see a pass/fail state and so are safe\n    /// to lock funds while a Sale is active.\n    function timeout() external {\n        require(saleTimeoutStamp < block.timestamp, \"EARLY_TIMEOUT\");\n        require(\n            _saleStatus == SaleStatus.Pending ||\n                _saleStatus == SaleStatus.Active,\n            \"ALREADY_ENDED\"\n        );\n\n        // Mimic `end` with a failed state but `Timeout` event.\n        _remainingUnits = 0;\n        _saleStatus = SaleStatus.Fail;\n        emit Timeout(msg.sender);\n        RedeemableERC20(address(uint160(_token))).endDistribution(\n            address(this)\n        );\n    }\n\n    /// Main entrypoint to the sale. Sells rTKN in exchange for reserve token.\n    /// The price curve is eval'd to produce a reserve price quote. Each 1 unit\n    /// of rTKN costs `price` reserve token where BOTH the rTKN units and price\n    /// are treated as 18 decimal fixed point values. If the reserve token has\n    /// more or less precision by its own conventions (e.g. \"decimals\" method\n    /// on ERC20 tokens) then the price will need to scale accordingly.\n    /// The receipt is _logged_ rather than returned as it cannot be used in\n    /// same block for a refund anyway due to cooldowns.\n    /// @param config_ All parameters to configure the purchase.\n    function buy(BuyConfig memory config_)\n        external\n        onlyAfterCooldown\n        nonReentrant\n    {\n        require(0 < config_.minimumUnits, \"0_MINIMUM\");\n        require(\n            config_.minimumUnits <= config_.desiredUnits,\n            \"MINIMUM_OVER_DESIRED\"\n        );\n\n        // This state is loaded once and shared between 2x `_canLive` calls and\n        // a `_calculateBuy` call.\n        State memory state_ = _loadState();\n\n        // Start or end the sale as required.\n        if (_canLive(state_)) {\n            if (_saleStatus == SaleStatus.Pending) {\n                _start();\n            }\n        } else {\n            if (_saleStatus == SaleStatus.Active) {\n                _end();\n            }\n        }\n\n        // Check the status AFTER possibly modifying it to ensure the potential\n        // modification is respected.\n        require(_saleStatus == SaleStatus.Active, \"NOT_ACTIVE\");\n\n        uint256 targetUnits_ = config_.desiredUnits.min(_remainingUnits);\n\n        (uint256 maxUnits_, uint256 price_) = _calculateBuy(\n            state_,\n            targetUnits_\n        );\n\n        // The script may return a larger max units than the target so we have\n        // to cap it to prevent the sale selling more than requested. Scripts\n        // SHOULD NOT exceed the target units as it may be confusing to end\n        // users but it MUST be safe from the sale's perspective to do so.\n        // Scripts MAY return max units lower than the target units to enforce\n        // per-user or other purchase limits.\n        uint256 units_ = maxUnits_.min(targetUnits_);\n        require(units_ >= config_.minimumUnits, \"INSUFFICIENT_STOCK\");\n\n        require(price_ <= config_.maximumPrice, \"MAXIMUM_PRICE\");\n        uint256 cost_ = price_.fixedPointMul(units_);\n\n        Receipt memory receipt_ = Receipt(\n            nextReceiptId,\n            config_.feeRecipient,\n            config_.fee,\n            units_,\n            price_\n        );\n        nextReceiptId++;\n        // There should never be more than one of the same key due to the ID\n        // counter but we can use checked math to easily cover the case of\n        // potential duplicate receipts due to some bug.\n        receipts[msg.sender][keccak256(abi.encode(receipt_))]++;\n\n        fees[config_.feeRecipient] += config_.fee;\n\n        // We ignore any rTKN or reserve that is sent to the contract directly\n        // outside of a `buy` call. This also means we don't support reserve\n        // tokens with balances that can change outside of transfers\n        // (e.g. rebase).\n        _remainingUnits -= units_;\n        _totalReserveIn += cost_;\n\n        // This happens before `end` so that the transfer from happens before\n        // the transfer to.\n        // `end` changes state so `buy` needs to be nonReentrant.\n        IERC20(address(uint160(_reserve))).safeTransferFrom(\n            msg.sender,\n            address(this),\n            cost_ + config_.fee\n        );\n        // This happens before `end` so that the transfer happens before the\n        // distributor is burned and token is frozen.\n        IERC20(address(uint160(_token))).safeTransfer(msg.sender, units_);\n\n        emit Buy(msg.sender, config_, receipt_);\n\n        // Enforce the status of the sale after the purchase.\n        // The sale ending AFTER the purchase does NOT rollback the purchase,\n        // it simply prevents further purchases.\n        if (_canLive(state_)) {\n            // This prevents the sale from being left with so little stock that\n            // nobody else will want to clear it out. E.g. the dust might be\n            // worth significantly less than the price of gas to call `buy`.\n            require(_remainingUnits >= dustSize, \"DUST\");\n        } else {\n            _end();\n        }\n    }\n\n    /// @dev This is here so we can use a modifier like a function call.\n    function refundCooldown() private onlyAfterCooldown {}\n\n    /// Rollback a buy given its receipt.\n    /// Ignoring gas (which cannot be refunded) the refund process rolls back\n    /// all state changes caused by a buy, other than the receipt id increment.\n    /// Refunds are limited by the global cooldown to mitigate rapid buy/refund\n    /// cycling that could cause volatile price curves or other unwanted side\n    /// effects for other sale participants. Cooldowns are bypassed if the sale\n    /// ends and is a failure.\n    /// @param receipt_ The receipt of the buy to rollback.\n    function refund(Receipt calldata receipt_) external {\n        require(_saleStatus != SaleStatus.Success, \"REFUND_SUCCESS\");\n        // If the sale failed then cooldowns do NOT apply. Everyone should\n        // immediately refund all their receipts.\n        if (_saleStatus != SaleStatus.Fail) {\n            refundCooldown();\n        }\n\n        // Checked math here will prevent consuming a receipt that doesn't\n        // exist or was already refunded as it will underflow.\n        receipts[msg.sender][keccak256(abi.encode(receipt_))]--;\n\n        uint256 cost_ = receipt_.price.fixedPointMul(receipt_.units);\n\n        _totalReserveIn -= cost_;\n        _remainingUnits += receipt_.units;\n        fees[receipt_.feeRecipient] -= receipt_.fee;\n\n        emit Refund(msg.sender, receipt_);\n\n        IERC20(address(uint160(_token))).safeTransferFrom(\n            msg.sender,\n            address(this),\n            receipt_.units\n        );\n        IERC20(address(uint160(_reserve))).safeTransfer(\n            msg.sender,\n            cost_ + receipt_.fee\n        );\n    }\n\n    /// After a sale ends in success all fees collected for a recipient can be\n    /// cleared. If the raise is active or fails then fees cannot be claimed as\n    /// they are set aside in case of refund. A failed raise implies that all\n    /// buyers should immediately refund and zero fees claimed.\n    /// @param recipient_ The recipient to claim fees for. Does NOT need to be\n    /// the `msg.sender`.\n    function claimFees(address recipient_) external {\n        require(_saleStatus == SaleStatus.Success, \"NOT_SUCCESS\");\n        uint256 amount_ = fees[recipient_];\n        if (amount_ > 0) {\n            delete fees[recipient_];\n            IERC20(address(uint160(_reserve))).safeTransfer(\n                recipient_,\n                amount_\n            );\n        }\n    }\n\n    function fnPtrs() public pure override returns (bytes memory) {\n        return AllStandardOps.fnPtrs();\n    }\n}\n"
    },
    "contracts/cooldown/Cooldown.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title Cooldown\n/// @notice `Cooldown` is a base contract that rate limits functions on\n/// the implementing contract per `msg.sender`.\n///\n/// Each time a function with the `onlyAfterCooldown` modifier is called the\n/// `msg.sender` must wait N seconds before calling any modified function.\n///\n/// This does nothing to prevent sybils who can generate an arbitrary number of\n/// `msg.sender` values in parallel to spam a contract.\n///\n/// `Cooldown` is intended to prevent rapid state cycling to grief a contract,\n/// such as rapidly locking and unlocking a large amount of capital in the\n/// `SeedERC20` contract.\n///\n/// Requiring a lock/deposit of significant economic stake that sybils will not\n/// have access to AND applying a cooldown IS a sybil mitigation. The economic\n/// stake alone is NOT sufficient if gas is cheap as sybils can cycle the same\n/// stake between each other. The cooldown alone is NOT sufficient as many\n/// sybils can be created, each as a new `msg.sender`.\n///\n/// @dev Base for anything that enforces a cooldown delay on functions.\n/// `Cooldown` requires a minimum time in seconds to elapse between actions\n/// that cooldown. The modifier `onlyAfterCooldown` both enforces and triggers\n/// the cooldown. There is a single cooldown across all functions per-contract\n/// so any function call that requires a cooldown will also trigger it for\n/// all other functions.\n///\n/// Cooldown is NOT an effective sybil resistance alone, as the cooldown is\n/// per-address only. It is always possible for many accounts to be created\n/// to spam a contract with dust in parallel.\n/// Cooldown is useful to stop a single account rapidly cycling contract\n/// state in a way that can be disruptive to peers. Cooldown works best when\n/// coupled with economic stake associated with each state change so that\n/// peers must lock capital during the cooldown. `Cooldown` tracks the first\n/// `msg.sender` it sees for a call stack so cooldowns are enforced across\n/// reentrant code. Any function that enforces a cooldown also has reentrancy\n/// protection.\ncontract Cooldown {\n    event CooldownInitialize(address sender, uint256 cooldownDuration);\n    event CooldownTriggered(address caller, uint256 cooldown);\n    /// Time in blocks to restrict access to modified functions.\n    uint256 internal cooldownDuration;\n\n    /// Every caller has its own cooldown, the minimum block that the caller\n    /// call another function sharing the same cooldown state.\n    mapping(address => uint256) private cooldowns;\n    address private caller;\n\n    /// Initialize the cooldown duration.\n    /// The cooldown duration is global to the contract.\n    /// Cooldown duration must be greater than 0.\n    /// Cooldown duration can only be set once.\n    /// @param cooldownDuration_ The global cooldown duration.\n    function initializeCooldown(uint256 cooldownDuration_) internal {\n        require(cooldownDuration_ > 0, \"COOLDOWN_0\");\n        require(cooldownDuration <= type(uint32).max, \"COOLDOWN_MAX\");\n        // Reinitialization is a bug.\n        assert(cooldownDuration == 0);\n        cooldownDuration = cooldownDuration_;\n        emit CooldownInitialize(msg.sender, cooldownDuration_);\n    }\n\n    /// Modifies a function to enforce the cooldown for `msg.sender`.\n    /// Saves the original caller so that cooldowns are enforced across\n    /// reentrant code.\n    modifier onlyAfterCooldown() {\n        address caller_ = caller == address(0) ? caller = msg.sender : caller;\n        require(cooldowns[caller_] <= block.timestamp, \"COOLDOWN\");\n        // Every action that requires a cooldown also triggers a cooldown.\n        uint256 cooldown_ = block.timestamp + cooldownDuration;\n        cooldowns[caller_] = cooldown_;\n        emit CooldownTriggered(caller_, cooldown_);\n        _;\n        // Refund as much gas as we can.\n        delete caller;\n    }\n}\n"
    },
    "contracts/sale/ISale.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// An `ISale` can be in one of 4 possible states and a linear progression is\n/// expected from an \"in flight\" status to an immutable definitive outcome.\n/// - Pending: The sale is deployed onchain but cannot be interacted with yet.\n/// - Active: The sale can now be bought into and otherwise interacted with.\n/// - Success: The sale has ended AND reached its minimum raise target.\n/// - Fail: The sale has ended BUT NOT reached its minimum raise target.\n/// Once an `ISale` reaches `Active` it MUST NOT return `Pending` ever again.\n/// Once an `ISale` reaches `Success` or `Fail` it MUST NOT return any other\n/// status ever again.\nenum SaleStatus {\n    Pending,\n    Active,\n    Success,\n    Fail\n}\n\ninterface ISale {\n    /// Returns the address of the token being sold in the sale.\n    /// MUST NOT change during the lifecycle of the sale contract.\n    function token() external view returns (address);\n\n    /// Returns the address of the token that sale prices are denominated in.\n    /// MUST NOT change during the lifecycle of the sale contract.\n    function reserve() external view returns (address);\n\n    /// Returns the current `SaleStatus` of the sale.\n    /// Represents a linear progression of the sale through its major lifecycle\n    /// events.\n    function saleStatus() external view returns (SaleStatus);\n}\n"
    },
    "contracts/redeemableERC20/RedeemableERC20.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {ERC20Config} from \"../erc20/ERC20Config.sol\";\nimport \"../erc20/ERC20Redeem.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {ITierV2} from \"../tier/ITierV2.sol\";\nimport {TierReport} from \"../tier/libraries/TierReport.sol\";\n\nimport {Phased} from \"../phased/Phased.sol\";\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\n/// Everything required by the `RedeemableERC20` constructor.\n/// @param reserve Reserve token that the associated `Trust` or equivalent\n/// raise contract will be forwarding to the `RedeemableERC20` contract.\n/// @param erc20Config ERC20 config forwarded to the ERC20 constructor.\n/// @param tier Tier contract to compare statuses against on transfer.\n/// @param minimumTier Minimum tier required for transfers in `Phase.ZERO`.\n/// Can be `0`.\n/// @param distributionEndForwardingAddress Optional address to send rTKN to at\n/// the end of the distribution phase. If `0` address then all undistributed\n/// rTKN will burn itself at the end of the distribution.\nstruct RedeemableERC20Config {\n    address reserve;\n    ERC20Config erc20Config;\n    address tier;\n    uint256 minimumTier;\n    address distributionEndForwardingAddress;\n}\n\n/// @title RedeemableERC20\n/// @notice This is the ERC20 token that is minted and distributed.\n///\n/// During `Phase.ZERO` the token can be traded and so compatible with the\n/// Balancer pool mechanics.\n///\n/// During `Phase.ONE` the token is frozen and no longer able to be traded on\n/// any AMM or transferred directly.\n///\n/// The token can be redeemed during `Phase.ONE` which burns the token in\n/// exchange for pro-rata erc20 tokens held by the `RedeemableERC20` contract\n/// itself.\n///\n/// The token balances can be used indirectly for other claims, promotions and\n/// events as a proof of participation in the original distribution by token\n/// holders.\n///\n/// The token can optionally be restricted by the `ITierV2` contract to only\n/// allow receipients with a specified membership status.\n///\n/// @dev `RedeemableERC20` is an ERC20 with 2 phases.\n///\n/// `Phase.ZERO` is the distribution phase where the token can be freely\n/// transfered but not redeemed.\n/// `Phase.ONE` is the redemption phase where the token can be redeemed but no\n/// longer transferred.\n///\n/// Redeeming some amount of `RedeemableERC20` burns the token in exchange for\n/// some other tokens held by the contract. For example, if the\n/// `RedeemableERC20` token contract holds 100 000 USDC then a holder of the\n/// redeemable token can burn some of their tokens to receive a % of that USDC.\n/// If they redeemed (burned) an amount equal to 10% of the redeemable token\n/// supply then they would receive 10 000 USDC.\n///\n/// To make the treasury assets discoverable anyone can call `newTreasuryAsset`\n/// to emit an event containing the treasury asset address. As malicious and/or\n/// spam users can emit many treasury events there is a need for sensible\n/// indexing and filtering of asset events to only trusted users. This contract\n/// is agnostic to how that trust relationship is defined for each user.\n///\n/// Users must specify all the treasury assets they wish to redeem to the\n/// `redeem` function. After `redeem` is called the redeemed tokens are burned\n/// so all treasury assets must be specified and claimed in a batch atomically.\n/// Note: The same amount of `RedeemableERC20` is burned, regardless of which\n/// treasury assets were specified. Specifying fewer assets will NOT increase\n/// the proportion of each that is returned.\n///\n/// `RedeemableERC20` has several owner administrative functions:\n/// - Owner can add senders and receivers that can send/receive tokens even\n///   during `Phase.ONE`\n/// - Owner can end `Phase.ONE` during `Phase.ZERO` by specifying the address\n///   of a distributor, which will have any undistributed tokens burned.\n/// The owner should be a `Trust` not an EOA.\n///\n/// The redeem functions MUST be used to redeem and burn RedeemableERC20s\n/// (NOT regular transfers).\n///\n/// `redeem` will simply revert if called outside `Phase.ONE`.\n/// A `Redeem` event is emitted on every redemption (per treasury asset) as\n/// `(redeemer, asset, redeemAmount)`.\ncontract RedeemableERC20 is Initializable, Phased, ERC20Redeem {\n    using SafeERC20 for IERC20;\n\n    /// @dev Phase constants.\n    /// Contract is not yet initialized.\n    uint256 private constant PHASE_UNINITIALIZED = 0;\n    /// @dev Token is in the distribution phase and can be transferred freely\n    /// subject to tier requirements.\n    uint256 private constant PHASE_DISTRIBUTING = 1;\n    /// @dev Token is frozen and cannot be transferred unless the\n    /// sender/receiver is authorized as a sender/receiver.\n    uint256 private constant PHASE_FROZEN = 2;\n\n    /// @dev Bits for a receiver.\n    uint256 private constant RECEIVER = 0x1;\n    /// @dev Bits for a sender.\n    uint256 private constant SENDER = 0x2;\n\n    /// @dev To be clear, this admin is NOT intended to be an EOA.\n    /// This contract is designed assuming the admin is a `Sale` or equivalent\n    /// contract that itself does NOT have an admin key.\n    address private admin;\n    /// @dev Tracks addresses that can always send/receive regardless of phase.\n    /// sender/receiver => access bits\n    mapping(address => uint256) private access;\n\n    /// Results of initializing.\n    /// @param sender `msg.sender` of initialize.\n    /// @param config Initialization config.\n    event Initialize(address sender, RedeemableERC20Config config);\n\n    /// A new token sender has been added.\n    /// @param sender `msg.sender` that approved the token sender.\n    /// @param grantedSender address that is now a token sender.\n    event Sender(address sender, address grantedSender);\n\n    /// A new token receiver has been added.\n    /// @param sender `msg.sender` that approved the token receiver.\n    /// @param grantedReceiver address that is now a token receiver.\n    event Receiver(address sender, address grantedReceiver);\n\n    /// RedeemableERC20 uses the standard/default 18 ERC20 decimals.\n    /// The minimum supply enforced by the constructor is \"one\" token which is\n    /// `10 ** 18`.\n    /// The minimum supply does not prevent subsequent redemption/burning.\n    uint256 private constant MINIMUM_INITIAL_SUPPLY = 10**18;\n\n    /// Tier contract that produces the report that `minimumTier` is checked\n    /// against.\n    /// Public so external contracts can interface with the required tier.\n    ITierV2 public tier;\n\n    /// The minimum status that a user must hold to receive transfers during\n    /// `Phase.ZERO`.\n    /// The tier contract passed to `TierByConstruction` determines if\n    /// the status is held during `_beforeTokenTransfer`.\n    /// Public so external contracts can interface with the required tier.\n    uint256 public minimumTier;\n\n    /// Optional address to send rTKN to at the end of the distribution phase.\n    /// If `0` address then all undistributed rTKN will burn itself at the end\n    /// of the distribution.\n    address private distributionEndForwardingAddress;\n\n    /// Mint the full ERC20 token supply and configure basic transfer\n    /// restrictions. Initializes all base contracts.\n    /// @param config_ Initialized configuration.\n    function initialize(RedeemableERC20Config calldata config_)\n        external\n        initializer\n    {\n        initializePhased();\n\n        tier = ITierV2(config_.tier);\n\n        require(\n            ERC165Checker.supportsInterface(\n                config_.tier,\n                type(ITierV2).interfaceId\n            ),\n            \"ERC165_TIERV2\"\n        );\n\n        __ERC20_init(config_.erc20Config.name, config_.erc20Config.symbol);\n\n        require(\n            config_.erc20Config.initialSupply >= MINIMUM_INITIAL_SUPPLY,\n            \"MINIMUM_INITIAL_SUPPLY\"\n        );\n        minimumTier = config_.minimumTier;\n        distributionEndForwardingAddress = config_\n            .distributionEndForwardingAddress;\n\n        // Minting and burning must never fail.\n        access[address(0)] = RECEIVER | SENDER;\n\n        // Admin receives full supply.\n        access[config_.erc20Config.distributor] = RECEIVER;\n\n        // Forwarding address must be able to receive tokens.\n        if (distributionEndForwardingAddress != address(0)) {\n            access[distributionEndForwardingAddress] = RECEIVER;\n        }\n\n        admin = config_.erc20Config.distributor;\n\n        // Need to mint after assigning access.\n        _mint(\n            config_.erc20Config.distributor,\n            config_.erc20Config.initialSupply\n        );\n\n        // The reserve must always be one of the treasury assets.\n        newTreasuryAsset(config_.reserve);\n\n        emit Initialize(msg.sender, config_);\n\n        schedulePhase(PHASE_DISTRIBUTING, block.timestamp);\n    }\n\n    /// Require a function is only admin callable.\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"ONLY_ADMIN\");\n        _;\n    }\n\n    /// Check that an address is a receiver.\n    /// A sender is also a receiver.\n    /// @param maybeReceiver_ account to check.\n    /// @return True if account is a receiver.\n    function isReceiver(address maybeReceiver_) public view returns (bool) {\n        return access[maybeReceiver_] & RECEIVER > 0;\n    }\n\n    /// Admin can grant an address receiver rights.\n    /// @param newReceiver_ The account to grand receiver.\n    function grantReceiver(address newReceiver_) external onlyAdmin {\n        // Using `|` preserves sender if previously granted.\n        access[newReceiver_] |= RECEIVER;\n        emit Receiver(msg.sender, newReceiver_);\n    }\n\n    /// Check that an address is a sender.\n    /// @param maybeSender_ account to check.\n    /// @return True if account is a sender.\n    function isSender(address maybeSender_) public view returns (bool) {\n        return access[maybeSender_] & SENDER > 0;\n    }\n\n    /// Admin can grant an addres sender rights.\n    /// @param newSender_ The account to grant sender.\n    function grantSender(address newSender_) external onlyAdmin {\n        // Uinsg `|` preserves receiver if previously granted.\n        access[newSender_] |= SENDER;\n        emit Sender(msg.sender, newSender_);\n    }\n\n    /// The admin can forward or burn all tokens of a single address to end\n    /// `PHASE_DISTRIBUTING`.\n    /// The intent is that during `PHASE_DISTRIBUTING` there is some contract\n    /// responsible for distributing the tokens.\n    /// The admin specifies the distributor to end `PHASE_DISTRIBUTING` and the\n    /// forwarding address set during initialization is used. If the forwarding\n    /// address is `0` the rTKN will be burned, otherwise the entire balance of\n    /// the distributor is forwarded to the nominated address. In practical\n    /// terms the forwarding allows for escrow depositors to receive a prorata\n    /// claim on unsold rTKN if they forward it to themselves, otherwise raise\n    /// participants will receive a greater share of the final escrowed tokens\n    /// due to the burn reducing the total supply.\n    /// The distributor is NOT set during the constructor because it may not\n    /// exist at that point. For example, Balancer needs the paired erc20\n    /// tokens to exist before the trading pool can be built.\n    /// @param distributor_ The distributor according to the admin.\n    /// BURN the tokens if `address(0)`.\n    function endDistribution(address distributor_)\n        external\n        onlyPhase(PHASE_DISTRIBUTING)\n        onlyAdmin\n    {\n        schedulePhase(PHASE_FROZEN, block.timestamp);\n        address forwardTo_ = distributionEndForwardingAddress;\n        uint256 distributorBalance_ = balanceOf(distributor_);\n        if (distributorBalance_ > 0) {\n            if (forwardTo_ == address(0)) {\n                _burn(distributor_, distributorBalance_);\n            } else {\n                _transfer(distributor_, forwardTo_, distributorBalance_);\n            }\n        }\n    }\n\n    /// Wraps `_redeem` from `ERC20Redeem`.\n    /// Very thin wrapper so be careful when calling!\n    /// @param treasuryAssets_ The treasury assets to redeem for. If this is\n    /// empty or incomplete then tokens will be permanently burned for no\n    /// reason by the caller and the remaining funds will be effectively\n    /// redistributed to everyone else.\n    function redeem(IERC20[] calldata treasuryAssets_, uint256 redeemAmount_)\n        external\n        onlyPhase(PHASE_FROZEN)\n    {\n        _redeem(treasuryAssets_, redeemAmount_);\n    }\n\n    /// Apply phase sensitive transfer restrictions.\n    /// During `Phase.ZERO` only tier requirements apply.\n    /// During `Phase.ONE` all transfers except burns are prevented.\n    /// If a transfer involves either a sender or receiver with the SENDER\n    /// or RECEIVER role, respectively, it will bypass these restrictions.\n    /// @inheritdoc ERC20Upgradeable\n    function _beforeTokenTransfer(\n        address sender_,\n        address receiver_,\n        uint256 amount_\n    ) internal virtual override {\n        super._beforeTokenTransfer(sender_, receiver_, amount_);\n\n        // Sending tokens to this contract (e.g. instead of redeeming) is\n        // always an error.\n        require(receiver_ != address(this), \"TOKEN_SEND_SELF\");\n\n        // Some contracts may attempt a preflight (e.g. Balancer) of a 0 amount\n        // transfer.\n        // We don't want to accidentally cause external errors due to zero\n        // value transfers.\n        if (\n            amount_ > 0 &&\n            // The sender and receiver lists bypass all access restrictions.\n            !(isSender(sender_) || isReceiver(receiver_))\n        ) {\n            // During `PHASE_DISTRIBUTING` transfers are only restricted by the\n            // tier of the recipient. Every other phase only allows senders and\n            // receivers as above.\n            require(currentPhase() == PHASE_DISTRIBUTING, \"FROZEN\");\n\n            // Receivers act as \"hubs\" that can send to \"spokes\".\n            // i.e. any address of the minimum tier.\n            // Spokes cannot send tokens another \"hop\" e.g. to each other.\n            // Spokes can only send back to a receiver (doesn't need to be\n            // the same receiver they received from).\n            require(isReceiver(sender_), \"2SPOKE\");\n            require(\n                TierReport.tierAtTimeFromReport(\n                    tier.report(receiver_, new uint256[](0)),\n                    block.timestamp\n                ) >= minimumTier,\n                \"MIN_TIER\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/redeemableERC20/RedeemableERC20Factory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport {RedeemableERC20, RedeemableERC20Config} from \"./RedeemableERC20.sol\";\nimport {ITierV2} from \"../tier/ITierV2.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\n/// @title RedeemableERC20Factory\n/// @notice Factory for deploying and registering `RedeemableERC20` contracts.\ncontract RedeemableERC20Factory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new RedeemableERC20());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        RedeemableERC20Config memory config_ = abi.decode(\n            data_,\n            (RedeemableERC20Config)\n        );\n        address clone_ = Clones.clone(implementation);\n        RedeemableERC20(clone_).initialize(config_);\n        return clone_;\n    }\n\n    /// Allows calling `createChild` with `RedeemableERC20Config` struct.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `RedeemableERC20` initializer configuration.\n    /// @return New `RedeemableERC20` child contract.\n    function createChildTyped(RedeemableERC20Config calldata config_)\n        external\n        returns (RedeemableERC20)\n    {\n        return RedeemableERC20(this.createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/erc20/ERC20Redeem.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\n\ncontract ERC20Redeem is ERC20BurnableUpgradeable {\n    using SafeERC20 for IERC20;\n\n    /// Anon has burned their tokens in exchange for some treasury assets.\n    /// Emitted once per redeemed asset.\n    /// @param sender `msg.sender` is burning.\n    /// @param treasuryAsset Treasury asset being sent to redeemer.\n    /// @param redeemAmount Amount of token being burned.\n    /// @param assetAmount Amount of treasury asset being sent.\n    event Redeem(\n        address sender,\n        address treasuryAsset,\n        uint256 redeemAmount,\n        uint256 assetAmount\n    );\n\n    /// Anon can notify the world that they are adding treasury assets to the\n    /// contract. Indexers are strongly encouraged to ignore untrusted anons.\n    /// @param sender `msg.sender` adding a treasury asset.\n    /// @param asset The treasury asset being added.\n    event TreasuryAsset(address sender, address asset);\n\n    /// Anon can emit a `TreasuryAsset` event to notify token holders that\n    /// an asset could be redeemed by burning `RedeemableERC20` tokens.\n    /// As this is callable by anon the events should be filtered by the\n    /// indexer to those from trusted entities only.\n    /// @param newTreasuryAsset_ The asset to log.\n    function newTreasuryAsset(address newTreasuryAsset_) public {\n        emit TreasuryAsset(msg.sender, newTreasuryAsset_);\n    }\n\n    /// Burn tokens for a prorata share of the current treasury.\n    ///\n    /// The assets to be redeemed for must be specified as an array. This keeps\n    /// the redeem functionality:\n    /// - Gas efficient as we avoid tracking assets in storage\n    /// - Decentralised as any user can deposit any asset to be redeemed\n    /// - Error resistant as any individual asset reverting can be avoided by\n    ///   redeeming againt sans the problematic asset.\n    /// It is also a super sharp edge if someone burns their tokens prematurely\n    /// or with an incorrect asset list. Implementing contracts are strongly\n    /// encouraged to implement additional safety rails to prevent high value\n    /// mistakes.\n    /// Only \"vanilla\" erc20 token balances are supported as treasury assets.\n    /// I.e. if the balance is changing such as due to a rebasing token or\n    /// other mechanism then the WRONG token amounts will be redeemed. The\n    /// redemption calculation is very simple and naive in that it takes the\n    /// current balance of this contract of the assets being claimed via\n    /// redemption to calculate the \"prorata\" entitlement. If the contract's\n    /// balance of the claimed token is changing between redemptions (other\n    /// than due to the redemption itself) then each redemption will send\n    /// incorrect amounts.\n    /// @param treasuryAssets_ The list of assets to redeem.\n    /// @param redeemAmount_ The amount of redeemable token to burn.\n    function _redeem(IERC20[] memory treasuryAssets_, uint256 redeemAmount_)\n        internal\n    {\n        uint256 assetsLength_ = treasuryAssets_.length;\n\n        // Calculate everything before any balances change.\n        uint256[] memory amounts_ = new uint256[](assetsLength_);\n\n        // The fraction of the assets we release is the fraction of the\n        // outstanding total supply of the redeemable being burned.\n        // Every treasury asset is released in the same proportion.\n        // Guard against no asset redemptions and log all events before we\n        // change any contract state or call external contracts.\n        require(assetsLength_ > 0, \"EMPTY_ASSETS\");\n        uint256 supply_ = IERC20(address(this)).totalSupply();\n        uint256 amount_ = 0;\n        for (uint256 i_ = 0; i_ < assetsLength_; i_++) {\n            amount_ =\n                (treasuryAssets_[i_].balanceOf(address(this)) * redeemAmount_) /\n                supply_;\n            require(amount_ > 0, \"ZERO_AMOUNT\");\n            emit Redeem(\n                msg.sender,\n                address(treasuryAssets_[i_]),\n                redeemAmount_,\n                amount_\n            );\n            amounts_[i_] = amount_;\n        }\n\n        // Burn FIRST (reentrancy safety).\n        _burn(msg.sender, redeemAmount_);\n\n        // THEN send all assets.\n        for (uint256 i_ = 0; i_ < assetsLength_; i_++) {\n            treasuryAssets_[i_].safeTransfer(msg.sender, amounts_[i_]);\n        }\n    }\n}\n"
    },
    "contracts/phased/Phased.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title Phased\n/// @notice `Phased` is an abstract contract that defines up to `9` phases that\n/// an implementing contract moves through.\n///\n/// Phase `0` is always the first phase and does not, and cannot, be set\n/// expicitly. Effectively it is implied that phase `0` has been active\n/// since block zero.\n///\n/// Each subsequent phase `1` through `8` must be scheduled sequentially and\n/// explicitly at a block timestamp.\n///\n/// Only the immediate next phase can be scheduled with `scheduleNextPhase`,\n/// it is not possible to schedule multiple phases ahead.\n///\n/// Multiple phases can be scheduled in a single second if each scheduled phase\n/// is scheduled for the current block OR the contract is operating on a chain\n/// with sub-second block times. I.e. if uniqueness of block timestamps is NOT\n/// enforced by a chain then phases scheduling can share a timstamp across\n/// multiple transactions. To enforce uniqueness of timestamps across\n/// transactions on subsecond blockchains, simply schedule the final phase\n/// shift of a transaction in the future.\n///\n/// Several utility functions and modifiers are provided.\n///\n/// One event `PhaseShiftScheduled` is emitted each time a phase shift is\n/// scheduled (not when the scheduled phase is reached).\n///\n/// @dev `Phased` contracts have a defined timeline with available\n/// functionality grouped into phases.\n/// Every `Phased` contract starts at `0` and moves sequentially\n/// through phases `1` to `8`.\n/// Every `Phase` other than `0` is optional, there is no requirement\n/// that all 9 phases are implemented.\n/// Phases can never be revisited, the inheriting contract always moves through\n/// each achieved phase linearly.\n/// This is enforced by only allowing `scheduleNextPhase` to be called once per\n/// phase.\n/// It is possible to call `scheduleNextPhase` several times in a single second\n/// but the `block.timestamp` for each phase must be reached each time to\n/// schedule the next phase.\n/// Importantly there are events and several modifiers and checks available to\n/// ensure that functionality is limited to the current phase.\n/// The full history of each phase shift block is recorded as a fixed size\n/// array of `uint32`.\ncontract Phased {\n    /// @dev Every phase block starts uninitialized.\n    /// Only uninitialized blocks can be set by the phase scheduler.\n    uint32 private constant UNINITIALIZED = type(uint32).max;\n    /// @dev This is how many phases can fit in a `uint256`.\n    uint256 private constant MAX_PHASE = 8;\n\n    /// `PhaseScheduled` is emitted when the next phase is scheduled.\n    /// @param sender `msg.sender` that scheduled the next phase.\n    /// @param newPhase The next phase being scheduled.\n    /// @param scheduledTime The timestamp the phase will be achieved.\n    event PhaseScheduled(\n        address sender,\n        uint256 newPhase,\n        uint256 scheduledTime\n    );\n\n    /// 8 phases each as 32 bits to fit a single 32 byte word.\n    uint32[MAX_PHASE] public phaseTimes;\n\n    /// Initialize the blocks at \"never\".\n    /// All phase blocks are initialized to `UNINITIALIZED`.\n    /// i.e. not fallback solidity value of `0`.\n    function initializePhased() internal {\n        // Reinitialization is a bug.\n        // Only need to check the first block as all times are about to be set\n        // to `UNINITIALIZED`.\n        assert(phaseTimes[0] < 1);\n        uint32[MAX_PHASE] memory phaseTimes_ = [\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED\n        ];\n        phaseTimes = phaseTimes_;\n        // 0 is always the timestamp for implied phase 0.\n        emit PhaseScheduled(msg.sender, 0, 0);\n    }\n\n    /// Pure function to reduce an array of phase times and block timestamp to\n    /// a specific `Phase`.\n    /// The phase will be the highest attained even if several phases have the\n    /// same timestamp.\n    /// If every phase block is after the timestamp then `0` is returned.\n    /// If every phase block is before the timestamp then `MAX_PHASE` is\n    /// returned.\n    /// @param phaseTimes_ Fixed array of phase times to compare against.\n    /// @param timestamp_ Determine the relevant phase relative to this time.\n    /// @return phase_ The \"current\" phase relative to the timestamp and phase\n    /// times list.\n    function phaseAtTime(\n        uint32[MAX_PHASE] memory phaseTimes_,\n        uint256 timestamp_\n    ) public pure returns (uint256 phase_) {\n        for (phase_ = 0; phase_ < MAX_PHASE; phase_++) {\n            if (timestamp_ < phaseTimes_[phase_]) {\n                break;\n            }\n        }\n    }\n\n    /// Pure function to reduce an array of phase times and phase to a\n    /// specific timestamp.\n    /// `Phase.ZERO` will always return block `0`.\n    /// Every other phase will map to a time in `phaseTimes_`.\n    /// @param phaseTimes_ Fixed array of phase blocks to compare against.\n    /// @param phase_ Determine the relevant block number for this phase.\n    /// @return timestamp_ The timestamp for the phase according to\n    /// `phaseTimes_`.\n    function timeForPhase(uint32[MAX_PHASE] memory phaseTimes_, uint256 phase_)\n        public\n        pure\n        returns (uint256 timestamp_)\n    {\n        timestamp_ = phase_ > 0 ? phaseTimes_[phase_ - 1] : 0;\n    }\n\n    /// Impure read-only function to return the \"current\" phase from internal\n    /// contract state.\n    /// Simply wraps `phaseAtTime` for current values of `phaseTimes`\n    /// and `block.timestamp`.\n    function currentPhase() public view returns (uint256 phase_) {\n        phase_ = phaseAtTime(phaseTimes, block.timestamp);\n    }\n\n    /// Modifies functions to only be callable in a specific phase.\n    /// @param phase_ Modified functions can only be called during this phase.\n    modifier onlyPhase(uint256 phase_) {\n        require(currentPhase() == phase_, \"BAD_PHASE\");\n        _;\n    }\n\n    /// Modifies functions to only be callable in a specific phase OR if the\n    /// specified phase has passed.\n    /// @param phase_ Modified function only callable during or after this\n    /// phase.\n    modifier onlyAtLeastPhase(uint256 phase_) {\n        require(currentPhase() >= phase_, \"MIN_PHASE\");\n        _;\n    }\n\n    /// Writes the timestamp for the next phase.\n    /// Only uninitialized times can be written to.\n    /// Only the immediate next phase relative to `currentPhase` can be written\n    /// to. It is still required to specify the `phase_` so that it is explicit\n    /// and clear in the calling code which phase is being moved to.\n    /// Emits `PhaseShiftScheduled` with the phase timestamp.\n    /// @param phase_ The phase being scheduled.\n    /// @param timestamp_ The timestamp for the phase.\n    function schedulePhase(uint256 phase_, uint256 timestamp_) internal {\n        require(block.timestamp <= timestamp_, \"NEXT_TIME_PAST\");\n        require(timestamp_ < UNINITIALIZED, \"NEXT_TIME_UNINITIALIZED\");\n        // Don't need to check for underflow as the index will be used as a\n        // fixed array index below. Implies that scheduling phase `0` is NOT\n        // supported.\n        uint256 index_;\n        unchecked {\n            index_ = phase_ - 1;\n        }\n        // Bit of a hack to check the current phase against the index to\n        // save calculating the subtraction twice.\n        require(currentPhase() == index_, \"NEXT_PHASE\");\n\n        require(UNINITIALIZED == phaseTimes[index_], \"NEXT_TIME_SET\");\n\n        // Cannot exceed UNINITIALIZED (see above) so don't need to check\n        // overflow on downcast.\n        unchecked {\n            phaseTimes[index_] = uint32(timestamp_);\n        }\n\n        emit PhaseScheduled(msg.sender, phase_, timestamp_);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/sale/SaleFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport \"./Sale.sol\";\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\n/// @title SaleFactory\n/// @notice Factory for creating and deploying `Sale` contracts.\ncontract SaleFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address private immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor(SaleConstructorConfig memory config_) {\n        address implementation_ = address(new Sale(config_));\n        // silence slither.\n        require(implementation_ != address(0), \"0_IMPLEMENTATION\");\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        (\n            SaleConfig memory config_,\n            SaleRedeemableERC20Config memory saleRedeemableERC20Config_\n        ) = abi.decode(data_, (SaleConfig, SaleRedeemableERC20Config));\n        address clone_ = Clones.clone(implementation);\n        Sale(clone_).initialize(config_, saleRedeemableERC20Config_);\n        return clone_;\n    }\n\n    /// Allows calling `createChild` with `SeedERC20Config` struct.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `SaleConfig` constructor configuration.\n    /// @return New `Sale` child contract.\n    function createChildTyped(\n        SaleConfig calldata config_,\n        SaleRedeemableERC20Config calldata saleRedeemableERC20Config_\n    ) external returns (Sale) {\n        return\n            Sale(\n                this.createChild(\n                    abi.encode(config_, saleRedeemableERC20Config_)\n                )\n            );\n    }\n}\n"
    },
    "contracts/vm/ops/AllStandardOpsStateBuilder.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../VMStateBuilder.sol\";\nimport \"./AllStandardOps.sol\";\n\ncontract AllStandardOpsStateBuilder is VMStateBuilder {\n    /// @inheritdoc VMStateBuilder\n    function stackPopsFnPtrs() public pure override returns (bytes memory) {\n        return AllStandardOps.stackPopsFnPtrs();\n    }\n\n    /// @inheritdoc VMStateBuilder\n    function stackPushesFnPtrs() public pure override returns (bytes memory) {\n        return AllStandardOps.stackPushesFnPtrs();\n    }\n}\n"
    },
    "contracts/test/StackHeightTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {RainVM} from \"../vm/RainVM.sol\";\nimport \"../vm/VMStateBuilder.sol\";\nimport {AllStandardOps} from \"../vm/ops/AllStandardOps.sol\";\n\nuint256 constant ENTRYPOINT = 0;\nuint256 constant MIN_FINAL_STACK_INDEX = 2; // note this value\n\n/// @title StackHeightTest\n/// Test contract that has misconfigured final stack height.\ncontract StackHeightTest is RainVM {\n    address private immutable self;\n    address private immutable vmStateBuilder;\n    address private vmStatePointer;\n\n    constructor(address vmStateBuilder_) {\n        self = address(this);\n        vmStateBuilder = vmStateBuilder_;\n    }\n\n    /// Using initialize rather than constructor because fnPtrs doesn't return\n    /// the same thing during construction.\n    function initialize(StateConfig calldata stateConfig_) external {\n        Bounds memory bounds_;\n        bounds_.entrypoint = ENTRYPOINT;\n        bounds_.minFinalStackIndex = MIN_FINAL_STACK_INDEX;\n        Bounds[] memory boundss_ = new Bounds[](1);\n        boundss_[0] = bounds_;\n        bytes memory stateBytes_ = VMStateBuilder(vmStateBuilder).buildState(\n            self,\n            stateConfig_,\n            boundss_\n        );\n        vmStatePointer = SSTORE2.write(stateBytes_);\n    }\n\n    function fnPtrs() public pure override returns (bytes memory) {\n        return AllStandardOps.fnPtrs();\n    }\n}\n"
    },
    "contracts/test/FnPtrsTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {RainVM} from \"../vm/RainVM.sol\";\nimport \"../vm/VMStateBuilder.sol\";\n\nuint256 constant ENTRYPOINT = 0;\nuint256 constant MIN_FINAL_STACK_INDEX = 1;\n\n/// @title FnPtrsTest\n/// Test contract that returns bad fnPtrs length.\ncontract FnPtrsTest is RainVM {\n    address private immutable self;\n    address private immutable vmStateBuilder;\n    address private vmStatePointer;\n\n    constructor(address vmStateBuilder_) {\n        self = address(this);\n        vmStateBuilder = vmStateBuilder_;\n    }\n\n    /// Using initialize rather than constructor because fnPtrs doesn't return\n    /// the same thing during construction.\n    function initialize(StateConfig calldata stateConfig_) external {\n        Bounds memory bounds_;\n        bounds_.entrypoint = ENTRYPOINT;\n        bounds_.minFinalStackIndex = MIN_FINAL_STACK_INDEX;\n        Bounds[] memory boundss_ = new Bounds[](1);\n        boundss_[0] = bounds_;\n        bytes memory stateBytes_ = VMStateBuilder(vmStateBuilder).buildState(\n            self,\n            stateConfig_,\n            boundss_\n        );\n        vmStatePointer = SSTORE2.write(stateBytes_);\n    }\n\n    function fnPtrs() public pure override returns (bytes memory) {\n        bytes memory ret_;\n        return ret_;\n    }\n}\n"
    },
    "contracts/test/AllStandardOpsTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {RainVM, State, RAIN_VM_OPS_LENGTH} from \"../vm/RainVM.sol\";\nimport \"../vm/ops/AllStandardOps.sol\";\nimport \"../vm/VMStateBuilder.sol\";\n\nuint256 constant ENTRYPOINT = 0;\nuint256 constant MIN_FINAL_STACK_INDEX = 1;\n\nuint256 constant STORAGE_OPCODES_LENGTH = 3;\n\n/// @title AllStandardOpsTest\n/// Simple contract that exposes all standard ops for testing.\ncontract AllStandardOpsTest is RainVM {\n    address private immutable self;\n    address private immutable vmStateBuilder;\n    address private vmStatePointer;\n\n    /// *** STORAGE OPCODES START ***\n\n    uint256 private _val0 = 0;\n    uint256 private _val1 = 1;\n    uint256 private _val2 = 2;\n    uint256 private _val3 = 3; // deliberately not in range\n\n    /// *** STORAGE OPCODES END ***\n\n    State private _state;\n\n    constructor(address vmStateBuilder_) {\n        self = address(this);\n        vmStateBuilder = vmStateBuilder_;\n    }\n\n    /// Using initialize rather than constructor because fnPtrs doesn't return\n    /// the same thing during construction.\n    function initialize(StateConfig calldata stateConfig_) external {\n        uint256 a_ = gasleft();\n        Bounds memory bounds_;\n        bounds_.entrypoint = ENTRYPOINT;\n        bounds_.minFinalStackIndex = MIN_FINAL_STACK_INDEX;\n        Bounds[] memory boundss_ = new Bounds[](1);\n        boundss_[0] = bounds_;\n        bytes memory stateBytes_ = VMStateBuilder(vmStateBuilder).buildState(\n            self,\n            stateConfig_,\n            boundss_\n        );\n        uint256 b_ = gasleft();\n        console.log(\"new state gas\", a_ - b_);\n        vmStatePointer = SSTORE2.write(stateBytes_);\n    }\n\n    /// Wraps `runState` and returns top of stack.\n    /// @return top of `runState` stack.\n    function stackTop() external view returns (uint256) {\n        return _state.stack[_state.stackIndex - 1];\n    }\n\n    function stack() external view returns (uint256[] memory) {\n        return _state.stack;\n    }\n\n    function state() external view returns (State memory) {\n        return _state;\n    }\n\n    function fnPtrs() public pure override returns (bytes memory) {\n        return AllStandardOps.fnPtrs();\n    }\n\n    /// Runs `eval` and stores full state.\n    function run() public {\n        uint256 a_ = gasleft();\n        bytes memory stateBytes_ = SSTORE2.read(vmStatePointer);\n        uint256 b_ = gasleft();\n        uint256 c_ = gasleft();\n        State memory state_ = LibState.fromBytesPacked(stateBytes_);\n        uint256 d_ = gasleft();\n        uint256 e_ = gasleft();\n        eval(\"\", state_, ENTRYPOINT);\n        uint256 f_ = gasleft();\n        console.log(\"load gas:\", a_ - b_);\n        console.log(\"decode gas:\", c_ - d_);\n        console.log(\"run gas:\", e_ - f_);\n        // Never actually do this, state is gigantic so can't live in storage.\n        // This is just being done to make testing easier than trying to read\n        // results from events etc.\n        _state = state_;\n    }\n\n    /// Runs `eval` and stores full state. Stores `values_` to be accessed later\n    /// via CONTEXT opcode.\n    /// @param values_ - Values to add to context.\n    function runContext(uint256[] memory values_) public {\n        bytes memory context_ = new bytes(0x20 * values_.length);\n        for (uint256 i_ = 0; i_ < values_.length; i_++) {\n            uint256 value_ = values_[i_];\n            uint256 offset_ = i_ * 0x20;\n            assembly {\n                mstore(add(add(context_, offset_), 0x20), value_)\n            }\n        }\n        uint256 a_ = gasleft();\n        bytes memory stateBytes_ = SSTORE2.read(vmStatePointer);\n        uint256 b_ = gasleft();\n        uint256 c_ = gasleft();\n        State memory state_ = LibState.fromBytesPacked(stateBytes_);\n        uint256 d_ = gasleft();\n        uint256 e_ = gasleft();\n        eval(context_, state_, ENTRYPOINT);\n        uint256 f_ = gasleft();\n        console.log(\"load gas:\", a_ - b_);\n        console.log(\"decode gas:\", c_ - d_);\n        console.log(\"run gas:\", e_ - f_);\n        // Never actually do this, state is gigantic so can't live in storage.\n        // This is just being done to make testing easier than trying to read\n        // results from events etc.\n        _state = state_;\n    }\n\n    function storageOpcodesRange()\n        public\n        pure\n        override\n        returns (StorageOpcodesRange memory)\n    {\n        uint256 pointer_;\n        assembly {\n            pointer_ := _val0.slot\n        }\n        return StorageOpcodesRange(pointer_, STORAGE_OPCODES_LENGTH);\n    }\n}\n"
    },
    "contracts/orderbook/OrderBook.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../vm/RainVM.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../math/FixedPointMath.sol\";\nimport \"../vm/ops/AllStandardOps.sol\";\nimport \"./libraries/Vault.sol\";\nimport \"./libraries/Order.sol\";\n\nstruct DepositConfig {\n    address token;\n    VaultId vaultId;\n    uint256 amount;\n}\n\nstruct WithdrawConfig {\n    address token;\n    VaultId vaultId;\n    uint256 amount;\n}\n\nstruct BountyConfig {\n    VaultId aVaultId;\n    VaultId bVaultId;\n}\n\nstruct EvalContext {\n    OrderHash orderHash;\n    address counterparty;\n}\n\nstruct ClearStateChange {\n    uint256 aOutput;\n    uint256 bOutput;\n    uint256 aInput;\n    uint256 bInput;\n}\n\nuint constant LOCAL_OP_CLEARED_ORDER = ALL_STANDARD_OPS_LENGTH;\nuint constant LOCAL_OP_CLEARED_COUNTERPARTY = LOCAL_OP_CLEARED_ORDER + 1;\nuint256 constant LOCAL_OPS_LENGTH = 2;\n\nuint256 constant TRACKING_MASK_CLEARED_ORDER = 0x1;\nuint256 constant TRACKING_MASK_CLEARED_COUNTERPARTY = 0x2;\nuint256 constant TRACKING_MASK_ALL = TRACKING_MASK_CLEARED_ORDER |\n    TRACKING_MASK_CLEARED_COUNTERPARTY;\n\nlibrary LibEvalContext {\n    function toContextBytes(EvalContext memory evalContext_)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        uint256[2] memory vals_;\n        vals_[0] = OrderHash.unwrap(evalContext_.orderHash);\n        vals_[1] = uint256(uint160(evalContext_.counterparty));\n        return abi.encodePacked(vals_);\n    }\n}\n\ncontract OrderBook is RainVM {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n    using FixedPointMath for uint256;\n    using LibOrder for OrderLiveness;\n    using LibOrder for Order;\n    using LibEvalContext for EvalContext;\n\n    event Deposit(address sender, DepositConfig config);\n    /// @param sender `msg.sender` withdrawing tokens.\n    /// @param config All config sent to the `withdraw` call.\n    /// @param amount The amount of tokens withdrawn, can be less than the\n    /// config amount if the vault does not have the funds available to cover\n    /// the config amount.\n    event Withdraw(address sender, WithdrawConfig config, uint256 amount);\n    event OrderLive(address sender, Order config);\n    event OrderDead(address sender, Order config);\n    event Clear(address sender, Order a_, Order b_, BountyConfig bountyConfig);\n    event AfterClear(ClearStateChange stateChange);\n\n    address private immutable self;\n    address private immutable vmStateBuilder;\n\n    // order hash => order liveness\n    mapping(OrderHash => OrderLiveness) private orders;\n    // depositor => token => vault => token amount.\n    mapping(address => mapping(address => mapping(VaultId => uint256)))\n        private vaults;\n\n    // funds were cleared from the hashed order to anyone.\n    mapping(OrderHash => uint256) private clearedOrder;\n    // funds were cleared from the owner of the hashed order.\n    // order owner is the counterparty funds were cleared to.\n    // order hash => order owner => token amount\n    mapping(OrderHash => mapping(address => uint256))\n        private clearedCounterparty;\n\n    constructor(address vmStateBuilder_) {\n        self = address(this);\n        vmStateBuilder = vmStateBuilder_;\n    }\n\n    function _isTracked(uint256 tracking_, uint256 mask_)\n        internal\n        pure\n        returns (bool)\n    {\n        return (tracking_ & mask_) > 0;\n    }\n\n    function deposit(DepositConfig calldata config_) external {\n        vaults[msg.sender][config_.token][config_.vaultId] += config_.amount;\n        emit Deposit(msg.sender, config_);\n        IERC20(config_.token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            config_.amount\n        );\n    }\n\n    /// Allows the sender to withdraw any tokens from their own vaults.\n    /// @param config_ All config required to withdraw. Notably if the amount\n    /// is less than the current vault balance then the vault will be cleared\n    /// to 0 rather than the withdraw transaction reverting.\n    function withdraw(WithdrawConfig calldata config_) external {\n        uint256 vaultBalance_ = vaults[msg.sender][config_.token][\n            config_.vaultId\n        ];\n        uint256 withdrawAmount_ = config_.amount.min(vaultBalance_);\n        vaults[msg.sender][config_.token][config_.vaultId] =\n            vaultBalance_ -\n            withdrawAmount_;\n        emit Withdraw(msg.sender, config_, withdrawAmount_);\n        IERC20(config_.token).safeTransfer(msg.sender, withdrawAmount_);\n    }\n\n    function addOrder(OrderConfig calldata orderConfig_) external {\n        Order memory order_ = LibOrder.fromOrderConfig(\n            vmStateBuilder,\n            self,\n            orderConfig_\n        );\n        OrderHash orderHash_ = order_.hash();\n        if (orders[orderHash_].isDead()) {\n            orders[orderHash_] = ORDER_LIVE;\n            emit OrderLive(msg.sender, order_);\n        }\n    }\n\n    function removeOrder(Order calldata order_) external {\n        require(msg.sender == order_.owner, \"OWNER\");\n        OrderHash orderHash_ = order_.hash();\n        if (orders[orderHash_].isLive()) {\n            orders[orderHash_] = ORDER_DEAD;\n            emit OrderDead(msg.sender, order_);\n        }\n    }\n\n    function clear(\n        Order memory a_,\n        Order memory b_,\n        BountyConfig calldata bountyConfig_\n    ) external {\n        OrderHash aHash_ = a_.hash();\n        OrderHash bHash_ = b_.hash();\n        {\n            require(a_.outputToken == b_.inputToken, \"TOKEN_MISMATCH\");\n            require(b_.outputToken == a_.inputToken, \"TOKEN_MISMATCH\");\n            require(orders[aHash_].isLive(), \"A_NOT_LIVE\");\n            require(orders[bHash_].isLive(), \"B_NOT_LIVE\");\n        }\n\n        ClearStateChange memory stateChange_;\n\n        {\n            // Price is input per output for both a_ and b_.\n            uint256 aPrice_;\n            uint256 bPrice_;\n            // a_ and b_ can both set a maximum output from the VM.\n            uint256 aOutputMax_;\n            uint256 bOutputMax_;\n\n            // emit the Clear event before a_ and b_ are mutated due to the\n            // VM execution in eval.\n            emit Clear(msg.sender, a_, b_, bountyConfig_);\n\n            unchecked {\n                State memory vmState_;\n                {\n                    vmState_ = LibState.fromBytesPacked(a_.vmState);\n                    eval(\n                        EvalContext(aHash_, b_.owner).toContextBytes(),\n                        vmState_,\n                        ENTRYPOINT\n                    );\n                    aPrice_ = vmState_.stack[vmState_.stackIndex - 1];\n                    aOutputMax_ = vmState_.stack[vmState_.stackIndex - 2];\n                }\n\n                {\n                    vmState_ = LibState.fromBytesPacked(b_.vmState);\n                    eval(\n                        EvalContext(bHash_, a_.owner).toContextBytes(),\n                        vmState_,\n                        ENTRYPOINT\n                    );\n                    bPrice_ = vmState_.stack[vmState_.stackIndex - 1];\n                    bOutputMax_ = vmState_.stack[vmState_.stackIndex - 2];\n                }\n            }\n\n            // outputs are capped by the remaining funds in their output vault.\n            {\n                aOutputMax_ = aOutputMax_.min(\n                    vaults[a_.owner][a_.outputToken][a_.outputVaultId]\n                );\n                bOutputMax_ = bOutputMax_.min(\n                    vaults[b_.owner][b_.outputToken][b_.outputVaultId]\n                );\n            }\n\n            stateChange_.aOutput = aOutputMax_.min(\n                bOutputMax_.fixedPointMul(bPrice_)\n            );\n            stateChange_.bOutput = bOutputMax_.min(\n                aOutputMax_.fixedPointMul(aPrice_)\n            );\n\n            require(\n                stateChange_.aOutput > 0 || stateChange_.bOutput > 0,\n                \"0_CLEAR\"\n            );\n\n            stateChange_.aInput = stateChange_.aOutput.fixedPointMul(aPrice_);\n            stateChange_.bInput = stateChange_.bOutput.fixedPointMul(bPrice_);\n        }\n\n        if (stateChange_.aOutput > 0) {\n            vaults[a_.owner][a_.outputToken][a_.outputVaultId] -= stateChange_\n                .aOutput;\n            if (_isTracked(a_.tracking, TRACKING_MASK_CLEARED_ORDER)) {\n                clearedOrder[aHash_] += stateChange_.aOutput;\n            }\n            if (_isTracked(a_.tracking, TRACKING_MASK_CLEARED_COUNTERPARTY)) {\n                // A counts funds paid to cover the bounty as cleared for B.\n                clearedCounterparty[aHash_][b_.owner] += stateChange_.aOutput;\n            }\n        }\n        if (stateChange_.bOutput > 0) {\n            vaults[b_.owner][b_.outputToken][b_.outputVaultId] -= stateChange_\n                .bOutput;\n            if (_isTracked(b_.tracking, TRACKING_MASK_CLEARED_ORDER)) {\n                clearedOrder[bHash_] += stateChange_.bOutput;\n            }\n            if (_isTracked(b_.tracking, TRACKING_MASK_CLEARED_COUNTERPARTY)) {\n                clearedCounterparty[bHash_][a_.owner] += stateChange_.bOutput;\n            }\n        }\n        if (stateChange_.aInput > 0) {\n            vaults[a_.owner][a_.inputToken][a_.inputVaultId] += stateChange_\n                .aInput;\n        }\n        if (stateChange_.bInput > 0) {\n            vaults[b_.owner][b_.inputToken][b_.inputVaultId] += stateChange_\n                .bInput;\n        }\n        {\n            // At least one of these will overflow due to negative bounties if\n            // there is a spread between the orders.\n            uint256 aBounty_ = stateChange_.aOutput - stateChange_.bInput;\n            uint256 bBounty_ = stateChange_.bOutput - stateChange_.aInput;\n            if (aBounty_ > 0) {\n                vaults[msg.sender][a_.outputToken][\n                    bountyConfig_.aVaultId\n                ] += aBounty_;\n            }\n            if (bBounty_ > 0) {\n                vaults[msg.sender][b_.outputToken][\n                    bountyConfig_.bVaultId\n                ] += bBounty_;\n            }\n        }\n\n        emit AfterClear(stateChange_);\n    }\n\n    function opOrderFundsCleared(uint256, uint256 stackTopLocation_)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 location_;\n        OrderHash orderHash_;\n        assembly {\n            location_ := sub(stackTopLocation_, 0x20)\n            orderHash_ := mload(location_)\n        }\n        uint256 fundsCleared_ = clearedOrder[orderHash_];\n        assembly {\n            mstore(location_, fundsCleared_)\n        }\n        return stackTopLocation_;\n    }\n\n    function opOrderCounterpartyFundsCleared(uint256, uint256 stackTopLocation_)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 location_;\n        OrderHash orderHash_;\n        uint256 counterparty_;\n        assembly {\n            stackTopLocation_ := sub(stackTopLocation_, 0x20)\n            location_ := sub(stackTopLocation_, 0x20)\n            orderHash_ := mload(location_)\n            counterparty_ := mload(stackTopLocation_)\n        }\n        uint256 fundsCleared_ = clearedCounterparty[orderHash_][\n            address(uint160(counterparty_))\n        ];\n        assembly {\n            mstore(location_, fundsCleared_)\n        }\n        return stackTopLocation_;\n    }\n\n    function localFnPtrs() internal pure returns (bytes memory) {\n        unchecked {\n            uint256 lenBytes_ = LOCAL_OPS_LENGTH * 0x20;\n            function(uint256, uint256) pure returns (uint256) zeroFn_;\n            assembly {\n                zeroFn_ := 0\n            }\n            function(uint256, uint256) view returns (uint256)[LOCAL_OPS_LENGTH +\n                1]\n                memory fns_ = [\n                    // will be overridden with length\n                    zeroFn_,\n                    opOrderFundsCleared,\n                    opOrderCounterpartyFundsCleared\n                ];\n            bytes memory ret_;\n            assembly {\n                mstore(fns_, lenBytes_)\n                ret_ := fns_\n            }\n            return ret_;\n        }\n    }\n\n    function fnPtrs() public pure override returns (bytes memory) {\n        return bytes.concat(AllStandardOps.fnPtrs(), localFnPtrs());\n    }\n}\n"
    },
    "contracts/orderbook/libraries/Vault.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\ntype VaultId is uint256;\n"
    },
    "contracts/orderbook/libraries/Order.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../OrderBook.sol\";\nimport \"./Vault.sol\";\nimport \"../../vm/RainVM.sol\";\nimport \"../../vm/VMStateBuilder.sol\";\n\ntype OrderHash is uint256;\ntype OrderLiveness is uint256;\n\nstruct OrderConfig {\n    address inputToken;\n    VaultId inputVaultId;\n    address outputToken;\n    VaultId outputVaultId;\n    StateConfig vmStateConfig;\n}\n\nstruct Order {\n    address owner;\n    address inputToken;\n    VaultId inputVaultId;\n    address outputToken;\n    VaultId outputVaultId;\n    uint256 tracking;\n    bytes vmState;\n}\n\nuint256 constant ENTRYPOINT = 0;\nuint256 constant MIN_FINAL_STACK_INDEX = 2;\n\nOrderLiveness constant ORDER_DEAD = OrderLiveness.wrap(0);\nOrderLiveness constant ORDER_LIVE = OrderLiveness.wrap(1);\n\nlibrary LibOrder {\n    function deriveTracking(bytes[] memory sources_)\n        internal\n        pure\n        returns (uint256 tracking_)\n    {\n        unchecked {\n            uint localOpClearedOrder_ = LOCAL_OP_CLEARED_ORDER;\n            uint localOpClearedCounterparty_ = LOCAL_OP_CLEARED_COUNTERPARTY;\n            uint trackingMaskClearedOrder_ = TRACKING_MASK_CLEARED_ORDER;\n            uint trackingMaskClearedCounterparty_ = TRACKING_MASK_CLEARED_COUNTERPARTY;\n            uint trackingMaskAll_ = TRACKING_MASK_ALL;\n            for (uint256 i_ = 0; i_ < sources_.length; i_++) {\n                bytes memory source_ = sources_[i_];\n                assembly {\n                    let op_ := 0\n                    for {\n                        let cursor_ := add(source_, 1)\n                        let end_ := add(cursor_, mload(source_))\n                    } lt(cursor_, end_) {\n                        cursor_ := add(cursor_, 2)\n                    } {\n                        op_ := byte(31, mload(cursor_))\n                        if lt(op_, localOpClearedOrder_) {\n                            continue\n                        }\n                        if eq(op_, localOpClearedOrder_) {\n                            tracking_ := or(tracking_, trackingMaskClearedOrder_)\n                        }\n                        if eq(op_, localOpClearedCounterparty_) {\n                            tracking_ := or(tracking_, trackingMaskClearedCounterparty_)\n                        }\n                        if eq(tracking_, trackingMaskAll_) {\n                            // break the outer non-assembly loop by setting i_\n                            // to sources length.\n                            i_ := mload(sources_)\n                            // break the inner assembly loop.\n                            break\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    function fromOrderConfig(\n        address vmStateBuilder_,\n        address vm_,\n        OrderConfig memory config_\n    ) internal returns (Order memory) {\n        Bounds memory bounds_;\n        bounds_.entrypoint = ENTRYPOINT;\n        bounds_.minFinalStackIndex = MIN_FINAL_STACK_INDEX;\n        Bounds[] memory boundss_ = new Bounds[](1);\n        boundss_[0] = bounds_;\n        return\n            Order(\n                msg.sender,\n                config_.inputToken,\n                config_.inputVaultId,\n                config_.outputToken,\n                config_.outputVaultId,\n                deriveTracking(config_.vmStateConfig.sources),\n                VMStateBuilder(vmStateBuilder_).buildState(\n                    vm_,\n                    config_.vmStateConfig,\n                    boundss_\n                )\n            );\n    }\n\n    function isLive(OrderLiveness liveness_) internal pure returns (bool) {\n        return\n            OrderLiveness.unwrap(liveness_) == OrderLiveness.unwrap(ORDER_LIVE);\n    }\n\n    function isDead(OrderLiveness liveness_) internal pure returns (bool) {\n        return\n            OrderLiveness.unwrap(liveness_) == OrderLiveness.unwrap(ORDER_DEAD);\n    }\n\n    function hash(Order memory order_) internal pure returns (OrderHash) {\n        return OrderHash.wrap(uint256(keccak256(abi.encode(order_))));\n    }\n}\n"
    },
    "contracts/orderbook/OrderBookStateBuilder.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../vm/VMStateBuilder.sol\";\nimport \"../vm/ops/AllStandardOps.sol\";\nimport \"./OrderBook.sol\";\n\ncontract OrderBookStateBuilder is VMStateBuilder {\n    function localStackPopsFnPtrs() internal pure returns (bytes memory) {\n        unchecked {\n            uint256 lenBytes_ = LOCAL_OPS_LENGTH * 0x20;\n            function(uint256) pure returns (uint256) zeroFn_;\n            assembly {\n                zeroFn_ := 0\n            }\n            function(uint256) pure returns (uint256)[LOCAL_OPS_LENGTH + 1]\n                memory fns_ = [\n                    // will be overriden with length\n                    zeroFn_,\n                    // order funds cleared\n                    AllStandardOps.one,\n                    // order counterparty funds cleared\n                    AllStandardOps.two\n                ];\n            bytes memory ret_;\n            assembly {\n                mstore(fns_, lenBytes_)\n                ret_ := fns_\n            }\n            return ret_;\n        }\n    }\n\n    function localStackPushesFnPtrs() internal pure returns (bytes memory) {\n        unchecked {\n            uint256 lenBytes_ = LOCAL_OPS_LENGTH * 0x20;\n            function(uint256) pure returns (uint256) zeroFn_;\n            assembly {\n                zeroFn_ := 0\n            }\n            function(uint256) pure returns (uint256)[LOCAL_OPS_LENGTH + 1]\n                memory fns_ = [\n                    // will be overriden with length\n                    zeroFn_,\n                    // order funds cleared\n                    AllStandardOps.one,\n                    // order counterparty funds cleared\n                    AllStandardOps.one\n                ];\n            bytes memory ret_;\n            assembly {\n                mstore(fns_, lenBytes_)\n                ret_ := fns_\n            }\n            return ret_;\n        }\n    }\n\n    /// @inheritdoc VMStateBuilder\n    function stackPopsFnPtrs() public pure override returns (bytes memory) {\n        return\n            bytes.concat(\n                AllStandardOps.stackPopsFnPtrs(),\n                localStackPopsFnPtrs()\n            );\n    }\n\n    /// @inheritdoc VMStateBuilder\n    function stackPushesFnPtrs() public pure override returns (bytes memory) {\n        return\n            bytes.concat(\n                AllStandardOps.stackPushesFnPtrs(),\n                localStackPushesFnPtrs()\n            );\n    }\n}\n"
    },
    "contracts/test/FixedPointMathTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity 0.8.10;\n\nimport {FixedPointMath} from \"../math/FixedPointMath.sol\";\n\n/// @title FixedPointMathTest\n/// Thin wrapper around the `SaturatingMath` library for hardhat unit testing.\ncontract FixedPointMathTest {\n    /// Wraps `FixedPointMath.scale18`.\n    /// Scale a fixed point decimal of some scale factor to match `DECIMALS`.\n    /// @param a_ Some fixed point decimal value.\n    /// @param aDecimals_ The number of fixed decimals of `a_`.\n    /// @return `a_` scaled to match `DECIMALS`.\n    function scale18(uint256 a_, uint256 aDecimals_)\n        external\n        pure\n        returns (uint256)\n    {\n        return FixedPointMath.scale18(a_, aDecimals_);\n    }\n\n    /// Wraps `FixedPointMath.scaleN`.\n    /// Scale a fixed point decimals of `DECIMALS` to some other scale.\n    /// @param a_ A `DECIMALS` fixed point decimals.\n    /// @param targetDecimals_ The new scale of `a_`.\n    /// @return `a_` rescaled from `DECIMALS` to `targetDecimals_`.\n    function scaleN(uint256 a_, uint256 targetDecimals_)\n        external\n        pure\n        returns (uint256)\n    {\n        return FixedPointMath.scaleN(a_, targetDecimals_);\n    }\n\n    /// Wraps `FixedPointMath.scaleBy`.\n    /// Scale a fixed point up or down by `scaleBy_` orders of magnitude.\n    /// @param a_ Some integer of any scale.\n    /// @param scaleBy_ OOMs to scale `a_` up or down by.\n    /// @return `a_` rescaled according to `scaleBy_`.\n    function scaleBy(uint256 a_, int8 scaleBy_)\n        external\n        pure\n        returns (uint256)\n    {\n        return FixedPointMath.scaleBy(a_, scaleBy_);\n    }\n\n    /// Wraps `FixedPointMath.fixedPointMul`.\n    /// Fixed point multiplication in native scale decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` multiplied by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointMul(uint256 a_, uint256 b_)\n        external\n        pure\n        returns (uint256)\n    {\n        return FixedPointMath.fixedPointMul(a_, b_);\n    }\n\n    /// Wraps `FixedPointMath.fixedPointDiv`.\n    /// Fixed point division in native scale decimals.\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` divided by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointDiv(uint256 a_, uint256 b_)\n        external\n        pure\n        returns (uint256)\n    {\n        return FixedPointMath.fixedPointDiv(a_, b_);\n    }\n}\n"
    },
    "contracts/stake/Stake.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../tier/TierV2.sol\";\nimport \"../tier/libraries/TierConstants.sol\";\n\nimport \"../math/FixedPointMath.sol\";\nimport \"../tier/libraries/TierReport.sol\";\n\nstruct StakeConfig {\n    address token;\n    uint256 initialRatio;\n    string name;\n    string symbol;\n}\n\n/// @param amount Largest value we can squeeze into a uint256 alongside a\n/// uint32.\nstruct Deposit {\n    uint32 timestamp;\n    uint224 amount;\n}\n\ncontract Stake is ERC20Upgradeable, TierV2, ReentrancyGuard {\n    event Initialize(address sender, StakeConfig config);\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using FixedPointMath for uint256;\n\n    IERC20 private token;\n    uint256 private initialRatio;\n\n    mapping(address => Deposit[]) private deposits;\n\n    function initialize(StakeConfig calldata config_) external initializer {\n        require(config_.token != address(0), \"0_TOKEN\");\n        require(config_.initialRatio > 0, \"0_RATIO\");\n        __ERC20_init(config_.name, config_.symbol);\n        token = IERC20(config_.token);\n        initialRatio = config_.initialRatio;\n        emit Initialize(msg.sender, config_);\n    }\n\n    function deposit(uint256 amount_) external nonReentrant {\n        require(amount_ > 0, \"0_AMOUNT\");\n\n        // MUST check token balance before receiving additional tokens.\n        uint256 tokenPoolSize_ = token.balanceOf(address(this));\n        // MUST use supply from before the mint.\n        uint256 supply_ = totalSupply();\n\n        // Pull tokens before minting BUT AFTER reading contract balance.\n        token.safeTransferFrom(msg.sender, address(this), amount_);\n\n        uint256 mintAmount_;\n        if (supply_ == 0) {\n            mintAmount_ = amount_.fixedPointMul(initialRatio);\n        } else {\n            mintAmount_ = (supply_ * amount_) / tokenPoolSize_;\n        }\n        require(mintAmount_ > 0, \"0_MINT\");\n        _mint(msg.sender, mintAmount_);\n\n        uint224 highwater_ = deposits[msg.sender].length > 0\n            ? deposits[msg.sender][deposits[msg.sender].length - 1].amount\n            : 0;\n        deposits[msg.sender].push(\n            Deposit(uint32(block.timestamp), highwater_ + amount_.toUint224())\n        );\n    }\n\n    function withdraw(uint256 amount_) external nonReentrant {\n        require(amount_ > 0, \"0_AMOUNT\");\n\n        // MUST revert if length is 0 so we're guaranteed to have some amount\n        // for the old highwater. Users without deposits can't withdraw.\n        uint256 i_ = deposits[msg.sender].length - 1;\n        uint256 oldHighwater_ = uint256(deposits[msg.sender][i_].amount);\n        // MUST revert if withdraw amount exceeds highwater.\n        uint256 newHighwater_ = oldHighwater_ - amount_;\n\n        unchecked {\n            while (deposits[msg.sender][i_].amount > newHighwater_) {\n                delete deposits[msg.sender][i_];\n                if (i_ == 0) {\n                    break;\n                }\n                i_--;\n            }\n        }\n\n        // If the newHighwater_ is not identical to the current top we write it\n        // as the new top.\n        uint256 cmpHighwater_ = deposits[msg.sender].length > 0\n            ? deposits[msg.sender][deposits[msg.sender].length - 1].amount\n            : 0;\n        if (newHighwater_ > cmpHighwater_) {\n            deposits[msg.sender].push(\n                Deposit(uint32(block.timestamp), newHighwater_.toUint224())\n            );\n        }\n\n        // MUST calculate withdrawal amount against pre-burn supply.\n        uint256 supply_ = totalSupply();\n        _burn(msg.sender, amount_);\n        token.safeTransfer(\n            msg.sender,\n            (amount_ * token.balanceOf(address(this))) / supply_\n        );\n    }\n\n    /// @inheritdoc ITierV2\n    function report(address account_, uint256[] calldata context_)\n        external\n        view\n        returns (uint256 report_)\n    {\n        report_ = type(uint256).max;\n        if (context_.length > 0) {\n            uint256 t_ = 0;\n            Deposit memory deposit_;\n            for (uint256 i_ = 0; i_ < deposits[account_].length; i_++) {\n                deposit_ = deposits[account_][i_];\n                while (\n                    t_ < context_.length && deposit_.amount >= context_[t_]\n                ) {\n                    report_ = TierReport.updateTimeAtTier(\n                        report_,\n                        t_,\n                        deposit_.timestamp\n                    );\n                    t_++;\n                }\n                if (t_ == context_.length) {\n                    break;\n                }\n            }\n        }\n    }\n\n    /// @inheritdoc ITierV2\n    function reportTimeForTier(\n        address account_,\n        uint256 tier_,\n        uint256[] calldata context_\n    ) external view returns (uint256 time_) {\n        time_ = uint256(TierConstants.NEVER_TIME);\n        if (tier_ < context_.length) {\n            uint256 threshold_ = context_[tier_];\n            Deposit memory deposit_;\n            for (uint256 i_ = 0; i_ < deposits[account_].length; i_++) {\n                deposit_ = deposits[account_][i_];\n                if (deposit_.amount >= threshold_) {\n                    time_ = deposit_.timestamp;\n                    break;\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/stake/StakeFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport {Stake, StakeConfig} from \"./Stake.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\n/// @title StakeFactory\n/// @notice Factory for deploying and registering `Stake` contracts.\ncontract StakeFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new Stake());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        override\n        returns (address)\n    {\n        StakeConfig memory config_ = abi.decode(data_, (StakeConfig));\n        address clone_ = Clones.clone(implementation);\n        Stake(clone_).initialize(config_);\n        return clone_;\n    }\n\n    /// Allows calling `createChild` with `StakeConfig` struct.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `Stake` initializer configuration.\n    /// @return New `Stake` child contract.\n    function createChildTyped(StakeConfig calldata config_)\n        external\n        returns (Stake)\n    {\n        return Stake(this.createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "contracts/test/wrappers/TierReportTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {ITierV2} from \"../../tier/ITierV2.sol\";\nimport {TierReport} from \"../../tier/libraries/TierReport.sol\";\n\n/// @title TierReportTest\n/// Thin wrapper around the `TierReport` library for hardhat unit testing.\ncontract TierReportTest {\n    /// Wraps `TierReport.tierAtTimeFromReport`.\n    /// @param report_ Forwarded to TierReport.\n    /// @param timestamp_ Forwarded to TierReport.\n    function tierAtTimeFromReport(uint256 report_, uint256 timestamp_)\n        external\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            return TierReport.tierAtTimeFromReport(report_, timestamp_);\n        }\n    }\n\n    /// Wraps `TierReport.reportForTier`.\n    /// @param report_ Forwarded to TierReport.\n    /// @param tier_ Forwarded to TierReport.\n    function reportTimeForTier(uint256 report_, uint256 tier_)\n        external\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            return TierReport.reportTimeForTier(report_, tier_);\n        }\n    }\n\n    /// Wraps `TierReport.truncateTiersAbove`.\n    /// @param report_ Forwarded to TierReport.\n    /// @param tier_ Forwarded to TierReport.\n    function truncateTiersAbove(uint256 report_, uint256 tier_)\n        external\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            return TierReport.truncateTiersAbove(report_, tier_);\n        }\n    }\n\n    /// Wraps `TierReport.updateTimesForTierRange`.\n    /// @param report_ Forwarded to TestUtil.\n    /// @param startTier_ Forwarded to TestUtil.\n    /// @param endTier_ Forwarded to TestUtil.\n    /// @param timestamp_ Forwarded to TestUtil.\n    function updateTimesForTierRange(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 timestamp_\n    ) external pure returns (uint256) {\n        unchecked {\n            return\n                TierReport.updateTimesForTierRange(\n                    report_,\n                    startTier_,\n                    endTier_,\n                    timestamp_\n                );\n        }\n    }\n\n    /// Wraps `TierReport.updateReportWithTierAtTime`.\n    /// @param report_ Forwarded to TestUtil.\n    /// @param startTier_ Forwarded to TestUtil.\n    /// @param endTier_ Forwarded to TestUtil.\n    /// @param timestamp_ Forwarded to TestUtil.\n    function updateReportWithTierAtTime(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 timestamp_\n    ) external pure returns (uint256) {\n        unchecked {\n            return\n                TierReport.updateReportWithTierAtTime(\n                    report_,\n                    startTier_,\n                    endTier_,\n                    timestamp_\n                );\n        }\n    }\n\n    /// Updates a report with a timestamp for a given tier.\n    /// More gas efficient than `updateTimesForTierRange` if only a single\n    /// tier is being modified.\n    /// The tier at/above the given tier is updated. E.g. tier `0` will update\n    /// the block for tier `1`.\n    function updateTimeAtTier(\n        uint256 report_,\n        uint256 tier_,\n        uint256 timestamp_\n    ) external pure returns (uint256) {\n        unchecked {\n            return TierReport.updateTimeAtTier(report_, tier_, timestamp_);\n        }\n    }\n}\n"
    },
    "contracts/test/wrappers/TierV2Test.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {TierV2} from \"../../tier/TierV2.sol\";\nimport {ITierV2} from \"../../tier/ITierV2.sol\";\nimport {TierConstants} from \"../../tier/libraries/TierConstants.sol\";\n\n/// @title TierV2Test\n///\n/// Very simple TierV2 implementation for testing.\ncontract TierV2Test is TierV2 {\n    /// Either fetch the report from storage or return UNINITIALIZED.\n    /// @inheritdoc ITierV2\n    function report(address, uint256[] memory)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return TierConstants.NEVER_REPORT;\n    }\n\n    /// @inheritdoc ITierV2\n    function reportTimeForTier(\n        address,\n        uint256,\n        uint256[] calldata\n    ) external view returns (uint256) {\n        return block.timestamp;\n    }\n}\n"
    },
    "contracts/test/ReadWriteTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {TierV2} from \"../tier/TierV2.sol\";\nimport \"../tier/libraries/TierConstants.sol\";\nimport \"../tier/libraries/TierReport.sol\";\n\n/// @title ReadWriteTier\n///\n/// Very simple TierV2 implementation for testing.\ncontract ReadWriteTier is TierV2 {\n    /// Every time a tier changes we log start and end tier against the\n    /// account.\n    /// This MAY NOT be emitted if reports are being read from the state of an\n    /// external contract.\n    /// The start tier MAY be lower than the current tier as at the block this\n    /// event is emitted in.\n    /// @param sender The `msg.sender` that authorized the tier change.\n    /// @param account The account changing tier.\n    /// @param startTier The previous tier the account held.\n    /// @param endTier The newly acquired tier the account now holds.\n    /// @param data The associated data for the tier change.\n    event TierChange(\n        address sender,\n        address account,\n        uint256 startTier,\n        uint256 endTier,\n        bytes data\n    );\n\n    /// account => reports\n    mapping(address => uint256) private reports;\n\n    /// Either fetch the report from storage or return UNINITIALIZED.\n    /// @inheritdoc ITierV2\n    function report(address account_, uint256[] memory)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        // Inequality here to silence slither warnings.\n        return\n            reports[account_] > 0\n                ? reports[account_]\n                : TierConstants.NEVER_REPORT;\n    }\n\n    /// @inheritdoc ITierV2\n    function reportTimeForTier(\n        address account_,\n        uint256 tier_,\n        uint256[] calldata\n    ) external view returns (uint256) {\n        return TierReport.reportTimeForTier(reports[account_], tier_);\n    }\n\n    /// Errors if the user attempts to return to the ZERO tier.\n    /// Updates the report from `report` using default `TierReport` logic.\n    /// Emits `TierChange` event.\n    function setTier(\n        address account_,\n        uint256 endTier_,\n        bytes calldata data_\n    ) external {\n        // The user must move to at least tier 1.\n        // The tier 0 status is reserved for users that have never\n        // interacted with the contract.\n        require(endTier_ > 0, \"SET_ZERO_TIER\");\n\n        uint256[] memory context_;\n        uint256 report_ = report(account_, context_);\n\n        uint256 startTier_ = TierReport.tierAtTimeFromReport(\n            report_,\n            block.timestamp\n        );\n\n        reports[account_] = TierReport.updateReportWithTierAtTime(\n            report_,\n            startTier_,\n            endTier_,\n            block.timestamp\n        );\n\n        emit TierChange(msg.sender, account_, startTier_, endTier_, data_);\n    }\n\n    /// Re-export TierReport utilities\n\n    function tierAtTimeFromReport(uint256 report_, uint256 timestamp_)\n        external\n        pure\n        returns (uint256 tier_)\n    {\n        return TierReport.tierAtTimeFromReport(report_, timestamp_);\n    }\n\n    function reportTimeForTier(uint256 report_, uint256 tier_)\n        external\n        pure\n        returns (uint256 timestamp_)\n    {\n        return TierReport.reportTimeForTier(report_, tier_);\n    }\n\n    function truncateTiersAbove(uint256 report_, uint256 tier_)\n        external\n        pure\n        returns (uint256)\n    {\n        return TierReport.truncateTiersAbove(report_, tier_);\n    }\n\n    function updateTimeAtTier(\n        uint256 report_,\n        uint256 tier_,\n        uint256 timestamp_\n    ) external pure returns (uint256 updatedReport_) {\n        return TierReport.updateTimeAtTier(report_, tier_, timestamp_);\n    }\n\n    function updateTimesForTierRange(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 timestamp_\n    ) external pure returns (uint256 updatedReport_) {\n        return\n            TierReport.updateTimesForTierRange(\n                report_,\n                startTier_,\n                endTier_,\n                timestamp_\n            );\n    }\n\n    function updateReportWithTierAtTime(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 timestamp_\n    ) external pure returns (uint256 updatedReport_) {\n        return\n            TierReport.updateReportWithTierAtTime(\n                report_,\n                startTier_,\n                endTier_,\n                timestamp_\n            );\n    }\n}\n"
    },
    "contracts/test/RedeemableERC20Reentrant.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {ReserveToken} from \"./ReserveToken.sol\";\nimport {RedeemableERC20} from \"../redeemableERC20/RedeemableERC20.sol\";\n\n/// @title RedeemableERC20Reentrant\n/// Test contract that attempts to call reentrant code on `RedeemableERC20`.\n/// The calls MUST fail when driven by the test harness.\ncontract RedeemableERC20Reentrant is ReserveToken {\n    RedeemableERC20 private redeemableERC20;\n\n    /// Configures the contract to attempt to reenter.\n    constructor() ReserveToken() {}\n\n    /// Set the contract to attempt to reenter.\n    /// @param redeemableERC20_ RedeemableERC20 contract to reeenter.\n    function addReentrantTarget(RedeemableERC20 redeemableERC20_) external {\n        redeemableERC20 = redeemableERC20_;\n    }\n\n    /// @inheritdoc ReserveToken\n    function _beforeTokenTransfer(\n        address sender_,\n        address receiver_,\n        uint256 amount_\n    ) internal virtual override {\n        super._beforeTokenTransfer(sender_, receiver_, amount_);\n        if (sender_ != address(0) && sender_ == address(redeemableERC20)) {\n            IERC20[] memory treasuryAssets_ = new IERC20[](1);\n            treasuryAssets_[0] = IERC20(address(this));\n            // This call MUST fail.\n            redeemableERC20.redeem(treasuryAssets_, amount_);\n        }\n    }\n}\n"
    },
    "contracts/test/ERC20PulleeTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n// solhint-disable-next-line max-line-length\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {RedeemableERC20} from \"../redeemableERC20/RedeemableERC20.sol\";\n\ncontract ERC20PulleeTest {\n    using SafeERC20 for IERC20;\n\n    function approve(\n        address token_,\n        address recipient_,\n        uint256 amount_\n    ) external {\n        IERC20(token_).safeIncreaseAllowance(recipient_, amount_);\n    }\n\n    function transfer(\n        address token_,\n        address recipient_,\n        uint256 amount_\n    ) external {\n        IERC20(token_).transfer(recipient_, amount_);\n    }\n\n    function endDistribution(address token_, address distributor_) external {\n        RedeemableERC20(token_).endDistribution(distributor_);\n    }\n\n    function grantSender(address token_, address sender_) external {\n        RedeemableERC20(token_).grantSender(sender_);\n    }\n\n    function grantReceiver(address token_, address receiver_) external {\n        RedeemableERC20(token_).grantReceiver(receiver_);\n    }\n\n    function redeem(\n        address token_,\n        IERC20[] calldata assets_,\n        uint256 amount_\n    ) external {\n        RedeemableERC20(token_).redeem(assets_, amount_);\n    }\n}\n"
    },
    "contracts/escrow/RedeemableERC20ClaimEscrow.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {RedeemableERC20} from \"../redeemableERC20/RedeemableERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./SaleEscrow.sol\";\n\n/// Escrow contract for ERC20 tokens to be deposited and withdrawn against\n/// redeemableERC20 tokens from a specific `Sale`.\n///\n/// When some token is deposited the running total of that token against the\n/// trust is incremented by the deposited amount. When some `redeemableERC20`\n/// token holder calls `withdraw` they are sent the full balance they have not\n/// previously claimed, multiplied by their fraction of the redeemable token\n/// supply that they currently hold. As redeemable tokens are frozen after\n/// distribution there are no issues with holders manipulating withdrawals by\n/// transferring tokens to claim multiple times.\n///\n/// As redeemable tokens can be burned it is possible for the total supply to\n/// decrease over time, which naively would result in claims being larger\n/// retroactively (prorata increases beyond what can be paid).\n///\n/// For example:\n/// - Alice and Bob hold 50 rTKN each, 100 total supply\n/// - 100 TKN is deposited\n/// - Alice withdraws 50% of 100 TKN => alice holds 50 TKN escrow holds 50 TKN\n/// - Alice burns her 50 rTKN\n/// - Bob attempts to withdraw his 50 rTKN which is now 100% of supply\n/// - Escrow tries to pay 100% of 100 TKN deposited and fails as the escrow\n///   only holds 50 TKN (alice + bob = 150%).\n///\n/// To avoid the escrow allowing more withdrawals than deposits we include the\n/// total rTKN supply in the key of each deposit mapping, and include it in the\n/// emmitted event. Alice and Bob must read the events offchain and make a\n/// withdrawal relative to the rTKN supply as it was at deposit time. Many\n/// deposits can be made under a single rTKN supply and will all combine to a\n/// single withdrawal but deposits made across different supplies will require\n/// multiple withdrawals.\n///\n/// Alice or Bob could burn their tokens before withdrawing and would simply\n/// withdraw zero or only some of the deposited TKN. This hurts them\n/// individually, so they SHOULD check their indexer for claimable assets in\n/// the escrow before considering a burn. But neither of them can cause the\n/// other to be able to withdraw more or less relative to the supply as it was\n/// at the time of TKN being deposited, or to trick the escrow into overpaying\n/// more TKN than was deposited under a given `Sale`.\n///\n/// A griefer could attempt to flood the escrow with many dust deposits under\n/// many different supplies in an attempt to confuse alice/bob. They are free\n/// to filter out events in their indexer that come from an unknown depositor\n/// or fall below some dust value threshold.\n///\n/// Tokens may also exit the escrow as an `undeposit` call where the depositor\n/// receives back the tokens they deposited. As above the depositor must\n/// provide the rTKN supply from `deposit` time in order to `undeposit`.\n///\n/// As `withdraw` and `undeposit` both represent claims on the same tokens they\n/// are mutually exclusive outcomes, hence the need for an escrow. The escrow\n/// will process `withdraw` only if the `Sale` is reporting a complete and\n/// successful raise. Similarly `undeposit` will only return tokens after the\n/// `Sale` completes and reports failure. While the `Sale` is in active\n/// distribution neither `withdraw` or `undeposit` will move tokens. This is\n/// necessary in part because it is only safe to calculate entitlements once\n/// the redeemable tokens are fully distributed and frozen.\n///\n/// Because much of the redeemable token supply will never be sold, and then\n/// burned, `depositPending` MUST be called rather than `deposit` while the\n/// raise is active. When the raise completes anon can call `sweepPending`\n/// which will calculate and emit a `Deposit` event for a useful `supply`.\n///\n/// Any supported ERC20 token can be deposited at any time BUT ONLY under a\n/// `Sale` contract that is the child of the `TrustFactory` that the escrow\n/// is deployed for. `TrustEscrow` is used to prevent a `Sale` from changing\n/// the pass/fail outcome once it is known due to a bug/attempt to double\n/// spend escrow funds.\n///\n/// This mechanism is very similar to the native burn mechanism on\n/// `redeemableERC20` itself under `redeem` but without requiring any tokens to\n/// be burned in the process. Users can claim the same token many times safely,\n/// simply receiving 0 tokens if there is nothing left to claim.\n///\n/// This does NOT support rebase/elastic token _balance_ mechanisms on the\n/// escrowed token as the escrow has no way to track deposits/withdrawals other\n/// than 1:1 conservation of input/output. For example, if 100 tokens are\n/// deposited under two different trusts and then that token rebases all\n/// balances to half, there will be 50 tokens in the escrow but the escrow will\n/// attempt transfers up to 100 tokens between the two trusts. Essentially the\n/// first 50 tokens will send and the next 50 tokens will fail because the\n/// trust literally doesn't have 100 tokens at that point.\n///\n/// Elastic _supply_ tokens are supported as every token to be withdrawn must\n/// be first deposited, with the caveat that if some mechanism can\n/// mint/burn/transfer tokens out from under the escrow contract directly, this\n/// will break internal accounting much like the rebase situation.\n///\n/// Using a real-world example, stETH from LIDO would be NOT be supported as\n/// the balance changes every day to reflect incoming ETH from validators, but\n/// wstETH IS supported as balances remain static while the underlying assets\n/// per unit of wstETH increase each day. This is of course exactly why wstETH\n/// was created in the first place.\n///\n/// Every escrowed token has a separate space in the deposited/withdrawn\n/// mappings so that some broken/malicious/hacked token that leads to incorrect\n/// token movement in/out of the escrow cannot impact other tokens, even for\n/// the same trust and redeemable.\ncontract RedeemableERC20ClaimEscrow is SaleEscrow {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    /// Emitted for every successful pending deposit.\n    /// @param sender Anon `msg.sender` depositing the token.\n    /// @param sale `ISale` contract deposit is under.\n    /// @param redeemable Redeemable token that can claim this deposit.\n    /// Implicitly snapshots the redeemable so malicious `Trust` cannot\n    /// redirect funds later.\n    /// @param token `IERC20` token being deposited.\n    /// @param amount Amount of token deposited.\n    event PendingDeposit(\n        address sender,\n        address sale,\n        address redeemable,\n        address token,\n        uint256 amount\n    );\n\n    /// Emitted every time a pending deposit is swept to a full deposit.\n    /// @param sender Anon `msg.sender` sweeping the deposit.\n    /// @param depositor Anon `msg.sender` who originally deposited the token.\n    /// @param sale `ISale` contract deposit is under.\n    /// @param redeemable Redeemable token first reported by the trust.\n    /// @param token `IERC20` token being swept into a deposit.\n    /// @param amount Amount of token being swept into a deposit.\n    event Sweep(\n        address sender,\n        address depositor,\n        address sale,\n        address redeemable,\n        address token,\n        uint256 amount\n    );\n\n    /// Emitted for every successful deposit.\n    /// @param sender Anon `msg.sender` triggering the deposit.\n    /// MAY NOT be the `depositor` in the case of a pending sweep.\n    /// @param depositor Anon `msg.sender` who originally deposited the token.\n    /// MAY NOT be the current `msg.sender` in the case of a pending sweep.\n    /// @param sale `ISale` contract deposit is under.\n    /// @param redeemable Redeemable token that can claim this deposit.\n    /// @param token `IERC20` token being deposited.\n    /// @param supply rTKN supply at moment of deposit.\n    /// @param amount Amount of token deposited.\n    event Deposit(\n        address sender,\n        address depositor,\n        address sale,\n        address redeemable,\n        address token,\n        uint256 supply,\n        uint256 amount\n    );\n\n    /// Emitted for every successful undeposit.\n    /// @param sender Anon `msg.sender` undepositing the token.\n    /// @param sale `ISale` contract undeposit is from.\n    /// @param redeemable Redeemable token that is being undeposited against.\n    /// @param token `IERC20` token being undeposited.\n    /// @param supply rTKN supply at moment of deposit.\n    /// @param amount Amount of token undeposited.\n    event Undeposit(\n        address sender,\n        address sale,\n        address redeemable,\n        address token,\n        uint256 supply,\n        uint256 amount\n    );\n\n    /// Emitted for every successful withdrawal.\n    /// @param withdrawer Anon `msg.sender` withdrawing the token.\n    /// @param sale `ISale` contract withdrawal is from.\n    /// @param redeemable Redeemable token used to withdraw.\n    /// @param token `IERC20` token being withdrawn.\n    /// @param supply rTKN supply at moment of deposit.\n    /// @param amount Amount of token withdrawn.\n    event Withdraw(\n        address withdrawer,\n        address sale,\n        address redeemable,\n        address token,\n        uint256 supply,\n        uint256 amount\n    );\n\n    /// Every time an address calls `withdraw` their withdrawals increases to\n    /// match the current `totalDeposits` for that trust/token combination.\n    /// The token amount they actually receive is only their prorata share of\n    /// that deposited balance. The prorata scaling calculation happens inline\n    /// within the `withdraw` function.\n    /// trust => withdrawn token =>  rTKN supply => withdrawer => amount\n    // solhint-disable-next-line max-line-length\n    mapping(address => mapping(address => mapping(uint256 => mapping(address => uint256))))\n        internal withdrawals;\n\n    /// Deposits during an active raise are desirable to trustlessly prove to\n    /// raise participants that they will in fact be able to access the TKN\n    /// after the raise succeeds. Deposits during the pending stage are set\n    /// aside with no rTKN supply mapping, to be swept into a real deposit by\n    /// anon once the raise completes.\n    mapping(address => mapping(address => mapping(address => uint256)))\n        internal pendingDeposits;\n\n    /// Every time an address calls `deposit` their deposited trust/token\n    /// combination is increased. If they call `undeposit` when the raise has\n    /// failed they will receive the full amount they deposited back. Every\n    /// depositor must call `undeposit` for themselves.\n    /// trust => deposited token => depositor => rTKN supply => amount\n    // solhint-disable-next-line max-line-length\n    mapping(address => mapping(address => mapping(address => mapping(uint256 => uint256))))\n        internal deposits;\n\n    /// Every time an address calls `deposit` the amount is added to that\n    /// trust/token/supply combination. This increase becomes the\n    /// \"high water mark\" that withdrawals move up to with each `withdraw`\n    /// call.\n    /// trust => deposited token => rTKN supply => amount\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\n        internal totalDeposits;\n\n    /// Redundant tracking of deposits withdrawn.\n    /// Counts aggregate deposits down as users withdraw, while their own\n    /// individual withdrawal counters count up.\n    /// Guards against buggy/malicious redeemable tokens that don't correctly\n    /// freeze their balances, hence opening up double spends.\n    /// trust => deposited token => rTKN supply => amount\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\n        internal remainingDeposits;\n\n    /// Depositor can set aside tokens during pending raise status to be swept\n    /// into a real deposit later.\n    /// The problem with doing a normal deposit while the raise is still active\n    /// is that the `Sale` will burn all unsold tokens when the raise ends. If\n    /// we captured the token supply mid-raise then many deposited TKN would\n    /// be allocated to unsold rTKN. Instead we set aside TKN so that raise\n    /// participants can be sure that they will be claimable upon raise success\n    /// but they remain unbound to any rTKN supply until `sweepPending` is\n    /// called.\n    /// `depositPending` is a one-way function, there is no way to `undeposit`\n    /// until after the raise fails. Strongly recommended that depositors do\n    /// NOT call `depositPending` until raise starts, so they know it will also\n    /// end.\n    /// @param sale_ The `Sale` to assign this deposit to.\n    /// @param token_ The `IERC20` token to deposit to the escrow.\n    /// @param amount_ The amount of token to despoit. Requires depositor has\n    /// approved at least this amount to succeed.\n    function depositPending(\n        address sale_,\n        address token_,\n        uint256 amount_\n    ) external {\n        require(amount_ > 0, \"ZERO_DEPOSIT\");\n        require(escrowStatus(sale_) == EscrowStatus.Pending, \"NOT_PENDING\");\n        pendingDeposits[sale_][token_][msg.sender] += amount_;\n        // Important to snapshot the token from the trust here so it can't be\n        // changed later by the trust.\n        address redeemable_ = token(sale_);\n\n        emit PendingDeposit(msg.sender, sale_, redeemable_, token_, amount_);\n\n        IERC20(token_).safeTransferFrom(msg.sender, address(this), amount_);\n    }\n\n    /// Internal accounting for a deposit.\n    /// Identical for both a direct deposit and sweeping a pending deposit.\n    /// @param sale_ The sale to register a deposit under.\n    /// @param token_ The token being deposited.\n    /// @param depositor_ The depositor address to register the deposit under.\n    /// @param amount_ The size of the deposit denominated in `token_`.\n    function registerDeposit(\n        address sale_,\n        address token_,\n        address depositor_,\n        uint256 amount_\n    ) private {\n        require(escrowStatus(sale_) > EscrowStatus.Pending, \"PENDING\");\n        require(amount_ > 0, \"ZERO_DEPOSIT\");\n\n        address redeemable_ = token(sale_);\n        uint256 supply_ = IERC20(redeemable_).totalSupply();\n        // Zero supply means the escrow is at best useless (no recipients) and\n        // at worst dangerous (tokens trapped behind a divide by zero).\n        require(supply_ > 0, \"ZERO_SUPPLY\");\n\n        deposits[sale_][token_][depositor_][supply_] += amount_;\n        totalDeposits[sale_][token_][supply_] += amount_;\n        remainingDeposits[sale_][token_][supply_] += amount_;\n\n        emit Deposit(\n            msg.sender,\n            depositor_,\n            sale_,\n            redeemable_,\n            token_,\n            supply_,\n            amount_\n        );\n    }\n\n    /// Anon can convert any existing pending deposit to a deposit with known\n    /// rTKN supply once the escrow has moved out of pending status.\n    /// As `sweepPending` is anon callable, raise participants know that the\n    /// depositor cannot later prevent a sweep, and depositor knows that raise\n    /// participants cannot prevent a sweep. As per normal deposits, the output\n    /// of swept tokens depends on success/fail state allowing `undeposit` or\n    /// `withdraw` to be called subsequently.\n    /// Partial sweeps are NOT supported, to avoid griefers splitting a deposit\n    /// across many different `supply_` values.\n    /// @param sale_ The sale to sweep all pending deposits for.\n    /// @param token_ The token to sweep into registered deposits.\n    /// @param depositor_ The depositor to sweep registered deposits under.\n    function sweepPending(\n        address sale_,\n        address token_,\n        address depositor_\n    ) external {\n        uint256 amount_ = pendingDeposits[sale_][token_][depositor_];\n        delete pendingDeposits[sale_][token_][depositor_];\n        emit Sweep(\n            msg.sender,\n            depositor_,\n            sale_,\n            token(sale_),\n            token_,\n            amount_\n        );\n        registerDeposit(sale_, token_, depositor_, amount_);\n    }\n\n    /// Any address can deposit any amount of its own `IERC20` under a `Sale`.\n    /// The `Sale` MUST be a child of the trusted factory.\n    /// The deposit will be accounted for under both the depositor individually\n    /// and the trust in aggregate. The aggregate value is used by `withdraw`\n    /// and the individual value by `undeposit`.\n    /// The depositor is responsible for approving the token for this contract.\n    /// `deposit` is still enabled after the distribution ends; `undeposit` is\n    /// always allowed in case of a fail and disabled on success. Multiple\n    /// `deposit` calls before and after a success result are supported. If a\n    /// depositor deposits when a raise has failed they will need to undeposit\n    /// it again manually.\n    /// Delegated `deposit` is not supported. Every depositor is directly\n    /// responsible for every `deposit`.\n    /// WARNING: As `undeposit` can only be called when the `Sale` reports\n    /// failure, `deposit` should only be called when the caller is sure the\n    /// `Sale` will reach a clear success/fail status. For example, when a\n    /// `Sale` has not yet been seeded it may never even start the raise so\n    /// depositing at this point is dangerous. If the `Sale` never starts the\n    /// raise it will never fail the raise either.\n    /// @param sale_ The `Sale` to assign this deposit to.\n    /// @param token_ The `IERC20` token to deposit to the escrow.\n    /// @param amount_ The amount of token to deposit. Requires depositor has\n    /// approved at least this amount to succeed.\n    function deposit(\n        address sale_,\n        address token_,\n        uint256 amount_\n    ) external {\n        registerDeposit(sale_, token_, msg.sender, amount_);\n        IERC20(token_).safeTransferFrom(msg.sender, address(this), amount_);\n    }\n\n    /// The inverse of `deposit`.\n    /// In the case of a failed distribution the depositors can claim back any\n    /// tokens they deposited in the escrow.\n    /// Ideally the distribution is a success and this does not need to be\n    /// called but it is important that we can walk back deposits and try again\n    /// for some future raise if needed.\n    /// Delegated `undeposit` is not supported, only the depositor can wind\n    /// back their original deposit.\n    /// `amount_` must be non-zero.\n    /// If several tokens have been deposited against a given trust for the\n    /// depositor then each token must be individually undeposited. There is\n    /// no onchain tracking or bulk processing for the depositor, they are\n    /// expected to know what they have previously deposited and if/when to\n    /// process an `undeposit`.\n    /// @param sale_ The `Sale` to undeposit from.\n    /// @param token_ The token to undeposit.\n    /// @param supply_ The total supply of the sale token associated with the\n    /// deposit being undeposited.\n    /// @param amount_ The amount to undeposit.\n    function undeposit(\n        address sale_,\n        address token_,\n        uint256 supply_,\n        uint256 amount_\n    ) external {\n        // Can only undeposit when the `Trust` reports failure.\n        require(escrowStatus(sale_) == EscrowStatus.Fail, \"NOT_FAIL\");\n        require(amount_ > 0, \"ZERO_AMOUNT\");\n\n        deposits[sale_][token_][msg.sender][supply_] -= amount_;\n        // Guard against outputs exceeding inputs.\n        // Last undeposit gets a gas refund.\n        totalDeposits[sale_][token_][supply_] -= amount_;\n        remainingDeposits[sale_][token_][supply_] -= amount_;\n\n        emit Undeposit(\n            msg.sender,\n            sale_,\n            // Include this in the event so that indexer consumers see a\n            // consistent world view even if the trust_ changes its answer\n            // about the redeemable.\n            token(sale_),\n            token_,\n            supply_,\n            amount_\n        );\n\n        IERC20(token_).safeTransfer(msg.sender, amount_);\n    }\n\n    /// The successful handover of a `deposit` to a recipient.\n    /// When a redeemable token distribution is successful the redeemable token\n    /// holders are automatically and immediately eligible to `withdraw` any\n    /// and all tokens previously deposited against the relevant `Sale`.\n    /// The `withdraw` can only happen if/when the relevant `Sale` reaches the\n    /// success distribution status.\n    /// Delegated `withdraw` is NOT supported. Every redeemable token holder is\n    /// directly responsible for being aware of and calling `withdraw`.\n    /// If a redeemable token holder calls `redeem` they also burn their claim\n    /// on any tokens held in escrow so they MUST first call `withdraw` THEN\n    /// `redeem`.\n    /// It is expected that the redeemable token holder knows about the tokens\n    /// that they will be withdrawing. This information is NOT tracked onchain\n    /// or exposed for bulk processing.\n    /// Partial `withdraw` is not supported, all tokens allocated to the caller\n    /// are withdrawn`. 0 amount withdrawal is an error, if the prorata share\n    /// of the token being claimed is small enough to round down to 0 then the\n    /// withdraw will revert.\n    /// Multiple withdrawals across multiple deposits is supported and is\n    /// equivalent to a single withdraw after all relevant deposits.\n    /// @param sale_ The trust to `withdraw` against.\n    /// @param token_ The token to `withdraw`.\n    /// @param supply_ The total supply of the sale token at time of deposit\n    /// to process this withdrawal against.\n    function withdraw(\n        address sale_,\n        address token_,\n        uint256 supply_\n    ) external {\n        // Can only withdraw when the `Trust` reports success.\n        require(escrowStatus(sale_) == EscrowStatus.Success, \"NOT_SUCCESS\");\n\n        uint256 totalDeposited_ = totalDeposits[sale_][token_][supply_];\n        uint256 withdrawn_ = withdrawals[sale_][token_][supply_][msg.sender];\n        withdrawals[sale_][token_][supply_][msg.sender] = totalDeposited_;\n\n        RedeemableERC20 redeemable_ = RedeemableERC20(token(sale_));\n\n        //solhint-disable-next-line max-line-length\n        uint256 amount_ = (// Underflow MUST error here (should not be possible).\n        (totalDeposited_ - withdrawn_) *\n            // prorata share of `msg.sender`'s current balance vs. supply\n            // as at the time deposit was made. If nobody burns they will\n            // all get a share rounded down by integer division. 100 split\n            // 3 ways will be 33 tokens each, leaving 1 TKN as escrow dust,\n            // for example. If someone burns before withdrawing they will\n            // receive less, so 0/33/33 from 100 with 34 TKN as escrow\n            // dust, for example.\n            redeemable_.balanceOf(msg.sender)) / supply_;\n\n        // Guard against outputs exceeding inputs.\n        // For example a malicious `Trust` could report a `redeemable_` token\n        // that does NOT freeze balances. In this case token holders can double\n        // spend their withdrawals by simply shuffling the same token around\n        // between accounts.\n        remainingDeposits[sale_][token_][supply_] -= amount_;\n\n        require(amount_ > 0, \"ZERO_WITHDRAW\");\n        emit Withdraw(\n            msg.sender,\n            sale_,\n            address(redeemable_),\n            token_,\n            supply_,\n            amount_\n        );\n        IERC20(token_).safeTransfer(msg.sender, amount_);\n    }\n}\n"
    },
    "contracts/escrow/SaleEscrow.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../sale/ISale.sol\";\n\n/// Represents the 3 possible statuses an escrow could care about.\n/// Either the escrow takes no action or consistently allows a success/fail\n/// action.\nenum EscrowStatus {\n    /// The underlying `Sale` has not reached a definitive pass/fail state.\n    /// Important this is the first item in the enum as inequality is used to\n    /// check pending vs. pass/fail in security sensitive code.\n    Pending,\n    /// The underlying `Sale` distribution failed.\n    Fail,\n    /// The underlying `Sale` distribution succeeded.\n    Success\n}\n\n/// @title SaleEscrow\n/// An escrow that is designed to work with untrusted `Sale` bytecode.\n/// `escrowStatus` wraps `Sale` functions to guarantee that results do not\n/// change. Reserve and token addresses never change for a given `Sale` and\n/// a pass/fail result is one-way. Even if some bug in the `Sale` causes the\n/// pass/fail status to flip, this will not result in the escrow double\n/// spending or otherwise changing the direction that it sends funds.\ncontract SaleEscrow {\n    /// ISale address => reserve address.\n    mapping(address => address) internal reserves;\n    /// ISale address => token address.\n    mapping(address => address) internal tokens;\n    /// ISale address => status.\n    mapping(address => EscrowStatus) internal escrowStatuses;\n\n    /// Immutable wrapper around `ISale.reserve`.\n    /// Once a `Sale` reports a reserve address the `SaleEscrow` never asks\n    /// again. Prevents a malicious `Sale` from changing the reserve at some\n    /// point to break internal escrow accounting.\n    /// @param sale_ The ISale to fetch reserve for.\n    function reserve(address sale_) internal returns (address) {\n        address reserve_ = reserves[sale_];\n        if (reserve_ == address(0)) {\n            address saleReserve_ = address(ISale(sale_).reserve());\n            require(saleReserve_ != address(0), \"0_RESERVE\");\n            reserves[sale_] = saleReserve_;\n            reserve_ = saleReserve_;\n        }\n        return reserve_;\n    }\n\n    /// Immutable wrapper around `ISale.token`.\n    /// Once a `Sale` reports a token address the `SaleEscrow` never asks\n    /// again. Prevents a malicious `Sale` from changing the token at some\n    /// point to divert escrow payments after assets have already been set\n    /// aside.\n    /// @param sale_ The ISale to fetch token for.\n    function token(address sale_) internal returns (address) {\n        address token_ = tokens[sale_];\n        if (token_ == address(0)) {\n            address saleToken_ = address(ISale(sale_).token());\n            require(saleToken_ != address(0), \"0_TOKEN\");\n            tokens[sale_] = saleToken_;\n            token_ = saleToken_;\n        }\n        return token_;\n    }\n\n    /// Read the one-way, one-time transition from pending to success/fail.\n    /// We never change our opinion of a success/fail outcome.\n    /// If a buggy/malicious `ISale` somehow changes success/fail state then\n    /// that is obviously bad as the escrow will release funds in the wrong\n    /// direction. But if we were to change our opinion that would be worse as\n    /// claims/refunds could potentially be \"double spent\" somehow.\n    /// @param sale_ The sale to get the escrow status for.\n    function escrowStatus(address sale_) internal returns (EscrowStatus) {\n        EscrowStatus escrowStatus_ = escrowStatuses[sale_];\n        // Short circuit and ignore the `ISale` if we previously saved a value.\n        if (escrowStatus_ > EscrowStatus.Pending) {\n            return escrowStatus_;\n        }\n        // We have never seen a success/fail outcome so need to ask the `ISale`\n        // for the distribution status.\n        else {\n            SaleStatus saleStatus_ = ISale(sale_).saleStatus();\n            // Success maps to success.\n            if (saleStatus_ == SaleStatus.Success) {\n                escrowStatuses[sale_] = EscrowStatus.Success;\n                return EscrowStatus.Success;\n            }\n            // Fail maps to fail.\n            else if (saleStatus_ == SaleStatus.Fail) {\n                escrowStatuses[sale_] = EscrowStatus.Fail;\n                return EscrowStatus.Fail;\n            }\n            // Everything else is still pending.\n            else {\n                return EscrowStatus.Pending;\n            }\n        }\n    }\n}\n"
    },
    "contracts/test/wrappers/RedeemableERC20ClaimEscrowWrapper.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n//solhint-disable-next-line max-line-length\nimport {RedeemableERC20ClaimEscrow} from \"../../escrow/RedeemableERC20ClaimEscrow.sol\";\n\n/// @title RedeemableERC20ClaimEscrowWrapper\n/// Thin wrapper around the `RedeemableERC20ClaimEscrow` contract with\n/// accessors to facilitate hardhat unit testing of `internal` variables.\ncontract RedeemableERC20ClaimEscrowWrapper is RedeemableERC20ClaimEscrow {\n    function getWithdrawals(\n        address trust_,\n        address token_,\n        uint256 supply_,\n        address withdrawer_\n    ) external view returns (uint256) {\n        return withdrawals[trust_][token_][supply_][withdrawer_];\n    }\n\n    function getPendingDeposits(\n        address trust_,\n        address token_,\n        address depositor_\n    ) external view returns (uint256) {\n        return pendingDeposits[trust_][token_][depositor_];\n    }\n\n    function getDeposits(\n        address trust_,\n        address token_,\n        address depositor_,\n        uint256 supply_\n    ) external view returns (uint256) {\n        return deposits[trust_][token_][depositor_][supply_];\n    }\n\n    function getTotalDeposits(\n        address trust_,\n        address token_,\n        uint256 supply_\n    ) external view returns (uint256) {\n        return totalDeposits[trust_][token_][supply_];\n    }\n}\n"
    },
    "contracts/test/wrappers/SaleEscrowWrapper.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\nimport {SaleEscrow, EscrowStatus} from \"../../escrow/SaleEscrow.sol\";\n\n/// @title SaleEscrowWrapper\n/// Thin wrapper around the `SaleEscrow` contract with\n/// accessors to facilitate hardhat unit testing of `internal` functions\n/// and variables.\ncontract SaleEscrowWrapper is SaleEscrow {\n    function getReserve(address sale_) external view returns (address) {\n        return reserves[sale_];\n    }\n\n    function getToken(address sale_) external view returns (address) {\n        return tokens[sale_];\n    }\n\n    function getEscrowStatus(address sale_)\n        external\n        view\n        returns (EscrowStatus)\n    {\n        return escrowStatuses[sale_];\n    }\n\n    function fetchReserve(address sale_) external {\n        reserve(sale_);\n    }\n\n    function fetchToken(address sale_) external {\n        token(sale_);\n    }\n\n    function fetchEscrowStatus(address sale_) external {\n        escrowStatus(sale_);\n    }\n}\n"
    },
    "contracts/test/MockISale.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../sale/ISale.sol\";\n\ncontract MockISale is ISale {\n    address public _reserve;\n    SaleStatus public _saleStatus;\n    address public _token;\n\n    function setReserve(address reserve_) external {\n        _reserve = reserve_;\n    }\n\n    function setSaleStatus(SaleStatus saleStatus_) external {\n        _saleStatus = saleStatus_;\n    }\n\n    function setToken(address token_) external {\n        _token = token_;\n    }\n\n    function reserve() external view returns (address) {\n        return _reserve;\n    }\n\n    function saleStatus() external view returns (SaleStatus) {\n        return _saleStatus;\n    }\n\n    function token() external view returns (address) {\n        return _token;\n    }\n}\n"
    },
    "contracts/test/SaturatingMathTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity 0.8.10;\n\nimport {SaturatingMath} from \"../math/SaturatingMath.sol\";\n\n/// @title SaturatingMathTest\n/// Thin wrapper around the `SaturatingMath` library for hardhat unit testing.\ncontract SaturatingMathTest {\n    /// Wraps `SaturatingMath.saturatingAdd`.\n    /// Saturating addition.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return Minimum of a_ + b_ and max uint256.\n    function saturatingAdd(uint256 a_, uint256 b_)\n        external\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            return SaturatingMath.saturatingAdd(a_, b_);\n        }\n    }\n\n    /// Wraps `SaturatingMath.saturatingSub`.\n    /// Saturating subtraction.\n    /// @param a_ Minuend.\n    /// @param b_ Subtrahend.\n    /// @return a_ - b_ if a_ greater than b_, else 0.\n    function saturatingSub(uint256 a_, uint256 b_)\n        external\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            return SaturatingMath.saturatingSub(a_, b_);\n        }\n    }\n\n    /// Wraps `SaturatingMath.saturatingMul`.\n    /// Saturating multiplication.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return Minimum of a_ * b_ and max uint256.\n    function saturatingMul(uint256 a_, uint256 b_)\n        external\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            return SaturatingMath.saturatingMul(a_, b_);\n        }\n    }\n}\n"
    },
    "contracts/test/ReserveTokenERC20Snapshot.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\";\n\n/// @title ReserveTokenERC20Snapshot\n/// A test token that can be used as a reserve asset.\n/// On mainnet this would likely be some brand of stablecoin but can be\n/// anything.\n/// Notably mimics 6 decimals commonly used by stables in production.\ncontract ReserveTokenERC20Snapshot is ERC20Snapshot {\n    // Stables such as USDT and USDC commonly have 6 decimals.\n    uint256 public constant DECIMALS = 6;\n    // One _billion_ dollars 👷😈.\n    uint256 public constant TOTAL_SUPPLY = 10**(DECIMALS + 9);\n\n    /// Define and mint the erc20 token.\n    constructor() ERC20(\"USD Classic\", \"USDCC\") {\n        _mint(msg.sender, TOTAL_SUPPLY);\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return uint8(DECIMALS);\n    }\n\n    /// Take a snapshot of the current balances and total supply.\n    function snapshot() external {\n        _snapshot();\n    }\n}\n"
    },
    "contracts/test/phased/PhasedTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Phased} from \"../../phased/Phased.sol\";\n\n/// @title PhasedTest\n/// Empty contract for tests enumerating behaviour of the `Phased` modifiers.\ncontract PhasedTest is Phased {\n    bool public condition = true;\n\n    constructor() {\n        initializePhased();\n    }\n\n    /// Exposes `schedulePhase` for testing.\n    /// @param timestamp_ As per `schedulePhase`.\n    function testScheduleNextPhase(uint256 timestamp_) external {\n        require(condition, \"CONDITION\");\n        schedulePhase(currentPhase() + 1, timestamp_);\n    }\n\n    /// This function wraps `onlyPhase` modifier, passing phase directly into\n    /// modifier argument.\n    /// @param phase_ Modifier MUST error if current phase is not `phase_`.\n    /// @return Always true if not error.\n    function runsOnlyPhase(uint256 phase_)\n        external\n        view\n        onlyPhase(phase_)\n        returns (bool)\n    {\n        return true;\n    }\n\n    /// This function wraps `onlyAtLeastPhase` modifier, passing phase directly\n    /// into modifier argument.\n    /// @param phase_ Modifier MUST error if current phase is not AT LEAST\n    /// `phase_`.\n    /// @return Always true if not error.\n    function runsOnlyAtLeastPhase(uint256 phase_)\n        external\n        view\n        onlyAtLeastPhase(phase_)\n        returns (bool)\n    {\n        return true;\n    }\n\n    /// Toggles `condition` for testing phase scheduling hook.\n    function toggleCondition() external {\n        condition = !condition;\n    }\n}\n"
    },
    "contracts/test/phased/PhasedScheduleTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {Phased} from \"../../phased/Phased.sol\";\n\n/// @title PhasedScheduleTest\n/// Contract for testing phase hook functionality.\ncontract PhasedScheduleTest is Phased {\n    constructor() {\n        initializePhased();\n    }\n\n    /// Exposes `schedulePhase` for testing.\n    function testScheduleNextPhase() external {\n        uint256 initialPhase_ = currentPhase();\n\n        succeedsOnlyPhase(initialPhase_);\n        schedulePhase(initialPhase_ + 1, block.timestamp);\n        succeedsOnlyPhase(initialPhase_ + 1);\n    }\n\n    /// Exposes `onlyPhase` for testing.\n    /// @param phase_ As per `onlyPhase`.\n    function succeedsOnlyPhase(uint256 phase_) internal onlyPhase(phase_) {}\n}\n"
    },
    "contracts/dance/SeedDance.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../math/FixedPointMath.sol\";\n\n/// Represents a minimum and maximum duration for the dance in a structure that\n/// can fit in a single slot. uint32 representation for timestamps is inline\n/// with the rest of the rain protocol.\n/// @param baseDuration Every participant will be able to reveal for at least\n/// this amount of seconds after the start of the dance.\n/// @param maxExtraTime The theoretical maximum number of additional seconds\n/// above the baseDuration that an individual participant may reveal during. In\n/// practical terms the seed is reallocating extra time randomly on this range\n/// every time anyone reveals, so it is very unlikely that a given participant\n/// will be able to utilise this maximum extra time.\nstruct TimeBound {\n    uint32 baseDuration;\n    uint32 maxExtraTime;\n}\n\ntype Seed is uint256;\ntype Secret is uint256;\ntype Commitment is uint256;\n\nlibrary LibSeed {\n    /// Generates a new unpredictable, cryptographic strength seed by hashing\n    /// an existing seed with some value. All values used to build the new seed\n    /// are equally valid due to hashing guarantees but of course same seed and\n    /// value will give the same output. That is to say, `with` is entirely\n    /// deterministic for any given inputs. In this context \"unpredictable\"\n    /// means, \"unpredictable provided you don't know both seed and val\".\n    /// @param seed_ An existing seed.\n    /// @param val_ Can be literally any uint as the hashing will ensure the\n    /// returned seed is unpredictable.\n    /// @return newSeed_ The result of applying `val_` to `seed_`.\n    function with(Seed seed_, uint256 val_)\n        internal\n        pure\n        returns (Seed newSeed_)\n    {\n        newSeed_ = Seed.wrap(uint256(keccak256(abi.encodePacked(seed_, val_))));\n    }\n}\n\nlibrary LibCommitment {\n    /// Equality check for commitments.\n    /// @param a_ First commitment to compare.\n    /// @param b_ Second commitment to compare.\n    /// @return eq_ True if a_ equals b_, else false.\n    function eq(Commitment a_, Commitment b_) internal pure returns (bool eq_) {\n        eq_ = Commitment.unwrap(a_) == Commitment.unwrap(b_);\n    }\n\n    /// Build the commitment for a secret.\n    /// Standard commitment build is by hashing the secret as bytes.\n    /// DO NOT EXPOSE THIS ONCHAIN. Replicate the functionality offchain so it\n    /// can and WILL be run locally to the secret generation process.\n    /// It is far too difficult to ensure that secrets will stay secret if\n    /// users are expected to be forwarding them around to RPCs etc. just to\n    /// find the value of their commitments.\n    /// DO NOT SEND SECRETS ANYWHERE, LEAVE THEM WHERE YOU MADE THEM.\n    /// DO NOT REUSE SECRETS, GENERATE A NEW ONE FOR EVERY COMMITMENT.\n    /// Of course, you MAY send a secret if and only if it is being revealed as\n    /// part of a dance.\n    function fromSecret(Secret secret_)\n        internal\n        pure\n        returns (Commitment commitment_)\n    {\n        commitment_ = Commitment.wrap(\n            uint256(keccak256(abi.encodePacked(secret_)))\n        );\n    }\n\n    /// The zero valued commitment.\n    /// No secret can match this commitment, or at least probably nobody knows\n    /// the secret that does match this commitment.\n    /// @return zero_ Zero valued commitment.\n    function zero() internal pure returns (Commitment zero_) {\n        zero_ = Commitment.wrap(0);\n    }\n}\n\n/// @title SeedDance\n/// @notice A multiparty commit/reveal scheme designed to generate a shared\n/// seed that impacts involved parties directly. For example, generating the\n/// seed for a lottery/shuffle mechanic that maps NFT IDs to their metadata.\n///\n/// SeedDance does NOT implement any access or integrity checks (e.g. to ensure\n/// that the correct `TimeBound` is passed to `_reveal`) as it is unopinionated\n/// as to how inheriting contracts expose the dance to end users. Therefore it\n/// is insecure by default, until the implementing contract carefully defines\n/// participants and time bounds.\n///\n/// Assuming that interactive seed generation is an acceptible UX/workflow, the\n/// main problem with commit/reveal schemes such as this is the \"last actor\"\n/// weakness. Whoever is the last party to reveal the secret can see every\n/// prior reveal, and knows the outcome of revealing their secret, so has an\n/// outsized degree of control over the final result. The last actor can choose\n/// if (can simply refuse to reveal) and when (dangerous if able to collude\n/// with minter to manipulate results) they reveal.\n///\n/// Common mitigation strategies involve rewards for revealing and punishments\n/// for not revealing. SeedDance makes some assumptions about how the seed is\n/// to be generated and used, allowing it to focus on _fairness_ of outcome\n/// rather than trying to avoid there being a last actor.\n///\n/// There WILL always be some last actor in every seed dance, but:\n/// - Nobody can predict who the last actor is ahead of time\n/// - It is difficult to predict who the last actor will be _during_ the dance\n/// - Everyone is equally likely to be in the position of last actor\n/// - Everyone chooses for themselves if/when to act, the order is not preset\n/// - Anyone who can currently reveal during the dance may randomise all other\n///   actor's ability to act\n///\n/// This is achieved by granting every address a random (up to a maximum)\n/// additional duration during which they may reveal their secret. Only the\n/// commiter of a secret may reveal it and have the shared secret updated, so\n/// we can restrict the time window during which each agent may meaningfully\n/// reveal the secret. Of course an agent may reveal a secret in a failed\n/// transaction and then everyone will be able to see it, but it won't change\n/// the seed. Every time a secret is revealed, it randomises everyone's time\n/// windows, thus implicitly changing who MAY be the last actor. This random\n/// shuffling MAY remove someone's ability to reveal that they previously had,\n/// or grant the ability to reveal to someone who had previously timed out.\n/// This mitigates the ability to manipulate the system by trying to be the\n/// last actor in the following ways:\n/// - The current last actor has only 1/N chance of being the last actor after\n///   each reveal\n/// - The longer the current last actor waits to reveal, the more likely it is\n///   they will lose the ability to reveal at all the next time their window is\n///   randomised, as they MAY be randomised to a time in the past\n/// - The longer any actor waits to reveal, the more likely they are to be\n///   front run on their reveal and have the subsequent shuffle rollback their\n///   attempt to reveal (because other agents know their own secret and can see\n///   the reveal in the mempool before it exists onchain)\n/// - As the reveal times are frequently being shuffled it is much more\n///   difficult for an agent to manipulate or censor a single or several blocks\n///   as/with a miner/validator to manipulate the overall outcome of the dance\n///\n/// Note that as the secret is broadcast to the mempool as soon as reveal is\n/// called, all other participants MAY front run the reveal in an attempt to\n/// grief that reveal. Similarly miners can reorg or exclude any\n/// reveal within a single block arbitrarily. While this likely will\n/// disadvantage the greifee it will still result in at least one global reseed\n/// and the greifer will consume their secret and commitment in the process.\n/// Subsequently some other seeder MAY roll the seed again in a way that\n/// allows the griefee access to the dance once more, but the griefer will have\n/// used their secret and so cannot attack a second time.\n///\n/// It is entirely that cartels form attempting to reseed the dance in their\n/// favour. In this case the best defense is a statistical one, for example an\n/// NFT project can engineer their rarities such that a large cartel implies a\n/// large sample size, so each reseed becomes increasingly boring as the cartel\n/// grows, thus undermining the advantage of having a cartel in the first place.\n/// This can work as statistically the chance of achieving an average outcome\n/// increases as the number of samples (members of the cartel) increases.\n///\n/// However, a griefing cartel MAY form with the sole goal to prevent a single\n/// or small number of addresses from acheiving a desirable outcome. In this\n/// case the attack MAY succeed if the cartel represents a large percentage of\n/// the dancers, but it still only requires a single reseed after the cartel\n/// performs its actions to completely negate all cartel actions. There is no\n/// specific defense against this kind of attack, other than to hope the chaos\n/// of the dance thwarts the cartel in the moment. One must ask why a cartel\n/// would form (which involves e.g. mass minting/buying NFTs) in the first\n/// place merely to perform a DOS style attack on a single wallet. It MAY\n/// happen sometime, but we expect it is unlikely to be a common occurance.\n///\n/// As there are no external or financial incentives required by the system,\n/// the dance instead relies on \"skin in the game\". The addresses that are\n/// allowed to commit secrets before the dance should only be those that are\n/// DIRECTLY impacted by the outcome of the final seed. For example, in the NFT\n/// mint/reveal workflow the dancers should be restricted to those addresses\n/// that bought/minted NFT IDs and so are impacted by the metadata assignment.\n/// By disallowing unaffected third parties it helps minimise the participation\n/// of wallets who simply want to grief some address with no cost (besides gas)\n/// to themselves.\n///\n/// Of course, as with all commit/reveal schemes, the secrets must be commited\n/// before the dance starts and the reveal will fail if the secret provided\n/// does not match the commitment. This prevents trivial manipulation of the\n/// outcome by \"revealing\" arbitrary secrets designed to benefit the revealer.\n///\n/// The dance starts when `_start` is called. This is an internal function that\n/// will fail if called more than once, but has no access controls by default.\n/// There is no explicit end to the dance. The dance is complete when no more\n/// agents will reveal their secret. This can only be observed once either all\n/// secrets are revealed or all times have expired, but it MAY be effectively\n/// true but impossible to measure when all parties are satisfied with the\n/// outcome of the dance and so will choose not to reveal.\n///\n/// There is no requirement that everyone reveals their secrets and the choice\n/// of initial seed is almost arbitrary. A block hash or similar can be used\n/// as all participants may immediately reseed any initial seed that they are\n/// not satisfied with. Even if a miner were to manipulate the starting seed it\n/// would be very likely to be hashed into something else that the miner cannot\n/// control or predict.\ncontract SeedDance {\n    using FixedPointMath for uint256;\n    using LibCommitment for Commitment;\n\n    /// The dance has started.\n    /// @param sender `msg.sender` that started the dance.\n    /// @param initialSeed The initial seed for the dance.\n    event Start(address sender, Seed initialSeed);\n\n    /// A new commitment is made.\n    /// @param sender `msg.sender` that is committing a secret.\n    /// @param commitment The cryptographic commitment (hash) for the secret.\n    event Commit(address sender, Commitment commitment);\n\n    /// A secret has been revealed.\n    /// @param sender `msg.sender` that has revealed their secret.\n    /// @param secret The secret that was successfully revealed\n    /// i.e. it matched the commitment within the time bounds.\n    /// @param newSeed The new shared seed resulting from hashing the revealed\n    /// secret with the old shared seed.\n    event Reveal(address sender, Secret secret, Seed newSeed);\n\n    /// The current shared seed that embodies all current revealed secrets from\n    /// the dance. Will be initialized when `_start` is called and zero before.\n    Seed internal _sharedSeed;\n\n    /// The timestamp the dance was started at. Will be 0 before the dance has\n    /// started.\n    uint32 private _startedAt;\n\n    /// All AVAILABLE commitments from all addresses who called `_commit`.\n    /// Each commitment is DELETED from storage when the owner calls `_reveal`.\n    /// owner => secret\n    mapping(address => Commitment) private _commitments;\n\n    /// Require this function to only be callable before the dance has started.\n    modifier onlyNotStarted() {\n        if (_startedAt > 0) {\n            require(block.timestamp < _startedAt, \"STARTED\");\n        }\n        _;\n    }\n\n    /// Start the dance. Can only happen once.\n    /// Has no access control so the implementing contract must safeguard the\n    /// workflow and decide when to start.\n    /// @param initialSeed_ The seed to start the dance with. Either all\n    /// dancers will be satisfied and do nothing or it will be quickly hashed\n    /// into oblivion during the dance.\n    function _start(Seed initialSeed_) internal onlyNotStarted {\n        // Initialize the dance.\n        _startedAt = uint32(block.timestamp);\n        _sharedSeed = initialSeed_;\n\n        // Tell the world.\n        emit Start(msg.sender, initialSeed_);\n    }\n\n    /// Before the dance starts anyone can commit a secret.\n    /// Has no access control so if committers is to be a closed set it must be\n    /// enforced by the implementing contract. The implementing contract SHOULD\n    /// ensure that only users with \"skin in the game\" can commit secrets, to\n    /// mitigate griefing strategies where sybils endlessly reseed at no cost\n    /// to themselves.\n    /// Users are free to commit as many times as they like prior to the dance\n    /// starting, which will overwrite previous commitments rending them\n    /// unusable during the dance. Once the dance starts no further additions\n    /// or changes to commitments can be made.\n    /// @param commitment_ The commitment (hash) for the secret that only\n    /// `msg.sender` knows. MUST match the secret or the subsequent reveal will\n    /// fail.\n    function _commit(Commitment commitment_) internal onlyNotStarted {\n        // Store the commitment over whatever was there before.\n        _commitments[msg.sender] = commitment_;\n\n        // Tell the world.\n        emit Commit(msg.sender, commitment_);\n    }\n\n    /// `msg.sender` reveals a valid secret, changing the shared seed and\n    /// consuming their commitment. To successfully reveal the sender MUST\n    /// complete the reveal within their personal time as defined by the\n    /// provided time bounds and current shared seed.\n    /// The implementing contract MUST ensure the validity of the time bounds\n    /// being passed in and any additional access controls for reveals.\n    /// Each secret can only be revealed once as the commitment will be deleted\n    /// after the first reveal per-secret.\n    /// Users can ONLY reveal their own commitments BUT their secret will be\n    /// publicly visible as soon as the transaction hits the mempool, so they\n    /// SHOULD NOT attempt a reveal if they believe the transaction will fail,\n    /// including due to being front run by other reveals reshuffling times.\n    /// @param timeBound_ The time bounds to check for the reveal. These are\n    /// NOT checked for validity so the caller MUST NOT trust user provided\n    /// bounds without verifying them.\n    /// @param secret_ The secret revealed by the user. MUST be revealed\n    /// within the user's personal time and match their prior commitment. MUST\n    /// be 32 bytes as we want to discourage predictable secrets and\n    /// unnecessarily long secrets.\n    function _reveal(TimeBound memory timeBound_, Secret secret_) internal {\n        // Enforce individual time constraints.\n        require(\n            block.timestamp <=\n                canRevealUntil(_sharedSeed, _startedAt, timeBound_, msg.sender),\n            \"CANT_REVEAL\"\n        );\n\n        // This will fail if the commitment was already consumed, we don't\n        // need an additional check for that case.\n        require(\n            _commitments[msg.sender].eq(LibCommitment.fromSecret(secret_)),\n            \"BAD_SECRET\"\n        );\n        // Clear out commitment so it can't be used again for the same seed.\n        // Also a lil' gas refund.\n        _commitments[msg.sender] = LibCommitment.zero();\n\n        // Build the new shared seed.\n        Seed newSeed_ = LibSeed.with(_sharedSeed, Secret.unwrap(secret_));\n        _sharedSeed = newSeed_;\n\n        // Notify the world.\n        emit Reveal(msg.sender, secret_, newSeed_);\n    }\n\n    /// Every owner can reveal until some time but this time is different for\n    /// every owner, and is reshuffled for every new shared secret.\n    /// @param seed_ The seed to calculate the final timestamp from. Will be\n    /// the shared seed when called from within `_reveal`.\n    /// @param start_ The start timestamp to calculate the final timestamp\n    /// relative to. Will be `_startedAt` when called from within `_reveal`. If\n    /// start_ is 0 then the returned `until_` will always be 0.\n    /// @param timeBound_ The time bounds to check for the hypothetical reveal.\n    /// This is not checked for validity so it is the responsibility of the\n    /// caller to ensure the bounds are correct or the return value will be\n    /// incorrect.\n    /// @param owner_ Owner of the secret that would hypothetically be revealed.\n    /// @return until_ The last second that the the owner can reveal, given all\n    /// the above parameters. Note that in real usage the above parameters can\n    /// change very quickly and unpredictably, including multiple times in a\n    /// single block. Even if a user checks their reveal time before calling\n    /// `_reveal`, they MAY be front run by another reveal that negates their\n    /// ability to reveal, potentially permanently. If `start_` is 0 then the\n    /// returned `until_` will always be 0.\n    function canRevealUntil(\n        Seed seed_,\n        uint256 start_,\n        TimeBound memory timeBound_,\n        address owner_\n    ) public pure returns (uint256 until_) {\n        unchecked {\n            // Default is to just return 0.\n            until_ = start_;\n\n            // If it isn't 0 then we've started so add the relevant duration.\n            if (until_ > 0) {\n                // Technically this means the duration will be [0, extra)\n                // rather than (0, extra] because of the % but let's assume\n                // nobody cares about the missing second enough to pay the gas\n                // to calculate it.\n                uint256 ownerExtraTime_ = Seed.unwrap(\n                    LibSeed.with(seed_, uint256(uint160(owner_)))\n                ) % timeBound_.maxExtraTime;\n                until_ += timeBound_.baseDuration + ownerExtraTime_;\n            }\n        }\n    }\n}\n"
    },
    "contracts/test/wrappers/SeedDanceTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\nimport {SeedDance, Seed, Commitment, TimeBound, Secret} from \"../../dance/SeedDance.sol\";\n\n/// @title SeedDanceTest\n/// Thin wrapper around the `SeedDance` contract to expose internal functions\n/// for testing\ncontract SeedDanceTest is SeedDance {\n    function sharedSeed() external view returns (Seed) {\n        return _sharedSeed;\n    }\n\n    function start(Seed initialSeed_) external {\n        _start(initialSeed_);\n    }\n\n    function commit(Commitment commitment_) external {\n        _commit(commitment_);\n    }\n\n    function reveal(TimeBound memory timeBound_, Secret secret_) external {\n        _reveal(timeBound_, secret_);\n    }\n}\n"
    },
    "contracts/test/wrappers/LibSeedTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\nimport {LibSeed, Seed} from \"../../dance/SeedDance.sol\";\n\n/// @title LibSeedTest\n/// Thin wrapper around the `LibSeed` library\ncontract LibSeedTest {\n    function with(Seed seed_, uint256 val_)\n        external\n        pure\n        returns (Seed newSeed_)\n    {\n        newSeed_ = LibSeed.with(seed_, val_);\n    }\n}\n"
    },
    "contracts/test/wrappers/LibCommitmentTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\nimport {LibCommitment, Commitment, Secret} from \"../../dance/SeedDance.sol\";\n\n/// @title LibCommitmentTest\n/// Thin wrapper around the `LibCommitment` library\ncontract LibCommitmentTest {\n    function eq(Commitment a_, Commitment b_) external pure returns (bool eq_) {\n        eq_ = LibCommitment.eq(a_, b_);\n    }\n\n    function fromSecret(Secret secret_)\n        external\n        pure\n        returns (Commitment commitment_)\n    {\n        commitment_ = LibCommitment.fromSecret(secret_);\n    }\n\n    function zero() external pure returns (Commitment zero_) {\n        zero_ = LibCommitment.zero();\n    }\n}\n"
    },
    "contracts/test/RandomTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../math/Random.sol\";\nimport \"../sstore2/SSTORE2.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract RandomTest {\n    address public shuffled;\n\n    uint256 private val;\n\n    function microLottery(\n        uint256 seed_,\n        uint256 max_,\n        uint256 n_\n    ) external pure returns (uint256 item_) {\n        // uint256 a_ = gasleft();\n        item_ = Random.microLottery(seed_, max_, n_);\n        // uint256 b_ = gasleft();\n        // console.log(\"microLottery gas used: %s\", a_ - b_);\n    }\n\n    function shuffle(uint256 seed_, uint256 len_)\n        external\n        returns (bytes memory shuffled_)\n    {\n        uint256 a_ = gasleft();\n        shuffled_ = Random.shuffle(seed_, len_);\n        uint256 b_ = gasleft();\n        console.log(\n            \"shuffle gas used: %s %s %s\",\n            len_,\n            a_ - b_,\n            (a_ - b_) / len_\n        );\n        require(\n            uint256(\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000\n            ) == uint256(~uint256(0xFFFF)),\n            \"BADBAD\"\n        );\n        a_ = gasleft();\n        shuffled = SSTORE2.write(shuffled_);\n        b_ = gasleft();\n        console.log(\"storage gas used: %s\", a_ - b_);\n    }\n\n    function shuffleIdAtIndex(uint256 index_) external returns (uint256 id_) {\n        // Write something so we can see gas costs.\n        val = 1;\n        uint256 a_ = gasleft();\n        address shuffled_ = shuffled;\n\n        id_ = Random.shuffleIdAtIndex(shuffled_, index_);\n        uint256 b_ = gasleft();\n        console.log(\"shuffle id: %s\", id_);\n        console.log(\"shuffle index gas: %s\", a_ - b_);\n\n        uint index2_ = index_+1;\n        a_ = gasleft();\n        Random.shuffleIdAtIndex(shuffled_, index2_);\n        b_ = gasleft();\n        console.log(\"shuffle index gas 2: %s\", a_ - b_);\n    }\n\n    function randomId(uint256 seed_, uint256 index_)\n        external\n        returns (uint256 id_)\n    {\n        // write something so we can see gas costs.\n        val = 2;\n\n        uint256 a_ = gasleft();\n        id_ = Random.randomId(seed_, index_);\n        uint256 b_ = gasleft();\n\n        console.log(\"random id: %s\", id_);\n        console.log(\"random gas: %s\", a_ - b_);\n    }\n}\n"
    },
    "contracts/math/Random.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"../sstore2/SSTORE2.sol\";\n\nlibrary Random {\n    /// Implements a fisher yates algorithm to report a single result\n    /// of a shuffle at position `n_` out of `max_`.\n    ///\n    /// Optimizations:\n    /// - We leave the initial allocation of the array as 0 values and use the\n    ///   index of the internal shuffle iterations as the values to write. This\n    ///   avoids an additional initial O(n) operation to prepopulate the array,\n    ///   it also means we only support sequential arrays from [0,max].\n    /// - We don't read or write the values that we draw from the side of the\n    ///   swap that can't possibly be subsequently written to `n_`.\n    /// - We stop processing the shuffle as soon as we know the value for `n_`.\n    ///\n    /// Each index is represented as a single byte so the micro lottery values\n    /// cannot exceed `type(uint8).max`.\n    ///\n    /// Gas cost is `~230 * (max_ - n_)` so it is `O(n)` but lower ID values\n    /// will pay more gas due to the lazy calculation of higher IDs. Worst case\n    /// gas cost for the largest possible micro lottery and ID 0 is therefore\n    /// about ~60 000 gas. Note however that memory expansion costs in the evm\n    /// are non-linear past ~720 bytes, so if a function call is shuffling\n    /// AND using other memory, it may incur substantial costs above the base\n    /// cost due to the allocation of bytes needed to calculate the shuffle.\n    /// The shuffle algorithm needs to allocate 1 byte for each ID + 32 bytes\n    /// for the length slot of the bytes array.\n    ///\n    /// One possible NFT minting workflow for the microLottery:\n    /// - All metadata is revealed publicly before the onchain process\n    /// - Users reserve a sequential ID for themselves\n    /// - A seed is generated somehow, e.g. \"rain dance\"\n    /// - Users mint an NFT for themselves where the NFT ID is the output of\n    ///   their reserved ID as `n_` and everyone uses the same seed\n    ///\n    /// Using the above workflow, users pay the gas cost for their own ID\n    /// shuffling, which is potentially more decentralised than a single user\n    /// being responsible for shuffling. OTOH the total gas cost across all\n    /// users is likely much higher than a single shuffle because every user\n    /// must calculate _their_ shuffle, which includes all higher ID shuffles.\n    /// This is simply how fisher yates works, and seems unavoidable without\n    /// finding a different shuffle algorithm.\n    ///\n    /// Note that lottery uses a simple `%` to select a random index from the\n    /// 32 byte keccak output. This will introduce some \"small\" module bias,\n    /// which is likely negligible in the context of e.g. assigning NFT metadata\n    /// but could easily be enough bias to break cryptographic systems. DO NOT\n    /// use lottery as a component in cryptographic systems.\n    ///\n    /// One benefit of the micro lottery approach is that it can be exposed by\n    /// the implementing contract as a \"preview\" public function, where it can\n    /// be called offchain to inspect any ID for any seed without paying gas.\n    function microLottery(\n        uint256 seed_,\n        uint256 max_,\n        uint256 n_\n    ) internal pure returns (uint256 item_) {\n        unchecked {\n            require(n_ < max_, \"MAX_N\");\n            require(max_ <= type(uint8).max, \"MAX_MAX\");\n            bytes memory array_ = new bytes(max_);\n            assembly {\n                // Select a random index [0, j_] using the hash of the\n                // current value in scratch memory as source of randomness.\n                function randomIndex(j_) -> v_ {\n                    // roll the dice by hashing the scratch.\n                    let roll_ := keccak256(0, 0x20)\n                    // store the roll in scratch so it seeds the next roll.\n                    mstore(0, roll_)\n                    // mod will return every multiple of j_ as 0 so if we want\n                    // the range of possible values to include both 0 and j_ we\n                    // need to mod on j + 1.\n                    v_ := mod(roll_, add(j_, 1))\n                }\n\n                // Read the item relative to the array pointer `ptr` at\n                // index `j_`.\n                function readItemAtIndex(ptr_, j_) -> v_ {\n                    v_ := byte(31, mload(add(ptr_, j_)))\n                    // we never call this function in a context where v_ being\n                    // zero implies that zero was previously written at j_.\n                    // j_ MAY also be zero in which case setting v_ will be a\n                    // noop.\n                    if iszero(v_) {\n                        v_ := j_\n                    }\n                }\n\n                // put the seed in scratch to initialize randomIndex.\n                mstore(0, seed_)\n                // We use mstore8 to write so a write index of 0 is exactly the\n                // end of the length slot of the array.\n                let writeStart_ := add(array_, 0x20)\n                // We have to use mload (32 bytes) to read 1 byte by & 0xFF so\n                // a read index of 0 needs to push the mload one byte to the\n                // right of the length slot of the array.\n                let readStart_ := add(array_, 1)\n\n                // Write randomly to the array for all values above the target.\n                // This won't run if n_ == max - 1.\n                for {\n                    let i_ := sub(max_, 1)\n                } gt(i_, n_) {\n                    i_ := sub(i_, 1)\n                } {\n                    mstore8(\n                        add(writeStart_, randomIndex(i_)),\n                        readItemAtIndex(readStart_, i_)\n                    )\n                }\n\n                // Read randomly at the target.\n                item_ := readItemAtIndex(readStart_, randomIndex(n_))\n            }\n        }\n    }\n\n    /// Implements a fisher yates algorithm to return a shuffled list of 2-byte\n    /// sequential uint16s represented as raw bytes. Uses the same general\n    /// approach as `microLottery` but always shuffles the entire list, rather\n    /// than exiting at a specified ID. As the entire list is returned there is\n    /// an extra write in the shuffle implementation vs. the microLottery that\n    /// leads to a somewhat higher gas cost of ~260 per ID (vs. ~230). Assuming\n    /// that negligible other memory has been allocated in the same function\n    /// call, so that memory expansion costs are approximately linear, the\n    /// per-ID gas cost is almost constant from 1-10k IDs.\n    ///\n    /// After the shuffle is complete the resulting bytes need to be stored\n    /// for later lookups. Assuming SSTORE2 there will be ~55k fixed overhead\n    /// to create the data contract and store a pointer to it, then 400 gas per\n    /// id (200 per byte) to write the shuffled array.\n    ///\n    /// Total gas cost of shuffle + SSTORE2 ~= 55k + (660 * length)\n    ///\n    /// Absolute maximum size of a contract is 24576 bytes ~= 12k IDs which\n    /// costs a little over 8 million gas to generate and deploy. At this point\n    /// the shuffle is getting close to triggering network limits in several\n    /// dimensions, so projects should plan accordingly.\n    ///\n    /// Once the shuffled array is stored as SSTORE2 it has a constant read cost\n    /// O(1) for any ID and any total number of IDs. The gas cost will be ~2.1k\n    /// for the storage read of the pointer to the data contract and ~3k to load\n    /// the data contract and fetch the shuffled ID, total ~5k gas to read. If\n    /// more than one shuffled ID is read in a single call then the gas cost of\n    /// subsequent reads is significantly cheaper at ~750 gas per read, as the\n    /// data contract is \"warm\" to read from.\n    ///\n    /// One possible NFT minting workflow for the shuffle:\n    /// - All metadata is revealed publicly before the onchain process\n    /// - Users reserve a sequential ID for themselves\n    /// - A seed is generated somehow, e.g. \"rain dance\"\n    /// - \"Someone\" (can be anyone willing to pay the gas) calls a function to\n    /// build and store the shuffled bytes from the seed\n    /// - Users mint an NFT for themselves where the NFT ID is the shuffled ID\n    /// at the user's sequential ID as an index\n    ///\n    /// Using the above workflow a single entity must pay the gas cost to map\n    /// every ID to a shuffled ID via a shared seed. As the mapping is\n    /// deterministic given a seed and length there is no security concern\n    /// leaving this mapping function world-callable. There is no obligation for\n    /// the deployers of the NFT contract to be the entity that pays the gas,\n    /// although it often will be socially expected of them.\n    ///\n    /// Note that shuffle uses a simple `%` to select a random index from the\n    /// 32 byte keccak output. This will introduce some \"small\" module bias,\n    /// which is likely negligible in the context of e.g. assigning NFT metadata\n    /// but could easily be enough bias to break cryptographic systems. DO NOT\n    /// use shuffle as a component in cryptographic systems.\n    ///\n    /// @param seed_ The seed that feeds into the deterministic shuffle output.\n    /// @param len_ The number of items to shuffle, final output will be 2x the\n    /// length in bytes as each item is uint16.\n    /// @return shuffled_ The shuffled items as bytes in memory, length will be\n    /// 2x `len_` as each item is 16 bits.\n    function shuffle(uint256 seed_, uint256 len_)\n        internal\n        pure\n        returns (bytes memory shuffled_)\n    {\n        unchecked {\n            // Allocate all the items up front as empty bytes.\n            shuffled_ = new bytes(len_ * 2);\n            assembly {\n                // Initialize the seed in scratch space.\n                // Needed for \"random\" rolls below.\n                mstore(0, seed_)\n\n                // Item 0 will be read 2-bytes past the length of `shuffled_`.\n                // All offsets for items are relative to the pointer.\n                let ptr_ := add(shuffled_, 2)\n                // When we `mload` then `or` the new values with existing data\n                // in memory from the bytes array we have to mask out the 2\n                // bytes at the end of the loaded value.\n                // solhint-disable-next-line max-line-length\n                let itemMask_ := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000\n\n                // When we want to read ONLY the current item being considered\n                // from a full 32 byte `mload` we want to keep only the last\n                // 2 bytes.\n                let vMask_ := 0xFFFF\n\n                // Start at the end of the bytes array and work down towards 0.\n                // Don't need to shuffle index 0 because it will always be\n                // itself, which is whatever was written to it or 0.\n                // i_ is the index being shuffled which is converted to a\n                // 2 byte offset as needed.\n                for {\n                    let i_ := sub(len_, 1)\n                } gt(i_, 0) {\n                    i_ := sub(i_, 1)\n                } {\n                    // Calculate the location, base and value for the current\n                    // index being shuffled.\n                    let location_ := add(ptr_, mul(i_, 2))\n                    let base_ := mload(location_)\n                    let v_ := and(base_, vMask_)\n                    if iszero(v_) {\n                        v_ := i_\n                    }\n\n                    // Generate a \"random\" index by hashing the first value in\n                    // current scratch space.\n                    let roll_ := keccak256(0, 0x20)\n                    mstore(0, roll_)\n                    let randomIndex_ := mod(roll_, add(i_, 1))\n\n                    // Calculate the location, base and value for the \"random\"\n                    // index that the current index will be swapped with.\n                    let randomLocation_ := add(ptr_, mul(randomIndex_, 2))\n                    let randomBase_ := mload(randomLocation_)\n                    let randomV_ := and(randomBase_, vMask_)\n                    if iszero(randomV_) {\n                        randomV_ := randomIndex_\n                    }\n\n                    // Merge the value from the \"random\" index with the read\n                    // from current index and save it back to the current\n                    // index's location.\n                    mstore(location_, or(and(base_, itemMask_), randomV_))\n                    // Merge the value from the current index with the read from\n                    // the \"random\" index and save it back to the \"random\"\n                    // index's location.\n                    mstore(randomLocation_, or(and(randomBase_, itemMask_), v_))\n                }\n            }\n        }\n    }\n\n    /// Given a pointer to some shuffled bytes written by SSTORE2, read back the\n    /// bytes and extract the shuffled ID for the sequential unshuffled index.\n    /// @param ptr_ The address of the data contract deployed by SSTORE2.\n    /// @param index_ Sequential index to read 2-byte ID from.\n    /// @return id_ The shuffled ID associated with the passed index. Internally\n    /// is only 2-bytes, i.e. uint16 but is returned as uint256 as e.g. NFT IDs\n    /// etc. are typically uint256 values.\n    function shuffleIdAtIndex(address ptr_, uint256 index_)\n        internal\n        view\n        returns (uint256 id_)\n    {\n        unchecked {\n            uint256 offset_ = index_ * 2;\n            bytes memory idBytes_ = SSTORE2.read(ptr_, offset_, offset_ + 2);\n            assembly {\n                id_ := and(mload(add(idBytes_, 2)), 0xFFFF)\n            }\n        }\n    }\n\n    /// Given a seed and an index, return a randomized ID value across the space\n    /// of all possible uint256 values. The result is simply hashing the seed\n    /// and index together, so it is cheap and simple at 105 gas flat per ID.\n    /// The random mappings will NOT be the same as the shuffling for any ID.\n    ///\n    /// This approach trades off the ability to have fixed size rarity buckets\n    /// of metadata for the ability to scale input IDs \"infinitely\" for a\n    /// given seed. There are no upfront or non-constant costs beyond seed\n    /// generation, no matter how many IDs (even millions) there are.\n    ///\n    /// The approach requires procedural generation of metadata, or at least\n    /// enough headroom in rarity buckets that there will always be \"enough\" to\n    /// cover probabalistic fluctuations in how many IDs are in each bucket.\n    /// To ensure that the metadata is trustless, the procedure in which the\n    /// metadata is generated MUST be public along with the metdata itself. This\n    /// can be done offchain such as in a subgraph or through open source code\n    /// to allow users to verify the generated metadata itself hasn't been\n    /// tampered with.\n    ///\n    /// Rarity buckets can be simulated geometrically by calculating thresholds\n    /// across [0, 2^256-1] that are positioned according to the\n    /// desired probabilities of any ID falling in the bucket. For example, if\n    /// bucket A is to be twice as likely as bucket B we need 2/3 of all IDs to\n    /// be in A and 1/3 in bucket B. If we calculate 2/3 * (2^256 - 1) and treat\n    /// every shuffled ID below this value as rarity A and every ID above as B\n    /// then we expect it to distributed IDs in buckets exactly as a shuffled\n    /// array with a 2/3 and 1/3 split of metadata.\n    ///\n    /// Keccak gives an extremely (cryptographic) uniform distribution of\n    /// outputs across all possible inputs. Deviations from the actual number\n    /// of IDs falling into buckets for any seed vs. what we desire/predict\n    /// will be small and uncommon, with the precision increasing with larger\n    /// sample sizes (more total IDs).\n    /// This is similar to simulating/approximating without calculating directly\n    /// using Monte Carlo methods, where increasing the number of uniformly\n    /// distributed points improves the quality of the approximation:\n    /// https://en.wikipedia.org/wiki/Monte_Carlo_method\n    ///\n    /// Note that if you try to create buckets with modulo `%` you will probably\n    /// introduce potentially significant modulo bias that will need to be\n    /// compensated for, e.g. re-rolling results in the biased range.\n    ///\n    /// Exactly as the shuffle/lottery systems, once the seed is known, all\n    /// mappings of input indexes to output IDs are known, so ad-hoc/JIT hashing\n    /// does nothing to solve this problem.\n    ///\n    /// @param seed_ The input seed that is used to map all indexes to the\n    /// randomized output ids.\n    /// @param index_ The index to calculate the output ID for.\n    /// @param id_ The output ID corresponding to the input and seed, will be\n    /// across the entire range [0, 2^256 - 1].\n    function randomId(uint256 seed_, uint256 index_)\n        internal\n        pure\n        returns (uint256 id_)\n    {\n        assembly {\n            mstore(0, seed_)\n            mstore(0x20, index_)\n            id_ := keccak256(0, 0x40)\n        }\n    }\n}\n"
    },
    "contracts/test/ReserveTokenERC721.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n// solhint-disable-next-line max-line-length\nimport {ERC721Burnable} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\n\n/// @title ReserveTokenERC721\n// Extremely basic ERC721 implementation for testing purposes.\ncontract ReserveTokenERC721 is ERC721, ERC721Burnable {\n    // Incremented token count for use as id for newly minted tokens.\n    uint256 public tokenCount;\n\n    /// Define and mint a erc721 token.\n    constructor() ERC721(\"Test NFT\", \"TNFT\") {\n        tokenCount = 0;\n        _mint(msg.sender, tokenCount);\n    }\n\n    function mintNewToken() external {\n        tokenCount++;\n        _mint(msg.sender, tokenCount);\n    }\n}\n"
    },
    "contracts/test/VerifyCallbackTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport {IVerifyCallback, Evidence} from \"../verify/IVerifyCallback.sol\";\n\n// Test contract for testing Verify hooks after adding, approving, banning or\n// removing an account.\n// All logic here is for testing purposes and should not necessarily be used in\n// an actual Verify callback contract.\ncontract VerifyCallbackTest is IVerifyCallback {\n    /// Account => Boolean\n    mapping(address => bool) public additions;\n    mapping(address => bool) public approvals;\n    mapping(address => bool) public bans;\n    mapping(address => bool) public removals;\n\n    function afterAdd(address adder_, Evidence[] calldata evidences_)\n        external\n        virtual\n        override\n    {\n        require(adder_ != address(0), \"0_ADDRESS\");\n        for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n            require(!additions[evidences_[i_].account], \"PRIOR_ADD\");\n            require(\n                keccak256(evidences_[i_].data) == keccak256(bytes(\"Good\")),\n                \"BAD_EVIDENCE\"\n            );\n            additions[evidences_[i_].account] = true;\n        }\n    }\n\n    function afterApprove(address approver_, Evidence[] calldata evidences_)\n        external\n        virtual\n        override\n    {\n        require(approver_ != address(0), \"0_ADDRESS\");\n        for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n            require(!approvals[evidences_[i_].account], \"PRIOR_APPROVE\");\n            require(\n                keccak256(evidences_[i_].data) == keccak256(bytes(\"Good\")),\n                \"BAD_EVIDENCE\"\n            );\n            // Require that added callback already triggered\n            require(additions[evidences_[i_].account], \"NOT_ADDED_CALLBACK\");\n            approvals[evidences_[i_].account] = true;\n        }\n    }\n\n    function afterBan(address banner_, Evidence[] calldata evidences_)\n        external\n        virtual\n        override\n    {\n        require(banner_ != address(0), \"0_ADDRESS\");\n        for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n            require(!bans[evidences_[i_].account], \"PRIOR_BAN\");\n            require(\n                keccak256(evidences_[i_].data) == keccak256(bytes(\"Good\")),\n                \"BAD_EVIDENCE\"\n            );\n            // Require that added callback already triggered\n            require(additions[evidences_[i_].account], \"NOT_ADDED_CALLBACK\");\n            bans[evidences_[i_].account] = true;\n        }\n    }\n\n    function afterRemove(address remover_, Evidence[] calldata evidences_)\n        external\n        virtual\n        override\n    {\n        require(remover_ != address(0), \"0_ADDRESS\");\n        for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n            require(!removals[evidences_[i_].account], \"PRIOR_REMOVE\");\n            require(\n                keccak256(evidences_[i_].data) == keccak256(bytes(\"Good\")),\n                \"BAD_EVIDENCE\"\n            );\n            // Require that added callback already triggered\n            require(additions[evidences_[i_].account], \"NOT_ADDED_CALLBACK\");\n            removals[evidences_[i_].account] = true;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100000
    },
    "metadata": {
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}