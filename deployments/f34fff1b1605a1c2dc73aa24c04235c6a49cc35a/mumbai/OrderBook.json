{
  "address": "0x609F0B36d2C45827F6CBAA0a651Ec86766A57787",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "interpreter",
              "type": "address"
            },
            {
              "internalType": "EncodedDispatch",
              "name": "dispatch",
              "type": "uint256"
            },
            {
              "internalType": "EncodedDispatch",
              "name": "handleIODispatch",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IO[]",
              "name": "validInputs",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IO[]",
              "name": "validOutputs",
              "type": "tuple[]"
            }
          ],
          "indexed": false,
          "internalType": "struct Order",
          "name": "order",
          "type": "tuple"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "orderHash",
          "type": "uint256"
        }
      ],
      "name": "AddOrder",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "aOutput",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "bOutput",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "aInput",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "bInput",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct ClearStateChange",
          "name": "stateChange",
          "type": "tuple"
        }
      ],
      "name": "AfterClear",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "interpreter",
              "type": "address"
            },
            {
              "internalType": "EncodedDispatch",
              "name": "dispatch",
              "type": "uint256"
            },
            {
              "internalType": "EncodedDispatch",
              "name": "handleIODispatch",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IO[]",
              "name": "validInputs",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IO[]",
              "name": "validOutputs",
              "type": "tuple[]"
            }
          ],
          "indexed": false,
          "internalType": "struct Order",
          "name": "a",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "interpreter",
              "type": "address"
            },
            {
              "internalType": "EncodedDispatch",
              "name": "dispatch",
              "type": "uint256"
            },
            {
              "internalType": "EncodedDispatch",
              "name": "handleIODispatch",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IO[]",
              "name": "validInputs",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IO[]",
              "name": "validOutputs",
              "type": "tuple[]"
            }
          ],
          "indexed": false,
          "internalType": "struct Order",
          "name": "b",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "aInputIOIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "aOutputIOIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "bInputIOIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "bOutputIOIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "aBountyVaultId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "bBountyVaultId",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct ClearConfig",
          "name": "clearConfig",
          "type": "tuple"
        }
      ],
      "name": "Clear",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "vaultId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct DepositConfig",
          "name": "config",
          "type": "tuple"
        }
      ],
      "name": "Deposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "orderHash",
          "type": "uint256"
        }
      ],
      "name": "OrderExceedsMaxRatio",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "orderHash",
          "type": "uint256"
        }
      ],
      "name": "OrderNotFound",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "orderHash",
          "type": "uint256"
        }
      ],
      "name": "OrderZeroAmount",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "interpreter",
              "type": "address"
            },
            {
              "internalType": "EncodedDispatch",
              "name": "dispatch",
              "type": "uint256"
            },
            {
              "internalType": "EncodedDispatch",
              "name": "handleIODispatch",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IO[]",
              "name": "validInputs",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IO[]",
              "name": "validOutputs",
              "type": "tuple[]"
            }
          ],
          "indexed": false,
          "internalType": "struct Order",
          "name": "order",
          "type": "tuple"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "orderHash",
          "type": "uint256"
        }
      ],
      "name": "RemoveOrder",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "owner",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "interpreter",
                  "type": "address"
                },
                {
                  "internalType": "EncodedDispatch",
                  "name": "dispatch",
                  "type": "uint256"
                },
                {
                  "internalType": "EncodedDispatch",
                  "name": "handleIODispatch",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "vaultId",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IO[]",
                  "name": "validInputs",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "vaultId",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct IO[]",
                  "name": "validOutputs",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct Order",
              "name": "order",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "inputIOIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "outputIOIndex",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct TakeOrderConfig",
          "name": "takeOrder",
          "type": "tuple"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "input",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "output",
          "type": "uint256"
        }
      ],
      "name": "TakeOrder",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "vaultId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct WithdrawConfig",
          "name": "config",
          "type": "tuple"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Withdraw",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "CALLBACK_SUCCESS",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "expressionDeployer",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "interpreter",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "bytes[]",
                  "name": "sources",
                  "type": "bytes[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "constants",
                  "type": "uint256[]"
                }
              ],
              "internalType": "struct StateConfig",
              "name": "interpreterStateConfig",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IO[]",
              "name": "validInputs",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IO[]",
              "name": "validOutputs",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct OrderConfig",
          "name": "config_",
          "type": "tuple"
        }
      ],
      "name": "addOrder",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "interpreter",
              "type": "address"
            },
            {
              "internalType": "EncodedDispatch",
              "name": "dispatch",
              "type": "uint256"
            },
            {
              "internalType": "EncodedDispatch",
              "name": "handleIODispatch",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IO[]",
              "name": "validInputs",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IO[]",
              "name": "validOutputs",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct Order",
          "name": "a_",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "interpreter",
              "type": "address"
            },
            {
              "internalType": "EncodedDispatch",
              "name": "dispatch",
              "type": "uint256"
            },
            {
              "internalType": "EncodedDispatch",
              "name": "handleIODispatch",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IO[]",
              "name": "validInputs",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IO[]",
              "name": "validOutputs",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct Order",
          "name": "b_",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "aInputIOIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "aOutputIOIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "bInputIOIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "bOutputIOIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "aBountyVaultId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "bBountyVaultId",
              "type": "uint256"
            }
          ],
          "internalType": "struct ClearConfig",
          "name": "clearConfig_",
          "type": "tuple"
        }
      ],
      "name": "clear",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "vaultId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "internalType": "struct DepositConfig",
          "name": "config_",
          "type": "tuple"
        }
      ],
      "name": "deposit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "flashFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC3156FlashBorrower",
          "name": "receiver_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "token_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount_",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data_",
          "type": "bytes"
        }
      ],
      "name": "flashLoan",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token_",
          "type": "address"
        }
      ],
      "name": "maxFlashLoan",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes[]",
          "name": "data",
          "type": "bytes[]"
        }
      ],
      "name": "multicall",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "results",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "interpreter",
              "type": "address"
            },
            {
              "internalType": "EncodedDispatch",
              "name": "dispatch",
              "type": "uint256"
            },
            {
              "internalType": "EncodedDispatch",
              "name": "handleIODispatch",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IO[]",
              "name": "validInputs",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "vaultId",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IO[]",
              "name": "validOutputs",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct Order",
          "name": "order_",
          "type": "tuple"
        }
      ],
      "name": "removeOrder",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "output",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "input",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "minimumInput",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maximumInput",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "maximumIORatio",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "owner",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "interpreter",
                      "type": "address"
                    },
                    {
                      "internalType": "EncodedDispatch",
                      "name": "dispatch",
                      "type": "uint256"
                    },
                    {
                      "internalType": "EncodedDispatch",
                      "name": "handleIODispatch",
                      "type": "uint256"
                    },
                    {
                      "components": [
                        {
                          "internalType": "address",
                          "name": "token",
                          "type": "address"
                        },
                        {
                          "internalType": "uint256",
                          "name": "vaultId",
                          "type": "uint256"
                        }
                      ],
                      "internalType": "struct IO[]",
                      "name": "validInputs",
                      "type": "tuple[]"
                    },
                    {
                      "components": [
                        {
                          "internalType": "address",
                          "name": "token",
                          "type": "address"
                        },
                        {
                          "internalType": "uint256",
                          "name": "vaultId",
                          "type": "uint256"
                        }
                      ],
                      "internalType": "struct IO[]",
                      "name": "validOutputs",
                      "type": "tuple[]"
                    }
                  ],
                  "internalType": "struct Order",
                  "name": "order",
                  "type": "tuple"
                },
                {
                  "internalType": "uint256",
                  "name": "inputIOIndex",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "outputIOIndex",
                  "type": "uint256"
                }
              ],
              "internalType": "struct TakeOrderConfig[]",
              "name": "orders",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct TakeOrdersConfig",
          "name": "takeOrders_",
          "type": "tuple"
        }
      ],
      "name": "takeOrders",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "totalInput_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalOutput_",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "vaultBalance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "vaultId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            }
          ],
          "internalType": "struct WithdrawConfig",
          "name": "config_",
          "type": "tuple"
        }
      ],
      "name": "withdraw",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x4559282222225824fa9562232d52d4e3a7749df8857f39b9a41af7b33997b123",
  "receipt": {
    "to": null,
    "from": "0xbF334f8BD1420a1CbFE15407f73919424934B1B3",
    "contractAddress": "0x609F0B36d2C45827F6CBAA0a651Ec86766A57787",
    "transactionIndex": 12,
    "gasUsed": "3751026",
    "logsBloom": "0x00000000000000020000000000000000000000000000002000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000200000000000000000000000000000000000080000000010000000000000000000000000000000000000000000000000080000000100000000000200000000000000030000000000400000001000000000000000000000000004000000000000000000001000000040000000000000000000000100000000000000000000000000000000000000000000000000000000000000800000000100000",
    "blockHash": "0xce6cccb2876c865686da6bd3453ff4471ba15368025e58ada03b46f1b61d76ed",
    "transactionHash": "0x4559282222225824fa9562232d52d4e3a7749df8857f39b9a41af7b33997b123",
    "logs": [
      {
        "transactionIndex": 12,
        "blockNumber": 29770681,
        "transactionHash": "0x4559282222225824fa9562232d52d4e3a7749df8857f39b9a41af7b33997b123",
        "address": "0x609F0B36d2C45827F6CBAA0a651Ec86766A57787",
        "topics": [
          "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000000000000001",
        "logIndex": 36,
        "blockHash": "0xce6cccb2876c865686da6bd3453ff4471ba15368025e58ada03b46f1b61d76ed"
      },
      {
        "transactionIndex": 12,
        "blockNumber": 29770681,
        "transactionHash": "0x4559282222225824fa9562232d52d4e3a7749df8857f39b9a41af7b33997b123",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000bf334f8bd1420a1cbfe15407f73919424934b1b3",
          "0x000000000000000000000000c26880a0af2ea0c7e8130e6ec47af756465452e8"
        ],
        "data": "0x000000000000000000000000000000000000000000000000001d33a3207f776a000000000000000000000000000000000000000000000000b3a7f7287ba76a15000000000000000000000000000000000000000000001879f98780b5475cee1c000000000000000000000000000000000000000000000000b38ac3855b27f2ab000000000000000000000000000000000000000000001879f9a4b45867dc6586",
        "logIndex": 37,
        "blockHash": "0xce6cccb2876c865686da6bd3453ff4471ba15368025e58ada03b46f1b61d76ed"
      }
    ],
    "blockNumber": 29770681,
    "cumulativeGasUsed": "8252433",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "b7470563c64757443ad855b79d2f29e1",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"dispatch\",\"type\":\"uint256\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"handleIODispatch\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderHash\",\"type\":\"uint256\"}],\"name\":\"AddOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"aOutput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bOutput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bInput\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct ClearStateChange\",\"name\":\"stateChange\",\"type\":\"tuple\"}],\"name\":\"AfterClear\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"dispatch\",\"type\":\"uint256\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"handleIODispatch\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct Order\",\"name\":\"a\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"dispatch\",\"type\":\"uint256\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"handleIODispatch\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct Order\",\"name\":\"b\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"aInputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aOutputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bInputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bOutputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aBountyVaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bBountyVaultId\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct ClearConfig\",\"name\":\"clearConfig\",\"type\":\"tuple\"}],\"name\":\"Clear\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct DepositConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderHash\",\"type\":\"uint256\"}],\"name\":\"OrderExceedsMaxRatio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderHash\",\"type\":\"uint256\"}],\"name\":\"OrderNotFound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderHash\",\"type\":\"uint256\"}],\"name\":\"OrderZeroAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"dispatch\",\"type\":\"uint256\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"handleIODispatch\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderHash\",\"type\":\"uint256\"}],\"name\":\"RemoveOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"dispatch\",\"type\":\"uint256\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"handleIODispatch\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"inputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputIOIndex\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct TakeOrderConfig\",\"name\":\"takeOrder\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"}],\"name\":\"TakeOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct WithdrawConfig\",\"name\":\"config\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CALLBACK_SUCCESS\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"expressionDeployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes[]\",\"name\":\"sources\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"internalType\":\"struct StateConfig\",\"name\":\"interpreterStateConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct OrderConfig\",\"name\":\"config_\",\"type\":\"tuple\"}],\"name\":\"addOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"dispatch\",\"type\":\"uint256\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"handleIODispatch\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Order\",\"name\":\"a_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"dispatch\",\"type\":\"uint256\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"handleIODispatch\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Order\",\"name\":\"b_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"aInputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aOutputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bInputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bOutputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aBountyVaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bBountyVaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct ClearConfig\",\"name\":\"clearConfig_\",\"type\":\"tuple\"}],\"name\":\"clear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct DepositConfig\",\"name\":\"config_\",\"type\":\"tuple\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"flashFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC3156FlashBorrower\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"flashLoan\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"maxFlashLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"dispatch\",\"type\":\"uint256\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"handleIODispatch\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Order\",\"name\":\"order_\",\"type\":\"tuple\"}],\"name\":\"removeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"output\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumIORatio\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"dispatch\",\"type\":\"uint256\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"handleIODispatch\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"inputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputIOIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct TakeOrderConfig[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"internalType\":\"struct TakeOrdersConfig\",\"name\":\"takeOrders_\",\"type\":\"tuple\"}],\"name\":\"takeOrders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalInput_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalOutput_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vaultBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct WithdrawConfig\",\"name\":\"config_\",\"type\":\"tuple\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"Withdraw(address,(address,uint256,uint256),uint256)\":{\"params\":{\"amount\":\"The amount of tokens withdrawn, can be less than the config amount if the vault does not have the funds available to cover the config amount.\",\"config\":\"All config sent to the `withdraw` call.\",\"sender\":\"`msg.sender` withdrawing tokens.\"}}},\"kind\":\"dev\",\"methods\":{\"flashFee(address,uint256)\":{\"details\":\"The fee to be charged for a given loan.\",\"params\":{\"amount\":\"The amount of tokens lent.\",\"token\":\"The loan currency.\"},\"returns\":{\"_0\":\"The amount of `token` to be charged for the loan, on top of the returned principal.\"}},\"flashLoan(address,address,uint256,bytes)\":{\"details\":\"Initiate a flash loan.\",\"params\":{\"amount\":\"The amount of tokens lent.\",\"data\":\"Arbitrary data structure, intended to contain user-defined parameters.\",\"receiver\":\"The receiver of the tokens in the loan, and the receiver of the callback.\",\"token\":\"The loan currency.\"}},\"maxFlashLoan(address)\":{\"details\":\"The amount of currency available to be lent.\",\"params\":{\"token\":\"The loan currency.\"},\"returns\":{\"_0\":\"The amount of `token` that can be borrowed.\"}},\"multicall(bytes[])\":{\"details\":\"Receives and executes a batch of function calls on this contract.\"},\"withdraw((address,uint256,uint256))\":{\"params\":{\"config_\":\"All config required to withdraw. Notably if the amount is less than the current vault balance then the vault will be cleared to 0 rather than the withdraw transaction reverting.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"vaultBalance(address,address,uint256)\":{\"notice\":\"depositor => token => vault id => token amount.\"},\"withdraw((address,uint256,uint256))\":{\"notice\":\"Allows the sender to withdraw any tokens from their own vaults.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/orderbook/OrderBook.sol\":\"OrderBook\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000000},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\",\"keccak256\":\"0x6e6e4b0835904509406b070ee173b5bc8f677c19421b76be38aea3b1b3d30846\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0203dcadc5737d9ef2c211d6fa15d18ebc3b30dfa51903b64870b01a062b0b4e\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x8cc03c5ac17e8a7396e487cda41fc1f1dfdb91db7d528e6da84bee3b6dd7e167\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x091a49ef99a2be002680781a10cc9dd74c0f348301ede5482c4ea625f79a8ffe\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\",\"keccak256\":\"0x7c7ac0bc6c340a7f320524b9a4b4b079ee9da3c51258080d4bab237f329a427c\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4e733d3164f73f461eaf9d8087a7ad1ea180bdc8ba0d3d61b0e1ae16d8e63dff\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/extensions/ERC20Snapshot.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/ArraysUpgradeable.sol\\\";\\nimport \\\"../../../utils/CountersUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\\n * total supply at the time are recorded for later access.\\n *\\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\\n * In naive implementations it's possible to perform a \\\"double spend\\\" attack by reusing the same balance from different\\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\\n * used to create an efficient ERC20 forking mechanism.\\n *\\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\\n * and the account address.\\n *\\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\\n * return `block.number` will trigger the creation of snapshot at the beginning of each new block. When overriding this\\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\\n *\\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\\n * alternative consider {ERC20Votes}.\\n *\\n * ==== Gas Costs\\n *\\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\\n *\\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\\n * transfers will have normal cost until the next snapshot, and so on.\\n */\\n\\nabstract contract ERC20SnapshotUpgradeable is Initializable, ERC20Upgradeable {\\n    function __ERC20Snapshot_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC20Snapshot_init_unchained() internal onlyInitializing {\\n    }\\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\\n    // https://github.com/Giveth/minime/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\\n\\n    using ArraysUpgradeable for uint256[];\\n    using CountersUpgradeable for CountersUpgradeable.Counter;\\n\\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\\n    // Snapshot struct, but that would impede usage of functions that work on an array.\\n    struct Snapshots {\\n        uint256[] ids;\\n        uint256[] values;\\n    }\\n\\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\\n    Snapshots private _totalSupplySnapshots;\\n\\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\\n    CountersUpgradeable.Counter private _currentSnapshotId;\\n\\n    /**\\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\\n     */\\n    event Snapshot(uint256 id);\\n\\n    /**\\n     * @dev Creates a new snapshot and returns its snapshot id.\\n     *\\n     * Emits a {Snapshot} event that contains the same id.\\n     *\\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\\n     *\\n     * [WARNING]\\n     * ====\\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\\n     * you must consider that it can potentially be used by attackers in two ways.\\n     *\\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\\n     * section above.\\n     *\\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\\n     * ====\\n     */\\n    function _snapshot() internal virtual returns (uint256) {\\n        _currentSnapshotId.increment();\\n\\n        uint256 currentId = _getCurrentSnapshotId();\\n        emit Snapshot(currentId);\\n        return currentId;\\n    }\\n\\n    /**\\n     * @dev Get the current snapshotId\\n     */\\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\\n        return _currentSnapshotId.current();\\n    }\\n\\n    /**\\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\\n     */\\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\\n\\n        return snapshotted ? value : balanceOf(account);\\n    }\\n\\n    /**\\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\\n     */\\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\\n\\n        return snapshotted ? value : totalSupply();\\n    }\\n\\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        if (from == address(0)) {\\n            // mint\\n            _updateAccountSnapshot(to);\\n            _updateTotalSupplySnapshot();\\n        } else if (to == address(0)) {\\n            // burn\\n            _updateAccountSnapshot(from);\\n            _updateTotalSupplySnapshot();\\n        } else {\\n            // transfer\\n            _updateAccountSnapshot(from);\\n            _updateAccountSnapshot(to);\\n        }\\n    }\\n\\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\\n        require(snapshotId > 0, \\\"ERC20Snapshot: id is 0\\\");\\n        require(snapshotId <= _getCurrentSnapshotId(), \\\"ERC20Snapshot: nonexistent id\\\");\\n\\n        // When a valid snapshot is queried, there are three possibilities:\\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\\n        //  to this id is the current one.\\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\\n        //  requested id, and its value is the one to return.\\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\\n        //  larger than the requested one.\\n        //\\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\\n        // exactly this.\\n\\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\\n\\n        if (index == snapshots.ids.length) {\\n            return (false, 0);\\n        } else {\\n            return (true, snapshots.values[index]);\\n        }\\n    }\\n\\n    function _updateAccountSnapshot(address account) private {\\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\\n    }\\n\\n    function _updateTotalSupplySnapshot() private {\\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\\n    }\\n\\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\\n        uint256 currentId = _getCurrentSnapshotId();\\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\\n            snapshots.ids.push(currentId);\\n            snapshots.values.push(currentValue);\\n        }\\n    }\\n\\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\\n        if (ids.length == 0) {\\n            return 0;\\n        } else {\\n            return ids[ids.length - 1];\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[46] private __gap;\\n}\\n\",\"keccak256\":\"0x42da8099f59958af496f6c8f0d9c1ce0a929151e02f877e4be23aca4cc440cbe\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x605434219ebbe4653f703640f06969faa5a1d78f0bfef878e5ddbb1ca369ceeb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xcc70d8e2281fb3ff69e8ab242500f10142cd0a7fa8dd9e45882be270d4d09024\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/draft-IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf42efac0d704b136c4d85e970562d4dbc1160d726ee93b5133122eb14fe368df\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x016298e66a5810253c6c905e61966bb31c8775c3f3517bf946ff56ee31d6c005\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x611aa3f23e59cfdd1863c536776407b3e33d695152a266fa7cfb34440a29a8a3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ArraysUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Arrays.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/MathUpgradeable.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to array types.\\n */\\nlibrary ArraysUpgradeable {\\n    /**\\n     * @dev Searches a sorted `array` and returns the first index that contains\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\n     * values in the array are strictly less than `element`), the array length is\\n     * returned. Time complexity O(log n).\\n     *\\n     * `array` is expected to be sorted in ascending order, and to contain no\\n     * repeated elements.\\n     */\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        if (array.length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        while (low < high) {\\n            uint256 mid = MathUpgradeable.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds down (it does integer division with truncation).\\n            if (array[mid] > element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low > 0 && array[low - 1] == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7c78eb214065a464bc47849a116caf75cac46307e6dc80a789447dd0a13494d8\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary CountersUpgradeable {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\",\"keccak256\":\"0x798741e231b22b81e2dd2eddaaf8832dee4baf5cd8e2dbaa5c1dd12a1c053c4d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AddressUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract MulticallUpgradeable is Initializable {\\n    function __Multicall_init() internal onlyInitializing {\\n    }\\n\\n    function __Multicall_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract.\\n     */\\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = _functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return AddressUpgradeable.verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xb8709268fac307114f6cbb5e3cee798d91cd0adfea4d337c4920f8f0b2414f15\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc6cef87559d0aeffdf0a99803de655938a7779ec0a3cd5d4383483ad85565a09\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` \\u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x3b39e1a87bb94b9145d91007bbd2c964438e99a659b4accc6ec6df6a1c62589a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCastUpgradeable {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248) {\\n        require(value >= type(int248).min && value <= type(int248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return int248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240) {\\n        require(value >= type(int240).min && value <= type(int240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return int240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232) {\\n        require(value >= type(int232).min && value <= type(int232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return int232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224) {\\n        require(value >= type(int224).min && value <= type(int224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return int224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216) {\\n        require(value >= type(int216).min && value <= type(int216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return int216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208) {\\n        require(value >= type(int208).min && value <= type(int208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return int208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200) {\\n        require(value >= type(int200).min && value <= type(int200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return int200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192) {\\n        require(value >= type(int192).min && value <= type(int192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return int192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184) {\\n        require(value >= type(int184).min && value <= type(int184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return int184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176) {\\n        require(value >= type(int176).min && value <= type(int176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return int176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168) {\\n        require(value >= type(int168).min && value <= type(int168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return int168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160) {\\n        require(value >= type(int160).min && value <= type(int160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return int160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152) {\\n        require(value >= type(int152).min && value <= type(int152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return int152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144) {\\n        require(value >= type(int144).min && value <= type(int144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return int144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136) {\\n        require(value >= type(int136).min && value <= type(int136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return int136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120) {\\n        require(value >= type(int120).min && value <= type(int120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return int120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112) {\\n        require(value >= type(int112).min && value <= type(int112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return int112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104) {\\n        require(value >= type(int104).min && value <= type(int104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return int104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96) {\\n        require(value >= type(int96).min && value <= type(int96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return int96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88) {\\n        require(value >= type(int88).min && value <= type(int88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return int88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80) {\\n        require(value >= type(int80).min && value <= type(int80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return int80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72) {\\n        require(value >= type(int72).min && value <= type(int72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return int72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56) {\\n        require(value >= type(int56).min && value <= type(int56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return int56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48) {\\n        require(value >= type(int48).min && value <= type(int48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return int48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40) {\\n        require(value >= type(int40).min && value <= type(int40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return int40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24) {\\n        require(value >= type(int24).min && value <= type(int24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return int24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0xd7ebe0f80affaa622b9efd95cc8db3e03e70d699176f7457b4a95e34a11f9834\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x52a8cfb0f5239d11b457dcdd1b326992ef672714ca8da71a157255bddd13f3ad\",\"license\":\"MIT\"},\"contracts/array/LibUint256Array.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// @title Uint256Array\\n/// @notice Things we want to do carefully and efficiently with uint256 arrays\\n/// that Solidity doesn't give us native tools for.\\nlibrary LibUint256Array {\\n    using LibUint256Array for uint256[];\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ a single integer to build an array around.\\n    /// @return the newly allocated array including a_ as a single item.\\n    function arrayFrom(uint256 a_) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](1);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ the first integer to build an array around.\\n    /// @param b_ the second integer to build an array around.\\n    /// @return the newly allocated array including a_ and b_ as the only items.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](2);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n        }\\n        return array_;\\n    }\\n\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](3);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n        }\\n        return array_;\\n    }\\n\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](4);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n            mstore(add(array_, 0x80), d_)\\n        }\\n        return array_;\\n    }\\n\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_,\\n        uint256 e_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](5);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n            mstore(add(array_, 0x80), d_)\\n            mstore(add(array_, 0xA0), e_)\\n        }\\n        return array_;\\n    }\\n\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_,\\n        uint256 e_,\\n        uint f_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](6);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n            mstore(add(array_, 0x80), d_)\\n            mstore(add(array_, 0xA0), e_)\\n            mstore(add(array_, 0xC0), f_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ The head of the new array.\\n    /// @param tail_ The tail of the new array.\\n    /// @return The new array.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256[] memory tail_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](1);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n        }\\n        array_.extend(tail_);\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ The first item of the new array.\\n    /// @param b_ The second item of the new array.\\n    /// @param tail_ The tail of the new array.\\n    /// @return The new array.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256[] memory tail_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](2);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n        }\\n        array_.extend(tail_);\\n        return array_;\\n    }\\n\\n    function matrixFrom(\\n        uint256[] memory a_\\n    ) internal pure returns (uint256[][] memory) {\\n        uint256[][] memory matrix_ = new uint256[][](1);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(matrix_, 0x20), a_)\\n        }\\n        return matrix_;\\n    }\\n\\n    /// Solidity provides no way to change the length of in-memory arrays but\\n    /// it also does not deallocate memory ever. It is always safe to shrink an\\n    /// array that has already been allocated, with the caveat that the\\n    /// truncated items will effectively become inaccessible regions of memory.\\n    /// That is to say, we deliberately \\\"leak\\\" the truncated items, but that is\\n    /// no worse than Solidity's native behaviour of leaking everything always.\\n    /// The array is MUTATED in place so there is no return value and there is\\n    /// no new allocation or copying of data either.\\n    /// @param array_ The array to truncate.\\n    /// @param newLength_ The new length of the array after truncation.\\n    function truncate(\\n        uint256[] memory array_,\\n        uint256 newLength_\\n    ) internal pure {\\n        require(newLength_ <= array_.length, \\\"OOB_TRUNCATE\\\");\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(array_, newLength_)\\n        }\\n    }\\n\\n    /// Extends `base_` with `extend_` by allocating additional `extend_.length`\\n    /// uints onto `base_`. Reverts if some other memory has been allocated\\n    /// after `base_` already, in which case it is NOT safe to copy inline.\\n    /// If `base_` is large this MAY be significantly more efficient than\\n    /// allocating `base_.length + extend_.length` for an entirely new array and\\n    /// copying both `base_` and `extend_` into the new array one item at a\\n    /// time in Solidity.\\n    /// The Solidity compiler MAY rearrange sibling statements in a code block\\n    /// EVEN IF THE OPTIMIZER IS DISABLED such that it becomes unsafe to use\\n    /// `extend` for memory allocated in different code blocks. It is ONLY safe\\n    /// to `extend` arrays that were allocated in the same lexical scope and you\\n    /// WILL see subtle errors that revert transactions otherwise.\\n    /// i.e. the `new` keyword MUST appear in the same code block as `extend`.\\n    /// @param base_ The base integer array that will be extended by `extend_`.\\n    /// @param extend_ The integer array that extends `base_`.\\n    function extend(\\n        uint256[] memory base_,\\n        uint256[] memory extend_\\n    ) internal pure {\\n        uint256 freeMemoryPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            // Solidity stores free memory pointer at 0x40\\n            freeMemoryPointer_ := mload(0x40)\\n            let baseLength_ := mload(base_)\\n            let extendLength_ := mload(extend_)\\n\\n            // The freeMemoryPointer_ does NOT point to the end of `base_` so\\n            // it is NOT safe to copy `extend_` over the top of already\\n            // allocated memory. This happens whenever some memory is allocated\\n            // after `base_` is allocated but before `extend` is called.\\n            if gt(\\n                freeMemoryPointer_,\\n                add(base_, add(0x20, mul(0x20, baseLength_)))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            // Move the free memory pointer by the length of extend_, excluding\\n            // the length slot of extend as that will NOT be copied to `base_`.\\n            mstore(0x40, add(freeMemoryPointer_, mul(0x20, extendLength_)))\\n\\n            // Update the length of base to be the length of base+extend.\\n            mstore(base_, add(baseLength_, extendLength_))\\n        }\\n\\n        unsafeCopyValuesTo(extend_, freeMemoryPointer_);\\n    }\\n\\n    /// Copies `inputs_` to `outputCursor_` with NO attempt to check that this\\n    /// is safe to do so. The caller MUST ensure that there exists allocated\\n    /// memory at `outputCursor_` in which it is safe and appropriate to copy\\n    /// ALL `inputs_` to. Anything that was already written to memory at\\n    /// `[outputCursor_:outputCursor_+(inputs_.length * 32 bytes)]` will be\\n    /// overwritten. The length of `inputs_` is NOT copied to the output\\n    /// location, ONLY the `uint256` values of the `inputs_` array are copied.\\n    /// There is no return value as memory is modified directly.\\n    /// @param inputs_ The input array that will be copied from EXCLUDING the\\n    /// length at the start of the array in memory.\\n    /// @param outputCursor_ Location in memory that the values will be copied\\n    /// to linearly.\\n    function unsafeCopyValuesTo(\\n        uint256[] memory inputs_,\\n        uint256 outputCursor_\\n    ) internal pure {\\n        uint256 inputCursor_;\\n        assembly (\\\"memory-safe\\\") {\\n            inputCursor_ := add(inputs_, 0x20)\\n        }\\n        unsafeCopyValuesTo(inputCursor_, outputCursor_, inputs_.length);\\n    }\\n\\n    /// Copies `length_` 32 byte words from `inputCursor_` to a newly allocated\\n    /// uint256[] array with NO attempt to check that the inputs are sane.\\n    /// This function is safe in that the outputs are guaranteed to be copied\\n    /// to newly allocated memory so no existing data will be overwritten.\\n    /// This function is subtle in that the `inputCursor_` is NOT validated in\\n    /// any way so the caller MUST ensure it points to a sensible memory\\n    /// location to read (e.g. to exclude the length from input arrays etc.).\\n    /// @param inputCursor_ The start of the memory that will be copied to the\\n    /// newly allocated array.\\n    /// @param length_ Number of 32 byte words to copy starting at\\n    /// `inputCursor_` to the items of the newly allocated array.\\n    /// @return The newly allocated `uint256[]` array.\\n    function copyToNewUint256Array(\\n        uint256 inputCursor_,\\n        uint256 length_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory outputs_ = new uint256[](length_);\\n        uint256 outputCursor_;\\n        assembly (\\\"memory-safe\\\") {\\n            outputCursor_ := add(outputs_, 0x20)\\n        }\\n        unsafeCopyValuesTo(inputCursor_, outputCursor_, length_);\\n        return outputs_;\\n    }\\n\\n    /// Copies `length_` uint256 values starting from `inputsCursor_` to\\n    /// `outputCursor_` with NO attempt to check that this is safe to do so.\\n    /// The caller MUST ensure that there exists allocated memory at\\n    /// `outputCursor_` in which it is safe and appropriate to copy\\n    /// `length_ * 32` bytes to. Anything that was already written to memory at\\n    /// `[outputCursor_:outputCursor_+(length_ * 32 bytes)]` will be\\n    /// overwritten.\\n    /// There is no return value as memory is modified directly.\\n    /// @param inputCursor_ The starting position in memory that data will be\\n    /// copied from.\\n    /// @param outputCursor_ The starting position in memory that data will be\\n    /// copied to.\\n    /// @param length_ The number of 32 byte (i.e. `uint256`) values that will\\n    /// be copied.\\n    function unsafeCopyValuesTo(\\n        uint256 inputCursor_,\\n        uint256 outputCursor_,\\n        uint256 length_\\n    ) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n                let end_ := add(inputCursor_, mul(0x20, length_))\\n            } lt(inputCursor_, end_) {\\n                inputCursor_ := add(inputCursor_, 0x20)\\n                outputCursor_ := add(outputCursor_, 0x20)\\n            } {\\n                mstore(outputCursor_, mload(inputCursor_))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaa5c120cff396b2e133ec54e935d7b3ff3451528830118d2fc9afa11322a8997\",\"license\":\"CAL\"},\"contracts/bytes/LibBytes.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// @title LibBytes\\n/// @notice Things we want to do carefully and efficiently with `bytes` in memory\\n/// that Solidity doesn't give us native tools for.\\nlibrary LibBytes {\\n    /// Copy an arbitrary number of bytes from one location in memory to another.\\n    /// As we can only read/write bytes in 32 byte chunks we first have to loop\\n    /// over 32 byte values to copy then handle any unaligned remaining data. The\\n    /// remaining data will be appropriately masked with the existing data in the\\n    /// final chunk so as to not write past the desired length. Note that the\\n    /// final unaligned write will be more gas intensive than the prior aligned\\n    /// writes. The writes are completely unsafe, the caller MUST ensure that\\n    /// sufficient memory is allocated and reading/writing the requested number\\n    /// of bytes from/to the requested locations WILL NOT corrupt memory in the\\n    /// opinion of solidity or other subsequent read/write operations.\\n    /// @param inputCursor_ The starting location in memory to read from.\\n    /// @param outputCursor_ The starting location in memory to write to.\\n    /// @param remaining_ The number of bytes to read/write.\\n    function unsafeCopyBytesTo(\\n        uint256 inputCursor_,\\n        uint256 outputCursor_,\\n        uint256 remaining_\\n    ) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n\\n            } iszero(lt(remaining_, 0x20)) {\\n                remaining_ := sub(remaining_, 0x20)\\n                inputCursor_ := add(inputCursor_, 0x20)\\n                outputCursor_ := add(outputCursor_, 0x20)\\n            } {\\n                mstore(outputCursor_, mload(inputCursor_))\\n            }\\n\\n            if gt(remaining_, 0) {\\n                let mask_ := shr(\\n                    mul(remaining_, 8),\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n                // preserve existing bytes\\n                mstore(\\n                    outputCursor_,\\n                    or(\\n                        // input\\n                        and(mload(inputCursor_), not(mask_)),\\n                        and(mload(outputCursor_), mask_)\\n                    )\\n                )\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x613125e88688bca7d52cc48447a70fd2a17b3a120ef41c7c61092b3b523aa121\",\"license\":\"CAL\"},\"contracts/chainlink/LibChainlink.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../math/FixedPointMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nlibrary LibChainlink {\\n    using SafeCast for int256;\\n    using FixedPointMath for uint256;\\n\\n    function price(\\n        address feed_,\\n        uint256 staleAfter_\\n    ) internal view returns (uint256) {\\n        (, int256 answer_, , uint256 updatedAt_, ) = AggregatorV3Interface(\\n            feed_\\n        ).latestRoundData();\\n        require(answer_ > 0, \\\"MIN_BASE_PRICE\\\");\\n        // Checked time comparison ensures no updates from the future as that\\n        // would overflow, and no stale prices.\\n        // solhint-disable-next-line not-rely-on-time\\n        require(block.timestamp - updatedAt_ < staleAfter_, \\\"STALE_PRICE\\\");\\n\\n        // Safely cast the answer to uint and scale it to 18 decimal FP.\\n        return\\n            answer_.toUint256().scale18(\\n                AggregatorV3Interface(feed_).decimals()\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xc9af5aa3575581949fe9b128f52d324732711de59098fa639100b2e136c28ce8\",\"license\":\"CAL\"},\"contracts/idempotent/LibIdempotentFlag.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../math/Binary.sol\\\";\\n\\ntype IdempotentFlag is uint256;\\n\\nlibrary LibIdempotentFlag {\\n    using LibIdempotentFlag for IdempotentFlag;\\n\\n    function get(\\n        IdempotentFlag flag_,\\n        uint256 index_\\n    ) internal pure returns (bool) {\\n        return (IdempotentFlag.unwrap(flag_) >> index_) & 0x01 > 0;\\n    }\\n\\n    function set(\\n        IdempotentFlag flag_,\\n        uint256 index_\\n    ) internal pure returns (IdempotentFlag) {\\n        return\\n            IdempotentFlag.wrap(\\n                IdempotentFlag.unwrap(flag_) | (0x01 << index_)\\n            );\\n    }\\n\\n    modifier only16x16(uint256 column_, uint256 row_) {\\n        require(column_ < 16, \\\"OOB_COLUMN\\\");\\n        require(row_ < 16, \\\"OOB_ROW\\\");\\n        _;\\n    }\\n\\n    function get16x16(\\n        IdempotentFlag flag_,\\n        uint256 column_,\\n        uint256 row_\\n    ) internal pure only16x16(column_, row_) returns (bool) {\\n        unchecked {\\n            return flag_.get(column_ * 16 + row_);\\n        }\\n    }\\n\\n    function set16x16(\\n        IdempotentFlag flag_,\\n        uint256 column_,\\n        uint256 row_\\n    ) internal pure only16x16(column_, row_) returns (IdempotentFlag) {\\n        unchecked {\\n            return flag_.set(column_ * 16 + row_);\\n        }\\n    }\\n\\n    function set16x16Column(\\n        IdempotentFlag flag_,\\n        uint column_\\n    ) internal pure only16x16(column_, 0) returns (IdempotentFlag) {\\n        unchecked {\\n            return\\n                IdempotentFlag.wrap(\\n                    IdempotentFlag.unwrap(flag_) |\\n                        (MASK_16BIT << (column_ * 16))\\n                );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9801e9d4e870ff660f8c77c5d10ecc7234e81ca8059ff1cc2ce87e0f9e655219\",\"license\":\"CAL\"},\"contracts/ierc3156/IERC3156FlashBorrower.sol\":{\"content\":\"// SPDX-License-Identifier: CC0\\n// Alberto Cuesta Ca\\u00f1ada, Fiona Kobayashi, fubuloubu, Austin Williams, \\\"EIP-3156: Flash Loans,\\\" Ethereum Improvement Proposals, no. 3156, November 2020. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-3156.\\npragma solidity ^0.7.0 || ^0.8.0;\\n\\ninterface IERC3156FlashBorrower {\\n    /**\\n     * @dev Receive a flash loan.\\n     * @param initiator The initiator of the loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param fee The additional amount of tokens to repay.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     * @return The keccak256 hash of \\\"ERC3156FlashBorrower.onFlashLoan\\\"\\n     */\\n    function onFlashLoan(\\n        address initiator,\\n        address token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external returns (bytes32);\\n}\\n\",\"keccak256\":\"0x71f8d75d1a956893c99fccb4e994279a0fcbc73ad226d957c74b76c85f1c014a\",\"license\":\"CC0\"},\"contracts/ierc3156/IERC3156FlashLender.sol\":{\"content\":\"// SPDX-License-Identifier: CC0\\n// Alberto Cuesta Ca\\u00f1ada, Fiona Kobayashi, fubuloubu, Austin Williams, \\\"EIP-3156: Flash Loans,\\\" Ethereum Improvement Proposals, no. 3156, November 2020. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-3156.\\npragma solidity ^0.7.0 || ^0.8.0;\\nimport \\\"./IERC3156FlashBorrower.sol\\\";\\n\\ninterface IERC3156FlashLender {\\n    /**\\n     * @dev The amount of currency available to be lent.\\n     * @param token The loan currency.\\n     * @return The amount of `token` that can be borrowed.\\n     */\\n    function maxFlashLoan(address token) external view returns (uint256);\\n\\n    /**\\n     * @dev The fee to be charged for a given loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\\n     */\\n    function flashFee(\\n        address token,\\n        uint256 amount\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Initiate a flash loan.\\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     */\\n    function flashLoan(\\n        IERC3156FlashBorrower receiver,\\n        address token,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x1f9589c8e34d7c06edb509a061696199bb61c93ea10eb2f8bf7f5f362792c263\",\"license\":\"CC0\"},\"contracts/interpreter/deploy/IExpressionDeployerV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\n/// Config required to build a new `State`.\\n/// @param sources Sources verbatim.\\n/// @param constants Constants verbatim.\\nstruct StateConfig {\\n    bytes[] sources;\\n    uint256[] constants;\\n}\\n\\ninterface IExpressionDeployerV1 {\\n    function deployExpression(\\n        StateConfig memory config,\\n        uint[] memory minOutputs\\n    ) external returns (address expressionAddress, uint256 contextReads);\\n}\\n\",\"keccak256\":\"0x18d15ac73258fd9845212e31baeb8b5bd105cd815f7b622cf6450e1b7e007937\",\"license\":\"CAL\"},\"contracts/interpreter/deploy/IRainInterpreterIntegrity.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"./IExpressionDeployerV1.sol\\\";\\nimport \\\"./LibIntegrityState.sol\\\";\\n\\ninterface IRainInterpreterIntegrity {\\n    function ensureIntegrity(\\n        bytes[] memory sources,\\n        uint256 constantsLength,\\n        uint[] memory minStackOutputs\\n    ) external view returns (uint256 contextReads, uint256 stackLength);\\n}\\n\",\"keccak256\":\"0x7f14e32deab29142659dfc44f11bb20a2f98d0d9822dfaf3c9d58aed584a7a63\",\"license\":\"CAL\"},\"contracts/interpreter/deploy/LibIntegrityState.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../run/RainInterpreter.sol\\\";\\nimport \\\"../run/LibStackTop.sol\\\";\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\n\\nimport \\\"../run/IInterpreterV1.sol\\\";\\n\\nstruct IntegrityState {\\n    // Sources first as we read it in assembly.\\n    bytes[] sources;\\n    uint256 constantsLength;\\n    StackTop stackBottom;\\n    StackTop stackMaxTop;\\n    uint256 contextReads;\\n    function(IntegrityState memory, Operand, StackTop)\\n        view\\n        returns (StackTop)[] integrityFunctionPointers;\\n}\\n\\nlibrary LibIntegrityState {\\n    using LibIntegrityState for IntegrityState;\\n    using LibStackTop for StackTop;\\n    using Math for uint256;\\n\\n    function syncStackMaxTop(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_\\n    ) internal pure {\\n        if (\\n            StackTop.unwrap(stackTop_) >\\n            StackTop.unwrap(integrityState_.stackMaxTop)\\n        ) {\\n            integrityState_.stackMaxTop = stackTop_;\\n        }\\n    }\\n\\n    function ensureIntegrity(\\n        IntegrityState memory integrityState_,\\n        SourceIndex sourceIndex_,\\n        StackTop stackTop_,\\n        uint minStackOutputs_\\n    ) internal view returns (StackTop) {\\n        unchecked {\\n            uint256 cursor_;\\n            uint256 end_;\\n            assembly (\\\"memory-safe\\\") {\\n                cursor_ := mload(\\n                    add(\\n                        mload(integrityState_),\\n                        add(0x20, mul(0x20, sourceIndex_))\\n                    )\\n                )\\n                end_ := add(cursor_, mload(cursor_))\\n            }\\n\\n            // Loop until complete.\\n            while (cursor_ < end_) {\\n                uint256 opcode_;\\n                Operand operand_;\\n                cursor_ += 4;\\n                assembly (\\\"memory-safe\\\") {\\n                    let op_ := mload(cursor_)\\n                    operand_ := and(op_, 0xFFFF)\\n                    opcode_ := and(shr(16, op_), 0xFFFF)\\n                }\\n                // We index into the function pointers here to ensure that any\\n                // opcodes that we don't have a pointer for will error.\\n                stackTop_ = integrityState_.integrityFunctionPointers[opcode_](\\n                    integrityState_,\\n                    operand_,\\n                    stackTop_\\n                );\\n            }\\n            require(\\n                minStackOutputs_ <=\\n                    integrityState_.stackBottom.toIndex(stackTop_),\\n                \\\"MIN_FINAL_STACK\\\"\\n            );\\n            return stackTop_;\\n        }\\n    }\\n\\n    function push(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop stackTopAfter_) {\\n        stackTopAfter_ = stackTop_.up();\\n        integrityState_.syncStackMaxTop(stackTopAfter_);\\n    }\\n\\n    function push(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        uint256 n_\\n    ) internal pure returns (StackTop stackTopAfter_) {\\n        stackTopAfter_ = stackTop_.up(n_);\\n        integrityState_.syncStackMaxTop(stackTopAfter_);\\n    }\\n\\n    function popUnderflowCheck(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_\\n    ) internal pure {\\n        require(\\n            // Stack bottom may be non-zero so check we are above it.\\n            (StackTop.unwrap(stackTop_) >=\\n                StackTop.unwrap(integrityState_.stackBottom)) &&\\n                // If we underflowed zero then we will be above the stack max\\n                // top. Assumes that at least 1 item was popped so we can do a\\n                // strict inequality check here.\\n                (StackTop.unwrap(stackTop_) <\\n                    StackTop.unwrap(integrityState_.stackMaxTop)),\\n            \\\"STACK_UNDERFLOW\\\"\\n        );\\n    }\\n\\n    function pop(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop stackTopAfter_) {\\n        stackTopAfter_ = stackTop_.down();\\n        integrityState_.popUnderflowCheck(stackTopAfter_);\\n    }\\n\\n    function pop(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        uint256 n_\\n    ) internal pure returns (StackTop) {\\n        if (n_ > 0) {\\n            stackTop_ = stackTop_.down(n_);\\n            integrityState_.popUnderflowCheck(stackTop_);\\n        }\\n        return stackTop_;\\n    }\\n\\n    function applyFnN(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256, uint256) internal view returns (uint256),\\n        uint256 n_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(integrityState_.pop(stackTop_, n_));\\n    }\\n\\n    function applyFnN(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256) internal view,\\n        uint256 n_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.pop(stackTop_, n_);\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256) internal view returns (uint256)\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(integrityState_.pop(stackTop_));\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(Operand, uint256) internal view returns (uint256)\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(integrityState_.pop(stackTop_));\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256, uint256) internal view\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.pop(stackTop_, 2);\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256, uint256) internal view returns (uint256)\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(integrityState_.pop(stackTop_, 2));\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(Operand, uint256, uint256) internal view returns (uint256)\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(integrityState_.pop(stackTop_, 2));\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256, uint256, uint256) internal view returns (uint256)\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(integrityState_.pop(stackTop_, 3));\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256, uint256, uint256, uint)\\n            internal\\n            view\\n            returns (uint256)\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(integrityState_.pop(stackTop_, 4));\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256[] memory) internal view returns (uint256),\\n        uint256 length_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(integrityState_.pop(stackTop_, length_));\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256),\\n        uint256 length_\\n    ) internal pure returns (StackTop) {\\n        unchecked {\\n            return\\n                integrityState_.push(\\n                    integrityState_.pop(stackTop_, length_ + 2)\\n                );\\n        }\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256, uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256),\\n        uint256 length_\\n    ) internal pure returns (StackTop) {\\n        unchecked {\\n            return\\n                integrityState_.push(\\n                    integrityState_.pop(stackTop_, length_ + 3)\\n                );\\n        }\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256, uint256[] memory, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256[] memory),\\n        uint256 length_\\n    ) internal pure returns (StackTop) {\\n        unchecked {\\n            return\\n                integrityState_.push(\\n                    integrityState_.pop(stackTop_, length_ * 2 + 1),\\n                    length_\\n                );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x68bdd0b5272a70e797fbe2c7bcdcfb9beb8cdba6e0b864bc637c7632999be33f\",\"license\":\"CAL\"},\"contracts/interpreter/ops/AllStandardOps.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"../../type/LibCast.sol\\\";\\nimport \\\"../../type/LibConvert.sol\\\";\\nimport \\\"../../array/LibUint256Array.sol\\\";\\nimport \\\"../run/RainInterpreter.sol\\\";\\nimport \\\"./chainlink/OpChainlinkOraclePrice.sol\\\";\\nimport \\\"./core/OpCall.sol\\\";\\nimport \\\"./core/OpSet.sol\\\";\\nimport \\\"./core/OpContext.sol\\\";\\nimport \\\"./core/OpContextRow.sol\\\";\\nimport \\\"./core/OpDebug.sol\\\";\\nimport \\\"./core/OpDoWhile.sol\\\";\\nimport \\\"./core/OpFoldContext.sol\\\";\\nimport \\\"./core/OpLoopN.sol\\\";\\nimport \\\"./core/OpReadMemory.sol\\\";\\nimport \\\"./crypto/OpHash.sol\\\";\\nimport \\\"./erc20/OpERC20BalanceOf.sol\\\";\\nimport \\\"./erc20/OpERC20TotalSupply.sol\\\";\\nimport \\\"./erc20/snapshot/OpERC20SnapshotBalanceOfAt.sol\\\";\\nimport \\\"./erc20/snapshot/OpERC20SnapshotTotalSupplyAt.sol\\\";\\nimport \\\"./erc721/OpERC721BalanceOf.sol\\\";\\nimport \\\"./erc721/OpERC721OwnerOf.sol\\\";\\nimport \\\"./erc1155/OpERC1155BalanceOf.sol\\\";\\nimport \\\"./erc1155/OpERC1155BalanceOfBatch.sol\\\";\\nimport \\\"./error/OpEnsure.sol\\\";\\nimport \\\"./evm/OpBlockNumber.sol\\\";\\nimport \\\"./evm/OpCaller.sol\\\";\\nimport \\\"./evm/OpThisAddress.sol\\\";\\nimport \\\"./evm/OpTimestamp.sol\\\";\\nimport \\\"./list/OpExplode32.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScale18.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScale18Div.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScale18Mul.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScaleBy.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScaleN.sol\\\";\\nimport \\\"./math/logic/OpAny.sol\\\";\\nimport \\\"./math/logic/OpEagerIf.sol\\\";\\nimport \\\"./math/logic/OpEqualTo.sol\\\";\\nimport \\\"./math/logic/OpEvery.sol\\\";\\nimport \\\"./math/logic/OpGreaterThan.sol\\\";\\nimport \\\"./math/logic/OpIsZero.sol\\\";\\nimport \\\"./math/logic/OpLessThan.sol\\\";\\nimport \\\"./math/saturating/OpSaturatingAdd.sol\\\";\\nimport \\\"./math/saturating/OpSaturatingMul.sol\\\";\\nimport \\\"./math/saturating/OpSaturatingSub.sol\\\";\\nimport \\\"./math/OpAdd.sol\\\";\\nimport \\\"./math/OpDiv.sol\\\";\\nimport \\\"./math/OpExp.sol\\\";\\nimport \\\"./math/OpMax.sol\\\";\\nimport \\\"./math/OpMin.sol\\\";\\nimport \\\"./math/OpMod.sol\\\";\\nimport \\\"./math/OpMul.sol\\\";\\nimport \\\"./math/OpSub.sol\\\";\\nimport \\\"./rain/IOrderBookV1/OpIOrderBookV1VaultBalance.sol\\\";\\nimport \\\"./rain/ISaleV2/OpISaleV2RemainingTokenInventory.sol\\\";\\nimport \\\"./rain/ISaleV2/OpISaleV2Reserve.sol\\\";\\nimport \\\"./rain/ISaleV2/OpISaleV2SaleStatus.sol\\\";\\nimport \\\"./rain/ISaleV2/OpISaleV2Token.sol\\\";\\nimport \\\"./rain/ISaleV2/OpISaleV2TotalReserveReceived.sol\\\";\\nimport \\\"./tier/OpITierV2Report.sol\\\";\\nimport \\\"./tier/OpITierV2ReportTimeForTier.sol\\\";\\nimport \\\"./tier/OpSaturatingDiff.sol\\\";\\nimport \\\"./tier/OpSelectLte.sol\\\";\\nimport \\\"./tier/OpUpdateTimesForTierRange.sol\\\";\\n\\nuint256 constant ALL_STANDARD_OPS_LENGTH = 59;\\n\\n/// @title AllStandardOps\\n/// @notice RainInterpreter opcode pack to expose all other packs.\\nlibrary AllStandardOps {\\n    using LibCast for uint256;\\n    using LibCast for function(uint256) pure returns (uint256);\\n    using LibCast for function(InterpreterState memory, uint256, StackTop)\\n        view\\n        returns (StackTop);\\n    using LibCast for function(InterpreterState memory, uint256, StackTop)\\n        pure\\n        returns (StackTop);\\n    using LibCast for function(InterpreterState memory, uint256, StackTop)\\n        view\\n        returns (StackTop)[];\\n\\n    using AllStandardOps for function(IntegrityState memory, Operand, StackTop)\\n        view\\n        returns (StackTop)[ALL_STANDARD_OPS_LENGTH + 1];\\n    using AllStandardOps for function(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop\\n    ) view returns (StackTop)[ALL_STANDARD_OPS_LENGTH + 1];\\n\\n    using AllStandardOps for uint256[ALL_STANDARD_OPS_LENGTH + 1];\\n\\n    using LibUint256Array for uint256[];\\n    using LibConvert for uint256[];\\n    using LibCast for uint256[];\\n    using LibCast for function(IntegrityState memory, Operand, StackTop)\\n        view\\n        returns (StackTop);\\n    using LibCast for function(IntegrityState memory, Operand, StackTop)\\n        pure\\n        returns (StackTop);\\n    using LibCast for function(IntegrityState memory, Operand, StackTop)\\n        view\\n        returns (StackTop)[];\\n    using LibCast for function(InterpreterState memory, Operand, StackTop)\\n        view\\n        returns (StackTop)[];\\n\\n    /// An oddly specific conversion between a fixed and dynamic uint256 array.\\n    /// This is useful for the purpose of building metadata for bounds checks\\n    /// and dispatch of all the standard ops provided by RainInterpreter.\\n    /// The cast will fail if the length of the dynamic array doesn't match the\\n    /// first item of the fixed array; it relies on differences in memory\\n    /// layout in Solidity that MAY change in the future. The rollback guards\\n    /// against changes in Solidity memory layout silently breaking this cast.\\n    /// @param fixed_ The fixed size uint array to cast to a dynamic uint array.\\n    /// Specifically the size is fixed to match the number of standard ops.\\n    /// @param dynamic_ The dynamic uint array with length of the standard ops.\\n    function asUint256Array(\\n        function(IntegrityState memory, Operand, StackTop)\\n            view\\n            returns (StackTop)[ALL_STANDARD_OPS_LENGTH + 1]\\n            memory fixed_\\n    ) internal pure returns (uint256[] memory dynamic_) {\\n        assembly (\\\"memory-safe\\\") {\\n            dynamic_ := fixed_\\n        }\\n        require(\\n            dynamic_.length == ALL_STANDARD_OPS_LENGTH,\\n            \\\"BAD_DYNAMIC_LENGTH\\\"\\n        );\\n    }\\n\\n    function asUint256Array(\\n        function(InterpreterState memory, Operand, StackTop)\\n            view\\n            returns (StackTop)[ALL_STANDARD_OPS_LENGTH + 1]\\n            memory fixed_\\n    ) internal pure returns (uint256[] memory dynamic_) {\\n        assembly (\\\"memory-safe\\\") {\\n            dynamic_ := fixed_\\n        }\\n        require(\\n            dynamic_.length == ALL_STANDARD_OPS_LENGTH,\\n            \\\"BAD_DYNAMIC_LENGTH\\\"\\n        );\\n    }\\n\\n    function integrityFunctionPointers(\\n        function(IntegrityState memory, Operand, StackTop)\\n            view\\n            returns (StackTop)[]\\n            memory locals_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(IntegrityState memory, Operand, StackTop)\\n                view\\n                returns (StackTop)[]\\n                memory\\n        )\\n    {\\n        unchecked {\\n            function(IntegrityState memory, Operand, StackTop)\\n                view\\n                returns (StackTop)[ALL_STANDARD_OPS_LENGTH + 1]\\n                memory pointersFixed_ = [\\n                    ALL_STANDARD_OPS_LENGTH.asIntegrityFunctionPointer(),\\n                    OpChainlinkOraclePrice.integrity,\\n                    OpCall.integrity,\\n                    OpContext.integrity,\\n                    OpContextRow.integrity,\\n                    OpDebug.integrity,\\n                    OpDoWhile.integrity,\\n                    OpFoldContext.integrity,\\n                    OpLoopN.integrity,\\n                    OpReadMemory.integrity,\\n                    OpSet.integrity,\\n                    OpHash.integrity,\\n                    OpERC20BalanceOf.integrity,\\n                    OpERC20TotalSupply.integrity,\\n                    OpERC20SnapshotBalanceOfAt.integrity,\\n                    OpERC20SnapshotTotalSupplyAt.integrity,\\n                    OpERC721BalanceOf.integrity,\\n                    OpERC721OwnerOf.integrity,\\n                    OpERC1155BalanceOf.integrity,\\n                    OpERC1155BalanceOfBatch.integrity,\\n                    OpEnsure.integrity,\\n                    OpBlockNumber.integrity,\\n                    OpCaller.integrity,\\n                    OpThisAddress.integrity,\\n                    OpTimestamp.integrity,\\n                    OpExplode32.integrity,\\n                    OpFixedPointScale18.integrity,\\n                    OpFixedPointScale18Div.integrity,\\n                    OpFixedPointScale18Mul.integrity,\\n                    OpFixedPointScaleBy.integrity,\\n                    OpFixedPointScaleN.integrity,\\n                    OpAny.integrity,\\n                    OpEagerIf.integrity,\\n                    OpEqualTo.integrity,\\n                    OpEvery.integrity,\\n                    OpGreaterThan.integrity,\\n                    OpIsZero.integrity,\\n                    OpLessThan.integrity,\\n                    OpSaturatingAdd.integrity,\\n                    OpSaturatingMul.integrity,\\n                    OpSaturatingSub.integrity,\\n                    OpAdd.integrity,\\n                    OpDiv.integrity,\\n                    OpExp.integrity,\\n                    OpMax.integrity,\\n                    OpMin.integrity,\\n                    OpMod.integrity,\\n                    OpMul.integrity,\\n                    OpSub.integrity,\\n                    OpIOrderBookV1VaultBalance.integrity,\\n                    OpISaleV2RemainingTokenInventory.integrity,\\n                    OpISaleV2Reserve.integrity,\\n                    OpISaleV2SaleStatus.integrity,\\n                    OpISaleV2Token.integrity,\\n                    OpISaleV2TotalReserveReceived.integrity,\\n                    OpITierV2Report.integrity,\\n                    OpITierV2ReportTimeForTier.integrity,\\n                    OpSaturatingDiff.integrity,\\n                    OpSelectLte.integrity,\\n                    OpUpdateTimesForTierRange.integrity\\n                ];\\n            uint256[] memory pointers_ = pointersFixed_.asUint256Array();\\n            pointers_.extend(locals_.asUint256Array());\\n            return pointers_.asIntegrityPointers();\\n        }\\n    }\\n\\n    function opcodeFunctionPointers(\\n        function(InterpreterState memory, Operand, StackTop)\\n            view\\n            returns (StackTop)[]\\n            memory locals_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(InterpreterState memory, Operand, StackTop)\\n                view\\n                returns (StackTop)[]\\n                memory opcodeFunctionPointers_\\n        )\\n    {\\n        unchecked {\\n            function(InterpreterState memory, Operand, StackTop)\\n                view\\n                returns (StackTop)[ALL_STANDARD_OPS_LENGTH + 1]\\n                memory pointersFixed_ = [\\n                    ALL_STANDARD_OPS_LENGTH.asOpFunctionPointer(),\\n                    OpChainlinkOraclePrice.price,\\n                    OpCall.run,\\n                    OpContext.run,\\n                    OpContextRow.run,\\n                    OpDebug.debug,\\n                    OpDoWhile.run,\\n                    OpFoldContext.run,\\n                    OpLoopN.run,\\n                    OpReadMemory.run,\\n                    OpSet.run,\\n                    OpHash.hash,\\n                    OpERC20BalanceOf.balanceOf,\\n                    OpERC20TotalSupply.totalSupply,\\n                    OpERC20SnapshotBalanceOfAt.balanceOfAt,\\n                    OpERC20SnapshotTotalSupplyAt.totalSupplyAt,\\n                    OpERC721BalanceOf.balanceOf,\\n                    OpERC721OwnerOf.ownerOf,\\n                    OpERC1155BalanceOf.balanceOf,\\n                    OpERC1155BalanceOfBatch.balanceOfBatch,\\n                    OpEnsure.ensure,\\n                    OpBlockNumber.blockNumber,\\n                    OpCaller.caller,\\n                    OpThisAddress.thisAddress,\\n                    OpTimestamp.timestamp,\\n                    OpExplode32.explode32,\\n                    OpFixedPointScale18.scale18,\\n                    OpFixedPointScale18Div.scale18Div,\\n                    OpFixedPointScale18Mul.scale18Mul,\\n                    OpFixedPointScaleBy.scaleBy,\\n                    OpFixedPointScaleN.scaleN,\\n                    OpAny.any,\\n                    OpEagerIf.eagerIf,\\n                    OpEqualTo.equalTo,\\n                    OpEvery.every,\\n                    OpGreaterThan.greaterThan,\\n                    OpIsZero.isZero,\\n                    OpLessThan.lessThan,\\n                    OpSaturatingAdd.saturatingAdd,\\n                    OpSaturatingMul.saturatingMul,\\n                    OpSaturatingSub.saturatingSub,\\n                    OpAdd.add,\\n                    OpDiv.div,\\n                    OpExp.exp,\\n                    OpMax.max,\\n                    OpMin.min,\\n                    OpMod.mod,\\n                    OpMul.mul,\\n                    OpSub.sub,\\n                    OpIOrderBookV1VaultBalance.run,\\n                    OpISaleV2RemainingTokenInventory.run,\\n                    OpISaleV2Reserve.run,\\n                    OpISaleV2SaleStatus.run,\\n                    OpISaleV2Token.run,\\n                    OpISaleV2TotalReserveReceived.run,\\n                    OpITierV2Report.report,\\n                    OpITierV2ReportTimeForTier.reportTimeForTier,\\n                    OpSaturatingDiff.saturatingDiff,\\n                    OpSelectLte.selectLte,\\n                    OpUpdateTimesForTierRange.updateTimesForTierRange\\n                ];\\n            uint256[] memory pointers_ = pointersFixed_.asUint256Array();\\n            pointers_.extend(locals_.asUint256Array());\\n            opcodeFunctionPointers_ = pointers_.asOpcodeFunctionPointers();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x764fe327275070c5d6b3c46162373094f8dcfd5f9c602cb0a863420b8eb3ada1\",\"license\":\"CAL\"},\"contracts/interpreter/ops/chainlink/OpChainlinkOraclePrice.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {LibChainlink} from \\\"../../../chainlink/LibChainlink.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpChainlinkOraclePrice\\n/// @notice Opcode for chainlink oracle prices.\\nlibrary OpChainlinkOraclePrice {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _price(\\n        uint256 feed_,\\n        uint256 staleAfter_\\n    ) internal view returns (uint256) {\\n        return LibChainlink.price(address(uint160(feed_)), staleAfter_);\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _price);\\n    }\\n\\n    function price(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_price);\\n    }\\n}\\n\",\"keccak256\":\"0x914a4b322b831d81d26852d554807cb1f7e43f13cdf3cde8e13da4c591bc9f12\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpCall.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\nimport \\\"../../../math/Binary.sol\\\";\\n\\n/// @title OpCall\\n/// @notice Opcode for calling eval with a new scope. The construction of this\\n/// scope is split across integrity and runtime responsibilities. When the\\n/// integrity checks are done the expression being called has all its integrity\\n/// logic run, recursively if needed. The integrity checks are run against the\\n/// integrity state as it is but with the stack bottom set below the inputs to\\n/// the called source. This ensures that the sub-integrity checks do not\\n/// underflow what they perceive as a fresh stack, and it ensures that we set the\\n/// stack length long enough to cover all sub-executions as a single array in\\n/// memory. At runtime we trust the integrity checks have allocated enough runway\\n/// in the stack for all our recursive sub-calls so we simply move the stack\\n/// bottom in the state below the inputs during the call and move it back to\\n/// where it was after the call. Notably this means that reading from the stack\\n/// in the called source will 0 index from the first input, NOT the bottom of\\n/// the calling stack.\\nlibrary OpCall {\\n    using LibIntegrityState for IntegrityState;\\n    using LibStackTop for StackTop;\\n    using LibInterpreterState for InterpreterState;\\n    using LibUint256Array for uint;\\n\\n    /// Interpreter integrity logic.\\n    /// The basic movements on the outer stack are to pop the inputs and push the\\n    /// outputs, but the called source doesn't have access to a separately\\n    /// allocated region of memory. There's only a single shared memory\\n    /// allocation for all executions and sub-executions, so we recursively run\\n    /// integrity checks on the called source relative to the current stack\\n    /// position.\\n    /// @param integrityState_ The state of the current integrity check.\\n    /// @param operand_ The operand associated with this call.\\n    /// @param stackTop_ The current stack top within the integrity check.\\n    /// @return stackTopAfter_ The stack top after the call movements are applied.\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        // Unpack the operand to get IO and the source to be called.\\n        uint256 inputs_ = Operand.unwrap(operand_) & MASK_4BIT;\\n        uint256 outputs_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\\n        SourceIndex callSourceIndex_ = SourceIndex.wrap(\\n            Operand.unwrap(operand_) >> 8\\n        );\\n\\n        // Remember the outer stack bottom.\\n        StackTop stackBottom_ = integrityState_.stackBottom;\\n\\n        // Set the inner stack bottom to below the inputs.\\n        integrityState_.stackBottom = integrityState_.pop(stackTop_, inputs_);\\n\\n        // Ensure the integrity of the inner source on the current state using\\n        // the stack top above the inputs as the starting stack top.\\n        // Contraints namespace is irrelevant here.\\n        integrityState_.ensureIntegrity(callSourceIndex_, stackTop_, outputs_);\\n\\n        // The outer stack top will move above the outputs relative to the inner\\n        // stack bottom. At runtime any values that are not outputs will be\\n        // removed so they do not need to be accounted for here.\\n        stackTopAfter_ = integrityState_.push(\\n            integrityState_.stackBottom,\\n            outputs_\\n        );\\n\\n        // Reinstate the outer stack bottom.\\n        integrityState_.stackBottom = stackBottom_;\\n    }\\n\\n    /// Call eval with a new scope.\\n    /// @param state_ The state of the current evaluation.\\n    /// @param operand_ The operand associated with this call.\\n    /// @param stackTop_ The current stack top within the evaluation.\\n    /// @return stackTopAfter_ The stack top after the call is evaluated.\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        // Unpack the operand to get IO and the source to be called.\\n        uint256 inputs_ = Operand.unwrap(operand_) & MASK_4BIT;\\n        uint256 outputs_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\\n        SourceIndex callSourceIndex_ = SourceIndex.wrap(\\n            Operand.unwrap(operand_) >> 8\\n        );\\n\\n        // Remember the outer stack bottom.\\n        StackTop stackBottom_ = state_.stackBottom;\\n\\n        // Set the inner stack bottom to below the inputs.\\n        state_.stackBottom = stackTop_.down(inputs_);\\n\\n        // Eval the source from the operand on the current state using the stack\\n        // top above the inputs as the starting stack top. The final stack top\\n        // is where we will read outputs from below.\\n        StackTop stackTopEval_ = state_.eval(callSourceIndex_, stackTop_);\\n        // Normalize the inner final stack so that it contains only the outputs\\n        // starting from the inner stack bottom.\\n        LibUint256Array.unsafeCopyValuesTo(\\n            StackTop.unwrap(stackTopEval_.down(outputs_)),\\n            StackTop.unwrap(state_.stackBottom),\\n            outputs_\\n        );\\n\\n        // The outer stack top should now point above the outputs.\\n        stackTopAfter_ = state_.stackBottom.up(outputs_);\\n\\n        // The outer stack bottom needs to be reinstated as it was before eval.\\n        state_.stackBottom = stackBottom_;\\n    }\\n}\\n\",\"keccak256\":\"0xfe1bee408385509ce8992af7496f8f811a9915834d17a9eaeb8de5ba11ca9c55\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpContext.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\nimport \\\"../../../idempotent/LibIdempotentFlag.sol\\\";\\nimport \\\"../../../math/Binary.sol\\\";\\n\\n/// @title OpContext\\n/// @notice Opcode for stacking from the context. Context requires slightly\\n/// different handling to other memory reads as it is working with data that\\n/// is provided at runtime.\\nlibrary OpContext {\\n    using LibStackTop for StackTop;\\n    using LibInterpreterState for InterpreterState;\\n    using LibIntegrityState for IntegrityState;\\n\\n    /// Interpreter integrity logic.\\n    /// Context pushes a single value to the stack from memory.\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        uint256 row_ = Operand.unwrap(operand_) & MASK_8BIT;\\n        uint256 column_ = Operand.unwrap(operand_) >> 8;\\n        integrityState_.contextReads = IdempotentFlag.unwrap(\\n            LibIdempotentFlag.set16x16(\\n                IdempotentFlag.wrap(integrityState_.contextReads),\\n                column_,\\n                row_\\n            )\\n        );\\n        // Note that a expression with context can error at runtime due to OOB\\n        // reads that we don't know about here.\\n        return integrityState_.push(stackTop_);\\n    }\\n\\n    /// Stack a value from the context WITH OOB checks from solidity.\\n    /// The bounds checks are done at runtime because context MAY be provided\\n    /// by the end user with arbitrary length.\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        // The indexing syntax here enforces OOB checks at runtime.\\n        return\\n            stackTop_.push(\\n                state_.context[Operand.unwrap(operand_) >> 8][\\n                    Operand.unwrap(operand_) & MASK_8BIT\\n                ]\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x1618e7301e4758a25512e0c60bea38ac2110387a0e758d446f1673a18db087ff\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpContextRow.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\nimport \\\"../../../idempotent/LibIdempotentFlag.sol\\\";\\nimport \\\"../../../math/Binary.sol\\\";\\n\\n/// @title OpContextRow\\n/// @notice Opcode for stacking a dynamic row from the context. Context requires\\n/// slightly different handling to other memory reads as it is working with data\\n/// that is provided at runtime. `OpContextRow` works exactly like `OpContext`\\n/// but the row is provided from the stack instead of the operand. We rely on\\n/// Solidity OOB checks at runtime to enforce that the index from the stack is\\n/// within bounds at runtime. As we do NOT know statically which row will be read\\n/// the context reads is set to the entire column.\\nlibrary OpContextRow {\\n    using LibStackTop for StackTop;\\n    using LibInterpreterState for InterpreterState;\\n    using LibIntegrityState for IntegrityState;\\n\\n    /// Interpreter integrity logic.\\n    /// Context pushes a single value to the stack from memory.\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        uint256 column_ = Operand.unwrap(operand_);\\n        integrityState_.contextReads = IdempotentFlag.unwrap(\\n            LibIdempotentFlag.set16x16Column(\\n                IdempotentFlag.wrap(integrityState_.contextReads),\\n                column_\\n            )\\n        );\\n        // Note that a expression with context can error at runtime due to OOB\\n        // reads that we don't know about here.\\n        function(uint) internal pure returns (uint) fn_;\\n        return integrityState_.applyFn(stackTop_, fn_);\\n    }\\n\\n    /// Stack a value from the context WITH OOB checks from solidity.\\n    /// The bounds checks are done at runtime because context MAY be provided\\n    /// by the end user with arbitrary length.\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        // The indexing syntax here enforces OOB checks at runtime.\\n        (StackTop location_, uint row_) = stackTop_.pop();\\n        location_.set(state_.context[Operand.unwrap(operand_)][row_]);\\n        return stackTop_;\\n    }\\n}\\n\",\"keccak256\":\"0x097accc802b04d8558923b2c8d1ac4029d442062e43d545a611ddcf72eb9fd6a\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpDebug.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpDebug\\n/// @notice Opcode for debugging state. Uses the standard debugging logic from\\n/// InterpreterState.debug.\\nlibrary OpDebug {\\n    using LibStackTop for StackTop;\\n    using LibInterpreterState for InterpreterState;\\n\\n    /// Interpreter integrity for debug.\\n    /// Debug doesn't modify the stack.\\n    function integrity(\\n        IntegrityState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        // Try to build a debug style from the operand to ensure we can enumerate\\n        // it.\\n        DebugStyle(Operand.unwrap(operand_));\\n        return stackTop_;\\n    }\\n\\n    /// Debug the current state.\\n    function debug(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        DebugStyle debugStyle_ = DebugStyle(Operand.unwrap(operand_));\\n\\n        state_.debug(stackTop_, debugStyle_);\\n\\n        return stackTop_;\\n    }\\n}\\n\",\"keccak256\":\"0x7316fc6e8e238bc58668bd41a6dce0dc92d270a83792e969b7e5a8d417391a0d\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpDoWhile.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\nimport \\\"./OpCall.sol\\\";\\n\\n/// @title OpWhile\\n/// @notice Opcode for looping while the stack top is nonzero. As we pre-allocate\\n/// all the memory for execution during integrity checks we have an apparent\\n/// contradiction here. If we do not know how many times the loop will run then\\n/// we cannot calculate the final stack height or intermediate pops and pushes.\\n/// To solve this we simply wrap `OpCall` which already has fixed inputs and\\n/// outputs and enforce that the outputs of each iteration is 1 more than the\\n/// inputs. We then consume the extra output as the condition for the decision\\n/// to loop again, thus the outputs = inputs for every iteration. If the stack\\n/// height does not change between iterations we do not care how many times we\\n/// loop (although the user paying gas might).\\nlibrary OpDoWhile {\\n    using LibIntegrityState for IntegrityState;\\n    using LibStackTop for StackTop;\\n    using LibInterpreterState for InterpreterState;\\n\\n    /// Interpreter integrity for do while.\\n    /// The loop itself pops a single value from the stack to determine whether\\n    /// it should run another iteration of the loop. The source called by the\\n    /// loop must then put a value back on the stack in the same position to\\n    /// either continue or break the loop.\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        unchecked {\\n            uint inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\\n            /// We need outputs to be larger than inputs so inputs can't be the\\n            /// max value possible in 4 bits or outputs will overflow.\\n            require(inputs_ < MASK_4BIT, \\\"OP_DO_WHILE_INPUTS\\\");\\n            uint outputs_ = inputs_ + 1;\\n            Operand callOperand_ = Operand.wrap(\\n                Operand.unwrap(operand_) | (outputs_ << 4)\\n            );\\n            // Stack height changes are deterministic so if we call once we've\\n            // called a thousand times. Also we pop one output off the result of\\n            // the call to check the while condition.\\n            return\\n                integrityState_.pop(\\n                    OpCall.integrity(integrityState_, callOperand_, stackTop_)\\n                );\\n        }\\n    }\\n\\n    /// Loop the stack while the stack top is true.\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        unchecked {\\n            uint inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\\n            uint outputs_ = inputs_ + 1;\\n            Operand callOperand_ = Operand.wrap(\\n                Operand.unwrap(operand_) | (outputs_ << 4)\\n            );\\n            uint256 do_;\\n            (stackTop_, do_) = stackTop_.pop();\\n            while (do_ > 0) {\\n                stackTop_ = OpCall.run(state_, callOperand_, stackTop_);\\n                (stackTop_, do_) = stackTop_.pop();\\n            }\\n            return stackTop_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x440f21cc502c08900e6e508d9108a0871cc8040f9613afded5a11687c288be88\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpFoldContext.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\nimport \\\"./OpCall.sol\\\";\\nimport \\\"../../../idempotent/LibIdempotentFlag.sol\\\";\\n\\n/// @title OpFoldContext\\n/// Folds over columns of context from their start to end. Expressions do not\\n/// have a good way of handling dynamic lengths of things, and that is\\n/// intentional to avoid end users having to write out looping constructs of the\\n/// form `i = 0; i < length; i++` is is so tedious and error prone in software\\n/// development generally. It is very easy to implement \\\"off by one\\\" errors in\\n/// this form, and requires sourcing a length from somewhere. This opcode exposes\\n/// a pretty typical fold as found elsewhere in functional programming. A start\\n/// column and width of columns can be specified, the rows will be iterated and\\n/// pushed to the stack on top of any additional inputs specified by the\\n/// expression. The additional inputs are the accumulators and so the number of\\n/// outputs in the called source needs to match the number of accumulator inputs.\\nlibrary OpFoldContext {\\n    using LibIntegrityState for IntegrityState;\\n    using LibStackTop for StackTop;\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        unchecked {\\n            uint sourceIndex_ = Operand.unwrap(operand_) & MASK_4BIT;\\n            uint column_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\\n            uint width_ = (Operand.unwrap(operand_) >> 8) & MASK_4BIT;\\n            uint inputs_ = Operand.unwrap(operand_) >> 12;\\n            uint callInputs_ = width_ + inputs_;\\n\\n            for (uint i_ = 0; i_ < width_; i_++) {\\n                integrityState_.contextReads = IdempotentFlag.unwrap(\\n                    LibIdempotentFlag.set16x16Column(\\n                        IdempotentFlag.wrap(integrityState_.contextReads),\\n                        column_ + i_\\n                    )\\n                );\\n            }\\n\\n            Operand callOperand_ = Operand.wrap(\\n                (sourceIndex_ << 8) | (inputs_ << 4) | callInputs_\\n            );\\n\\n            // First the width of the context columns being folded is pushed to\\n            // the stack.\\n            stackTop_ = integrityState_.push(\\n                integrityState_.stackBottom,\\n                width_\\n            );\\n            // Then we loop over call taking the width and extra inputs, then\\n            // returning the same number of outputs as non-width inputs.\\n            return OpCall.integrity(integrityState_, callOperand_, stackTop_);\\n        }\\n    }\\n\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        unchecked {\\n            uint sourceIndex_ = Operand.unwrap(operand_) & MASK_4BIT;\\n            uint column_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\\n            uint width_ = (Operand.unwrap(operand_) >> 8) & MASK_4BIT;\\n            uint inputs_ = Operand.unwrap(operand_) >> 12;\\n            // Call will take the width of the context rows being copied and the\\n            // base inputs that will be the accumulators of the fold.\\n            uint callInputs_ = width_ + inputs_;\\n\\n            // Fold over the entire context. This will error with an OOB index\\n            // if the context columns are not of the same length.\\n            for (uint i_ = 0; i_ < state_.context[column_].length; i_++) {\\n                // Push the width of the context columns onto the stack as rows.\\n                for (uint j_ = 0; j_ < width_; j_++) {\\n                    stackTop_ = stackTop_.push(\\n                        state_.context[column_ + j_][i_]\\n                    );\\n                }\\n                // The outputs of call are the same as the base inputs, this is\\n                // similar to `OpDoWhile` so that we don't have to care how many\\n                // iterations there are in order to calculate the stack.\\n                Operand callOperand_ = Operand.wrap(\\n                    (sourceIndex_ << 8) | (inputs_ << 4) | callInputs_\\n                );\\n                stackTop_ = OpCall.run(state_, callOperand_, stackTop_);\\n            }\\n\\n            return stackTop_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf37a6a43dc33b99520d0051770abbbd3c3f9a1fee9ff5595fbd5f04708f7b4b8\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpLoopN.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\nimport \\\"./OpCall.sol\\\";\\n\\n/// @title OpLoopN\\n/// @notice Opcode for looping a static number of times. A thin wrapper around\\n/// `OpCall` with the 4 high bits as a number of times to loop. Each iteration\\n/// will use the outputs of the previous iteration as its inputs so the inputs\\n/// to call must be greater or equal to the outputs. If the outputs exceed the\\n/// inputs then each subsequent call will take as many inputs as it needs from\\n/// the top of the intermediate stack. The net outputs to the stack will include\\n/// all the intermediate excess outputs as:\\n/// `outputs + (inputs - outputs) * n`\\nlibrary OpLoopN {\\n    using LibStackTop for StackTop;\\n    using LibInterpreterState for InterpreterState;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        unchecked {\\n            uint n_ = Operand.unwrap(operand_) >> 12;\\n            uint inputs_ = Operand.unwrap(operand_) & MASK_4BIT;\\n            uint outputs_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\\n            require(inputs_ >= outputs_, \\\"LOOP_N_INPUTS\\\");\\n            Operand callOperand_ = Operand.wrap(\\n                Operand.unwrap(operand_) & MASK_12BIT\\n            );\\n            for (uint i_ = 0; i_ < n_; i_++) {\\n                stackTop_ = OpCall.integrity(\\n                    integrityState_,\\n                    callOperand_,\\n                    stackTop_\\n                );\\n            }\\n            return stackTop_;\\n        }\\n    }\\n\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        uint256 n_ = Operand.unwrap(operand_) >> 12;\\n        Operand callOperand_ = Operand.wrap(\\n            Operand.unwrap(operand_) & MASK_12BIT\\n        );\\n        for (uint256 i_ = 0; i_ < n_; i_++) {\\n            stackTop_ = OpCall.run(state_, callOperand_, stackTop_);\\n        }\\n        return stackTop_;\\n    }\\n}\\n\",\"keccak256\":\"0xe11a262889895d4e6a1d7161efddae26c0cc3299a453459e233d4ffc3cf5018d\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpReadMemory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\nimport \\\"../../../math/Binary.sol\\\";\\n\\nuint256 constant OPCODE_MEMORY_TYPE_STACK = 0;\\nuint256 constant OPCODE_MEMORY_TYPE_CONSTANT = 1;\\n\\n/// @title OpReadMemory\\n/// @notice Opcode for stacking from the state.\\nlibrary OpReadMemory {\\n    using LibStackTop for StackTop;\\n    using LibInterpreterState for InterpreterState;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        uint256 type_ = Operand.unwrap(operand_) & MASK_1BIT;\\n        uint256 offset_ = Operand.unwrap(operand_) >> 1;\\n        if (type_ == OPCODE_MEMORY_TYPE_STACK) {\\n            require(\\n                offset_ < integrityState_.stackBottom.toIndex(stackTop_),\\n                \\\"OOB_STACK_READ\\\"\\n            );\\n        } else {\\n            require(\\n                offset_ < integrityState_.constantsLength,\\n                \\\"OOB_CONSTANT_READ\\\"\\n            );\\n        }\\n        return integrityState_.push(stackTop_);\\n    }\\n\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        unchecked {\\n            uint256 type_ = Operand.unwrap(operand_) & MASK_1BIT;\\n            uint256 offset_ = Operand.unwrap(operand_) >> 1;\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(\\n                    stackTop_,\\n                    mload(\\n                        add(\\n                            mload(add(state_, mul(0x20, type_))),\\n                            mul(0x20, offset_)\\n                        )\\n                    )\\n                )\\n            }\\n            return StackTop.wrap(StackTop.unwrap(stackTop_) + 0x20);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x73dc3c7307f4c4baa8b8f2359f32366584ad2c3d438ca80b64efc6237661069d\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpSet.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\nimport \\\"../../../kv/LibMemoryKV.sol\\\";\\n\\n/// @title OpSet\\n/// @notice Opcode for recording k/v state changes to be set in storage.\\nlibrary OpSet {\\n    using LibStackTop for StackTop;\\n    using LibInterpreterState for InterpreterState;\\n    using LibIntegrityState for IntegrityState;\\n    using LibMemoryKV for MemoryKV;\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        unchecked {\\n            function(uint, uint) internal pure fn_;\\n            return integrityState_.applyFn(stackTop_, fn_);\\n        }\\n    }\\n\\n    function run(\\n        InterpreterState memory state_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        unchecked {\\n            uint k_;\\n            uint v_;\\n            (stackTop_, v_) = stackTop_.pop();\\n            (stackTop_, k_) = stackTop_.pop();\\n            state_.stateKV = state_.stateKV.setVal(\\n                MemoryKVKey.wrap(k_),\\n                MemoryKVVal.wrap(v_)\\n            );\\n            return stackTop_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x23a68b1fcdb0edc535d2276a7bf2ab06e11c859afc118260283c15b67a51306d\",\"license\":\"CAL\"},\"contracts/interpreter/ops/crypto/OpHash.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../../type/LibCast.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpHash\\n/// @notice Opcode for hashing a list of values.\\nlibrary OpHash {\\n    using LibStackTop for StackTop;\\n    using LibCast for uint256[];\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _hash(uint256[] memory values_) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encodePacked(values_)));\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFn(stackTop_, _hash, Operand.unwrap(operand_));\\n    }\\n\\n    // Stack the return of `balanceOfBatch`.\\n    // Operand will be the length\\n    function hash(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_hash, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x9caf9804d7ea52c357f52a04d0c3d30190d32522c03a10c7ab313a0845427be4\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc1155/OpERC1155BalanceOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC1155Upgradeable as IERC1155} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpERC1155BalanceOf\\n/// @notice Opcode for getting the current erc1155 balance of an account.\\nlibrary OpERC1155BalanceOf {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _balanceOf(\\n        uint256 token_,\\n        uint256 account_,\\n        uint256 id_\\n    ) internal view returns (uint256) {\\n        return\\n            IERC1155(address(uint160(token_))).balanceOf(\\n                address(uint160(account_)),\\n                id_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _balanceOf);\\n    }\\n\\n    // Stack the return of `balanceOf`.\\n    function balanceOf(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_balanceOf);\\n    }\\n}\\n\",\"keccak256\":\"0x75396722287f543bacb8488aedf3de105b3c8219aa4d3990ef0bd6f20a28f965\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc1155/OpERC1155BalanceOfBatch.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC1155Upgradeable as IERC1155} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../../type/LibCast.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpERC1155BalanceOfBatch\\n/// @notice Opcode for getting the current erc1155 balance of an accounts batch.\\nlibrary OpERC1155BalanceOfBatch {\\n    using LibStackTop for StackTop;\\n    using LibCast for uint256[];\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _balanceOfBatch(\\n        uint256 token_,\\n        uint256[] memory accounts_,\\n        uint256[] memory ids_\\n    ) internal view returns (uint256[] memory) {\\n        return\\n            IERC1155(address(uint160(token_))).balanceOfBatch(\\n                accounts_.asAddresses(),\\n                ids_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFn(\\n                stackTop_,\\n                _balanceOfBatch,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    // Stack the return of `balanceOfBatch`.\\n    // Operand will be the length\\n    function balanceOfBatch(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_balanceOfBatch, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xd10d354d864543821c6c2bd58b7b70b7f119985b456ab6aaa41831b9af073c13\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc20/OpERC20BalanceOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpERC20BalanceOf\\n/// @notice Opcode for ERC20 `balanceOf`.\\nlibrary OpERC20BalanceOf {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _balanceOf(\\n        uint256 token_,\\n        uint256 account_\\n    ) internal view returns (uint256) {\\n        return\\n            IERC20(address(uint160(token_))).balanceOf(\\n                address(uint160(account_))\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _balanceOf);\\n    }\\n\\n    /// Stack `balanceOf`.\\n    function balanceOf(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_balanceOf);\\n    }\\n}\\n\",\"keccak256\":\"0xf8fe8c1694a7a0d0343ff3e1586b264a2315de4ac814d643f1256543a59d83ee\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc20/OpERC20TotalSupply.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpERC20TotalSupply\\n/// @notice Opcode for ERC20 `totalSupply`.\\nlibrary OpERC20TotalSupply {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _totalSupply(uint256 token_) internal view returns (uint256) {\\n        return IERC20(address(uint160(token_))).totalSupply();\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _totalSupply);\\n    }\\n\\n    // Stack the return of `totalSupply`.\\n    function totalSupply(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_totalSupply);\\n    }\\n}\\n\",\"keccak256\":\"0xb43054e8d0d6d80860f4a79570283c5e21a8398c92e5b44805cf3b8a28b7594b\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc20/snapshot/OpERC20SnapshotBalanceOfAt.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {ERC20SnapshotUpgradeable as ERC20Snapshot} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\\\";\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpERC20SnapshotBalanceOfAt\\n/// @notice Opcode for Open Zeppelin `ERC20Snapshot.balanceOfAt`.\\n/// https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20Snapshot\\nlibrary OpERC20SnapshotBalanceOfAt {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _balanceOfAt(\\n        uint256 token_,\\n        uint256 account_,\\n        uint256 snapshotId_\\n    ) internal view returns (uint256) {\\n        return\\n            ERC20Snapshot(address(uint160(token_))).balanceOfAt(\\n                address(uint160(account_)),\\n                snapshotId_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _balanceOfAt);\\n    }\\n\\n    /// Stack `balanceOfAt`.\\n    function balanceOfAt(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_balanceOfAt);\\n    }\\n}\\n\",\"keccak256\":\"0x2898baf5c8f1ba682880b84788441b55a09002c0134e4d0ae15cdd84b293dfbb\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc20/snapshot/OpERC20SnapshotTotalSupplyAt.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {ERC20SnapshotUpgradeable as ERC20Snapshot} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\\\";\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpERC20SnapshotTotalSupplyAt\\n/// @notice Opcode for Open Zeppelin `ERC20Snapshot.totalSupplyAt`.\\n/// https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20Snapshot\\nlibrary OpERC20SnapshotTotalSupplyAt {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _totalSupplyAt(\\n        uint256 token_,\\n        uint256 snapshotId_\\n    ) internal view returns (uint256) {\\n        return\\n            ERC20Snapshot(address(uint160(token_))).totalSupplyAt(snapshotId_);\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _totalSupplyAt);\\n    }\\n\\n    /// Stack `totalSupplyAt`.\\n    function totalSupplyAt(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_totalSupplyAt);\\n    }\\n}\\n\",\"keccak256\":\"0x0aad29ec8221dc0b885d65cda174a80e3b7b7f3c8165f02ab00db943392b4fde\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc721/OpERC721BalanceOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC721Upgradeable as IERC721} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpERC721BalanceOf\\n/// @notice Opcode for getting the current erc721 balance of an account.\\nlibrary OpERC721BalanceOf {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _balanceOf(\\n        uint256 token_,\\n        uint256 account_\\n    ) internal view returns (uint256) {\\n        return\\n            IERC721(address(uint160(token_))).balanceOf(\\n                address(uint160(account_))\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _balanceOf);\\n    }\\n\\n    // Stack the return of `balanceOf`.\\n    function balanceOf(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_balanceOf);\\n    }\\n}\\n\",\"keccak256\":\"0xecbc78265bd6621e8d4b7df34c74474afb09bea83be3474193e0126220fd9235\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc721/OpERC721OwnerOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC721Upgradeable as IERC721} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpERC721OwnerOf\\n/// @notice Opcode for getting the current erc721 owner of an account.\\nlibrary OpERC721OwnerOf {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _ownerOf(\\n        uint256 token_,\\n        uint256 id_\\n    ) internal view returns (uint256) {\\n        return uint256(uint160(IERC721(address(uint160(token_))).ownerOf(id_)));\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _ownerOf);\\n    }\\n\\n    // Stack the return of `ownerOf`.\\n    function ownerOf(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_ownerOf);\\n    }\\n}\\n\",\"keccak256\":\"0x3619e49f01fce5ae3fb4e4430f3666cb4c2343655afa7dacd4fb184e21ddf217\",\"license\":\"CAL\"},\"contracts/interpreter/ops/error/OpEnsure.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpEnsure\\n/// @notice Opcode for requiring some truthy values.\\nlibrary OpEnsure {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _ensure(uint256 a_) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            if iszero(a_) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFnN(\\n                stackTop_,\\n                _ensure,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function ensure(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFnN(_ensure, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x0d11b06f19438b9cd33408bc9f95b093f365e5e32c1f92126d9ab2ea6cc89edd\",\"license\":\"CAL\"},\"contracts/interpreter/ops/evm/OpBlockNumber.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpBlockNumber\\n/// @notice Opcode for getting the current block number.\\nlibrary OpBlockNumber {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(stackTop_);\\n    }\\n\\n    function blockNumber(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.push(block.number);\\n    }\\n}\\n\",\"keccak256\":\"0xafcb42f5a1715a05cf74ad076fe5942bca86548d19803c924f2b1533c8229c4c\",\"license\":\"CAL\"},\"contracts/interpreter/ops/evm/OpCaller.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpCaller\\n/// @notice Opcode for getting the current caller.\\nlibrary OpCaller {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(stackTop_);\\n    }\\n\\n    function caller(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.push(uint256(uint160(msg.sender)));\\n    }\\n}\\n\",\"keccak256\":\"0xef73614014f64eca9d3d1aa6134e62a362aa15e9e6435236058bf8b4f339a8a8\",\"license\":\"CAL\"},\"contracts/interpreter/ops/evm/OpThisAddress.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpThisAddress\\n/// @notice Opcode for getting the address of the current contract.\\nlibrary OpThisAddress {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(stackTop_);\\n    }\\n\\n    function thisAddress(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.push(uint256(uint160(address(this))));\\n    }\\n}\\n\",\"keccak256\":\"0x96b0cebd032635eeb64b61613ceb418a1b9aa727aa5900f81784db73fc9c4373\",\"license\":\"CAL\"},\"contracts/interpreter/ops/evm/OpTimestamp.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpTimestamp\\n/// @notice Opcode for getting the current timestamp.\\nlibrary OpTimestamp {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(stackTop_);\\n    }\\n\\n    function timestamp(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.push(block.timestamp);\\n    }\\n}\\n\",\"keccak256\":\"0x3b4f400ba8d23d605c4d894b7527e7412dc21a5d8b71779304188bf0be2546d9\",\"license\":\"CAL\"},\"contracts/interpreter/ops/list/OpExplode32.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpExplode\\n/// @notice Opcode for exploding a single value into 8x 32 bit integers.\\nlibrary OpExplode32 {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(integrityState_.pop(stackTop_), 8);\\n    }\\n\\n    function explode32(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        (StackTop location_, uint256 i_) = stackTop_.pop();\\n        uint256 mask_ = uint256(type(uint32).max);\\n        return\\n            location_.push(\\n                i_ & mask_,\\n                (i_ >> 0x20) & mask_,\\n                (i_ >> 0x40) & mask_,\\n                (i_ >> 0x60) & mask_,\\n                (i_ >> 0x80) & mask_,\\n                (i_ >> 0xA0) & mask_,\\n                (i_ >> 0xC0) & mask_,\\n                (i_ >> 0xE0) & mask_\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x0b4721179efb8f6a25ef5b8b49b55e12e15cff01c6fc0104142ff0459b65349e\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpAdd.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpAdd\\n/// @notice Opcode for adding N numbers.\\nlibrary OpAdd {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _add(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ + b_;\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFnN(stackTop_, _add, Operand.unwrap(operand_));\\n    }\\n\\n    function add(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFnN(_add, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xefb1cfdfcbc488ba2b4691d0e81b82896b27d983643337be9227f676f4f435f5\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpDiv.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpDiv\\n/// @notice Opcode for dividing N numbers.\\nlibrary OpDiv {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _div(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ / b_;\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFnN(stackTop_, _div, Operand.unwrap(operand_));\\n    }\\n\\n    function div(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        return stackTop_.applyFnN(_div, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x31fc7a9dbbd889a10ea1641acaa6010f4af842415cafaf18c5a478395c532500\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpExp.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpExp\\n/// @notice Opcode to exponentiate N numbers.\\nlibrary OpExp {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _exp(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ ** b_;\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFnN(stackTop_, _exp, Operand.unwrap(operand_));\\n    }\\n\\n    function exp(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        return stackTop_.applyFnN(_exp, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x9b60144edf3eef15d8990ccc88f37d17a86180f1fecfaf14ef3786686cbb1226\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpMax.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpMax\\n/// @notice Opcode to stack the maximum of N numbers.\\nlibrary OpMax {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _max(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ > b_ ? a_ : b_;\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFnN(stackTop_, _max, Operand.unwrap(operand_));\\n    }\\n\\n    function max(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        return stackTop_.applyFnN(_max, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xc613d145b2a253ae464b96bf4683ead769eac2601d31293e6d2931e70d37e4cc\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpMin.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpMin\\n/// @notice Opcode to stack the minimum of N numbers.\\nlibrary OpMin {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _min(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ < b_ ? a_ : b_;\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFnN(stackTop_, _min, Operand.unwrap(operand_));\\n    }\\n\\n    function min(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        return stackTop_.applyFnN(_min, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xebcb9cee2b602e516af51d757af9c372df3888f9a74038df01302938ebf136f4\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpMod.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpMod\\n/// @notice Opcode to mod N numbers.\\nlibrary OpMod {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _mod(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ % b_;\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFnN(stackTop_, _mod, Operand.unwrap(operand_));\\n    }\\n\\n    function mod(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        return stackTop_.applyFnN(_mod, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xae2f902dce6a1ce4a0d9ad4774c6c6145ed5c7b9f574420e719e4099a99f612a\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpMul.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpMul\\n/// @notice Opcode for multiplying N numbers.\\nlibrary OpMul {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _mul(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ * b_;\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFnN(stackTop_, _mul, Operand.unwrap(operand_));\\n    }\\n\\n    function mul(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        return stackTop_.applyFnN(_mul, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x9b1d77f4dcc5015ffc2f31d3278dcff0e8f3c28497c5ad2d2f35c45449eb8d57\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpSub.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpSub\\n/// @notice Opcode for subtracting N numbers.\\nlibrary OpSub {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _sub(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ - b_;\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFnN(stackTop_, _sub, Operand.unwrap(operand_));\\n    }\\n\\n    function sub(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        return stackTop_.applyFnN(_sub, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xe19f317661b1b96d30eda11c8999a307347a4e22d4befd041d507085aee3261d\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/fixedPoint/OpFixedPointScale18.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpFixedPointScale18\\n/// @notice Opcode for scaling a number to 18 fixed point.\\nlibrary OpFixedPointScale18 {\\n    using FixedPointMath for uint256;\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _scale18(\\n        Operand operand_,\\n        uint256 a_\\n    ) internal pure returns (uint256) {\\n        return a_.scale18(Operand.unwrap(operand_));\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _scale18);\\n    }\\n\\n    function scale18(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_scale18, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0xbe086e2e1f63cd4196b18e57de1df9e0afb39dbca7ad86749850d3d82cc394c7\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/fixedPoint/OpFixedPointScale18Div.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpFixedPointScale18Div\\n/// @notice Opcode for performing scale 18 fixed point division.\\nlibrary OpFixedPointScale18Div {\\n    using FixedPointMath for uint256;\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _scale18Div(\\n        Operand operand_,\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        return a_.scale18(Operand.unwrap(operand_)).fixedPointDiv(b_);\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _scale18Div);\\n    }\\n\\n    function scale18Div(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_scale18Div, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0xc9fdb42a092629d5ca45cd7df5b311190d40bc56e2c11dc530e707296d33b32a\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/fixedPoint/OpFixedPointScale18Mul.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpFixedPointScale18Mul\\n/// @notice Opcode for performing scale 18 fixed point multiplication.\\nlibrary OpFixedPointScale18Mul {\\n    using FixedPointMath for uint256;\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _scale18Mul(\\n        Operand operand_,\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        return a_.scale18(Operand.unwrap(operand_)).fixedPointMul(b_);\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _scale18Mul);\\n    }\\n\\n    function scale18Mul(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_scale18Mul, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0xd6b24bf524a685c958ca558453dd8f71eac9f3ba7b2ba1d6c7dff97280aeedce\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/fixedPoint/OpFixedPointScaleBy.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpFixedPointScaleBy\\n/// @notice Opcode for scaling a number by some OOMs.\\nlibrary OpFixedPointScaleBy {\\n    using FixedPointMath for uint256;\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _scaleBy(\\n        Operand operand_,\\n        uint256 a_\\n    ) internal pure returns (uint256) {\\n        return a_.scaleBy(int8(uint8(Operand.unwrap(operand_))));\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _scaleBy);\\n    }\\n\\n    function scaleBy(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_scaleBy, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0xfccba58798545841dc63ccb8af9bc072d7ed81b3c5f86dcf6d245142b643dbc4\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/fixedPoint/OpFixedPointScaleN.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpFixedPointScaleN\\n/// @notice Opcode for scaling a number to N fixed point.\\nlibrary OpFixedPointScaleN {\\n    using FixedPointMath for uint256;\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _scaleN(\\n        Operand operand_,\\n        uint256 a_\\n    ) internal pure returns (uint256) {\\n        return a_.scaleN(Operand.unwrap(operand_));\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _scaleN);\\n    }\\n\\n    function scaleN(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_scaleN, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0x9162f000ffed26d4be6847ecd564d71f9a397dbf755d1fa03b0525218976d0a2\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpAny.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpAny\\n/// @notice Opcode to compare the top N stack values.\\nlibrary OpAny {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        function(uint256[] memory) internal view returns (uint256) fn_;\\n        return\\n            integrityState_.applyFn(stackTop_, fn_, Operand.unwrap(operand_));\\n    }\\n\\n    // ANY\\n    // ANY is the first nonzero item, else 0.\\n    // operand_ id the length of items to check.\\n    function any(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        StackTop bottom_ = stackTop_.down(Operand.unwrap(operand_));\\n        for (\\n            StackTop i_ = bottom_;\\n            StackTop.unwrap(i_) < StackTop.unwrap(stackTop_);\\n            i_ = i_.up()\\n        ) {\\n            uint256 item_ = i_.peekUp();\\n            if (item_ > 0) {\\n                return bottom_.push(item_);\\n            }\\n        }\\n        return bottom_.up();\\n    }\\n}\\n\",\"keccak256\":\"0x85d8832eb8371c9eaa99822ebf9643a70f32d806a966fcd0d51db42ef30e81cb\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpEagerIf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpEagerIf\\n/// @notice Opcode for selecting a value based on a condition.\\nlibrary OpEagerIf {\\n    using LibIntegrityState for IntegrityState;\\n    using LibStackTop for StackTop;\\n\\n    function _eagerIf(\\n        uint256 a_,\\n        uint256[] memory bs_,\\n        uint256[] memory cs_\\n    ) internal pure returns (uint256[] memory) {\\n        return a_ > 0 ? bs_ : cs_;\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFn(\\n                stackTop_,\\n                _eagerIf,\\n                Operand.unwrap(operand_) + 1\\n            );\\n    }\\n\\n    /// Eager because BOTH x_ and y_ must be eagerly evaluated\\n    /// before EAGER_IF will select one of them. If both x_ and y_\\n    /// are cheap (e.g. constant values) then this may also be the\\n    /// simplest and cheapest way to select one of them.\\n    function eagerIf(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        unchecked {\\n            return stackTop_.applyFn(_eagerIf, Operand.unwrap(operand_) + 1);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x741230f4e042da9753f89b80b50d636db3dc4baffd079bc92aad018e2689a05d\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpEqualTo.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../../type/LibCast.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpEqualTo\\n/// @notice Opcode to compare the top two stack values.\\nlibrary OpEqualTo {\\n    using LibCast for bool;\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _equalTo(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return (a_ == b_).asUint256();\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _equalTo);\\n    }\\n\\n    function equalTo(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_equalTo);\\n    }\\n}\\n\",\"keccak256\":\"0x956376edf38093d0fc8583379f8566635d93f8fe24dda9e64965c12b71d694f0\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpEvery.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpEvery\\n/// @notice Opcode to compare the top N stack values.\\nlibrary OpEvery {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        function(uint256[] memory) internal view returns (uint256) fn_;\\n        return\\n            integrityState_.applyFn(stackTop_, fn_, Operand.unwrap(operand_));\\n    }\\n\\n    // EVERY\\n    // EVERY is either the first item if every item is nonzero, else 0.\\n    // operand_ is the length of items to check.\\n    function every(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        StackTop bottom_ = stackTop_.down(Operand.unwrap(operand_));\\n        for (\\n            StackTop i_ = bottom_;\\n            StackTop.unwrap(i_) < StackTop.unwrap(stackTop_);\\n            i_ = i_.up()\\n        ) {\\n            if (i_.peekUp() == 0) {\\n                return bottom_.push(0);\\n            }\\n        }\\n        return bottom_.up();\\n    }\\n}\\n\",\"keccak256\":\"0x44678ff964d7b36c03190250c578d6cf2d2a02186528d7f39ca75247b46d4156\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpGreaterThan.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../../type/LibCast.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpGreaterThan\\n/// @notice Opcode to compare the top two stack values.\\nlibrary OpGreaterThan {\\n    using LibCast for bool;\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _greaterThan(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        return (a_ > b_).asUint256();\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _greaterThan);\\n    }\\n\\n    function greaterThan(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_greaterThan);\\n    }\\n}\\n\",\"keccak256\":\"0x49fbd57b54fc97fba5d5dcf29043207b0309951fd775bea3c100a8cffd361a27\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpIsZero.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../../type/LibCast.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpIsZero\\n/// @notice Opcode for checking if the stack top is zero.\\nlibrary OpIsZero {\\n    using LibCast for bool;\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _isZero(uint256 a_) internal pure returns (uint256) {\\n        return (a_ == 0).asUint256();\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _isZero);\\n    }\\n\\n    function isZero(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_isZero);\\n    }\\n}\\n\",\"keccak256\":\"0xe35353a8f13da7bb87fabc119ac5aa21bbc3c453f79e2c74eba46d1e708034df\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpLessThan.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../../type/LibCast.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpLessThan\\n/// @notice Opcode to compare the top two stack values.\\nlibrary OpLessThan {\\n    using LibStackTop for StackTop;\\n    using LibCast for bool;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _lessThan(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return (a_ < b_).asUint256();\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _lessThan);\\n    }\\n\\n    function lessThan(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_lessThan);\\n    }\\n}\\n\",\"keccak256\":\"0x89e0da8eb8cf5dd60f2e690e6472528fc2bdabca3609e53a8beb4674185d6e0c\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/saturating/OpSaturatingAdd.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/SaturatingMath.sol\\\";\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpSaturatingAdd\\n/// @notice Opcode for adding N numbers with saturating addition.\\nlibrary OpSaturatingAdd {\\n    using SaturatingMath for uint256;\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFnN(\\n                stackTop_,\\n                SaturatingMath.saturatingAdd,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function saturatingAdd(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        return\\n            stackTop_.applyFnN(\\n                SaturatingMath.saturatingAdd,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x907d9c4dbb860ccd9464448f215bf09993b5825eba4a4f7a8f61eb147c2ef678\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/saturating/OpSaturatingMul.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/SaturatingMath.sol\\\";\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpSaturatingMul\\n/// @notice Opcode for multiplying N numbers with saturating multiplication.\\nlibrary OpSaturatingMul {\\n    using SaturatingMath for uint256;\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFnN(\\n                stackTop_,\\n                SaturatingMath.saturatingMul,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function saturatingMul(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        return\\n            stackTop_.applyFnN(\\n                SaturatingMath.saturatingMul,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x6c35f6d1957e1c08f82682a5b8edb0783217acc5a443403fea1ab214404c3ae5\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/saturating/OpSaturatingSub.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/SaturatingMath.sol\\\";\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpSaturatingSub\\n/// @notice Opcode for subtracting N numbers with saturating subtraction.\\nlibrary OpSaturatingSub {\\n    using SaturatingMath for uint256;\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFnN(\\n                stackTop_,\\n                SaturatingMath.saturatingSub,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function saturatingSub(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        return\\n            stackTop_.applyFnN(\\n                SaturatingMath.saturatingSub,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x74428242266cf49890d1425a65fc5fa49cb4a400f494abef1033d19772e8727c\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/IOrderBookV1/OpIOrderBookV1VaultBalance.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../orderbook/IOrderBookV1.sol\\\";\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpIOrderBookV1VaultBalance\\n/// @notice Opcode for IOrderBookV1 `vaultBalance`.\\nlibrary OpIOrderBookV1VaultBalance {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function f(\\n        uint256 orderbook_,\\n        uint owner_,\\n        uint token_,\\n        uint id_\\n    ) internal view returns (uint256) {\\n        return\\n            uint256(\\n                uint160(\\n                    IOrderBookV1(address(uint160(orderbook_))).vaultBalance(\\n                        address(uint160(owner_)),\\n                        address(uint160(token_)),\\n                        id_\\n                    )\\n                )\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x973670ad7b47ae50228c8c9701a57894b1ee9581eea476bf600c242607c9659f\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/ISaleV2/OpISaleV2RemainingTokenInventory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../sale/ISaleV2.sol\\\";\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpISaleV2RemainingTokenInventory\\n/// @notice Opcode for ISaleV2 `remainingTokenInventory`.\\nlibrary OpISaleV2RemainingTokenInventory {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function f(uint256 sale_) internal view returns (uint256) {\\n        return ISaleV2(address(uint160(sale_))).remainingTokenInventory();\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, f);\\n    }\\n\\n    /// Stack `remainingTokenInventory`.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x75088738dd0ddc37fd9d2b5675aa2cea31dfe4abb366fede044686f8ce09c6bf\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/ISaleV2/OpISaleV2Reserve.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../sale/ISaleV2.sol\\\";\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpISaleV2Reserve\\n/// @notice Opcode for ISaleV2 `reserve`.\\nlibrary OpISaleV2Reserve {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function f(uint256 sale_) internal view returns (uint256) {\\n        return uint256(uint160(ISaleV2(address(uint160(sale_))).reserve()));\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, f);\\n    }\\n\\n    /// Stack `reserve`.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x040b234ac3380854378b5e4db00d66034e9743401d4af8487a7bc56300565360\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/ISaleV2/OpISaleV2SaleStatus.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../sale/ISaleV2.sol\\\";\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpISaleV2SaleStatus\\n/// @notice Opcode for ISaleV2 `saleStatus`.\\nlibrary OpISaleV2SaleStatus {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function f(uint256 sale_) internal view returns (uint256) {\\n        return uint(ISaleV2(address(uint160(sale_))).saleStatus());\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, f);\\n    }\\n\\n    /// Stack `saleStatus`.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0xc4247c512f293f9e0a87cfd1448ab9726c2395d0ccdc6dc442e7987ef408855d\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/ISaleV2/OpISaleV2Token.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../sale/ISaleV2.sol\\\";\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpISaleV2Token\\n/// @notice Opcode for ISaleV2 `token`.\\nlibrary OpISaleV2Token {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function f(uint256 sale_) internal view returns (uint256) {\\n        return uint256(uint160(ISaleV2(address(uint160(sale_))).token()));\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, f);\\n    }\\n\\n    /// Stack `token`.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x9fea0d009841f988eb22b44c13f01f4d9a2520d1bf1e988d3de8d9fccee1a0f8\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/ISaleV2/OpISaleV2TotalReserveReceived.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../sale/ISaleV2.sol\\\";\\nimport \\\"../../../run/LibStackTop.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpISaleV2TotalReserveReceived\\n/// @notice Opcode for ISaleV2 `totalReserveReceived`.\\nlibrary OpISaleV2TotalReserveReceived {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function f(uint256 sale_) internal view returns (uint256) {\\n        return ISaleV2(address(uint160(sale_))).totalReserveReceived();\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, f);\\n    }\\n\\n    /// Stack `totalReserveReceived`.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0xd4aa4803ae8e0fae3f929238b9a23304789fcc2c1252f1386dbf4182780fd7d0\",\"license\":\"CAL\"},\"contracts/interpreter/ops/tier/OpITierV2Report.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../tier/ITierV2.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpITierV2Report\\n/// @notice Exposes `ITierV2.report` as an opcode.\\nlibrary OpITierV2Report {\\n    using LibStackTop for StackTop;\\n    using LibStackTop for uint256[];\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _report(\\n        uint256 tierContract_,\\n        uint256 account_,\\n        uint256[] memory context_\\n    ) internal view returns (uint256) {\\n        return\\n            ITierV2(address(uint160(tierContract_))).report(\\n                address(uint160(account_)),\\n                context_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFn(\\n                stackTop_,\\n                _report,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    // Stack the `report` returned by an `ITierV2` contract.\\n    function report(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        return stackTop_.applyFn(_report, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x4d4cf91245fe5c41cc840b1c22eead649dec7508be64039d98d70a1dc4a3205c\",\"license\":\"CAL\"},\"contracts/interpreter/ops/tier/OpITierV2ReportTimeForTier.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../tier/ITierV2.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\n/// @title OpITierV2Report\\n/// @notice Exposes `ITierV2.reportTimeForTier` as an opcode.\\nlibrary OpITierV2ReportTimeForTier {\\n    using LibStackTop for StackTop;\\n    using LibStackTop for uint256[];\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _reportTimeForTier(\\n        uint256 tierContract_,\\n        uint256 account_,\\n        uint256 tier_,\\n        uint256[] memory context_\\n    ) internal view returns (uint256) {\\n        return\\n            ITierV2(address(uint160(tierContract_))).reportTimeForTier(\\n                address(uint160(account_)),\\n                tier_,\\n                context_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFn(\\n                stackTop_,\\n                _reportTimeForTier,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    // Stack the `reportTimeForTier` returned by an `ITierV2` contract.\\n    function reportTimeForTier(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_reportTimeForTier, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x69752dc83389231a766ecdee98bbef3a99cd6812ce671ab175a2be0bc98c57b1\",\"license\":\"CAL\"},\"contracts/interpreter/ops/tier/OpSaturatingDiff.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../tier/libraries/TierwiseCombine.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\nlibrary OpSaturatingDiff {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return\\n            integrityState_.applyFn(stackTop_, TierwiseCombine.saturatingSub);\\n    }\\n\\n    // Stack the tierwise saturating subtraction of two reports.\\n    // If the older report is newer than newer report the result will\\n    // be `0`, else a tierwise diff in blocks will be obtained.\\n    // The older and newer report are taken from the stack.\\n    function saturatingDiff(\\n        InterpreterState memory,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(TierwiseCombine.saturatingSub);\\n    }\\n}\\n\",\"keccak256\":\"0x5b5aefc9fb0582d7a3c04879fb8c0437628574e4ce330b1966cfd4262cf5cdb5\",\"license\":\"CAL\"},\"contracts/interpreter/ops/tier/OpSelectLte.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../tier/libraries/TierwiseCombine.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\nimport \\\"../../../math/Binary.sol\\\";\\n\\n/// @title OpSelectLte\\n/// @notice Exposes `TierwiseCombine.selectLte` as an opcode.\\nlibrary OpSelectLte {\\n    using LibStackTop for StackTop;\\n    using LibStackTop for uint256[];\\n    using LibIntegrityState for IntegrityState;\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        unchecked {\\n            uint256 inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\\n            require(inputs_ > 0, \\\"SELECT_LTE_ZERO_INPUTS\\\");\\n            return\\n                integrityState_.push(integrityState_.pop(stackTop_, inputs_));\\n        }\\n    }\\n\\n    // Stacks the result of a `selectLte` combinator.\\n    // All `selectLte` share the same stack and argument handling.\\n    // Takes the `logic_` and `mode_` from the `operand_` high bits.\\n    // `logic_` is the highest bit.\\n    // `mode_` is the 2 highest bits after `logic_`.\\n    // The other bits specify how many values to take from the stack\\n    // as reports to compare against each other and the block number.\\n    function selectLte(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        unchecked {\\n            uint inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\\n            uint mode_ = (Operand.unwrap(operand_) >> 8) & MASK_2BIT;\\n            uint logic_ = Operand.unwrap(operand_) >> 10;\\n            (uint256 time_, uint256[] memory reports_) = stackTop_.list(\\n                inputs_\\n            );\\n            return\\n                reports_.asStackTop().push(\\n                    TierwiseCombine.selectLte(logic_, mode_, time_, reports_)\\n                );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1eab22cbec2ad94b6d9ad9dfe3df7b412e2caddb89ac4727877c8a94b4c71c21\",\"license\":\"CAL\"},\"contracts/interpreter/ops/tier/OpUpdateTimesForTierRange.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../tier/libraries/TierReport.sol\\\";\\nimport \\\"../../run/LibStackTop.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityState.sol\\\";\\n\\nlibrary OpUpdateTimesForTierRange {\\n    using LibStackTop for StackTop;\\n    using LibIntegrityState for IntegrityState;\\n\\n    function _updateTimesForTierRange(\\n        Operand operand_,\\n        uint256 report_,\\n        uint256 timestamp_\\n    ) internal pure returns (uint256) {\\n        return\\n            TierReport.updateTimesForTierRange(\\n                report_,\\n                // start tier.\\n                // 4 low bits.\\n                Operand.unwrap(operand_) & 0x0f,\\n                // end tier.\\n                // 4 high bits.\\n                (Operand.unwrap(operand_) >> 4) & 0x0f,\\n                timestamp_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityState memory integrityState_,\\n        Operand,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.applyFn(stackTop_, _updateTimesForTierRange);\\n    }\\n\\n    // Stacks a report with updated times over tier range.\\n    // The start and end tier are taken from the low and high bits of\\n    // the `operand_` respectively.\\n    // The report to update and timestamp to update to are both\\n    // taken from the stack.\\n    function updateTimesForTierRange(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return stackTop_.applyFn(_updateTimesForTierRange, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0xafae2a08f5026772f5d298d443330bc31d80b5dbf7ec8a924571e67923663a92\",\"license\":\"CAL\"},\"contracts/interpreter/run/IInterpreterV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\ntype SourceIndex is uint;\\ntype EncodedDispatch is uint256;\\ntype StateNamespace is uint;\\n\\ninterface IInterpreterV1 {\\n    function functionPointers() external view returns (bytes memory);\\n\\n    function eval(\\n        EncodedDispatch dispatch,\\n        uint256[][] memory context\\n    )\\n        external\\n        view\\n        returns (uint256[] memory stack, uint[] memory stateChanges);\\n\\n    function stateChanges(uint[] memory stateChanges) external;\\n\\n    function evalWithNamespace(\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint[][] memory context\\n    ) external view returns (uint[] memory stack, uint[] memory stateChanges);\\n\\n    function stateChangesWithNamespace(\\n        StateNamespace namespace,\\n        uint[] memory stateChanges\\n    ) external;\\n}\\n\",\"keccak256\":\"0xcdf6d90a79eb3c7c3a2a67a919e176dac0a5c0ddbfc65fe2b63d6c99f132eec1\",\"license\":\"CAL\"},\"contracts/interpreter/run/LibEncodedDispatch.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\nlibrary LibEncodedDispatch {\\n    function encode(\\n        address expressionPointer_,\\n        SourceIndex sourceIndex_,\\n        uint maxOutputs_\\n    ) internal pure returns (EncodedDispatch) {\\n        return\\n            EncodedDispatch.wrap(\\n                (uint(uint160(expressionPointer_)) << 32) |\\n                    (SourceIndex.unwrap(sourceIndex_) << 16) |\\n                    maxOutputs_\\n            );\\n    }\\n\\n    function decode(\\n        EncodedDispatch dispatch_\\n    ) internal pure returns (address, SourceIndex, uint) {\\n        return (\\n            address(uint160(EncodedDispatch.unwrap(dispatch_) >> 32)),\\n            SourceIndex.wrap((EncodedDispatch.unwrap(dispatch_) >> 16) & 0xFF),\\n            EncodedDispatch.unwrap(dispatch_) & 0xFF\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x439aed0b49a12ace271052a2dc274854953c09508654ddcad35523f77e46b461\",\"license\":\"CAL\"},\"contracts/interpreter/run/LibInterpreterState.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../run/IInterpreterV1.sol\\\";\\nimport \\\"../deploy/IExpressionDeployerV1.sol\\\";\\nimport \\\"./LibStackTop.sol\\\";\\nimport \\\"../../type/LibCast.sol\\\";\\nimport \\\"../../type/LibConvert.sol\\\";\\nimport \\\"../../array/LibUint256Array.sol\\\";\\nimport \\\"../../memory/LibMemorySize.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\nimport {SafeCastUpgradeable as SafeCast} from \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\\\";\\nimport {Operand} from \\\"./RainInterpreter.sol\\\";\\nimport \\\"../../kv/LibMemoryKV.sol\\\";\\n\\nenum DebugStyle {\\n    Stack,\\n    Constant,\\n    Context,\\n    Source\\n}\\n\\n/// Everything required to evaluate and track the state of a Rain expression.\\n/// As this is a struct it will be in memory when passed to `RainInterpreter` and so\\n/// will be modified by reference internally. This is important for gas\\n/// efficiency; the stack, arguments and stackIndex will likely be mutated by\\n/// the running expression.\\n/// @param stackIndex Opcodes write to the stack at the stack index and can\\n/// consume from the stack by decrementing the index and reading between the\\n/// old and new stack index.\\n/// IMPORANT: The stack is never zeroed out so the index must be used to\\n/// find the \\\"top\\\" of the stack as the result of an `eval`.\\n/// @param stack Stack is the general purpose runtime state that opcodes can\\n/// read from and write to according to their functionality.\\n/// @param sources Sources available to be executed by `eval`.\\n/// Notably `ZIPMAP` can also select a source to execute by index.\\n/// @param constants Constants that can be copied to the stack by index by\\n/// `VAL`.\\n/// @param arguments `ZIPMAP` populates arguments which can be copied to the\\n/// stack by `VAL`.\\nstruct InterpreterState {\\n    StackTop stackBottom;\\n    StackTop constantsBottom;\\n    MemoryKV stateKV;\\n    StateNamespace stateNamespace;\\n    uint256[][] context;\\n    bytes[] compiledSources;\\n}\\n\\nstring constant DEBUG_DELIMETER = \\\"~~~\\\";\\n\\nlibrary LibInterpreterState {\\n    using SafeCast for uint256;\\n    using LibMemorySize for uint256;\\n    using LibMemorySize for uint256[];\\n    using LibMemorySize for bytes;\\n    using LibUint256Array for uint256[];\\n    using LibUint256Array for uint256;\\n    using LibInterpreterState for InterpreterState;\\n    using LibStackTop for uint256[];\\n    using LibStackTop for StackTop;\\n    using LibStackTop for bytes;\\n    using LibCast for uint256;\\n    using LibCast for function(InterpreterState memory, SourceIndex, StackTop)\\n        view\\n        returns (StackTop);\\n    using LibCast for function(InterpreterState memory, Operand, StackTop)\\n        view\\n        returns (StackTop)[];\\n    using LibConvert for uint256[];\\n\\n    function debugArray(uint256[] memory array_) internal view {\\n        console.log(DEBUG_DELIMETER);\\n        for (uint256 i_ = 0; i_ < array_.length; i_++) {\\n            console.log(i_, array_[i_]);\\n        }\\n        console.log(DEBUG_DELIMETER);\\n    }\\n\\n    function debugStack(\\n        StackTop stackBottom_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        uint256 length_ = stackBottom_.toIndex(stackTop_);\\n        debugArray(\\n            StackTop.unwrap(stackTop_.down(length_)).copyToNewUint256Array(\\n                length_\\n            )\\n        );\\n        return stackTop_;\\n    }\\n\\n    function debugStack(\\n        InterpreterState memory state_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return debugStack(state_.stackBottom, stackTop_);\\n    }\\n\\n    /// Console log various aspects of the Interpreter state.\\n    /// Gas intensive and relies on hardhat console so not intended for\\n    /// production but great for debugging Rain expressions.\\n    function debug(\\n        InterpreterState memory state_,\\n        StackTop stackTop_,\\n        DebugStyle debugStyle_\\n    ) internal view returns (StackTop) {\\n        if (debugStyle_ == DebugStyle.Source) {\\n            for (uint256 i_ = 0; i_ < state_.compiledSources.length; i_++) {\\n                console.logBytes(state_.compiledSources[i_]);\\n            }\\n        } else {\\n            if (debugStyle_ == DebugStyle.Stack) {\\n                state_.debugStack(stackTop_);\\n            } else if (debugStyle_ == DebugStyle.Constant) {\\n                debugArray(state_.constantsBottom.down().asUint256Array());\\n            } else {\\n                for (uint256 i_ = 0; i_ < state_.context.length; i_++) {\\n                    debugArray(state_.context[i_]);\\n                }\\n            }\\n        }\\n        return stackTop_;\\n    }\\n\\n    function serialize(\\n        StateConfig memory config_,\\n        uint256 stackLength_,\\n        bytes memory opcodeFunctionPointers_\\n    ) internal pure returns (bytes memory) {\\n        unchecked {\\n            uint256 size_ = 0;\\n            size_ += stackLength_.size();\\n            size_ += config_.constants.size();\\n            for (uint256 i_ = 0; i_ < config_.sources.length; i_++) {\\n                size_ += config_.sources[i_].size();\\n            }\\n            bytes memory serialized_ = new bytes(size_);\\n            StackTop cursor_ = serialized_.asStackTop().up();\\n\\n            // Copy stack length.\\n            cursor_ = cursor_.push(stackLength_);\\n\\n            // Then the constants.\\n            cursor_ = cursor_.pushWithLength(config_.constants);\\n\\n            // Last the sources.\\n            bytes memory source_;\\n            for (uint256 i_ = 0; i_ < config_.sources.length; i_++) {\\n                source_ = config_.sources[i_];\\n                compile(source_, opcodeFunctionPointers_);\\n                cursor_ = cursor_.unalignedPushWithLength(source_);\\n            }\\n            return serialized_;\\n        }\\n    }\\n\\n    function deserialize(\\n        bytes memory serialized_\\n    ) internal pure returns (InterpreterState memory) {\\n        unchecked {\\n            InterpreterState memory state_;\\n\\n            // Context will probably be overridden by the caller according to the\\n            // context scratch that we deserialize so best to just set it empty\\n            // here.\\n            state_.context = new uint256[][](0);\\n\\n            StackTop cursor_ = serialized_.asStackTop().up();\\n            // The end of processing is the end of the state bytes.\\n            StackTop end_ = cursor_.upBytes(cursor_.peek());\\n\\n            // Read the stack length and build a stack.\\n            cursor_ = cursor_.up();\\n            uint256 stackLength_ = cursor_.peek();\\n\\n            // The stack is never stored in stack bytes so we allocate a new\\n            // array for it with length as per the indexes and point the state\\n            // at it.\\n            uint256[] memory stack_ = new uint256[](stackLength_);\\n            state_.stackBottom = stack_.asStackTopUp();\\n\\n            // Reference the constants array and move cursor past it.\\n            cursor_ = cursor_.up();\\n            state_.constantsBottom = cursor_;\\n            cursor_ = cursor_.up(cursor_.peek());\\n\\n            // Rebuild the sources array.\\n            uint256 i_ = 0;\\n            StackTop lengthCursor_ = cursor_;\\n            uint256 sourcesLength_ = 0;\\n            while (StackTop.unwrap(lengthCursor_) < StackTop.unwrap(end_)) {\\n                lengthCursor_ = lengthCursor_\\n                    .upBytes(lengthCursor_.peekUp())\\n                    .up();\\n                sourcesLength_++;\\n            }\\n            state_.compiledSources = new bytes[](sourcesLength_);\\n            while (StackTop.unwrap(cursor_) < StackTop.unwrap(end_)) {\\n                state_.compiledSources[i_] = cursor_.asBytes();\\n                cursor_ = cursor_.upBytes(cursor_.peekUp()).up();\\n                i_++;\\n            }\\n            return state_;\\n        }\\n    }\\n\\n    /// Given a source in opcodes compile to an equivalent source with real\\n    /// function pointers for a given Interpreter contract. The \\\"compilation\\\"\\n    /// involves simply replacing the opcode with the pointer at the index of\\n    /// the opcode. i.e. opcode 4 will be replaced with `pointers_[4]`.\\n    /// Relies heavily on the integrity checks ensuring opcodes used are not OOB\\n    /// and that the pointers provided are valid and in the correct order.\\n    /// Hopefully it goes without saying that the list of pointers MUST NOT be\\n    /// user defined, otherwise any source can be compiled with a completely\\n    /// different mapping between opcodes and dispatched functions.\\n    function compile(\\n        bytes memory source_,\\n        bytes memory pointers_\\n    ) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n                let replaceMask_ := 0xFFFF\\n                let preserveMask_ := not(replaceMask_)\\n                let sourceLength_ := mload(source_)\\n                let pointersBottom_ := add(pointers_, 2)\\n                let cursor_ := add(source_, 2)\\n                let end_ := add(source_, sourceLength_)\\n            } lt(cursor_, end_) {\\n                cursor_ := add(cursor_, 4)\\n            } {\\n                let data_ := mload(cursor_)\\n                let pointer_ := and(\\n                    replaceMask_,\\n                    mload(\\n                        add(pointersBottom_, mul(2, and(data_, replaceMask_)))\\n                    )\\n                )\\n                mstore(cursor_, or(and(data_, preserveMask_), pointer_))\\n            }\\n        }\\n    }\\n\\n    /// Evaluates a Rain expression.\\n    /// The main workhorse of the rain Interpreter, `eval` runs any core opcodes\\n    /// and dispatches anything it is unaware of to the implementing contract.\\n    /// For an expression to be useful the implementing contract must override\\n    /// `applyOp` and dispatch non-core opcodes to domain specific logic. This\\n    /// could be mathematical operations for a calculator, tier reports for\\n    /// a membership combinator, entitlements for a minting curve, etc.\\n    ///\\n    /// Everything required to coordinate the execution of a Rain expression to\\n    /// completion is contained in the `State`. The context and source index\\n    /// are provided so the caller can provide additional data and kickoff the\\n    /// opcode dispatch from the correct source in `sources`.\\n    function eval(\\n        InterpreterState memory state_,\\n        SourceIndex sourceIndex_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        unchecked {\\n            uint256 cursor_;\\n            uint256 end_;\\n            assembly (\\\"memory-safe\\\") {\\n                cursor_ := mload(\\n                    add(\\n                        mload(add(state_, 0xA0)),\\n                        add(0x20, mul(0x20, sourceIndex_))\\n                    )\\n                )\\n                end_ := add(cursor_, mload(cursor_))\\n            }\\n\\n            // Loop until complete.\\n            while (cursor_ < end_) {\\n                function(InterpreterState memory, Operand, StackTop)\\n                    internal\\n                    view\\n                    returns (StackTop) fn_;\\n                Operand operand_;\\n                cursor_ += 4;\\n                {\\n                    uint256 op_;\\n                    assembly (\\\"memory-safe\\\") {\\n                        op_ := mload(cursor_)\\n                        operand_ := and(op_, 0xFFFF)\\n                        fn_ := and(shr(16, op_), 0xFFFF)\\n                    }\\n                }\\n                stackTop_ = fn_(state_, operand_, stackTop_);\\n            }\\n            return stackTop_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6a2c956607ead01db0a1da9de42920fbf7e275205e4c55ab4dc2cc575d550423\",\"license\":\"CAL\"},\"contracts/interpreter/run/LibStackTop.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"./RainInterpreter.sol\\\";\\nimport \\\"../../array/LibUint256Array.sol\\\";\\nimport \\\"../../bytes/LibBytes.sol\\\";\\n\\n/// Custom type to point to memory ostensibly in a stack.\\ntype StackTop is uint256;\\n\\n/// @title LibStackTop\\n/// @notice A `StackTop` is just a pointer to some memory. Ostensibly it is the\\n/// top of some stack used by the `RainInterpreter` so that means it can move \\\"up\\\" and\\n/// \\\"down\\\" (increment and decrement) by `uint256` (32 bytes) increments. In\\n/// general we're abusing that concept a bit to extend to things like the bottom\\n/// of a stack or a hypothetical maximum stack or even treating an arbitrary\\n/// `uint256[]` array as \\\"a stack\\\". In the future it's likely this lib and\\n/// concept will be renamed to reflect that it is used much more generally than\\n/// simply the top of some stack.\\n/// All the functions in `LibStackTop` operate on memory to read/write what is\\n/// referenced but the pointers and values themselves are typically input/output\\n/// of the functions. I.e. the stack top itself is not being mutated in-place,\\n/// typically the caller would have both the input stack top and the output\\n/// stack top in scope after calling library functions.\\n/// Most of the functions in this library are equivalent to each other via\\n/// composition, i.e. everything could be achieved with just `up`, `down`,\\n/// `pop`, `push`, `peek`. The reason there is so much duplication of logic is\\n/// that the Solidity compiler seems to fail at inlining equivalent logic quite\\n/// a lot sadly. There appears to be effort upstream towards improving the\\n/// function inlining by the optimizer so we should expect a lot of this library\\n/// to become redundant or even counterproductive in the future.\\nlibrary LibStackTop {\\n    using LibStackTop for StackTop;\\n    using LibStackTop for uint256[];\\n    using LibStackTop for bytes;\\n    using LibUint256Array for uint256[];\\n    using LibBytes for uint256;\\n\\n    /// Reads the value above the stack top. If the stack top is the current\\n    /// true stack top this is an out of bounds read. This is only useful if\\n    /// the stack was first moved down and the value it moved past needs to be\\n    /// read as part of the current operation.\\n    /// @param stackTop_ Position to read past/above.\\n    function peekUp(StackTop stackTop_) internal pure returns (uint256 a_) {\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(stackTop_)\\n        }\\n    }\\n\\n    /// Read the value immediately below the given stack top. Equivalent to\\n    /// calling `pop` and discarding the `stackTopAfter_` value, so may be\\n    /// less gas than setting and discarding a value.\\n    /// @param stackTop_ The stack top to read below.\\n    /// @return a_ The value that was read.\\n    function peek(StackTop stackTop_) internal pure returns (uint256 a_) {\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(sub(stackTop_, 0x20))\\n        }\\n    }\\n\\n    /// Reads 2 values below the given stack top.\\n    /// The following statements are equivalent but A may use gas if the\\n    /// compiler fails to inline some function calls.\\n    /// A:\\n    /// ```\\n    /// (uint a_, uint b_) = stackTop_.peek2();\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// uint b_;\\n    /// (stackTop_, b_) = stackTop_.pop();\\n    /// uint a_ = stackTop_.peek();\\n    /// ```\\n    /// @param stackTop_ The stack top to peek below.\\n    function peek2(\\n        StackTop stackTop_\\n    ) internal pure returns (uint256 a_, uint256 b_) {\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(sub(stackTop_, 0x40))\\n            b_ := mload(sub(stackTop_, 0x20))\\n        }\\n    }\\n\\n    /// Read the value immediately below the given stack top and return the\\n    /// stack top that points to the value that was read alongside the value.\\n    /// The following are equivalent but A may be cheaper if the compiler\\n    /// fails to inline some function calls:\\n    /// A:\\n    /// ```\\n    /// uint a_;\\n    /// (stackTop_, a_) = stackTop_.pop();\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackTop_ = stackTop_.down();\\n    /// uint a_ = stackTop_.peekUp();\\n    /// ```\\n    /// @param stackTop_ The stack top to read below.\\n    /// @return stackTopAfter_ The stack top that points to the value that was\\n    /// read.\\n    /// @return a_ The value that was read.\\n    function pop(\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop stackTopAfter_, uint256 a_) {\\n        assembly (\\\"memory-safe\\\") {\\n            stackTopAfter_ := sub(stackTop_, 0x20)\\n            a_ := mload(stackTopAfter_)\\n        }\\n    }\\n\\n    function consumeSentinel(\\n        StackTop stackTop_,\\n        StackTop stackBottom_,\\n        uint256 sentinel_,\\n        uint256 stepSize_\\n    ) internal pure returns (StackTop, uint256[] memory) {\\n        uint256[] memory array_;\\n        assembly (\\\"memory-safe\\\") {\\n            // Underflow is not allowed and pointing at position 0 in memory is\\n            // corrupt behaviour anyway.\\n            if iszero(stackBottom_) {\\n                revert(0, 0)\\n            }\\n            let sentinelLocation_ := 0\\n            let length_ := 0\\n            let step_ := mul(stepSize_, 0x20)\\n            for {\\n                stackTop_ := sub(stackTop_, 0x20)\\n                let end_ := sub(stackBottom_, 0x20)\\n            } gt(stackTop_, end_) {\\n                stackTop_ := sub(stackTop_, step_)\\n                length_ := add(length_, stepSize_)\\n            } {\\n                if eq(sentinel_, mload(stackTop_)) {\\n                    sentinelLocation_ := stackTop_\\n                    break\\n                }\\n            }\\n            // Sentinel MUST exist in the stack if consumer expects it to there.\\n            if iszero(sentinelLocation_) {\\n                revert(0, 0)\\n            }\\n            mstore(sentinelLocation_, length_)\\n            array_ := sentinelLocation_\\n        }\\n        return (stackTop_, array_);\\n    }\\n\\n    function consumeStructs(\\n        StackTop stackTop_,\\n        StackTop stackBottom_,\\n        uint256 sentinel_,\\n        uint256 structSize_\\n    ) internal pure returns (StackTop, uint256[] memory) {\\n        uint256[] memory tempArray_;\\n        (stackTop_, tempArray_) = stackTop_.consumeSentinel(\\n            stackBottom_,\\n            sentinel_,\\n            structSize_\\n        );\\n        uint256 structsLength_ = tempArray_.length / structSize_;\\n        uint256[] memory refs_ = new uint256[](structsLength_);\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n                let refCursor_ := add(refs_, 0x20)\\n                let refEnd_ := add(refCursor_, mul(structsLength_, 0x20))\\n                let tempCursor_ := add(tempArray_, 0x20)\\n                let tempStepSize_ := mul(structSize_, 0x20)\\n            } lt(refCursor_, refEnd_) {\\n                refCursor_ := add(refCursor_, 0x20)\\n                tempCursor_ := add(tempCursor_, tempStepSize_)\\n            } {\\n                mstore(refCursor_, tempCursor_)\\n            }\\n        }\\n        return (stackTop_, refs_);\\n    }\\n\\n    /// Write a value at the stack top location. Typically not useful if the\\n    /// given stack top is not subsequently moved past the written value , or\\n    /// if the given stack top is actually located somewhere below the \\\"true\\\"\\n    /// stack top.\\n    /// @param stackTop_ The stack top to write the value at.\\n    /// @param a_ The value to write.\\n    function set(StackTop stackTop_, uint256 a_) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackTop_, a_)\\n        }\\n    }\\n\\n    /// Store a `uint256` at the stack top position and return the stack top\\n    /// above the written value. The following statements are equivalent in\\n    /// functionality but A may be less gas if the compiler fails to inline\\n    /// some function calls.\\n    /// A:\\n    /// ```\\n    /// stackTop_ = stackTop_.push(a_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackTop_.set(a_);\\n    /// stackTop_ = stackTop_.up();\\n    /// ```\\n    /// @param stackTop_ The stack top to write at.\\n    /// @param a_ The value to write.\\n    /// @return The stack top above where `a_` was written to.\\n    function push(\\n        StackTop stackTop_,\\n        uint256 a_\\n    ) internal pure returns (StackTop) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackTop_, a_)\\n            stackTop_ := add(stackTop_, 0x20)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Store a `uint256[]` at the stack top position and return the stack top\\n    /// above the written values. The length of the array is NOT written to the\\n    /// stack, ONLY the array values are copied to the stack. The following\\n    /// statements are equivalent in functionality but A may be less gas if the\\n    /// compiler fails to inline some function calls.\\n    /// A:\\n    /// ```\\n    /// stackTop_ = stackTop_.push(array_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// unchecked {\\n    ///   for (uint i_ = 0; i_ < array_.length; i_++) {\\n    ///     stackTop_ = stackTop_.push(array_[i_]);\\n    ///   }\\n    /// }\\n    /// ```\\n    /// @param stackTop_ The stack top to write at.\\n    /// @param array_ The array of values to write.\\n    /// @return The stack top above the array.\\n    function push(\\n        StackTop stackTop_,\\n        uint256[] memory array_\\n    ) internal pure returns (StackTop) {\\n        array_.unsafeCopyValuesTo(StackTop.unwrap(stackTop_));\\n        return stackTop_.up(array_.length);\\n    }\\n\\n    /// Store a `uint256[]` at the stack top position and return the stack top\\n    /// above the written values. The length of the array IS written to the\\n    /// stack.\\n    /// @param stackTop_ The stack top to write at.\\n    /// @param array_ The array of values and length to write.\\n    /// @return The stack top above the array.\\n    function pushWithLength(\\n        StackTop stackTop_,\\n        uint256[] memory array_\\n    ) internal pure returns (StackTop) {\\n        return stackTop_.push(array_.length).push(array_);\\n    }\\n\\n    /// Store `bytes` at the stack top position and return the stack top above\\n    /// the written bytes. The length of the bytes is NOT written to the stack,\\n    /// ONLY the bytes are written. As `bytes` may be of arbitrary length, i.e.\\n    /// it MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\\n    /// ensure that this is safe in context of subsequent reads and writes.\\n    /// @param stackTop_ The stack top to write at.\\n    /// @param bytes_ The bytes to write at the stack top.\\n    /// @return The stack top above the written bytes.\\n    function unalignedPush(\\n        StackTop stackTop_,\\n        bytes memory bytes_\\n    ) internal pure returns (StackTop) {\\n        StackTop.unwrap(bytes_.asStackTop().up()).unsafeCopyBytesTo(\\n            StackTop.unwrap(stackTop_),\\n            bytes_.length\\n        );\\n        return stackTop_.upBytes(bytes_.length);\\n    }\\n\\n    /// Store `bytes` at the stack top position and return the stack top above\\n    /// the written bytes. The length of the bytes IS written to the stack in\\n    /// addition to the bytes. As `bytes` may be of arbitrary length, i.e. it\\n    /// MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\\n    /// ensure that this is safe in context of subsequent reads and writes.\\n    /// @param stackTop_ The stack top to write at.\\n    /// @param bytes_ The bytes to write with their length at the stack top.\\n    /// @return The stack top above the written bytes.\\n    function unalignedPushWithLength(\\n        StackTop stackTop_,\\n        bytes memory bytes_\\n    ) internal pure returns (StackTop) {\\n        return stackTop_.push(bytes_.length).unalignedPush(bytes_);\\n    }\\n\\n    /// Store 8x `uint256` at the stack top position and return the stack top\\n    /// above the written value. The following statements are equivalent in\\n    /// functionality but A may be cheaper if the compiler fails to\\n    /// inline some function calls.\\n    /// A:\\n    /// ```\\n    /// stackTop_ = stackTop_.push(a_, b_, c_, d_, e_, f_, g_, h_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackTop_ = stackTop_\\n    ///   .push(a_)\\n    ///   .push(b_)\\n    ///   .push(c_)\\n    ///   .push(d_)\\n    ///   .push(e_)\\n    ///   .push(f_)\\n    ///   .push(g_)\\n    ///   .push(h_);\\n    /// @param stackTop_ The stack top to write at.\\n    /// @param a_ The first value to write.\\n    /// @param b_ The second value to write.\\n    /// @param c_ The third value to write.\\n    /// @param d_ The fourth value to write.\\n    /// @param e_ The fifth value to write.\\n    /// @param f_ The sixth value to write.\\n    /// @param g_ The seventh value to write.\\n    /// @param h_ The eighth value to write.\\n    /// @return The stack top above where `h_` was written.\\n    function push(\\n        StackTop stackTop_,\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_,\\n        uint256 e_,\\n        uint256 f_,\\n        uint256 g_,\\n        uint256 h_\\n    ) internal pure returns (StackTop) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackTop_, a_)\\n            mstore(add(stackTop_, 0x20), b_)\\n            mstore(add(stackTop_, 0x40), c_)\\n            mstore(add(stackTop_, 0x60), d_)\\n            mstore(add(stackTop_, 0x80), e_)\\n            mstore(add(stackTop_, 0xA0), f_)\\n            mstore(add(stackTop_, 0xC0), g_)\\n            mstore(add(stackTop_, 0xE0), h_)\\n            stackTop_ := add(stackTop_, 0x100)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackTop) {\\n        uint256 a_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        a_ = fn_(a_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(Operand, uint256) internal view returns (uint256) fn_,\\n        Operand operand_\\n    ) internal view returns (StackTop) {\\n        uint256 a_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        a_ = fn_(operand_, a_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(uint256, uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackTop) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x20)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n        }\\n        a_ = fn_(a_, b_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Reduce a function N times, reading and writing inputs and the accumulated\\n    /// result on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param n_ The number of times to apply fn_ to accumulate a final result.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFnN(\\n        StackTop stackTop_,\\n        function(uint256, uint256) internal view returns (uint256) fn_,\\n        uint256 n_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        unchecked {\\n            uint256 bottom_;\\n            uint256 cursor_;\\n            uint256 a_;\\n            uint256 b_;\\n            assembly (\\\"memory-safe\\\") {\\n                bottom_ := sub(stackTop_, mul(n_, 0x20))\\n                a_ := mload(bottom_)\\n                stackTopAfter_ := add(bottom_, 0x20)\\n                cursor_ := stackTopAfter_\\n            }\\n            while (cursor_ < StackTop.unwrap(stackTop_)) {\\n                assembly (\\\"memory-safe\\\") {\\n                    b_ := mload(cursor_)\\n                }\\n                a_ = fn_(a_, b_);\\n                cursor_ += 0x20;\\n            }\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(bottom_, a_)\\n            }\\n        }\\n    }\\n\\n    function applyFnN(\\n        StackTop stackTop_,\\n        function(uint256) internal view fn_,\\n        uint256 n_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        uint256 cursor_;\\n        uint256 a_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTopAfter_ := sub(stackTop_, mul(n_, 0x20))\\n            cursor_ := stackTopAfter_\\n        }\\n        while (cursor_ < StackTop.unwrap(stackTop_)) {\\n            assembly (\\\"memory-safe\\\") {\\n                a_ := mload(cursor_)\\n                cursor_ := add(cursor_, 0x20)\\n            }\\n            fn_(a_);\\n        }\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(uint256, uint256, uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackTop) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 c_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x40)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n            c_ := mload(add(stackTop_, 0x20))\\n        }\\n        a_ = fn_(a_, b_, c_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(uint256, uint256, uint256, uint)\\n            internal\\n            view\\n            returns (uint256) fn_\\n    ) internal view returns (StackTop) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 c_;\\n        uint d_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x60)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n            c_ := mload(add(stackTop_, 0x20))\\n            d_ := mload(add(stackTop_, 0x40))\\n        }\\n        a_ = fn_(a_, b_, c_, d_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param operand_ Operand is passed from the source instead of the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(Operand, uint256, uint256) internal view returns (uint256) fn_,\\n        Operand operand_\\n    ) internal view returns (StackTop) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x20)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n        }\\n        a_ = fn_(operand_, a_, b_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(uint256[] memory) internal view returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        (uint256 a_, uint256[] memory tail_) = stackTop_.list(length_);\\n        uint256 b_ = fn_(tail_);\\n        return tail_.asStackTop().push(a_).push(b_);\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the array to pass to fn_ from the stack.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        (uint256 b_, uint256[] memory tail_) = stackTop_.list(length_);\\n        stackTopAfter_ = tail_.asStackTop();\\n        (StackTop location_, uint256 a_) = stackTopAfter_.pop();\\n        location_.set(fn_(a_, b_, tail_));\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the array to pass to fn_ from the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(uint256, uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackTop) {\\n        (uint256 c_, uint256[] memory tail_) = stackTop_.list(length_);\\n        (StackTop stackTopAfter_, uint256 b_) = tail_.asStackTop().pop();\\n        uint256 a_ = stackTopAfter_.peek();\\n        stackTopAfter_.down().set(fn_(a_, b_, c_, tail_));\\n        return stackTopAfter_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the arrays to pass to fn_ from the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(uint256, uint256[] memory, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256[] memory) fn_,\\n        uint256 length_\\n    ) internal view returns (StackTop) {\\n        StackTop csStart_ = stackTop_.down(length_);\\n        uint256[] memory cs_ = LibUint256Array.copyToNewUint256Array(\\n            StackTop.unwrap(csStart_),\\n            length_\\n        );\\n        (uint256 a_, uint256[] memory bs_) = csStart_.list(length_);\\n\\n        uint256[] memory results_ = fn_(a_, bs_, cs_);\\n        require(results_.length == length_, \\\"BAD_RESULT_LENGTH\\\");\\n        StackTop bottom_ = bs_.asStackTop();\\n        LibUint256Array.unsafeCopyValuesTo(results_, StackTop.unwrap(bottom_));\\n        return bottom_.up(length_);\\n    }\\n\\n    /// Returns `length_` values from the stack as an array without allocating\\n    /// new memory. As arrays always start with their length, this requires\\n    /// writing the length value to the stack below the array values. The value\\n    /// that is overwritten in the process is also returned so that data is not\\n    /// lost. For example, imagine a stack `[ A B C D ]` and we list 2 values.\\n    /// This will write the stack to look like `[ A 2 C D ]` and return both `B`\\n    /// and a pointer to `2` represented as a `uint256[]`.\\n    /// The returned array is ONLY valid for as long as the stack DOES NOT move\\n    /// back into its memory. As soon as the stack moves up again and writes into\\n    /// the array it will be corrupt. The caller MUST ensure that it does not\\n    /// read from the returned array after it has been corrupted by subsequent\\n    /// stack writes.\\n    /// @param stackTop_ The stack top to read the values below into an array.\\n    /// @param length_ The number of values to include in the returned array.\\n    /// @return head_ The value that was overwritten with the length.\\n    /// @return tail_ The array constructed from the stack memory.\\n    function list(\\n        StackTop stackTop_,\\n        uint256 length_\\n    ) internal pure returns (uint256 head_, uint256[] memory tail_) {\\n        assembly (\\\"memory-safe\\\") {\\n            tail_ := sub(stackTop_, add(0x20, mul(length_, 0x20)))\\n            head_ := mload(tail_)\\n            mstore(tail_, length_)\\n        }\\n    }\\n\\n    /// Cast a `uint256[]` array to a stack top. The stack top will point to the\\n    /// length of the array, NOT its first value.\\n    /// @param array_ The array to cast to a stack top.\\n    /// @return stackTop_ The stack top that points to the length of the array.\\n    function asStackTop(\\n        uint256[] memory array_\\n    ) internal pure returns (StackTop stackTop_) {\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := array_\\n        }\\n    }\\n\\n    /// Cast a stack top to an array. The value immediately above the stack top\\n    /// will be treated as the length of the array, so the proceeding length\\n    /// values will be the items of the array. The caller MUST ensure the values\\n    /// above the stack top constitute a valid array. The retured array will be\\n    /// corrupt if/when the stack subsequently moves into it and writes to those\\n    /// memory locations. The caller MUST ensure that it does NOT read from the\\n    /// returned array after the stack writes over it.\\n    /// @param stackTop_ The stack top that will be cast to an array.\\n    /// @return array_ The array above the stack top.\\n    function asUint256Array(\\n        StackTop stackTop_\\n    ) internal pure returns (uint256[] memory array_) {\\n        assembly (\\\"memory-safe\\\") {\\n            array_ := stackTop_\\n        }\\n    }\\n\\n    /// Cast a stack top to bytes. The value immediately above the stack top will\\n    /// be treated as the length of the `bytes`, so the proceeding length bytes\\n    /// will be the data of the `bytes`. The caller MUST ensure the length and\\n    /// bytes above the stack top constitute valid `bytes` data. The returned\\n    /// `bytes` will be corrupt if/when the stack subsequently moves into it and\\n    /// writes to those memory locations. The caller MUST ensure that it does\\n    /// NOT read from the returned bytes after the stack writes over it.\\n    /// @param stackTop_ The stack top that will be cast to bytes.\\n    /// @return bytes_ The bytes above the stack top.\\n    function asBytes(\\n        StackTop stackTop_\\n    ) internal pure returns (bytes memory bytes_) {\\n        assembly (\\\"memory-safe\\\") {\\n            bytes_ := stackTop_\\n        }\\n    }\\n\\n    /// Cast a `uint256[]` array to a stack top after its length. The stack top\\n    /// will point to the first item of the array, NOT its length.\\n    /// @param array_ The array to cast to a stack top.\\n    /// @return stackTop_ The stack top that points to the first item of the array.\\n    function asStackTopUp(\\n        uint256[] memory array_\\n    ) internal pure returns (StackTop stackTop_) {\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := add(array_, 0x20)\\n        }\\n    }\\n\\n    function asStackTopAfter(\\n        uint256[] memory array_\\n    ) internal pure returns (StackTop stackTop_) {\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := add(array_, add(0x20, mul(mload(array_), 0x20)))\\n        }\\n    }\\n\\n    /// Cast `bytes` to a stack top. The stack top will point to the length of\\n    /// the `bytes`, NOT the first byte.\\n    /// @param bytes_ The `bytes` to cast to a stack top.\\n    /// @return stackTop_ The stack top that points to the length of the bytes.\\n    function asStackTop(\\n        bytes memory bytes_\\n    ) internal pure returns (StackTop stackTop_) {\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := bytes_\\n        }\\n    }\\n\\n    /// Returns the stack top 32 bytes above/past the passed stack top.\\n    /// @param stackTop_ The stack top at the starting position.\\n    /// @return The stack top 32 bytes above the passed stack top.\\n    function up(StackTop stackTop_) internal pure returns (StackTop) {\\n        unchecked {\\n            return StackTop.wrap(StackTop.unwrap(stackTop_) + 0x20);\\n        }\\n    }\\n\\n    /// Returns the stack top `n_ * 32` bytes above/past the passed stack top.\\n    /// @param stackTop_ The stack top at the starting position.\\n    /// @param n_ The multiplier on the stack movement. MAY be zero.\\n    /// @return The stack top `n_ * 32` bytes above/past the passed stack top.\\n    function up(\\n        StackTop stackTop_,\\n        uint256 n_\\n    ) internal pure returns (StackTop) {\\n        unchecked {\\n            return StackTop.wrap(StackTop.unwrap(stackTop_) + 0x20 * n_);\\n        }\\n    }\\n\\n    /// Returns the stack top `n_` bytes above/past the passed stack top.\\n    /// The returned stack top MAY NOT be aligned with the passed stack top for\\n    /// subsequent 32 byte reads and writes. The caller MUST ensure that it is\\n    /// safe to read and write data relative to the returned stack top.\\n    /// @param stackTop_ The stack top at the starting position.\\n    /// @param n_ The number of bytes to move.\\n    /// @return The stack top `n_` bytes above/past the passed stack top.\\n    function upBytes(\\n        StackTop stackTop_,\\n        uint256 n_\\n    ) internal pure returns (StackTop) {\\n        unchecked {\\n            return StackTop.wrap(StackTop.unwrap(stackTop_) + n_);\\n        }\\n    }\\n\\n    /// Returns the stack top 32 bytes below/before the passed stack top.\\n    /// @param stackTop_ The stack top at the starting position.\\n    /// @return The stack top 32 bytes below/before the passed stack top.\\n    function down(StackTop stackTop_) internal pure returns (StackTop) {\\n        unchecked {\\n            return StackTop.wrap(StackTop.unwrap(stackTop_) - 0x20);\\n        }\\n    }\\n\\n    /// Returns the stack top `n_ * 32` bytes below/before the passed stack top.\\n    /// @param stackTop_ The stack top at the starting position.\\n    /// @param n_ The multiplier on the movement.\\n    /// @return The stack top `n_ * 32` bytes below/before the passed stack top.\\n    function down(\\n        StackTop stackTop_,\\n        uint256 n_\\n    ) internal pure returns (StackTop) {\\n        unchecked {\\n            return StackTop.wrap(StackTop.unwrap(stackTop_) - 0x20 * n_);\\n        }\\n    }\\n\\n    /// Convert two stack top values to a single stack index. A stack index is\\n    /// the distance in 32 byte increments between two stack positions. The\\n    /// calculations assumes the two stack positions are aligned. The caller MUST\\n    /// ensure the alignment of both values. The calculation is unchecked and MAY\\n    /// underflow. The caller MUST ensure that the stack top is always above the\\n    /// stack bottom.\\n    /// @param stackBottom_ The lower of the two values.\\n    /// @param stackTop_ The higher of the two values.\\n    /// @return The stack index as 32 byte distance between the two stack\\n    /// positions.\\n    function toIndex(\\n        StackTop stackBottom_,\\n        StackTop stackTop_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            return\\n                (StackTop.unwrap(stackTop_) - StackTop.unwrap(stackBottom_)) /\\n                0x20;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3365a67cfc54be5907d50e79ebaf071152eae5293576f56a0455b4794f513f4a\",\"license\":\"CAL\"},\"contracts/interpreter/run/RainInterpreter.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\nimport \\\"../../math/SaturatingMath.sol\\\";\\nimport \\\"../../type/LibCast.sol\\\";\\nimport \\\"./LibStackTop.sol\\\";\\nimport \\\"./LibInterpreterState.sol\\\";\\nimport \\\"../../array/LibUint256Array.sol\\\";\\nimport \\\"../../sstore2/SSTORE2.sol\\\";\\nimport \\\"../deploy/IRainInterpreterIntegrity.sol\\\";\\nimport {SafeCastUpgradeable as SafeCast} from \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\\\";\\n\\ntype Operand is uint256;\\n\\n/// @title RainInterpreter\\n/// @notice Interpreter for implementing and executing custom contract DSLs.\\n/// Libraries and contracts map opcodes to `view` functionality then\\n/// `RainInterpreter` runs Rain expressions using these opcodes. Rain expressions\\n/// dispatch as pairs of bytes. The first byte is an opcode to run and the\\n/// second byte is a value the opcode can use contextually to inform how to run.\\n/// Typically opcodes will read/write to the stack to produce some meaningful\\n/// final state after all opcodes have been dispatched.\\n///\\n/// The only thing required to run a Rain expression is a `State` struct to pass\\n/// to `eval`, and the index of the source to run. Additional context can\\n/// optionally be provided to be used by opcodes. For example, an `ITierV2`\\n/// contract can take the input of `report`, abi encode it as context, then\\n/// expose a local opcode that copies this account to the stack. The state will\\n/// be mutated by reference rather than returned by `eval`, this is to make it\\n/// very clear to implementers that the inline mutation is occurring.\\n///\\n/// Rain expressions run \\\"top to bottom\\\", i.e. \\\"left to right\\\".\\n/// See the tests for examples on how to construct Rain expression in JavaScript\\n/// then pass to `ImmutableSource` contracts deployed by a factory that then\\n/// run `eval` to produce a final value.\\n///\\n/// There are only 4 \\\"core\\\" opcodes for `RainInterpreter`:\\n/// - `0`: Copy value from either `constants` at index `operand` to the top of\\n///   the stack.\\n/// - `1`: Duplicates the value at stack index `operand_` to the top of the\\n///   stack.\\n/// - `2`: Zipmap takes N values from the stack, interprets each as an array of\\n///   configurable length, then zips them into `arguments` and maps a source\\n///   from `sources` over these. See `zipmap` for more details.\\n/// - `3`: Debug prints the state to the console log as per hardhat.\\n///\\n/// To do anything useful the contract that inherits `RainInterpreter` needs to provide\\n/// opcodes to build up an internal DSL. This may sound complex but it only\\n/// requires mapping opcode integers to functions to call, and reading/writing\\n/// values to the stack as input/output for these functions. Further, opcode\\n/// packs are provided in rain that any inheriting contract can use as a normal\\n/// solidity library. See `MathOps.sol` opcode pack and the\\n/// `CalculatorTest.sol` test contract for an example of how to dispatch\\n/// opcodes and handle the results in a wrapping contract.\\n///\\n/// RainInterpreter natively has no concept of branching logic such as `if` or loops.\\n/// An opcode pack could implement these similar to the core zipmap by lazily\\n/// evaluating a source from `sources` based on some condition, etc. Instead\\n/// some simpler, eagerly evaluated selection tools such as `min` and `max` in\\n/// the `MathOps` opcode pack are provided. Future versions of `RainInterpreter` MAY\\n/// implement lazy `if` and other similar patterns.\\n///\\n/// The `eval` function is `view` because Rain expressions are expected to\\n/// compute results only without modifying any state. The contract wrapping the\\n/// Interpreter is free to mutate as usual. This model encourages exposing only\\n/// read-only functionality to end-user deployers who provide expressions to an\\n/// interpreter factory. Removing all writes removes a lot of potential\\n/// foot-guns for expression authors and allows contract authors to reason more\\n/// clearly about the input/output of the wrapping solidity code.\\n///\\n/// Internally `RainInterpreter` makes heavy use of unchecked math and assembly\\n/// logic as the opcode dispatch logic runs on a tight loop and so gas costs can\\n/// ramp up very quickly.\\nabstract contract RainInterpreter {\\n    using Math for uint256;\\n    using SaturatingMath for uint256;\\n    using LibCast for uint256;\\n    using LibInterpreterState for InterpreterState;\\n    using LibStackTop for uint256[];\\n    using LibStackTop for bytes;\\n    using LibStackTop for StackTop;\\n    using LibCast for function(InterpreterState memory, SourceIndex, StackTop)\\n        internal\\n        view\\n        returns (StackTop);\\n    using LibCast for function(InterpreterState memory, Operand, StackTop)\\n        internal\\n        view\\n        returns (StackTop)[];\\n    using LibConvert for uint256[];\\n    using LibInterpreterState for StateConfig;\\n\\n    /// Expose all the function pointers for every opcode as 2-byte pointers in\\n    /// a bytes list. The implementing Interpreter MUST ensure each pointer is\\n    /// to a `function(uint256,uint256) view returns (uint256)` function as this\\n    /// is the ONLY supported signature for opcodes. Pointers for the core\\n    /// opcodes must be provided in the packed pointers list but will be ignored\\n    /// at runtime.\\n    function opcodeFunctionPointers()\\n        internal\\n        view\\n        virtual\\n        returns (\\n            function(InterpreterState memory, Operand, StackTop)\\n                internal\\n                view\\n                returns (StackTop)[]\\n                memory\\n        );\\n\\n    /// Builds a new `State` bytes from `StateConfig`.\\n    /// Empty stack and arguments with stack index 0.\\n    /// @param config_ State config to build the new `State`.\\n    function buildStateBytes(\\n        IRainInterpreterIntegrity interpreterIntegrity_,\\n        StateConfig memory config_,\\n        uint[] memory minStackOutputs_\\n    ) internal view returns (bytes memory) {\\n        unchecked {\\n            (, uint256 stackLength_) = interpreterIntegrity_.ensureIntegrity(\\n                config_.sources,\\n                config_.constants.length,\\n                minStackOutputs_\\n            );\\n\\n            return\\n                config_.serialize(\\n                    stackLength_,\\n                    opcodeFunctionPointers()\\n                        .asUint256Array()\\n                        .unsafeTo16BitBytes()\\n                );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd5c680686bb532a56d10c1cdaa767ad9b9e6f30362ff47f248711b91bfbcf6b1\",\"license\":\"CAL\"},\"contracts/kv/LibMemoryKV.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../math/Binary.sol\\\";\\n\\ntype MemoryKV is uint;\\ntype MemoryKVKey is uint;\\ntype MemoryKVPtr is uint;\\ntype MemoryKVVal is uint;\\n\\nlibrary LibMemoryKV {\\n    function readPtrVal(MemoryKVPtr ptr_) internal pure returns (MemoryKVVal) {\\n        // This is ALWAYS a bug. It means the caller did not check if the ptr is\\n        // nonzero before trying to read from it.\\n        require(MemoryKVPtr.unwrap(ptr_) > 0, \\\"INVALID_PTR\\\");\\n        MemoryKVVal v_;\\n        assembly (\\\"memory-safe\\\") {\\n            v_ := mload(add(ptr_, 0x20))\\n        }\\n        return v_;\\n    }\\n\\n    function getPtr(\\n        MemoryKV kv_,\\n        MemoryKVKey k_\\n    ) internal pure returns (MemoryKVPtr) {\\n        uint mask_ = MASK_16BIT;\\n        MemoryKVPtr ptr_;\\n        assembly (\\\"memory-safe\\\") {\\n            // loop until k found or give up if ptr is zero\\n            for {\\n                ptr_ := and(kv_, mask_)\\n            } iszero(iszero(ptr_)) {\\n                ptr_ := mload(add(ptr_, 0x40))\\n            } {\\n                if eq(k_, mload(ptr_)) {\\n                    break\\n                }\\n            }\\n        }\\n        return ptr_;\\n    }\\n\\n    function setVal(\\n        MemoryKV kv_,\\n        MemoryKVKey k_,\\n        MemoryKVVal v_\\n    ) internal pure returns (MemoryKV) {\\n        MemoryKVPtr ptr_ = getPtr(kv_, k_);\\n        uint mask_ = MASK_16BIT;\\n        // update\\n        if (MemoryKVPtr.unwrap(ptr_) > 0) {\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(add(ptr_, 0x20), v_)\\n            }\\n        }\\n        // insert\\n        else {\\n            assembly (\\\"memory-safe\\\") {\\n                // allocate new memory\\n                ptr_ := mload(0x40)\\n                mstore(0x40, add(ptr_, 0x60))\\n                // set k/v/ptr\\n                mstore(ptr_, k_)\\n                mstore(add(ptr_, 0x20), v_)\\n                mstore(add(ptr_, 0x40), and(kv_, mask_))\\n                // kv must point to new insertion and update array len\\n                kv_ := or(\\n                    // inc len by 2\\n                    shl(16, add(shr(16, kv_), 2)),\\n                    // set ptr\\n                    ptr_\\n                )\\n            }\\n        }\\n        return kv_;\\n    }\\n\\n    function toUint256Array(\\n        MemoryKV kv_\\n    ) internal pure returns (uint[] memory) {\\n        unchecked {\\n            uint ptr_ = MemoryKV.unwrap(kv_) & MASK_16BIT;\\n            uint length_ = MemoryKV.unwrap(kv_) >> 16;\\n            uint[] memory arr_ = new uint[](length_);\\n            assembly (\\\"memory-safe\\\") {\\n                for {\\n                    let cursor_ := add(arr_, 0x20)\\n                    let end_ := add(cursor_, mul(mload(arr_), 0x20))\\n                } lt(cursor_, end_) {\\n                    cursor_ := add(cursor_, 0x20)\\n                    ptr_ := mload(add(ptr_, 0x40))\\n                } {\\n                    // key\\n                    mstore(cursor_, mload(ptr_))\\n                    cursor_ := add(cursor_, 0x20)\\n                    // value\\n                    mstore(cursor_, mload(add(ptr_, 0x20)))\\n                }\\n            }\\n            return arr_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x312fd2f1eddee6df3a2b94b3bbc5e159a940422e8c7dc2d636a55ba926fc2f83\",\"license\":\"CAL\"},\"contracts/math/Binary.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// @dev Binary 1.\\nuint constant B_1 = 2 ** 1 - 1;\\n/// @dev Binary 11.\\nuint constant B_11 = 2 ** 2 - 1;\\n/// @dev Binary 111.\\nuint constant B_111 = 2 ** 3 - 1;\\n/// @dev Binary 1111.\\nuint constant B_1111 = 2 ** 4 - 1;\\n/// @dev Binary 11111.\\nuint constant B_11111 = 2 ** 5 - 1;\\n/// @dev Binary 111111.\\nuint constant B_111111 = 2 ** 6 - 1;\\n/// @dev Binary 1111111.\\nuint constant B_1111111 = 2 ** 7 - 1;\\n/// @dev Binary 11111111.\\nuint constant B_11111111 = 2 ** 8 - 1;\\n/// @dev Binary 111111111.\\nuint constant B_111111111 = 2 ** 9 - 1;\\n/// @dev Binary 1111111111.\\nuint constant B_1111111111 = 2 ** 10 - 1;\\n/// @dev Binary 11111111111.\\nuint constant B_11111111111 = 2 ** 11 - 1;\\n/// @dev Binary 111111111111.\\nuint constant B_111111111111 = 2 ** 12 - 1;\\n/// @dev Binary 1111111111111.\\nuint constant B_1111111111111 = 2 ** 13 - 1;\\n/// @dev Binary 11111111111111.\\nuint constant B_11111111111111 = 2 ** 14 - 1;\\n/// @dev Binary 111111111111111.\\nuint constant B_111111111111111 = 2 ** 15 - 1;\\n/// @dev Binary 1111111111111111.\\nuint constant B_1111111111111111 = 2 ** 16 - 1;\\n\\n/// @dev Bitmask for 1 bit.\\nuint constant MASK_1BIT = B_1;\\n/// @dev Bitmask for 2 bits.\\nuint constant MASK_2BIT = B_11;\\n/// @dev Bitmask for 3 bits.\\nuint constant MASK_3BIT = B_111;\\n/// @dev Bitmask for 4 bits.\\nuint constant MASK_4BIT = B_1111;\\n/// @dev Bitmask for 5 bits.\\nuint constant MASK_5BIT = B_11111;\\n/// @dev Bitmask for 6 bits.\\nuint constant MASK_6BIT = B_111111;\\n/// @dev Bitmask for 7 bits.\\nuint constant MASK_7BIT = B_1111111;\\n/// @dev Bitmask for 8 bits.\\nuint constant MASK_8BIT = B_11111111;\\n/// @dev Bitmask for 9 bits.\\nuint constant MASK_9BIT = B_111111111;\\n/// @dev Bitmask for 10 bits.\\nuint constant MASK_10BIT = B_1111111111;\\n/// @dev Bitmask for 11 bits.\\nuint constant MASK_11BIT = B_11111111111;\\n/// @dev Bitmask for 12 bits.\\nuint constant MASK_12BIT = B_111111111111;\\n/// @dev Bitmask for 13 bits.\\nuint constant MASK_13BIT = B_1111111111111;\\n/// @dev Bitmask for 14 bits.\\nuint constant MASK_14BIT = B_11111111111111;\\n/// @dev Bitmask for 15 bits.\\nuint constant MASK_15BIT = B_111111111111111;\\n/// @dev Bitmask for 16 bits.\\nuint constant MASK_16BIT = B_1111111111111111;\\n\",\"keccak256\":\"0xb6b19cdc224817f0240f4452792570c812e299ae6c254cdb4c0f5f2766327b0c\",\"license\":\"CAL\"},\"contracts/math/FixedPointMath.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\n\\n/// @dev The scale of all fixed point math. This is adopting the conventions of\\n/// both ETH (wei) and most ERC20 tokens, so is hopefully uncontroversial.\\nuint256 constant FP_DECIMALS = 18;\\n/// @dev The number `1` in the standard fixed point math scaling. Most of the\\n/// differences between fixed point math and regular math is multiplying or\\n/// dividing by `ONE` after the appropriate scaling has been applied.\\nuint256 constant FP_ONE = 1e18;\\n\\n/// @title FixedPointMath\\n/// @notice Sometimes we want to do math with decimal values but all we have\\n/// are integers, typically uint256 integers. Floats are very complex so we\\n/// don't attempt to simulate them. Instead we provide a standard definition of\\n/// \\\"one\\\" as 10 ** 18 and scale everything up/down to this as fixed point math.\\n/// Overflows are errors as per Solidity.\\n///\\n/// Note that scaling down ANY fixed point decimal also reduces the precision\\n/// which lead to dust or in the worst case trapped funds if subsequent\\n/// subtraction overflows a rounded-down number. Consider using saturating\\n/// subtraction for safety against previously downscaled values, and whether\\n/// trapped dust is a significant issue. If you need to retain full/arbitrary\\n/// precision in the case of downscaling DO NOT use this library.\\nlibrary FixedPointMath {\\n    using Math for uint256;\\n\\n    /// Scale a fixed point decimal of some scale factor to match `DECIMALS`.\\n    /// @param a_ Some fixed point decimal value.\\n    /// @param aDecimals_ The number of fixed decimals of `a_`.\\n    /// @return `a_` scaled to match `DECIMALS`.\\n    function scale18(\\n        uint256 a_,\\n        uint256 aDecimals_\\n    ) internal pure returns (uint256) {\\n        uint256 decimals_;\\n        if (FP_DECIMALS == aDecimals_) {\\n            return a_;\\n        } else if (FP_DECIMALS > aDecimals_) {\\n            unchecked {\\n                decimals_ = FP_DECIMALS - aDecimals_;\\n            }\\n            return a_ * 10 ** decimals_;\\n        } else {\\n            unchecked {\\n                decimals_ = aDecimals_ - FP_DECIMALS;\\n            }\\n            return a_ / 10 ** decimals_;\\n        }\\n    }\\n\\n    /// Scale a fixed point decimals of `DECIMALS` to some other scale.\\n    /// @param a_ A `DECIMALS` fixed point decimals.\\n    /// @param targetDecimals_ The new scale of `a_`.\\n    /// @return `a_` rescaled from `DECIMALS` to `targetDecimals_`.\\n    function scaleN(\\n        uint256 a_,\\n        uint256 targetDecimals_\\n    ) internal pure returns (uint256) {\\n        uint256 decimals_;\\n        if (targetDecimals_ == FP_DECIMALS) {\\n            return a_;\\n        } else if (FP_DECIMALS > targetDecimals_) {\\n            unchecked {\\n                decimals_ = FP_DECIMALS - targetDecimals_;\\n            }\\n            return a_ / 10 ** decimals_;\\n        } else {\\n            unchecked {\\n                decimals_ = targetDecimals_ - FP_DECIMALS;\\n            }\\n            return a_ * 10 ** decimals_;\\n        }\\n    }\\n\\n    /// Scale a fixed point up or down by `scaleBy_` orders of magnitude.\\n    /// The caller MUST ensure the end result matches `DECIMALS` if other\\n    /// functions in this library are to work correctly.\\n    /// Notably `scaleBy` is a SIGNED integer so scaling down by negative OOMS\\n    /// is supported.\\n    /// @param a_ Some integer of any scale.\\n    /// @param scaleBy_ OOMs to scale `a_` up or down by.\\n    /// @return `a_` rescaled according to `scaleBy_`.\\n    function scaleBy(\\n        uint256 a_,\\n        int8 scaleBy_\\n    ) internal pure returns (uint256) {\\n        if (scaleBy_ == 0) {\\n            return a_;\\n        } else if (scaleBy_ > 0) {\\n            return a_ * 10 ** uint8(scaleBy_);\\n        } else {\\n            uint256 posScaleDownBy_;\\n            unchecked {\\n                posScaleDownBy_ = uint8(-1 * scaleBy_);\\n            }\\n            return a_ / 10 ** posScaleDownBy_;\\n        }\\n    }\\n\\n    /// Fixed point multiplication in native scale decimals.\\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return `a_` multiplied by `b_` to `DECIMALS` fixed point decimals.\\n    function fixedPointMul(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        return a_.mulDiv(b_, FP_ONE);\\n    }\\n\\n    /// Fixed point division in native scale decimals.\\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return `a_` divided by `b_` to `DECIMALS` fixed point decimals.\\n    function fixedPointDiv(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        return a_.mulDiv(FP_ONE, b_);\\n    }\\n}\\n\",\"keccak256\":\"0xcb5f2e5cd30023d7bbd938a92afa84bef453bf79e95a8602265e8e2e3d5a9118\",\"license\":\"CAL\"},\"contracts/math/SaturatingMath.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// @title SaturatingMath\\n/// @notice Sometimes we neither want math operations to error nor wrap around\\n/// on an overflow or underflow. In the case of transferring assets an error\\n/// may cause assets to be locked in an irretrievable state within the erroring\\n/// contract, e.g. due to a tiny rounding/calculation error. We also can't have\\n/// assets underflowing and attempting to approve/transfer \\\"infinity\\\" when we\\n/// wanted \\\"almost or exactly zero\\\" but some calculation bug underflowed zero.\\n/// Ideally there are no calculation mistakes, but in guarding against bugs it\\n/// may be safer pragmatically to saturate arithmatic at the numeric bounds.\\n/// Note that saturating div is not supported because 0/0 is undefined.\\nlibrary SaturatingMath {\\n    /// Saturating addition.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return Minimum of a_ + b_ and max uint256.\\n    function saturatingAdd(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 c_ = a_ + b_;\\n            return c_ < a_ ? type(uint256).max : c_;\\n        }\\n    }\\n\\n    /// Saturating subtraction.\\n    /// @param a_ Minuend.\\n    /// @param b_ Subtrahend.\\n    /// @return Maximum of a_ - b_ and 0.\\n    function saturatingSub(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            return a_ > b_ ? a_ - b_ : 0;\\n        }\\n    }\\n\\n    /// Saturating multiplication.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return Minimum of a_ * b_ and max uint256.\\n    function saturatingMul(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being\\n            // zero, but the benefit is lost if 'b' is also tested.\\n            // https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a_ == 0) return 0;\\n            uint256 c_ = a_ * b_;\\n            return c_ / a_ != b_ ? type(uint256).max : c_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5ffcfd7be86bf2a4e28bc55aceeae041b1c014e0a0d7394107238d607ace352a\",\"license\":\"CAL\"},\"contracts/memory/LibMemorySize.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.10;\\n\\n/// @title LibMemorySize\\n/// @notice Reports the size in bytes of type data that represents contigious\\n/// regions of memory. Pointers to regions of memory that may not be congigious\\n/// are not supported, e.g. fields on structs may point to dynamic data that is\\n/// separate to the struct. Length slots for dynamic data are included in the\\n/// size and the size is always measured in bytes.\\nlibrary LibMemorySize {\\n    /// Reports the size of a `uint256` in bytes. Is always 32.\\n    /// @return 32.\\n    function size(uint256) internal pure returns (uint256) {\\n        return 0x20;\\n    }\\n\\n    /// Reports the size of a `uint256[]` in bytes. Is the size of the length\\n    /// slot (32 bytes) plus the length of the array multiplied by 32 bytes per\\n    /// item.\\n    /// @return The size of the array data including its length slot size.\\n    function size(uint256[] memory array_) internal pure returns (uint256) {\\n        unchecked {\\n            return 0x20 + (array_.length * 0x20);\\n        }\\n    }\\n\\n    /// Reports the size of `bytes` data. Is the size of the length slot\\n    /// (32 bytes) plus the number of bytes as per its length.\\n    /// @return The size of the `bytes` data including its length slot size.\\n    function size(bytes memory bytes_) internal pure returns (uint256) {\\n        unchecked {\\n            return 0x20 + bytes_.length;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8d83afcdf42bce8f16b93f7c00f7059e02d86234e78f97ed9d2e19651da616d5\",\"license\":\"CAL\"},\"contracts/orderbook/IOrderBookV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../interpreter/deploy/IExpressionDeployerV1.sol\\\";\\nimport \\\"../interpreter/run/IInterpreterV1.sol\\\";\\n\\nstruct DepositConfig {\\n    address token;\\n    uint256 vaultId;\\n    uint256 amount;\\n}\\n\\nstruct WithdrawConfig {\\n    address token;\\n    uint256 vaultId;\\n    uint256 amount;\\n}\\n\\nstruct IO {\\n    address token;\\n    uint256 vaultId;\\n}\\n\\nstruct OrderConfig {\\n    address expressionDeployer;\\n    address interpreter;\\n    StateConfig interpreterStateConfig;\\n    IO[] validInputs;\\n    IO[] validOutputs;\\n}\\n\\nstruct Order {\\n    address owner;\\n    address interpreter;\\n    EncodedDispatch dispatch;\\n    EncodedDispatch handleIODispatch;\\n    IO[] validInputs;\\n    IO[] validOutputs;\\n}\\n\\nstruct TakeOrdersConfig {\\n    /// Output token from the perspective of the order taker.\\n    address output;\\n    /// Input token from the perspective of the order taker.\\n    address input;\\n    /// Minimum input from the perspective of the order taker.\\n    uint256 minimumInput;\\n    /// Maximum input from the perspective of the order taker.\\n    uint256 maximumInput;\\n    /// Maximum IO ratio as calculated by the order being taken. The input is\\n    /// from the perspective of the order so higher ratio means worse deal for\\n    /// the order taker.\\n    uint256 maximumIORatio;\\n    /// Ordered list of orders that will be taken until the limit is hit. Takers\\n    /// are expected to prioritise orders that appear to be offering better deals\\n    /// i.e. lower IO ratios. This prioritisation and sorting MUST happen\\n    /// offchain, e.g. via. some simulator.\\n    TakeOrderConfig[] orders;\\n}\\n\\nstruct TakeOrderConfig {\\n    Order order;\\n    uint256 inputIOIndex;\\n    uint256 outputIOIndex;\\n}\\n\\nstruct ClearConfig {\\n    uint256 aInputIOIndex;\\n    uint256 aOutputIOIndex;\\n    uint256 bInputIOIndex;\\n    uint256 bOutputIOIndex;\\n    uint256 aBountyVaultId;\\n    uint256 bBountyVaultId;\\n}\\n\\ninterface IOrderBookV1 {\\n    /// depositor => token => vault id => token amount.\\n    function vaultBalance(\\n        address owner,\\n        address token,\\n        uint id\\n    ) external view returns (uint balance);\\n\\n    function deposit(DepositConfig calldata config) external;\\n\\n    function withdraw(WithdrawConfig calldata config) external;\\n\\n    function addOrder(OrderConfig calldata config) external;\\n\\n    function removeOrder(Order calldata order) external;\\n\\n    function takeOrders(\\n        TakeOrdersConfig calldata takeOrders\\n    ) external returns (uint256 totalInput, uint256 totalOutput);\\n\\n    function clear(\\n        Order memory a,\\n        Order memory b,\\n        ClearConfig calldata clearConfig\\n    ) external;\\n}\\n\",\"keccak256\":\"0x5506d25e59ef9ff82d68eb94dbcab3d329b1eabfe17c8381a0a75cef9522d212\",\"license\":\"CAL\"},\"contracts/orderbook/OrderBook.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"./IOrderBookV1.sol\\\";\\nimport \\\"../interpreter/run/LibStackTop.sol\\\";\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {SafeERC20Upgradeable as SafeERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\nimport \\\"../math/FixedPointMath.sol\\\";\\nimport \\\"../interpreter/ops/AllStandardOps.sol\\\";\\nimport \\\"./OrderBookFlashLender.sol\\\";\\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"../interpreter/run/LibEncodedDispatch.sol\\\";\\nimport {MulticallUpgradeable as Multicall} from \\\"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\\\";\\n\\nSourceIndex constant ORDER_ENTRYPOINT = SourceIndex.wrap(0);\\nSourceIndex constant HANDLE_IO_ENTRYPOINT = SourceIndex.wrap(1);\\n\\nuint constant ORDER_MIN_OUTPUTS = 2;\\nuint constant ORDER_MAX_OUTPUTS = 2;\\n\\nuint constant HANDLE_IO_MIN_OUTPUTS = 0;\\nuint constant HANDLE_IO_MAX_OUTPUTS = type(uint16).max;\\n\\nuint constant CONTEXT_COLUMNS = 4;\\nuint constant CONTEXT_BASE_COLUMN = 0;\\nuint constant CONTEXT_CALCULATIONS_COLUMN = 1;\\nuint constant CONTEXT_VAULT_INPUTS_COLUMN = 2;\\nuint constant CONTEXT_VAULT_OUTPUTS_COLUMN = 3;\\n\\nuint constant CONTEXT_VAULT_IO_TOKEN = 0;\\nuint constant CONTEXT_VAULT_IO_VAULT_ID = 1;\\nuint constant CONTEXT_VAULT_IO_BALANCE_BEFORE = 2;\\nuint constant CONTEXT_VAULT_IO_BALANCE_DIFF = 3;\\nuint constant CONTEXT_VAULT_IO_ROWS = 4;\\n\\nstruct ClearStateChange {\\n    uint256 aOutput;\\n    uint256 bOutput;\\n    uint256 aInput;\\n    uint256 bInput;\\n}\\n\\nlibrary LibOrder {\\n    function hash(Order memory order_) internal pure returns (uint) {\\n        return uint256(keccak256(abi.encode(order_)));\\n    }\\n}\\n\\ncontract OrderBook is\\n    IOrderBookV1,\\n    ReentrancyGuard,\\n    Multicall,\\n    OrderBookFlashLender\\n{\\n    using LibInterpreterState for bytes;\\n    using LibStackTop for StackTop;\\n    using LibStackTop for uint256[];\\n    using LibUint256Array for uint256[];\\n    using SafeERC20 for IERC20;\\n    using Math for uint256;\\n    using FixedPointMath for uint256;\\n    using LibOrder for Order;\\n    using LibInterpreterState for InterpreterState;\\n    using LibIdempotentFlag for IdempotentFlag;\\n    using LibUint256Array for uint;\\n\\n    event Deposit(address sender, DepositConfig config);\\n    /// @param sender `msg.sender` withdrawing tokens.\\n    /// @param config All config sent to the `withdraw` call.\\n    /// @param amount The amount of tokens withdrawn, can be less than the\\n    /// config amount if the vault does not have the funds available to cover\\n    /// the config amount.\\n    event Withdraw(address sender, WithdrawConfig config, uint256 amount);\\n    event AddOrder(address sender, Order order, uint orderHash);\\n    event RemoveOrder(address sender, Order order, uint orderHash);\\n    event TakeOrder(\\n        address sender,\\n        TakeOrderConfig takeOrder,\\n        uint256 input,\\n        uint256 output\\n    );\\n    event OrderNotFound(address sender, address owner, uint orderHash);\\n    event OrderZeroAmount(address sender, address owner, uint orderHash);\\n    event OrderExceedsMaxRatio(address sender, address owner, uint orderHash);\\n    event Clear(address sender, Order a, Order b, ClearConfig clearConfig);\\n    event AfterClear(ClearStateChange stateChange);\\n\\n    // order hash => order is live\\n    mapping(uint => uint) private orders;\\n    /// @inheritdoc IOrderBookV1\\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\\n        public vaultBalance;\\n\\n    constructor() initializer {\\n        __ReentrancyGuard_init();\\n        __Multicall_init();\\n    }\\n\\n    function deposit(DepositConfig calldata config_) external nonReentrant {\\n        vaultBalance[msg.sender][config_.token][config_.vaultId] += config_\\n            .amount;\\n        emit Deposit(msg.sender, config_);\\n        IERC20(config_.token).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            config_.amount\\n        );\\n    }\\n\\n    /// Allows the sender to withdraw any tokens from their own vaults.\\n    /// @param config_ All config required to withdraw. Notably if the amount\\n    /// is less than the current vault balance then the vault will be cleared\\n    /// to 0 rather than the withdraw transaction reverting.\\n    function withdraw(WithdrawConfig calldata config_) external nonReentrant {\\n        uint256 vaultBalance_ = vaultBalance[msg.sender][config_.token][\\n            config_.vaultId\\n        ];\\n        uint256 withdrawAmount_ = config_.amount.min(vaultBalance_);\\n        vaultBalance[msg.sender][config_.token][config_.vaultId] =\\n            vaultBalance_ -\\n            withdrawAmount_;\\n        emit Withdraw(msg.sender, config_, withdrawAmount_);\\n        _decreaseFlashDebtThenSendToken(\\n            config_.token,\\n            msg.sender,\\n            withdrawAmount_\\n        );\\n    }\\n\\n    function addOrder(OrderConfig calldata config_) external nonReentrant {\\n        (address expression_, ) = IExpressionDeployerV1(\\n            config_.expressionDeployer\\n        ).deployExpression(\\n                config_.interpreterStateConfig,\\n                LibUint256Array.arrayFrom(\\n                    ORDER_MIN_OUTPUTS,\\n                    HANDLE_IO_MIN_OUTPUTS\\n                )\\n            );\\n        Order memory order_ = Order(\\n            msg.sender,\\n            config_.interpreter,\\n            LibEncodedDispatch.encode(\\n                expression_,\\n                ORDER_ENTRYPOINT,\\n                ORDER_MAX_OUTPUTS\\n            ),\\n            config_\\n                .interpreterStateConfig\\n                .sources[SourceIndex.unwrap(HANDLE_IO_ENTRYPOINT)]\\n                .length > 0\\n                ? LibEncodedDispatch.encode(\\n                    expression_,\\n                    HANDLE_IO_ENTRYPOINT,\\n                    HANDLE_IO_MAX_OUTPUTS\\n                )\\n                : EncodedDispatch.wrap(0),\\n            config_.validInputs,\\n            config_.validOutputs\\n        );\\n        uint orderHash_ = order_.hash();\\n        orders[orderHash_] = 1;\\n        emit AddOrder(msg.sender, order_, orderHash_);\\n    }\\n\\n    function removeOrder(Order calldata order_) external nonReentrant {\\n        require(msg.sender == order_.owner, \\\"OWNER\\\");\\n        uint orderHash_ = order_.hash();\\n        delete (orders[orderHash_]);\\n        emit RemoveOrder(msg.sender, order_, orderHash_);\\n    }\\n\\n    function _calculateOrderIO(\\n        Order memory order_,\\n        uint inputIOIndex_,\\n        uint256 outputIOIndex_,\\n        address counterparty_\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 orderOutputMax_,\\n            uint256 orderIORatio_,\\n            uint[][] memory,\\n            uint[] memory\\n        )\\n    {\\n        uint orderHash_ = order_.hash();\\n        uint[][] memory context_ = new uint[][](CONTEXT_COLUMNS);\\n\\n        {\\n            context_[CONTEXT_BASE_COLUMN] = LibUint256Array.arrayFrom(\\n                orderHash_,\\n                uint(uint160(order_.owner)),\\n                uint(uint160(counterparty_))\\n            );\\n\\n            context_[CONTEXT_VAULT_INPUTS_COLUMN] = new uint[](\\n                CONTEXT_VAULT_IO_ROWS\\n            );\\n            context_[CONTEXT_VAULT_OUTPUTS_COLUMN] = new uint[](\\n                CONTEXT_VAULT_IO_ROWS\\n            );\\n\\n            context_[CONTEXT_VAULT_INPUTS_COLUMN][\\n                CONTEXT_VAULT_IO_TOKEN\\n            ] = uint(uint160(order_.validInputs[inputIOIndex_].token));\\n            context_[CONTEXT_VAULT_OUTPUTS_COLUMN][\\n                CONTEXT_VAULT_IO_TOKEN\\n            ] = uint(uint160(order_.validOutputs[outputIOIndex_].token));\\n\\n            context_[CONTEXT_VAULT_INPUTS_COLUMN][\\n                CONTEXT_VAULT_IO_VAULT_ID\\n            ] = order_.validInputs[inputIOIndex_].vaultId;\\n            context_[CONTEXT_VAULT_OUTPUTS_COLUMN][\\n                CONTEXT_VAULT_IO_VAULT_ID\\n            ] = order_.validOutputs[outputIOIndex_].vaultId;\\n\\n            context_[CONTEXT_VAULT_INPUTS_COLUMN][\\n                CONTEXT_VAULT_IO_BALANCE_BEFORE\\n            ] = vaultBalance[order_.owner][\\n                order_.validInputs[inputIOIndex_].token\\n            ][order_.validInputs[inputIOIndex_].vaultId];\\n            context_[CONTEXT_VAULT_OUTPUTS_COLUMN][\\n                CONTEXT_VAULT_IO_BALANCE_BEFORE\\n            ] = vaultBalance[order_.owner][\\n                order_.validOutputs[outputIOIndex_].token\\n            ][order_.validOutputs[outputIOIndex_].vaultId];\\n        }\\n\\n        // The state changes produced here are handled in _recordVaultIO so that\\n        // local storage writes happen before writes on the interpreter.\\n        (uint[] memory stack_, uint[] memory stateChanges_) = IInterpreterV1(\\n            order_.interpreter\\n        ).evalWithNamespace(\\n                StateNamespace.wrap(uint(uint160(order_.owner))),\\n                order_.dispatch,\\n                context_\\n            );\\n        (orderOutputMax_, orderIORatio_) = stack_.asStackTopAfter().peek2();\\n        uint[] memory calculationsContext_ = new uint[](2);\\n        calculationsContext_[0] = orderOutputMax_;\\n        calculationsContext_[1] = orderIORatio_;\\n        context_[CONTEXT_CALCULATIONS_COLUMN] = calculationsContext_;\\n\\n        // The order owner can't send more than the smaller of their vault\\n        // balance or their per-order limit.\\n        orderOutputMax_ = orderOutputMax_.min(\\n            vaultBalance[order_.owner][\\n                order_.validOutputs[outputIOIndex_].token\\n            ][order_.validOutputs[outputIOIndex_].vaultId]\\n        );\\n\\n        return (orderOutputMax_, orderIORatio_, context_, stateChanges_);\\n    }\\n\\n    function _recordVaultIO(\\n        Order memory order_,\\n        uint256 input_,\\n        uint256 output_,\\n        uint[][] memory context_,\\n        uint[] memory stateChangesCalculate_\\n    ) internal {\\n        context_[CONTEXT_VAULT_INPUTS_COLUMN][\\n            CONTEXT_VAULT_IO_BALANCE_DIFF\\n        ] = input_;\\n        context_[CONTEXT_VAULT_OUTPUTS_COLUMN][\\n            CONTEXT_VAULT_IO_BALANCE_DIFF\\n        ] = output_;\\n\\n        if (input_ > 0) {\\n            // IMPORTANT! THIS MATH MUST BE CHECKED TO AVOID OVERFLOW.\\n            vaultBalance[order_.owner][\\n                address(\\n                    uint160(\\n                        context_[CONTEXT_VAULT_INPUTS_COLUMN][\\n                            CONTEXT_VAULT_IO_TOKEN\\n                        ]\\n                    )\\n                )\\n            ][\\n                context_[CONTEXT_VAULT_INPUTS_COLUMN][CONTEXT_VAULT_IO_VAULT_ID]\\n            ] += input_;\\n        }\\n        if (output_ > 0) {\\n            // IMPORTANT! THIS MATH MUST BE CHECKED TO AVOID UNDERFLOW.\\n            vaultBalance[order_.owner][\\n                address(\\n                    uint160(\\n                        context_[CONTEXT_VAULT_OUTPUTS_COLUMN][\\n                            CONTEXT_VAULT_IO_TOKEN\\n                        ]\\n                    )\\n                )\\n            ][\\n                context_[CONTEXT_VAULT_OUTPUTS_COLUMN][\\n                    CONTEXT_VAULT_IO_VAULT_ID\\n                ]\\n            ] -= output_;\\n        }\\n\\n        if (stateChangesCalculate_.length > 0) {\\n            IInterpreterV1(order_.interpreter).stateChangesWithNamespace(\\n                StateNamespace.wrap(uint(uint160(order_.owner))),\\n                stateChangesCalculate_\\n            );\\n        }\\n        if (EncodedDispatch.unwrap(order_.handleIODispatch) > 0) {\\n            (, uint[] memory stateChangesHandleIO_) = IInterpreterV1(\\n                order_.interpreter\\n            ).evalWithNamespace(\\n                    StateNamespace.wrap(uint(uint160(order_.owner))),\\n                    order_.handleIODispatch,\\n                    context_\\n                );\\n            if (stateChangesHandleIO_.length > 0) {\\n                IInterpreterV1(order_.interpreter).stateChangesWithNamespace(\\n                    StateNamespace.wrap(uint(uint160(order_.owner))),\\n                    stateChangesHandleIO_\\n                );\\n            }\\n        }\\n    }\\n\\n    function takeOrders(\\n        TakeOrdersConfig calldata takeOrders_\\n    )\\n        external\\n        nonReentrant\\n        returns (uint256 totalInput_, uint256 totalOutput_)\\n    {\\n        uint256 i_ = 0;\\n        TakeOrderConfig memory takeOrder_;\\n        Order memory order_;\\n        uint256 remainingInput_ = takeOrders_.maximumInput;\\n        while (i_ < takeOrders_.orders.length && remainingInput_ > 0) {\\n            takeOrder_ = takeOrders_.orders[i_];\\n            order_ = takeOrder_.order;\\n            uint orderHash_ = order_.hash();\\n            if (orders[orderHash_] == 0) {\\n                emit OrderNotFound(msg.sender, order_.owner, orderHash_);\\n            } else {\\n                require(\\n                    order_.validInputs[takeOrder_.inputIOIndex].token ==\\n                        takeOrders_.output,\\n                    \\\"TOKEN_MISMATCH\\\"\\n                );\\n                require(\\n                    order_.validOutputs[takeOrder_.outputIOIndex].token ==\\n                        takeOrders_.input,\\n                    \\\"TOKEN_MISMATCH\\\"\\n                );\\n\\n                (\\n                    uint256 orderOutputMax_,\\n                    uint256 orderIORatio_,\\n                    uint[][] memory context_,\\n                    uint[] memory stateChangesCalculate_\\n                ) = _calculateOrderIO(\\n                        order_,\\n                        takeOrder_.inputIOIndex,\\n                        takeOrder_.outputIOIndex,\\n                        msg.sender\\n                    );\\n\\n                // Skip orders that are too expensive rather than revert as we have\\n                // no way of knowing if a specific order becomes too expensive\\n                // between submitting to mempool and execution, but other orders may\\n                // be valid so we want to take advantage of those if possible.\\n                if (orderIORatio_ > takeOrders_.maximumIORatio) {\\n                    emit OrderExceedsMaxRatio(\\n                        msg.sender,\\n                        order_.owner,\\n                        orderHash_\\n                    );\\n                } else if (orderOutputMax_ == 0) {\\n                    emit OrderZeroAmount(msg.sender, order_.owner, orderHash_);\\n                } else {\\n                    uint256 input_ = remainingInput_.min(orderOutputMax_);\\n                    uint256 output_ = input_.fixedPointMul(orderIORatio_);\\n\\n                    remainingInput_ -= input_;\\n                    totalOutput_ += output_;\\n\\n                    _recordVaultIO(\\n                        order_,\\n                        output_,\\n                        input_,\\n                        context_,\\n                        stateChangesCalculate_\\n                    );\\n                    emit TakeOrder(msg.sender, takeOrder_, input_, output_);\\n                }\\n            }\\n\\n            unchecked {\\n                i_++;\\n            }\\n        }\\n        totalInput_ = takeOrders_.maximumInput - remainingInput_;\\n        require(totalInput_ >= takeOrders_.minimumInput, \\\"MIN_INPUT\\\");\\n        IERC20(takeOrders_.output).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            totalOutput_\\n        );\\n        _decreaseFlashDebtThenSendToken(\\n            takeOrders_.input,\\n            msg.sender,\\n            totalInput_\\n        );\\n    }\\n\\n    function clear(\\n        Order memory a_,\\n        Order memory b_,\\n        ClearConfig calldata clearConfig_\\n    ) external nonReentrant {\\n        {\\n            require(a_.owner != b_.owner, \\\"SAME_OWNER\\\");\\n            require(\\n                a_.validOutputs[clearConfig_.aOutputIOIndex].token ==\\n                    b_.validInputs[clearConfig_.bInputIOIndex].token,\\n                \\\"TOKEN_MISMATCH\\\"\\n            );\\n            require(\\n                b_.validOutputs[clearConfig_.bOutputIOIndex].token ==\\n                    a_.validInputs[clearConfig_.aInputIOIndex].token,\\n                \\\"TOKEN_MISMATCH\\\"\\n            );\\n            require(orders[a_.hash()] > 0, \\\"A_NOT_LIVE\\\");\\n            require(orders[b_.hash()] > 0, \\\"B_NOT_LIVE\\\");\\n        }\\n\\n        ClearStateChange memory stateChange_;\\n        uint[][] memory aContext_;\\n        uint[] memory aStateChangesCalculate_;\\n        uint[][] memory bContext_;\\n        uint[] memory bStateChangesCalculate_;\\n\\n        {\\n            // `IORatio` is input per output for both `a_` and `b_`.\\n            uint256 aIORatio_;\\n            uint256 bIORatio_;\\n            // `a_` and `b_` can both set a maximum output from the Interpreter.\\n            uint256 aOutputMax_;\\n            uint256 bOutputMax_;\\n\\n            // emit the Clear event before `a_` and `b_` are mutated due to the\\n            // Interpreter execution in eval.\\n            emit Clear(msg.sender, a_, b_, clearConfig_);\\n\\n            (\\n                aOutputMax_,\\n                aIORatio_,\\n                aContext_,\\n                aStateChangesCalculate_\\n            ) = _calculateOrderIO(\\n                a_,\\n                clearConfig_.aInputIOIndex,\\n                clearConfig_.aOutputIOIndex,\\n                b_.owner\\n            );\\n            (\\n                bOutputMax_,\\n                bIORatio_,\\n                bContext_,\\n                bStateChangesCalculate_\\n            ) = _calculateOrderIO(\\n                b_,\\n                clearConfig_.bInputIOIndex,\\n                clearConfig_.bOutputIOIndex,\\n                a_.owner\\n            );\\n\\n            stateChange_.aOutput = aOutputMax_.min(\\n                bOutputMax_.fixedPointMul(bIORatio_)\\n            );\\n            stateChange_.bOutput = bOutputMax_.min(\\n                aOutputMax_.fixedPointMul(aIORatio_)\\n            );\\n\\n            require(\\n                stateChange_.aOutput > 0 || stateChange_.bOutput > 0,\\n                \\\"0_CLEAR\\\"\\n            );\\n\\n            stateChange_.aInput = stateChange_.aOutput.fixedPointMul(aIORatio_);\\n            stateChange_.bInput = stateChange_.bOutput.fixedPointMul(bIORatio_);\\n        }\\n\\n        _recordVaultIO(\\n            a_,\\n            stateChange_.aInput,\\n            stateChange_.aOutput,\\n            aContext_,\\n            aStateChangesCalculate_\\n        );\\n        _recordVaultIO(\\n            b_,\\n            stateChange_.bInput,\\n            stateChange_.bOutput,\\n            bContext_,\\n            bStateChangesCalculate_\\n        );\\n\\n        {\\n            // At least one of these will overflow due to negative bounties if\\n            // there is a spread between the orders.\\n            uint256 aBounty_ = stateChange_.aOutput - stateChange_.bInput;\\n            uint256 bBounty_ = stateChange_.bOutput - stateChange_.aInput;\\n            if (aBounty_ > 0) {\\n                vaultBalance[msg.sender][\\n                    a_.validOutputs[clearConfig_.aOutputIOIndex].token\\n                ][clearConfig_.aBountyVaultId] += aBounty_;\\n            }\\n            if (bBounty_ > 0) {\\n                vaultBalance[msg.sender][\\n                    b_.validOutputs[clearConfig_.bOutputIOIndex].token\\n                ][clearConfig_.bBountyVaultId] += bBounty_;\\n            }\\n        }\\n\\n        emit AfterClear(stateChange_);\\n    }\\n}\\n\",\"keccak256\":\"0x6fc2625e4dd9516015feebff3d1897fbc81b6dffc52870da9aecfdc05d58a268\",\"license\":\"CAL\"},\"contracts/orderbook/OrderBookFlashLender.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {SafeERC20Upgradeable as SafeERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\n\\nimport \\\"../ierc3156/IERC3156FlashBorrower.sol\\\";\\nimport \\\"../ierc3156/IERC3156FlashLender.sol\\\";\\n\\n/**\\n * @author Alberto Cuesta Ca\\u00f1ada\\n * @dev Extension of {ERC20} that allows flash lending.\\n */\\ncontract OrderBookFlashLender is IERC3156FlashLender {\\n    bytes32 public constant CALLBACK_SUCCESS =\\n        keccak256(\\\"ERC3156FlashBorrower.onFlashLoan\\\");\\n    using SafeERC20 for IERC20;\\n\\n    // token => receiver => active debt\\n    mapping(address => mapping(address => uint)) internal activeFlashDebts;\\n\\n    function _increaseFlashDebtThenSendToken(\\n        address token_,\\n        address receiver_,\\n        uint amount_\\n    ) internal {\\n        activeFlashDebts[token_][receiver_] += amount_;\\n        IERC20(token_).safeTransfer(receiver_, amount_);\\n    }\\n\\n    function _decreaseFlashDebtThenSendToken(\\n        address token_,\\n        address receiver_,\\n        uint amount_\\n    ) internal {\\n        uint activeFlashDebt_ = activeFlashDebts[token_][receiver_];\\n        if (amount_ > activeFlashDebt_) {\\n            if (activeFlashDebt_ > 0) {\\n                delete activeFlashDebts[token_][receiver_];\\n            }\\n\\n            IERC20(token_).safeTransfer(receiver_, amount_ - activeFlashDebt_);\\n        } else {\\n            activeFlashDebts[token_][receiver_] -= amount_;\\n        }\\n    }\\n\\n    function _finalizeDebt(address token_, address receiver_) internal {\\n        uint activeFlashDebt_ = activeFlashDebts[token_][receiver_];\\n        if (activeFlashDebt_ > 0) {\\n            IERC20(token_).safeTransferFrom(\\n                receiver_,\\n                address(this),\\n                activeFlashDebt_\\n            );\\n            // Once we have the tokens safely in hand decrease the debt.\\n            activeFlashDebts[token_][receiver_] -= activeFlashDebt_;\\n        }\\n        require(activeFlashDebts[token_][receiver_] == 0, \\\"BAD_DEBT\\\");\\n    }\\n\\n    /// @inheritdoc IERC3156FlashLender\\n    function flashLoan(\\n        IERC3156FlashBorrower receiver_,\\n        address token_,\\n        uint256 amount_,\\n        bytes calldata data_\\n    ) external override returns (bool) {\\n        _increaseFlashDebtThenSendToken(token_, address(receiver_), amount_);\\n        require(\\n            receiver_.onFlashLoan(msg.sender, token_, amount_, 0, data_) ==\\n                CALLBACK_SUCCESS,\\n            \\\"FlashLender: Callback failed\\\"\\n        );\\n        _finalizeDebt(token_, address(receiver_));\\n        return true;\\n    }\\n\\n    /// @inheritdoc IERC3156FlashLender\\n    function flashFee(\\n        address,\\n        uint256\\n    ) external pure override returns (uint256) {\\n        return 0;\\n    }\\n\\n    /// @inheritdoc IERC3156FlashLender\\n    function maxFlashLoan(\\n        address token_\\n    ) external view override returns (uint256) {\\n        return IERC20(token_).balanceOf(address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x1897a31f60b0ef14413d4d30e876cdd2830ebae8a4b2b6950564b55cea794443\",\"license\":\"CAL\"},\"contracts/sale/ISaleV2.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// An `ISale` can be in one of 4 possible states and a linear progression is\\n/// expected from an \\\"in flight\\\" status to an immutable definitive outcome.\\n/// - Pending: The sale is deployed onchain but cannot be interacted with yet.\\n/// - Active: The sale can now be bought into and otherwise interacted with.\\n/// - Success: The sale has ended AND reached its minimum raise target.\\n/// - Fail: The sale has ended BUT NOT reached its minimum raise target.\\n/// Once an `ISale` reaches `Active` it MUST NOT return `Pending` ever again.\\n/// Once an `ISale` reaches `Success` or `Fail` it MUST NOT return any other\\n/// status ever again.\\nenum SaleStatus {\\n    Pending,\\n    Active,\\n    Success,\\n    Fail\\n}\\n\\ninterface ISaleV2 {\\n    /// Returns the address of the token being sold in the sale.\\n    /// MUST NOT change during the lifecycle of the sale contract.\\n    function token() external view returns (address);\\n\\n    function remainingTokenInventory() external view returns (uint256);\\n\\n    /// Returns the address of the token that sale prices are denominated in.\\n    /// MUST NOT change during the lifecycle of the sale contract.\\n    function reserve() external view returns (address);\\n\\n    /// total reserve taken in to the sale contract via. buys. Does NOT\\n    /// include any reserve sent directly to the sale contract outside the\\n    /// standard buy/refund loop, e.g. due to a dusting attack.\\n    function totalReserveReceived() external view returns (uint256);\\n\\n    /// Returns the current `SaleStatus` of the sale.\\n    /// Represents a linear progression of the sale through its major lifecycle\\n    /// events.\\n    function saleStatus() external view returns (SaleStatus);\\n}\\n\",\"keccak256\":\"0x4c55a0e1679ee3d00d3d80a76dad6d6eb149a959ed77e6af5b8e914830f7aa87\",\"license\":\"CAL\"},\"contracts/sstore2/SSTORE2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport \\\"./utils/Bytecode.sol\\\";\\n\\n/**\\n  @title A key-value storage with auto-generated keys for storing chunks of\\n  data with a lower write & read cost.\\n  @author Agustin Aguilar <aa@horizon.io>\\n\\n  Readme: https://github.com/0xsequence/sstore2#readme\\n*/\\nlibrary SSTORE2 {\\n    error WriteError();\\n\\n    /**\\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\\n    @dev The pointer is a contract address with `_data` as code\\n    @param _data to be written\\n    @return pointer Pointer to the written `_data`\\n  */\\n    function write(bytes memory _data) internal returns (address pointer) {\\n        // Append 00 to _data so contract can't be called\\n        // Build init code\\n        bytes memory code = Bytecode.creationCodeFor(\\n            abi.encodePacked(hex\\\"00\\\", _data)\\n        );\\n\\n        // Deploy contract using create\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := create(0, add(code, 32), mload(code))\\n        }\\n\\n        // Address MUST be non-zero\\n        if (pointer == address(0)) revert WriteError();\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first\\n    byte\\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @return data read from `_pointer` contract\\n  */\\n    function read(address _pointer) internal view returns (bytes memory) {\\n        return Bytecode.codeAt(_pointer, 1, type(uint256).max);\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first\\n    byte\\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @param _start number of bytes to skip\\n    @return data read from `_pointer` contract\\n  */\\n    function read(\\n        address _pointer,\\n        uint256 _start\\n    ) internal view returns (bytes memory) {\\n        return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first\\n    byte\\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @param _start number of bytes to skip\\n    @param _end index before which to end extraction\\n    @return data read from `_pointer` contract\\n  */\\n    function read(\\n        address _pointer,\\n        uint256 _start,\\n        uint256 _end\\n    ) internal view returns (bytes memory) {\\n        return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\\n    }\\n}\\n\",\"keccak256\":\"0x86864b4de9a76a67da6c19fd1f921e08bb5c31de2eddef161117e4a8aea97ddd\",\"license\":\"MIT\"},\"contracts/sstore2/utils/Bytecode.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nlibrary Bytecode {\\n    error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\\n\\n    /**\\n    @notice Generate a creation code that results on a contract with `_code` as\\n    bytecode\\n    @param _code The returning value of the resulting `creationCode`\\n    @return creationCode (constructor) for new contract\\n  */\\n    function creationCodeFor(\\n        bytes memory _code\\n    ) internal pure returns (bytes memory) {\\n        /*\\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\\n      0x01    0x80         0x80        DUP1                size size\\n      0x02    0x60         0x600e      PUSH1 14            14 size size\\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\\n      0x04    0x39         0x39        CODECOPY            size\\n      0x05    0x60         0x6000      PUSH1 00            0 size\\n      0x06    0xf3         0xf3        RETURN\\n      <CODE>\\n    */\\n\\n        return\\n            abi.encodePacked(\\n                hex\\\"63\\\",\\n                uint32(_code.length),\\n                hex\\\"80_60_0E_60_00_39_60_00_F3\\\",\\n                _code\\n            );\\n    }\\n\\n    /**\\n    @notice Returns the size of the code on a given address\\n    @param _addr Address that may or may not contain code\\n    @return size of the code on the given `_addr`\\n  */\\n    function codeSize(address _addr) internal view returns (uint256 size) {\\n        assembly (\\\"memory-safe\\\") {\\n            size := extcodesize(_addr)\\n        }\\n    }\\n\\n    /**\\n    @notice Returns the code of a given address\\n    @dev It will fail if `_end < _start`\\n    @param _addr Address that may or may not contain code\\n    @param _start number of bytes of code to skip on read\\n    @param _end index before which to end extraction\\n    @return oCode read from `_addr` deployed bytecode\\n\\n    Forked: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\\n  */\\n    function codeAt(\\n        address _addr,\\n        uint256 _start,\\n        uint256 _end\\n    ) internal view returns (bytes memory oCode) {\\n        uint256 csize = codeSize(_addr);\\n        if (csize == 0) return bytes(\\\"\\\");\\n\\n        if (_start > csize) return bytes(\\\"\\\");\\n        if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end);\\n\\n        unchecked {\\n            uint256 reqSize = _end - _start;\\n            uint256 maxSize = csize - _start;\\n\\n            uint256 size = maxSize < reqSize ? maxSize : reqSize;\\n\\n            assembly (\\\"memory-safe\\\") {\\n                // allocate output byte array - this could also be done without\\n                // assembly\\n                // by using o_code = new bytes(size)\\n                oCode := mload(0x40)\\n                // new \\\"memory end\\\" including padding\\n                mstore(\\n                    0x40,\\n                    add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f)))\\n                )\\n                // store length in memory\\n                mstore(oCode, size)\\n                // actually retrieve the code, this needs assembly\\n                extcodecopy(_addr, add(oCode, 0x20), _start, size)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x81b3a2d7c4ca79e6a6e8d097ce05e20432485d9603f2e651f83da90006e6ebc9\",\"license\":\"MIT\"},\"contracts/tier/ITierV2.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// @title ITierV2\\n/// @notice `ITierV2` is a simple interface that contracts can implement to\\n/// provide membership lists for other contracts.\\n///\\n/// There are many use-cases for a time-preserving conditional membership list.\\n///\\n/// Some examples include:\\n///\\n/// - Self-serve whitelist to participate in fundraising\\n/// - Lists of users who can claim airdrops and perks\\n/// - Pooling resources with implied governance/reward tiers\\n/// - POAP style attendance proofs allowing access to future exclusive events\\n///\\n/// @dev Standard interface to a tiered membership.\\n///\\n/// A \\\"membership\\\" can represent many things:\\n/// - Exclusive access.\\n/// - Participation in some event or process.\\n/// - KYC completion.\\n/// - Combination of sub-memberships.\\n/// - Etc.\\n///\\n/// The high level requirements for a contract implementing `ITierV2`:\\n/// - MUST represent held tiers as a `uint`.\\n/// - MUST implement `report`.\\n///   - The report is a `uint256` that SHOULD represent the time each tier has\\n///     been continuously held since encoded as `uint32`.\\n///   - The encoded tiers start at `1`; Tier `0` is implied if no tier has ever\\n///     been held.\\n///   - Tier `0` is NOT encoded in the report, it is simply the fallback value.\\n///   - If a tier is lost the time data is erased for that tier and will be\\n///     set if/when the tier is regained to the new time.\\n///   - If a tier is held but the historical time information is not available\\n///     the report MAY return `0x00000000` for all held tiers.\\n///   - Tiers that are lost or have never been held MUST return `0xFFFFFFFF`.\\n///   - Context can be a list of numbers that MAY pairwise define tiers such as\\n///     minimum thresholds, or MAY simply provide global context such as a\\n///     relevant NFT ID for example.\\n/// - MUST implement `reportTimeForTier`\\n///   - Functions exactly as `report` but only returns a single time for a\\n///     single tier\\n///   - MUST return the same time value `report` would for any given tier and\\n///     context combination.\\n///\\n/// So the four possible states and report values are:\\n/// - Tier is held and time is known: Timestamp is in the report\\n/// - Tier is held but time is NOT known: `0` is in the report\\n/// - Tier is NOT held: `0xFF..` is in the report\\n/// - Tier is unknown: `0xFF..` is in the report\\n///\\n/// The reason `context` is specified as a list of values rather than arbitrary\\n/// bytes is to allow clear and efficient compatibility with interpreter stacks.\\n/// Some N values can be taken from an interpreter stack and used directly as a\\n/// context, which would be difficult or impossible to ensure is safe for\\n/// arbitrary bytes.\\ninterface ITierV2 {\\n    /// Same as report but only returns the time for a single tier.\\n    /// Often the implementing contract can calculate a single tier more\\n    /// efficiently than all 8 tiers. If the consumer only needs one or a few\\n    /// tiers it MAY be much cheaper to request only those tiers individually.\\n    /// This DOES NOT apply to all contracts, an obvious example is token\\n    /// balance based tiers which always return `ALWAYS` or `NEVER` for all\\n    /// tiers so no efficiency is gained.\\n    /// The return value is a `uint256` for gas efficiency but the values will\\n    /// be bounded by `type(uint32).max` as no single tier can report a value\\n    /// higher than this.\\n    function reportTimeForTier(\\n        address account,\\n        uint256 tier,\\n        uint256[] calldata context\\n    ) external view returns (uint256 time);\\n\\n    /// Returns an 8 tier encoded report of 32 bit timestamps for the given\\n    /// account.\\n    ///\\n    /// Same as `ITier` (legacy interface) but with a list of values for\\n    /// `context` which allows a single underlying state to present many\\n    /// different reports dynamically.\\n    ///\\n    /// For example:\\n    /// - Staking ledgers can calculate different tier thresholds\\n    /// - NFTs can give different tiers based on different IDs\\n    /// - Snapshot ERC20s can give different reports based on snapshot ID\\n    ///\\n    /// `context` supercedes `setTier` function and `TierChange` event from\\n    /// `ITier` at the interface level.\\n    function report(\\n        address account,\\n        uint256[] calldata context\\n    ) external view returns (uint256 report);\\n}\\n\",\"keccak256\":\"0xbaa924c1ae43bb50718e2f9f19ae2dffc97eec916b58c544121c50c2ced211d7\",\"license\":\"CAL\"},\"contracts/tier/libraries/TierConstants.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// @title TierConstants\\n/// @notice Constants for use with tier logic.\\nlibrary TierConstants {\\n    /// NEVER is 0xFF.. as it is infinitely in the future.\\n    /// NEVER for an entire report.\\n    uint256 internal constant NEVER_REPORT = type(uint256).max;\\n    /// NEVER for a single tier time.\\n    uint32 internal constant NEVER_TIME = type(uint32).max;\\n\\n    /// Always is 0 as negative timestamps are not possible/supported onchain.\\n    /// Tiers can't predate the chain but they can predate an `ITierV2`\\n    /// contract.\\n    uint256 internal constant ALWAYS = 0;\\n\\n    /// Account has never held a tier.\\n    uint256 internal constant TIER_ZERO = 0;\\n\\n    /// Magic number for tier one.\\n    uint256 internal constant TIER_ONE = 1;\\n    /// Magic number for tier two.\\n    uint256 internal constant TIER_TWO = 2;\\n    /// Magic number for tier three.\\n    uint256 internal constant TIER_THREE = 3;\\n    /// Magic number for tier four.\\n    uint256 internal constant TIER_FOUR = 4;\\n    /// Magic number for tier five.\\n    uint256 internal constant TIER_FIVE = 5;\\n    /// Magic number for tier six.\\n    uint256 internal constant TIER_SIX = 6;\\n    /// Magic number for tier seven.\\n    uint256 internal constant TIER_SEVEN = 7;\\n    /// Magic number for tier eight.\\n    uint256 internal constant TIER_EIGHT = 8;\\n    /// Maximum tier is `TIER_EIGHT`.\\n    uint256 internal constant MAX_TIER = TIER_EIGHT;\\n}\\n\",\"keccak256\":\"0x8b28d4e524cdc6e728bd1c133e5e5bb14c80ddc4f75a04a1351d9f470c98fc0c\",\"license\":\"CAL\"},\"contracts/tier/libraries/TierReport.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\nimport {ITierV2} from \\\"../ITierV2.sol\\\";\\nimport \\\"./TierConstants.sol\\\";\\n\\n/// @title TierReport\\n/// @notice `TierReport` implements several pure functions that can be\\n/// used to interface with reports.\\n/// - `tierAtTimeFromReport`: Returns the highest status achieved relative to\\n/// a block timestamp and report. Statuses gained after that block are ignored.\\n/// - `tierTime`: Returns the timestamp that a given tier has been held\\n/// since according to a report.\\n/// - `truncateTiersAbove`: Resets all the tiers above the reference tier.\\n/// - `updateTimesForTierRange`: Updates a report with a timestamp for every\\n///    tier in a range.\\n/// - `updateReportWithTierAtTime`: Updates a report to a new tier.\\n/// @dev Utilities to consistently read, write and manipulate tiers in reports.\\n/// The low-level bit shifting can be difficult to get right so this\\n/// factors that out.\\nlibrary TierReport {\\n    /// Enforce upper limit on tiers so we can do unchecked math.\\n    /// @param tier_ The tier to enforce bounds on.\\n    modifier maxTier(uint256 tier_) {\\n        require(tier_ <= TierConstants.MAX_TIER, \\\"MAX_TIER\\\");\\n        _;\\n    }\\n\\n    /// Returns the highest tier achieved relative to a block timestamp\\n    /// and report.\\n    ///\\n    /// Note that typically the report will be from the _current_ contract\\n    /// state, i.e. `block.timestamp` but not always. Tiers gained after the\\n    /// reference time are ignored.\\n    ///\\n    /// When the `report` comes from a later block than the `timestamp_` this\\n    /// means the user must have held the tier continuously from `timestamp_`\\n    /// _through_ to the report time.\\n    /// I.e. NOT a snapshot.\\n    ///\\n    /// @param report_ A report as per `ITierV2`.\\n    /// @param timestamp_ The timestamp to check the tiers against.\\n    /// @return tier_ The highest tier held since `timestamp_` as per `report`.\\n    function tierAtTimeFromReport(\\n        uint256 report_,\\n        uint256 timestamp_\\n    ) internal pure returns (uint256 tier_) {\\n        unchecked {\\n            for (tier_ = 0; tier_ < 8; tier_++) {\\n                if (uint32(uint256(report_ >> (tier_ * 32))) > timestamp_) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// Returns the timestamp that a given tier has been held since from a\\n    /// report.\\n    ///\\n    /// The report MUST encode \\\"never\\\" as 0xFFFFFFFF. This ensures\\n    /// compatibility with `tierAtTimeFromReport`.\\n    ///\\n    /// @param report_ The report to read a timestamp from.\\n    /// @param tier_ The Tier to read the timestamp for.\\n    /// @return The timestamp the tier has been held since.\\n    function reportTimeForTier(\\n        uint256 report_,\\n        uint256 tier_\\n    ) internal pure maxTier(tier_) returns (uint256) {\\n        unchecked {\\n            // ZERO is a special case. Everyone has always been at least ZERO,\\n            // since block 0.\\n            if (tier_ == 0) {\\n                return 0;\\n            }\\n\\n            uint256 offset_ = (tier_ - 1) * 32;\\n            return uint256(uint32(uint256(report_ >> offset_)));\\n        }\\n    }\\n\\n    /// Resets all the tiers above the reference tier to 0xFFFFFFFF.\\n    ///\\n    /// @param report_ Report to truncate with high bit 1s.\\n    /// @param tier_ Tier to truncate above (exclusive).\\n    /// @return Truncated report.\\n    function truncateTiersAbove(\\n        uint256 report_,\\n        uint256 tier_\\n    ) internal pure maxTier(tier_) returns (uint256) {\\n        unchecked {\\n            uint256 offset_ = tier_ * 32;\\n            uint256 mask_ = (TierConstants.NEVER_REPORT >> offset_) << offset_;\\n            return report_ | mask_;\\n        }\\n    }\\n\\n    /// Updates a report with a timestamp for a given tier.\\n    /// More gas efficient than `updateTimesForTierRange` if only a single\\n    /// tier is being modified.\\n    /// The tier at/above the given tier is updated. E.g. tier `0` will update\\n    /// the time for tier `1`.\\n    /// @param report_ Report to use as the baseline for the updated report.\\n    /// @param tier_ The tier level to update.\\n    /// @param timestamp_ The new block number for `tier_`.\\n    /// @return The newly updated `report_`.\\n    function updateTimeAtTier(\\n        uint256 report_,\\n        uint256 tier_,\\n        uint256 timestamp_\\n    ) internal pure maxTier(tier_) returns (uint256) {\\n        unchecked {\\n            uint256 offset_ = tier_ * 32;\\n            return\\n                (report_ &\\n                    ~uint256(uint256(TierConstants.NEVER_TIME) << offset_)) |\\n                uint256(timestamp_ << offset_);\\n        }\\n    }\\n\\n    /// Updates a report with a block number for every tier in a range.\\n    ///\\n    /// Does nothing if the end status is equal or less than the start tier.\\n    /// @param report_ The report to update.\\n    /// @param startTier_ The tier at the start of the range (exclusive).\\n    /// @param endTier_ The tier at the end of the range (inclusive).\\n    /// @param timestamp_ The timestamp to set for every tier in the range.\\n    /// @return The updated report.\\n    function updateTimesForTierRange(\\n        uint256 report_,\\n        uint256 startTier_,\\n        uint256 endTier_,\\n        uint256 timestamp_\\n    ) internal pure maxTier(endTier_) returns (uint256) {\\n        unchecked {\\n            uint256 offset_;\\n            for (uint256 i_ = startTier_; i_ < endTier_; i_++) {\\n                offset_ = i_ * 32;\\n                report_ =\\n                    (report_ &\\n                        ~uint256(\\n                            uint256(TierConstants.NEVER_TIME) << offset_\\n                        )) |\\n                    uint256(timestamp_ << offset_);\\n            }\\n            return report_;\\n        }\\n    }\\n\\n    /// Updates a report to a new status.\\n    ///\\n    /// Internally dispatches to `truncateTiersAbove` and\\n    /// `updateBlocksForTierRange`.\\n    /// The dispatch is based on whether the new tier is above or below the\\n    /// current tier.\\n    /// The `startTier_` MUST match the result of `tierAtBlockFromReport`.\\n    /// It is expected the caller will know the current tier when\\n    /// calling this function and need to do other things in the calling scope\\n    /// with it.\\n    ///\\n    /// @param report_ The report to update.\\n    /// @param startTier_ The tier to start updating relative to. Data above\\n    /// this tier WILL BE LOST so probably should be the current tier.\\n    /// @param endTier_ The new highest tier held, at the given timestamp_.\\n    /// @param timestamp_ The timestamp_ to update the highest tier to, and\\n    /// intermediate tiers from `startTier_`.\\n    /// @return The updated report.\\n    function updateReportWithTierAtTime(\\n        uint256 report_,\\n        uint256 startTier_,\\n        uint256 endTier_,\\n        uint256 timestamp_\\n    ) internal pure returns (uint256) {\\n        return\\n            endTier_ < startTier_\\n                ? truncateTiersAbove(report_, endTier_)\\n                : updateTimesForTierRange(\\n                    report_,\\n                    startTier_,\\n                    endTier_,\\n                    timestamp_\\n                );\\n    }\\n}\\n\",\"keccak256\":\"0x05fb1319c05c5e40468fe07dc0b322598b721222a8c09cc3a3d0e64b17d1729e\",\"license\":\"CAL\"},\"contracts/tier/libraries/TierwiseCombine.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\nimport \\\"./TierReport.sol\\\";\\nimport \\\"../../math/SaturatingMath.sol\\\";\\n\\nlibrary TierwiseCombine {\\n    using Math for uint256;\\n    using SaturatingMath for uint256;\\n\\n    /// Every lte check in `selectLte` must pass.\\n    uint256 internal constant LOGIC_EVERY = 0;\\n    /// Only one lte check in `selectLte` must pass.\\n    uint256 internal constant LOGIC_ANY = 1;\\n\\n    /// Select the minimum block number from passing blocks in `selectLte`.\\n    uint256 internal constant MODE_MIN = 0;\\n    /// Select the maximum block number from passing blocks in `selectLte`.\\n    uint256 internal constant MODE_MAX = 1;\\n    /// Select the first block number that passes in `selectLte`.\\n    uint256 internal constant MODE_FIRST = 2;\\n\\n    /// Performs a tierwise saturating subtraction of two reports.\\n    /// Intepret as \\\"# of blocks older report was held before newer report\\\".\\n    /// If older report is in fact newer then `0` will be returned.\\n    /// i.e. the diff cannot be negative, older report as simply spent 0 blocks\\n    /// existing before newer report, if it is in truth the newer report.\\n    /// @param newerReport_ Block to subtract from.\\n    /// @param olderReport_ Block to subtract.\\n    function saturatingSub(\\n        uint256 newerReport_,\\n        uint256 olderReport_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 ret_;\\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\\n                uint256 newerBlock_ = TierReport.reportTimeForTier(\\n                    newerReport_,\\n                    tier_\\n                );\\n                uint256 olderBlock_ = TierReport.reportTimeForTier(\\n                    olderReport_,\\n                    tier_\\n                );\\n                uint256 diff_ = newerBlock_.saturatingSub(olderBlock_);\\n                ret_ = TierReport.updateTimeAtTier(ret_, tier_ - 1, diff_);\\n            }\\n            return ret_;\\n        }\\n    }\\n\\n    /// Given a list of reports, selects the best tier in a tierwise fashion.\\n    /// The \\\"best\\\" criteria can be configured by `logic_` and `mode_`.\\n    /// Logic can be \\\"every\\\" or \\\"any\\\", which means that the reports for a given\\n    /// tier must either all or any be less than or equal to the reference\\n    /// `blockNumber_`.\\n    /// Mode can be \\\"min\\\", \\\"max\\\", \\\"first\\\" which selects between all the block\\n    /// numbers for a given tier that meet the lte criteria.\\n    /// IMPORTANT: If the output of `selectLte` is used to write to storage\\n    /// care must be taken to ensure that \\\"upcoming\\\" tiers relative to the\\n    /// `blockNumber_` are not overwritten inappropriately. Typically this\\n    /// function should be used as a filter over reads only from an upstream\\n    /// source of truth.\\n    /// @param reports_ The list of reports to select over.\\n    /// @param blockNumber_ The block number that tier blocks must be lte.\\n    /// @param logic_ `LOGIC_EVERY` or `LOGIC_ANY`.\\n    /// @param mode_ `MODE_MIN`, `MODE_MAX` or `MODE_FIRST`.\\n    function selectLte(\\n        uint256 logic_,\\n        uint256 mode_,\\n        uint256 blockNumber_,\\n        uint256[] memory reports_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 ret_;\\n            uint256 block_;\\n            bool anyLte_;\\n            uint256 length_ = reports_.length;\\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\\n                uint256 accumulator_;\\n                // Nothing lte the reference block for this tier yet.\\n                anyLte_ = false;\\n\\n                // Initialize the accumulator for this tier.\\n                if (mode_ == MODE_MIN) {\\n                    accumulator_ = TierConstants.NEVER_REPORT;\\n                } else {\\n                    accumulator_ = 0;\\n                }\\n\\n                // Filter all the blocks at the current tier from all the\\n                // reports against the reference tier and each other.\\n                for (uint256 i_ = 0; i_ < length_; i_++) {\\n                    block_ = TierReport.reportTimeForTier(reports_[i_], tier_);\\n\\n                    if (block_ <= blockNumber_) {\\n                        // Min and max need to compare current value against\\n                        // the accumulator.\\n                        if (mode_ == MODE_MIN) {\\n                            accumulator_ = block_.min(accumulator_);\\n                        } else if (mode_ == MODE_MAX) {\\n                            accumulator_ = block_.max(accumulator_);\\n                        } else if (mode_ == MODE_FIRST && !anyLte_) {\\n                            accumulator_ = block_;\\n                        }\\n                        anyLte_ = true;\\n                    } else if (logic_ == LOGIC_EVERY) {\\n                        // Can short circuit for an \\\"every\\\" check.\\n                        accumulator_ = TierConstants.NEVER_REPORT;\\n                        break;\\n                    }\\n                }\\n                if (!anyLte_) {\\n                    accumulator_ = TierConstants.NEVER_REPORT;\\n                }\\n                ret_ = TierReport.updateTimeAtTier(\\n                    ret_,\\n                    tier_ - 1,\\n                    accumulator_\\n                );\\n            }\\n            return ret_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa795019166092c4663c1a6f441651a4866c9298ffa310f6f5105439cce8d2554\",\"license\":\"CAL\"},\"contracts/type/LibCast.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../interpreter/run/LibStackTop.sol\\\";\\nimport \\\"../interpreter/run/LibInterpreterState.sol\\\";\\nimport \\\"../interpreter/deploy/LibIntegrityState.sol\\\";\\nimport \\\"../interpreter/run/RainInterpreter.sol\\\";\\n\\n/// @title LibCast\\n/// @notice Additional type casting logic that the Solidity compiler doesn't\\n/// give us by default. A type cast (vs. conversion) is considered one where the\\n/// structure is unchanged by the cast. The cast does NOT (can't) check that the\\n/// input is a valid output, for example any integer MAY be cast to a function\\n/// pointer but almost all integers are NOT valid function pointers. It is the\\n/// calling context that MUST ensure the validity of the data, the cast will\\n/// merely retype the data in place, generally without additional checks.\\n/// As most structures in solidity have the same memory structure as a `uint256`\\n/// or fixed/dynamic array of `uint256` there are many conversions that can be\\n/// done with near zero or minimal overhead.\\nlibrary LibCast {\\n    /// Retype an integer to an opcode function pointer.\\n    /// @param u_ The integer to cast to an opcode function pointer.\\n    /// @return fn_ The opcode function pointer.\\n    function asOpFunctionPointer(\\n        uint256 u_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(InterpreterState memory, Operand, StackTop)\\n                view\\n                returns (StackTop) fn_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fn_ := u_\\n        }\\n    }\\n\\n    /// Retype an array of integers to an array of opcode function pointers.\\n    /// @param us_ The array of integers to cast to an array of opcode fuction\\n    /// pointers.\\n    /// @return fns_ The array of opcode function pointers.\\n    function asOpcodeFunctionPointers(\\n        uint256[] memory us_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(InterpreterState memory, Operand, StackTop)\\n                view\\n                returns (StackTop)[]\\n                memory fns_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fns_ := us_\\n        }\\n    }\\n\\n    /// Retype an integer to an integrity function pointer.\\n    /// @param u_ The integer to cast to an integrity function pointer.\\n    /// @return fn_ The integrity function pointer.\\n    function asIntegrityFunctionPointer(\\n        uint256 u_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(IntegrityState memory, Operand, StackTop)\\n                internal\\n                view\\n                returns (StackTop) fn_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fn_ := u_\\n        }\\n    }\\n\\n    /// Retype an integer to a pointer to the interpreter eval function.\\n    /// @param u_ The integer to cast to the eval function.\\n    /// @return fn_ The eval function.\\n    function asEvalFunctionPointer(\\n        uint256 u_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(InterpreterState memory, SourceIndex, StackTop)\\n                view\\n                returns (StackTop) fn_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fn_ := u_\\n        }\\n    }\\n\\n    /// Retype a stack move function pointer to an integer.\\n    /// Provided the origin of the function pointer is solidity and NOT yul, the\\n    /// returned integer will be valid to run if retyped back via yul. If the\\n    /// origin of the function pointer is yul then we cannot guarantee anything\\n    /// about the validity beyond the correctness of the yul code in question.\\n    ///\\n    /// Function pointers as integers are NOT portable across contracts as the\\n    /// code in different contracts is different so function pointers will point\\n    /// to a different, incompatible part of the code.\\n    ///\\n    /// Function pointers as integers lose the information about their signature\\n    /// so MUST ONLY be called in an appropriate context once restored.\\n    /// @param fn_ The stack move function pointer to integerify.\\n    /// @return u_ The integer of the function pointer.\\n    function asUint256(\\n        function(uint256) view returns (uint256) fn_\\n    ) internal pure returns (uint256 u_) {\\n        assembly (\\\"memory-safe\\\") {\\n            u_ := fn_\\n        }\\n    }\\n\\n    function asUint256(\\n        function(IntegrityState memory, Operand, StackTop)\\n            internal\\n            view\\n            returns (StackTop) fn_\\n    ) internal pure returns (uint256 u_) {\\n        assembly (\\\"memory-safe\\\") {\\n            u_ := fn_\\n        }\\n    }\\n\\n    function asUint256Array(\\n        function(IntegrityState memory, Operand, StackTop)\\n            internal\\n            view\\n            returns (StackTop)[]\\n            memory fns_\\n    ) internal pure returns (uint256[] memory us_) {\\n        assembly (\\\"memory-safe\\\") {\\n            us_ := fns_\\n        }\\n    }\\n\\n    function asUint256(bool bool_) internal pure returns (uint256 u_) {\\n        assembly (\\\"memory-safe\\\") {\\n            u_ := bool_\\n        }\\n    }\\n\\n    function asUint256(\\n        function(InterpreterState memory, SourceIndex, StackTop)\\n            view\\n            returns (StackTop) fn_\\n    ) internal pure returns (uint256 u_) {\\n        assembly (\\\"memory-safe\\\") {\\n            u_ := fn_\\n        }\\n    }\\n\\n    function asUint256Array(\\n        function(InterpreterState memory, Operand, StackTop)\\n            view\\n            returns (StackTop)[]\\n            memory fns_\\n    ) internal pure returns (uint256[] memory us_) {\\n        assembly (\\\"memory-safe\\\") {\\n            us_ := fns_\\n        }\\n    }\\n\\n    function asUint256Array(\\n        function(uint256) pure returns (uint256)[] memory fns_\\n    ) internal pure returns (uint256[] memory us_) {\\n        assembly (\\\"memory-safe\\\") {\\n            us_ := fns_\\n        }\\n    }\\n\\n    function asAddresses(\\n        uint256[] memory us_\\n    ) internal pure returns (address[] memory addresses_) {\\n        assembly (\\\"memory-safe\\\") {\\n            addresses_ := us_\\n        }\\n    }\\n\\n    function asIntegrityPointers(\\n        uint256[] memory us_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(IntegrityState memory, Operand, StackTop)\\n                view\\n                returns (StackTop)[]\\n                memory fns_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fns_ := us_\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x54b89011034a91d942cc1657759a77e01398af8d60f6b0ae75b7fc43f429952d\",\"license\":\"CAL\"},\"contracts/type/LibConvert.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// @title LibConvert\\n/// @notice Type conversions that require additional structural changes to\\n/// complete safely. These are NOT mere type casts and involve additional\\n/// reads and writes to complete, such as recalculating the length of an array.\\n/// The convention \\\"toX\\\" is adopted from Rust to imply the additional costs and\\n/// consumption of the source to produce the target.\\nlibrary LibConvert {\\n    /// Convert an array of integers to `bytes` data. This requires modifying\\n    /// the length in situ as the integer array length is measured in 32 byte\\n    /// increments while the length of `bytes` is the literal number of bytes.\\n    /// @return bytes_ The integer array converted to `bytes` data.\\n    function toBytes(\\n        uint256[] memory is_\\n    ) internal pure returns (bytes memory bytes_) {\\n        assembly (\\\"memory-safe\\\") {\\n            bytes_ := is_\\n            // Length in bytes is 32x the length in uint256\\n            mstore(bytes_, mul(0x20, mload(bytes_)))\\n        }\\n    }\\n\\n    function unsafeTo16BitBytes(\\n        uint256[] memory is_\\n    ) internal pure returns (bytes memory) {\\n        unchecked {\\n            // We will keep 2 bytes (16 bits) from each integer.\\n            bytes memory bytes_ = new bytes(is_.length * 2);\\n            assembly (\\\"memory-safe\\\") {\\n                let replaceMask_ := 0xFFFF\\n                let preserveMask_ := not(replaceMask_)\\n                for {\\n                    let cursor_ := add(is_, 0x20)\\n                    let end_ := add(cursor_, mul(mload(is_), 0x20))\\n                    let bytesCursor_ := add(bytes_, 0x02)\\n                } lt(cursor_, end_) {\\n                    cursor_ := add(cursor_, 0x20)\\n                    bytesCursor_ := add(bytesCursor_, 0x02)\\n                } {\\n                    let data_ := mload(bytesCursor_)\\n                    mstore(\\n                        bytesCursor_,\\n                        or(and(preserveMask_, data_), mload(cursor_))\\n                    )\\n                }\\n            }\\n            return bytes_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x24554781af9e5a79f0405133741bd4890bef21e6c63c4587d90659d5803bdcb0\",\"license\":\"CAL\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x60b0215121bf25612a6739fb2f1ec35f31ee82e4a8216c032c8243d904ab3aa9\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b50600054610100900460ff1615808015620000335750600054600160ff909116105b8062000063575062000050306200015260201b620019bf1760201c565b15801562000063575060005460ff166001145b620000cc5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084015b60405180910390fd5b6000805460ff191660011790558015620000f0576000805461ff0019166101001790555b620000fa62000161565b62000104620001c9565b80156200014b576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5062000287565b6001600160a01b03163b151590565b600054610100900460ff16620001bd5760405162461bcd60e51b815260206004820152602b6024820152600080516020620044b983398151915260448201526a6e697469616c697a696e6760a81b6064820152608401620000c3565b620001c762000225565b565b600054610100900460ff16620001c75760405162461bcd60e51b815260206004820152602b6024820152600080516020620044b983398151915260448201526a6e697469616c697a696e6760a81b6064820152608401620000c3565b600054610100900460ff16620002815760405162461bcd60e51b815260206004820152602b6024820152600080516020620044b983398151915260448201526a6e697469616c697a696e6760a81b6064820152608401620000c3565b60018055565b61422280620002976000396000f3fe608060405234801561001057600080fd5b50600436106100d45760003560e01c80638237e53811610081578063d97b2e481161005b578063d97b2e48146101df578063d9d98ce414610210578063e6b626361461022657600080fd5b80638237e53814610170578063ac9650d814610197578063b9bf81fa146101b757600080fd5b8063613255ab116100b2578063613255ab1461012957806366caae591461014a578063798178bf1461015d57600080fd5b806333395240146100d95780634f266187146100ee5780635cffe9de14610101575b600080fd5b6100ec6100e7366004613201565b610239565b005b6100ec6100fc366004613289565b610983565b61011461010f3660046132a5565b610b34565b60405190151581526020015b60405180910390f35b61013c610137366004613344565b610c80565b604051908152602001610120565b6100ec610158366004613361565b610d17565b6100ec61016b366004613396565b610e94565b61013c7f439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd981565b6101aa6101a53660046133d1565b6111ca565b60405161012091906134b4565b6101ca6101c5366004613361565b6112bf565b60408051928352602083019190915201610120565b61013c6101ed366004613534565b606760209081526000938452604080852082529284528284209052825290205481565b61013c61021e366004613575565b600092915050565b6100ec610234366004613289565b61186e565b6002600154036102aa576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064015b60405180910390fd5b60026001558151835173ffffffffffffffffffffffffffffffffffffffff918216911603610334576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f53414d455f4f574e45520000000000000000000000000000000000000000000060448201526064016102a1565b816080015181604001358151811061034e5761034e6135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff168360a0015182602001358151811061038a5761038a6135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1614610413576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f544f4b454e5f4d49534d4154434800000000000000000000000000000000000060448201526064016102a1565b60808301518051823590811061042b5761042b6135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff168260a00151826060013581518110610467576104676135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff16146104f0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f544f4b454e5f4d49534d4154434800000000000000000000000000000000000060448201526064016102a1565b6000606660006104ff866119db565b81526020019081526020016000205411610575576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f415f4e4f545f4c4956450000000000000000000000000000000000000000000060448201526064016102a1565b600060666000610584856119db565b815260200190815260200160002054116105fa576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f425f4e4f545f4c4956450000000000000000000000000000000000000000000060448201526064016102a1565b6106256040518060800160405280600081526020016000815260200160008152602001600081525090565b6060806060806000806000807ff8538f47b9fbd23cc19f0c878214510df604d2b60f398a157ba11d4006cbae3a338d8d8d604051610666949392919061369c565b60405180910390a16106868c8b600001358c602001358e60000151611a2a565b8f51919b5099509095509092506106aa908c9060408d01359060608e013590611a2a565b9098509650935090506106c76106c08285612171565b839061218d565b89526106dd6106d68386612171565b829061218d565b60208a015288511515806106f5575060008960200151115b61075b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600760248201527f305f434c4541520000000000000000000000000000000000000000000000000060448201526064016102a1565b88516107679085612171565b60408a0152602089015161077b9084612171565b60608a01525050506040860151865161079992508a919087876121a3565b6107ae878660600151876020015185856121a3565b606085015185516000916107c191613755565b90506000866040015187602001516107d99190613755565b9050811561087f57336000908152606760209081526040822060a08d01518051869492938d013590811061080f5761080f6135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008a60800135815260200190815260200160002060008282546108799190613768565b90915550505b80156109235733600090815260676020526040812060a08b015180518493919060608d01359081106108b3576108b36135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008a60a001358152602001908152602001600020600082825461091d9190613768565b90915550505b505060408051865181526020808801519082015286820151818301526060808801519082015290517f3e673c18070310617c4b157f17e875bbc59a81b0f5107d346dfed8775de6f0f79181900360800190a1505060018055505050505050565b6002600154036109ef576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016102a1565b60026001553360009081526067602090815260408220908290610a1490850185613344565b73ffffffffffffffffffffffffffffffffffffffff16815260208082019290925260409081016000908120858401358252909252808220549250610a5b908401358361218d565b9050610a678183613755565b33600090815260676020908152604082209190610a8690870187613344565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600085602001358152602001908152602001600020819055507f2538ccc7ad2a119a36f2e65c1e2fc908beef800cd59b5d6680db24de18e7847a338483604051610b0c939291906137b3565b60405180910390a1610b2b610b246020850185613344565b3383612615565b50506001805550565b6000610b4185878661270d565b6040517f23e30c8b0000000000000000000000000000000000000000000000000000000081527f439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd99073ffffffffffffffffffffffffffffffffffffffff8816906323e30c8b90610bc09033908a908a906000908b908b90600401613834565b6020604051808303816000875af1158015610bdf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c039190613886565b14610c6a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f466c6173684c656e6465723a2043616c6c6261636b206661696c65640000000060448201526064016102a1565b610c74858761277d565b50600195945050505050565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015260009073ffffffffffffffffffffffffffffffffffffffff8316906370a0823190602401602060405180830381865afa158015610ced573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d119190613886565b92915050565b600260015403610d83576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016102a1565b6002600155610d956020820182613344565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610e29576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600560248201527f4f574e455200000000000000000000000000000000000000000000000000000060448201526064016102a1565b6000610e3c610e378361389f565b6119db565b60008181526066602052604080822091909155519091507fb7bbf693ac1b0a6a24cc035f21ef2e1ab7eb0e33769dda8400b70ffca797107190610e849033908590859061396e565b60405180910390a1505060018055565b600260015403610f00576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016102a1565b60026001556000610f146020830183613344565b73ffffffffffffffffffffffffffffffffffffffff16631ed061d9610f3c6040850185613a4b565b610f48600260006128bc565b6040518363ffffffff1660e01b8152600401610f65929190613b6b565b60408051808303816000875af1158015610f83573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fa79190613caa565b50905060006040518060c001604052803373ffffffffffffffffffffffffffffffffffffffff168152602001846020016020810190610fe69190613344565b73ffffffffffffffffffffffffffffffffffffffff16815260209081019084901b77ffffffffffffffffffffffffffffffffffffffff0000000016600217815260200160006110386040870187613a4b565b6110429080613cd8565b6001818110611053576110536135a1565b90506020028101906110659190613d40565b905011611073576000611098565b6201ffff602085901b77ffffffffffffffffffffffffffffffffffffffff0000000016175b81526020016110aa6060860186613da5565b808060200260200160405190810160405280939291908181526020016000905b828210156110f6576110e760408302860136819003810190613e0d565b815260200190600101906110ca565b505050918352505060200161110e6080860186613da5565b808060200260200160405190810160405280939291908181526020016000905b8282101561115a5761114b60408302860136819003810190613e0d565b8152602001906001019061112e565b50505050508152509050600061116f826119db565b6000818152606660205260409081902060019055519091507ff78885f51d9a7bb8e5924562877609c44121ef6245bb6042a8613fb9d41c33fb906111b890339085908590613e29565b60405180910390a15050600180555050565b60608167ffffffffffffffff8111156111e5576111e5612f77565b60405190808252806020026020018201604052801561121857816020015b60608152602001906001900390816112035790505b50905060005b828110156112b8576112883085858481811061123c5761123c6135a1565b905060200281019061124e9190613d40565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506128f092505050565b82828151811061129a5761129a6135a1565b602002602001018190525080806112b090613e68565b91505061121e565b5092915050565b60008060026001540361132e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016102a1565b6002600155604080516101208101825260006060808301828152608080850184905260a080860185905260c080870186905260e08701859052610100870185905292865260208087018690528688018690528751938401885285845283018590529582018490528183018490528101829052938401529160608601355b6113b860a0880188613cd8565b9050841080156113c85750600081115b15611795576113da60a0880188613cd8565b858181106113ea576113ea6135a1565b90506020028101906113fc9190613ea0565b61140590613ed4565b805190935091506000611417836119db565b6000818152606660205260408120549192500361148b5782516040805133815273ffffffffffffffffffffffffffffffffffffffff909216602083015281018290527fe721f6888210c87666d3888f93b4139a86ab7757999ce54e268cba700d642a3b9060600160405180910390a1611789565b6114986020890189613344565b73ffffffffffffffffffffffffffffffffffffffff1683608001518560200151815181106114c8576114c86135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1614611551576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f544f4b454e5f4d49534d4154434800000000000000000000000000000000000060448201526064016102a1565b6115616040890160208a01613344565b73ffffffffffffffffffffffffffffffffffffffff168360a00151856040015181518110611591576115916135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff161461161a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f544f4b454e5f4d49534d4154434800000000000000000000000000000000000060448201526064016102a1565b6000806000806116348789602001518a6040015133611a2a565b93509350935093508b608001358311156116a65786516040805133815273ffffffffffffffffffffffffffffffffffffffff909216602083015281018690527f460c258f27efac20e56c4607a28003d235168e76997ffb7542637d26d45ea6d8906060015b60405180910390a1611784565b836000036117035786516040805133815273ffffffffffffffffffffffffffffffffffffffff909216602083015281018690527f3ba461a0ffd1b6782d4817ae7be605cfb1bbb4fa503c0dd613b8e50f1dcafacd90606001611699565b600061170f878661218d565b9050600061171d8286612171565b90506117298289613755565b9750611735818d613768565b9b5061174489828487876121a3565b7f77d7d9fea654008797ba160aa023363a12d0aa806ebcc1da570f3717c57f8ce2338b84846040516117799493929190613f4c565b60405180910390a150505b505050505b506001909301926113ab565b6117a3816060890135613755565b95508660400135861015611813576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f4d494e5f494e505554000000000000000000000000000000000000000000000060448201526064016102a1565b61184433308761182660208c018c613344565b73ffffffffffffffffffffffffffffffffffffffff16929190612a2f565b61185e6118576040890160208a01613344565b3388612615565b5050505060018081905550915091565b6002600154036118da576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016102a1565b60026001553360009081526067602090815260408083209084013592909161190490850185613344565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008360200135815260200190815260200160002060008282546119629190613768565b90915550506040517fadc7bd964a04a8a02261d33d2d09c6a7d9f539bc5eab77008e85fc6661ef1231906119999033908490613fab565b60405180910390a16119b8333060408401356118266020860186613344565b5060018055565b73ffffffffffffffffffffffffffffffffffffffff163b151590565b6000816040516020016119ee9190613fd5565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152919052805160209091012092915050565b6000806060806000611a3b896119db565b60408051600480825260a0820190925291925060009190816020015b6060815260200190600190039081611a57579050509050611aa9828b6000015173ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff16612b0b565b81600081518110611abc57611abc6135a1565b602090810291909101015260408051600480825260a08201909252908160200160208202803683370190505081600281518110611afb57611afb6135a1565b602090810291909101015260408051600480825260a08201909252908160200160208202803683370190505081600381518110611b3a57611b3a6135a1565b602002602001018190525089608001518981518110611b5b57611b5b6135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1681600281518110611b9057611b906135a1565b6020026020010151600081518110611baa57611baa6135a1565b6020026020010181815250508960a001518881518110611bcc57611bcc6135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1681600381518110611c0157611c016135a1565b6020026020010151600081518110611c1b57611c1b6135a1565b60200260200101818152505089608001518981518110611c3d57611c3d6135a1565b60200260200101516020015181600281518110611c5c57611c5c6135a1565b6020026020010151600181518110611c7657611c766135a1565b6020026020010181815250508960a001518881518110611c9857611c986135a1565b60200260200101516020015181600381518110611cb757611cb76135a1565b6020026020010151600181518110611cd157611cd16135a1565b602002602001018181525050606760008b6000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008b608001518b81518110611d3857611d386135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008b608001518b81518110611d9657611d966135a1565b60200260200101516020015181526020019081526020016000205481600281518110611dc457611dc46135a1565b6020026020010151600281518110611dde57611dde6135a1565b602002602001018181525050606760008b6000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008b60a001518a81518110611e4557611e456135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008b60a001518a81518110611ea357611ea36135a1565b60200260200101516020015181526020019081526020016000205481600381518110611ed157611ed16135a1565b6020026020010151600281518110611eeb57611eeb6135a1565b6020026020010181815250506000808b6020015173ffffffffffffffffffffffffffffffffffffffff1663be6575df8d6000015173ffffffffffffffffffffffffffffffffffffffff168e60400151866040518463ffffffff1660e01b8152600401611f5993929190613fe8565b600060405180830381865afa158015611f76573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052611fbc91908101906140d2565b815160200282017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810151905192945090925090604080516002808252606082018352939b5091995060009290602083019080368337019050509050888160008151811061202c5761202c6135a1565b602002602001018181525050878160018151811061204c5761204c6135a1565b602002602001018181525050808460018151811061206c5761206c6135a1565b602002602001018190525061215d606760008f6000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008f60a001518e815181106120d5576120d56135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008f60a001518e81518110612133576121336135a1565b6020026020010151602001518152602001908152602001600020548a61218d90919063ffffffff16565b9d979c50929a509850949650505050505050565b60006121868383670de0b6b3a7640000612b48565b9392505050565b600081831061219c5781612186565b5090919050565b83826002815181106121b7576121b76135a1565b60200260200101516003815181106121d1576121d16135a1565b60200260200101818152505082826003815181106121f1576121f16135a1565b602002602001015160038151811061220b5761220b6135a1565b6020908102919091010152831561231057845173ffffffffffffffffffffffffffffffffffffffff16600090815260676020526040812083518692908590600290811061225a5761225a6135a1565b6020026020010151600081518110612274576122746135a1565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000846002815181106122cb576122cb6135a1565b60200260200101516001815181106122e5576122e56135a1565b60200260200101518152602001908152602001600020600082825461230a9190613768565b90915550505b821561240a57845173ffffffffffffffffffffffffffffffffffffffff166000908152606760205260408120835185929085906003908110612354576123546135a1565b602002602001015160008151811061236e5761236e6135a1565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000846003815181106123c5576123c56135a1565b60200260200101516001815181106123df576123df6135a1565b6020026020010151815260200190815260200160002060008282546124049190613755565b90915550505b8051156124a157602085015185516040517fbeb677ed00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9283169263beb677ed9261246e929116908590600401614136565b600060405180830381600087803b15801561248857600080fd5b505af115801561249c573d6000803e3d6000fd5b505050505b60608501511561260e576000856020015173ffffffffffffffffffffffffffffffffffffffff1663be6575df876000015173ffffffffffffffffffffffffffffffffffffffff168860600151866040518463ffffffff1660e01b815260040161250c93929190613fe8565b600060405180830381865afa158015612529573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820160405261256f91908101906140d2565b91505060008151111561260c57602086015186516040517fbeb677ed00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9283169263beb677ed926125d9929116908590600401614136565b600060405180830381600087803b1580156125f357600080fd5b505af1158015612607573d6000803e3d6000fd5b505050505b505b5050505050565b73ffffffffffffffffffffffffffffffffffffffff808416600090815260656020908152604080832093861683529290522054808211156126bd57801561268c5773ffffffffffffffffffffffffffffffffffffffff80851660009081526065602090815260408083209387168352929052908120555b6126b88361269a8385613755565b73ffffffffffffffffffffffffffffffffffffffff87169190612c15565b612707565b73ffffffffffffffffffffffffffffffffffffffff808516600090815260656020908152604080832093871683529290529081208054849290612701908490613755565b90915550505b50505050565b73ffffffffffffffffffffffffffffffffffffffff808416600090815260656020908152604080832093861683529290529081208054839290612751908490613768565b90915550612778905073ffffffffffffffffffffffffffffffffffffffff84168383612c15565b505050565b73ffffffffffffffffffffffffffffffffffffffff8083166000908152606560209081526040808320938516835292905220548015612822576127d873ffffffffffffffffffffffffffffffffffffffff8416833084612a2f565b73ffffffffffffffffffffffffffffffffffffffff80841660009081526065602090815260408083209386168352929052908120805483929061281c908490613755565b90915550505b73ffffffffffffffffffffffffffffffffffffffff80841660009081526065602090815260408083209386168352929052205415612778576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4241445f4445425400000000000000000000000000000000000000000000000060448201526064016102a1565b6040805160028082526060808301845292600092919060208301908036833750505060208101949094525050604082015290565b606073ffffffffffffffffffffffffffffffffffffffff83163b612996576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e7472616374000000000000000000000000000000000000000000000000000060648201526084016102a1565b6000808473ffffffffffffffffffffffffffffffffffffffff16846040516129be919061414f565b600060405180830381855af49150503d80600081146129f9576040519150601f19603f3d011682016040523d82523d6000602084013e6129fe565b606091505b5091509150612a2682826040518060600160405280602781526020016141c660279139612c6b565b95945050505050565b60405173ffffffffffffffffffffffffffffffffffffffff808516602483015283166044820152606481018290526127079085907f23b872dd00000000000000000000000000000000000000000000000000000000906084015b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152612cbe565b6040805160038082526080820190925260609160009190602082018480368337505050602081019590955250506040830191909152606082015290565b600080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff85870985870292508281108382030391505080600003612ba057838281612b9657612b96614161565b0492505050612186565b808411612bac57600080fd5b60008486880960026001871981018816978890046003810283188082028403028082028403028082028403028082028403028082028403029081029092039091026000889003889004909101858311909403939093029303949094049190911702949350505050565b60405173ffffffffffffffffffffffffffffffffffffffff83166024820152604481018290526127789084907fa9059cbb0000000000000000000000000000000000000000000000000000000090606401612a89565b60608315612c7a575081612186565b825115612c8a5782518084602001fd5b816040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102a19190614190565b6000612d20826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65648152508573ffffffffffffffffffffffffffffffffffffffff16612dca9092919063ffffffff16565b8051909150156127785780806020019051810190612d3e91906141a3565b612778576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016102a1565b6060612dd98484600085612de1565b949350505050565b606082471015612e73576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016102a1565b73ffffffffffffffffffffffffffffffffffffffff85163b612ef1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016102a1565b6000808673ffffffffffffffffffffffffffffffffffffffff168587604051612f1a919061414f565b60006040518083038185875af1925050503d8060008114612f57576040519150601f19603f3d011682016040523d82523d6000602084013e612f5c565b606091505b5091509150612f6c828286612c6b565b979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405160c0810167ffffffffffffffff81118282101715612fc957612fc9612f77565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561301657613016612f77565b604052919050565b73ffffffffffffffffffffffffffffffffffffffff8116811461304057600080fd5b50565b803561304e8161301e565b919050565b600067ffffffffffffffff82111561306d5761306d612f77565b5060051b60200190565b60006040828403121561308957600080fd5b6040516040810181811067ffffffffffffffff821117156130ac576130ac612f77565b60405290508082356130bd8161301e565b8152602092830135920191909152919050565b600082601f8301126130e157600080fd5b813560206130f66130f183613053565b612fcf565b82815260069290921b8401810191818101908684111561311557600080fd5b8286015b848110156131395761312b8882613077565b835291830191604001613119565b509695505050505050565b600060c0828403121561315657600080fd5b61315e612fa6565b905061316982613043565b815261317760208301613043565b60208201526040820135604082015260608201356060820152608082013567ffffffffffffffff808211156131ab57600080fd5b6131b7858386016130d0565b608084015260a08401359150808211156131d057600080fd5b506131dd848285016130d0565b60a08301525092915050565b600060c082840312156131fb57600080fd5b50919050565b6000806000610100848603121561321757600080fd5b833567ffffffffffffffff8082111561322f57600080fd5b61323b87838801613144565b9450602086013591508082111561325157600080fd5b5061325e86828701613144565b92505061326e85604086016131e9565b90509250925092565b6000606082840312156131fb57600080fd5b60006060828403121561329b57600080fd5b6121868383613277565b6000806000806000608086880312156132bd57600080fd5b85356132c88161301e565b945060208601356132d88161301e565b935060408601359250606086013567ffffffffffffffff808211156132fc57600080fd5b818801915088601f83011261331057600080fd5b81358181111561331f57600080fd5b89602082850101111561333157600080fd5b9699959850939650602001949392505050565b60006020828403121561335657600080fd5b81356121868161301e565b60006020828403121561337357600080fd5b813567ffffffffffffffff81111561338a57600080fd5b612dd9848285016131e9565b6000602082840312156133a857600080fd5b813567ffffffffffffffff8111156133bf57600080fd5b820160a0818503121561218657600080fd5b600080602083850312156133e457600080fd5b823567ffffffffffffffff808211156133fc57600080fd5b818501915085601f83011261341057600080fd5b81358181111561341f57600080fd5b8660208260051b850101111561343457600080fd5b60209290920196919550909350505050565b60005b83811015613461578181015183820152602001613449565b50506000910152565b60008151808452613482816020860160208601613446565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b82811015613527577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc088860301845261351585835161346a565b945092850192908501906001016134db565b5092979650505050505050565b60008060006060848603121561354957600080fd5b83356135548161301e565b925060208401356135648161301e565b929592945050506040919091013590565b6000806040838503121561358857600080fd5b82356135938161301e565b946020939093013593505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600081518084526020808501945080840160005b83811015613621578151805173ffffffffffffffffffffffffffffffffffffffff16885283015183880152604090960195908201906001016135e4565b509495945050505050565b600073ffffffffffffffffffffffffffffffffffffffff808351168452806020840151166020850152506040820151604084015260608201516060840152608082015160c0608085015261368360c08501826135d0565b905060a083015184820360a0860152612a2682826135d0565b600061012073ffffffffffffffffffffffffffffffffffffffff871683528060208401526136cc8184018761362c565b905082810360408401526136e0818661362c565b9150508235606083015260208301356080830152604083013560a0830152606083013560c0830152608083013560e083015260a083013561010083015295945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b81810381811115610d1157610d11613726565b80820180821115610d1157610d11613726565b80356137868161301e565b73ffffffffffffffffffffffffffffffffffffffff16825260208181013590830152604090810135910152565b73ffffffffffffffffffffffffffffffffffffffff8416815260a081016137dd602083018561377b565b826080830152949350505050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b600073ffffffffffffffffffffffffffffffffffffffff808916835280881660208401525085604083015284606083015260a0608083015261387a60a0830184866137eb565b98975050505050505050565b60006020828403121561389857600080fd5b5051919050565b6000610d113683613144565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181126138e057600080fd5b830160208101925035905067ffffffffffffffff81111561390057600080fd5b8060061b360382131561391257600080fd5b9250929050565b8183526000602080850194508260005b8581101561362157813561393c8161301e565b73ffffffffffffffffffffffffffffffffffffffff168752818301358388015260409687019690910190600101613929565b600073ffffffffffffffffffffffffffffffffffffffff808616835260606020840152843561399c8161301e565b8116606084015260208501356139b18161301e565b81811660808501525050604084013560a0830152606084013560c08301526139dc60808501856138ab565b60c060e08501526139f261012085018284613919565b915050613a0260a08601866138ab565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa085840301610100860152613a38838284613919565b9350505050826040830152949350505050565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1833603018112613a7f57600080fd5b9190910192915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112613abe57600080fd5b830160208101925035905067ffffffffffffffff811115613ade57600080fd5b8060051b360382131561391257600080fd5b81835260007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff831115613b2257600080fd5b8260051b80836020870137939093016020019392505050565b600081518084526020808501945080840160005b8381101561362157815187529582019590820190600101613b4f565b60408152600060808201613b7f8586613a89565b6040808601528281845260a08601905060a08260051b87010193508260005b83811015613c4d577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6088870301835281357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1863603018112613bff57600080fd5b8501602081810191359067ffffffffffffffff821115613c1e57600080fd5b813603831315613c2d57600080fd5b613c388983856137eb565b98509485019493909301925050600101613b9e565b5050505050613c5f6020860186613a89565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0858403016060860152613c94838284613af0565b925050508281036020840152612a268185613b3b565b60008060408385031215613cbd57600080fd5b8251613cc88161301e565b6020939093015192949293505050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112613d0d57600080fd5b83018035915067ffffffffffffffff821115613d2857600080fd5b6020019150600581901b360382131561391257600080fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112613d7557600080fd5b83018035915067ffffffffffffffff821115613d9057600080fd5b60200191503681900382131561391257600080fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112613dda57600080fd5b83018035915067ffffffffffffffff821115613df557600080fd5b6020019150600681901b360382131561391257600080fd5b600060408284031215613e1f57600080fd5b6121868383613077565b73ffffffffffffffffffffffffffffffffffffffff84168152606060208201526000613e58606083018561362c565b9050826040830152949350505050565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203613e9957613e99613726565b5060010190565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa1833603018112613a7f57600080fd5b600060608236031215613ee657600080fd5b6040516060810167ffffffffffffffff8282108183111715613f0a57613f0a612f77565b816040528435915080821115613f1f57600080fd5b50613f2c36828601613144565b825250602083013560208201526040830135604082015280915050919050565b73ffffffffffffffffffffffffffffffffffffffff85168152608060208201526000845160606080840152613f8460e084018261362c565b602087015160a085015260409687015160c085015295830194909452506060015250919050565b73ffffffffffffffffffffffffffffffffffffffff8316815260808101612186602083018461377b565b602081526000612186602083018461362c565b600060608201858352602085818501526060604085015281855180845260808601915060808160051b870101935082870160005b82811015614068577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80888703018452614056868351613b3b565b9550928401929084019060010161401c565b50939998505050505050505050565b600082601f83011261408857600080fd5b815160206140986130f183613053565b82815260059290921b840181019181810190868411156140b757600080fd5b8286015b8481101561313957805183529183019183016140bb565b600080604083850312156140e557600080fd5b825167ffffffffffffffff808211156140fd57600080fd5b61410986838701614077565b9350602085015191508082111561411f57600080fd5b5061412c85828601614077565b9150509250929050565b828152604060208201526000612dd96040830184613b3b565b60008251613a7f818460208701613446565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b602081526000612186602083018461346a565b6000602082840312156141b557600080fd5b8151801515811461218657600080fdfe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220f77f57a158d1f5a30d97d2220b6f205d991848a6e40ac5ece40dd3b61bc8c56764736f6c63430008110033496e697469616c697a61626c653a20636f6e7472616374206973206e6f742069",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100d45760003560e01c80638237e53811610081578063d97b2e481161005b578063d97b2e48146101df578063d9d98ce414610210578063e6b626361461022657600080fd5b80638237e53814610170578063ac9650d814610197578063b9bf81fa146101b757600080fd5b8063613255ab116100b2578063613255ab1461012957806366caae591461014a578063798178bf1461015d57600080fd5b806333395240146100d95780634f266187146100ee5780635cffe9de14610101575b600080fd5b6100ec6100e7366004613201565b610239565b005b6100ec6100fc366004613289565b610983565b61011461010f3660046132a5565b610b34565b60405190151581526020015b60405180910390f35b61013c610137366004613344565b610c80565b604051908152602001610120565b6100ec610158366004613361565b610d17565b6100ec61016b366004613396565b610e94565b61013c7f439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd981565b6101aa6101a53660046133d1565b6111ca565b60405161012091906134b4565b6101ca6101c5366004613361565b6112bf565b60408051928352602083019190915201610120565b61013c6101ed366004613534565b606760209081526000938452604080852082529284528284209052825290205481565b61013c61021e366004613575565b600092915050565b6100ec610234366004613289565b61186e565b6002600154036102aa576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064015b60405180910390fd5b60026001558151835173ffffffffffffffffffffffffffffffffffffffff918216911603610334576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f53414d455f4f574e45520000000000000000000000000000000000000000000060448201526064016102a1565b816080015181604001358151811061034e5761034e6135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff168360a0015182602001358151811061038a5761038a6135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1614610413576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f544f4b454e5f4d49534d4154434800000000000000000000000000000000000060448201526064016102a1565b60808301518051823590811061042b5761042b6135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff168260a00151826060013581518110610467576104676135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff16146104f0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f544f4b454e5f4d49534d4154434800000000000000000000000000000000000060448201526064016102a1565b6000606660006104ff866119db565b81526020019081526020016000205411610575576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f415f4e4f545f4c4956450000000000000000000000000000000000000000000060448201526064016102a1565b600060666000610584856119db565b815260200190815260200160002054116105fa576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600a60248201527f425f4e4f545f4c4956450000000000000000000000000000000000000000000060448201526064016102a1565b6106256040518060800160405280600081526020016000815260200160008152602001600081525090565b6060806060806000806000807ff8538f47b9fbd23cc19f0c878214510df604d2b60f398a157ba11d4006cbae3a338d8d8d604051610666949392919061369c565b60405180910390a16106868c8b600001358c602001358e60000151611a2a565b8f51919b5099509095509092506106aa908c9060408d01359060608e013590611a2a565b9098509650935090506106c76106c08285612171565b839061218d565b89526106dd6106d68386612171565b829061218d565b60208a015288511515806106f5575060008960200151115b61075b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600760248201527f305f434c4541520000000000000000000000000000000000000000000000000060448201526064016102a1565b88516107679085612171565b60408a0152602089015161077b9084612171565b60608a01525050506040860151865161079992508a919087876121a3565b6107ae878660600151876020015185856121a3565b606085015185516000916107c191613755565b90506000866040015187602001516107d99190613755565b9050811561087f57336000908152606760209081526040822060a08d01518051869492938d013590811061080f5761080f6135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008a60800135815260200190815260200160002060008282546108799190613768565b90915550505b80156109235733600090815260676020526040812060a08b015180518493919060608d01359081106108b3576108b36135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008a60a001358152602001908152602001600020600082825461091d9190613768565b90915550505b505060408051865181526020808801519082015286820151818301526060808801519082015290517f3e673c18070310617c4b157f17e875bbc59a81b0f5107d346dfed8775de6f0f79181900360800190a1505060018055505050505050565b6002600154036109ef576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016102a1565b60026001553360009081526067602090815260408220908290610a1490850185613344565b73ffffffffffffffffffffffffffffffffffffffff16815260208082019290925260409081016000908120858401358252909252808220549250610a5b908401358361218d565b9050610a678183613755565b33600090815260676020908152604082209190610a8690870187613344565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600085602001358152602001908152602001600020819055507f2538ccc7ad2a119a36f2e65c1e2fc908beef800cd59b5d6680db24de18e7847a338483604051610b0c939291906137b3565b60405180910390a1610b2b610b246020850185613344565b3383612615565b50506001805550565b6000610b4185878661270d565b6040517f23e30c8b0000000000000000000000000000000000000000000000000000000081527f439148f0bbc682ca079e46d6e2c2f0c1e3b820f1a291b069d8882abf8cf18dd99073ffffffffffffffffffffffffffffffffffffffff8816906323e30c8b90610bc09033908a908a906000908b908b90600401613834565b6020604051808303816000875af1158015610bdf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c039190613886565b14610c6a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f466c6173684c656e6465723a2043616c6c6261636b206661696c65640000000060448201526064016102a1565b610c74858761277d565b50600195945050505050565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015260009073ffffffffffffffffffffffffffffffffffffffff8316906370a0823190602401602060405180830381865afa158015610ced573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d119190613886565b92915050565b600260015403610d83576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016102a1565b6002600155610d956020820182613344565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610e29576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600560248201527f4f574e455200000000000000000000000000000000000000000000000000000060448201526064016102a1565b6000610e3c610e378361389f565b6119db565b60008181526066602052604080822091909155519091507fb7bbf693ac1b0a6a24cc035f21ef2e1ab7eb0e33769dda8400b70ffca797107190610e849033908590859061396e565b60405180910390a1505060018055565b600260015403610f00576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016102a1565b60026001556000610f146020830183613344565b73ffffffffffffffffffffffffffffffffffffffff16631ed061d9610f3c6040850185613a4b565b610f48600260006128bc565b6040518363ffffffff1660e01b8152600401610f65929190613b6b565b60408051808303816000875af1158015610f83573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fa79190613caa565b50905060006040518060c001604052803373ffffffffffffffffffffffffffffffffffffffff168152602001846020016020810190610fe69190613344565b73ffffffffffffffffffffffffffffffffffffffff16815260209081019084901b77ffffffffffffffffffffffffffffffffffffffff0000000016600217815260200160006110386040870187613a4b565b6110429080613cd8565b6001818110611053576110536135a1565b90506020028101906110659190613d40565b905011611073576000611098565b6201ffff602085901b77ffffffffffffffffffffffffffffffffffffffff0000000016175b81526020016110aa6060860186613da5565b808060200260200160405190810160405280939291908181526020016000905b828210156110f6576110e760408302860136819003810190613e0d565b815260200190600101906110ca565b505050918352505060200161110e6080860186613da5565b808060200260200160405190810160405280939291908181526020016000905b8282101561115a5761114b60408302860136819003810190613e0d565b8152602001906001019061112e565b50505050508152509050600061116f826119db565b6000818152606660205260409081902060019055519091507ff78885f51d9a7bb8e5924562877609c44121ef6245bb6042a8613fb9d41c33fb906111b890339085908590613e29565b60405180910390a15050600180555050565b60608167ffffffffffffffff8111156111e5576111e5612f77565b60405190808252806020026020018201604052801561121857816020015b60608152602001906001900390816112035790505b50905060005b828110156112b8576112883085858481811061123c5761123c6135a1565b905060200281019061124e9190613d40565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506128f092505050565b82828151811061129a5761129a6135a1565b602002602001018190525080806112b090613e68565b91505061121e565b5092915050565b60008060026001540361132e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016102a1565b6002600155604080516101208101825260006060808301828152608080850184905260a080860185905260c080870186905260e08701859052610100870185905292865260208087018690528688018690528751938401885285845283018590529582018490528183018490528101829052938401529160608601355b6113b860a0880188613cd8565b9050841080156113c85750600081115b15611795576113da60a0880188613cd8565b858181106113ea576113ea6135a1565b90506020028101906113fc9190613ea0565b61140590613ed4565b805190935091506000611417836119db565b6000818152606660205260408120549192500361148b5782516040805133815273ffffffffffffffffffffffffffffffffffffffff909216602083015281018290527fe721f6888210c87666d3888f93b4139a86ab7757999ce54e268cba700d642a3b9060600160405180910390a1611789565b6114986020890189613344565b73ffffffffffffffffffffffffffffffffffffffff1683608001518560200151815181106114c8576114c86135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1614611551576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f544f4b454e5f4d49534d4154434800000000000000000000000000000000000060448201526064016102a1565b6115616040890160208a01613344565b73ffffffffffffffffffffffffffffffffffffffff168360a00151856040015181518110611591576115916135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff161461161a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f544f4b454e5f4d49534d4154434800000000000000000000000000000000000060448201526064016102a1565b6000806000806116348789602001518a6040015133611a2a565b93509350935093508b608001358311156116a65786516040805133815273ffffffffffffffffffffffffffffffffffffffff909216602083015281018690527f460c258f27efac20e56c4607a28003d235168e76997ffb7542637d26d45ea6d8906060015b60405180910390a1611784565b836000036117035786516040805133815273ffffffffffffffffffffffffffffffffffffffff909216602083015281018690527f3ba461a0ffd1b6782d4817ae7be605cfb1bbb4fa503c0dd613b8e50f1dcafacd90606001611699565b600061170f878661218d565b9050600061171d8286612171565b90506117298289613755565b9750611735818d613768565b9b5061174489828487876121a3565b7f77d7d9fea654008797ba160aa023363a12d0aa806ebcc1da570f3717c57f8ce2338b84846040516117799493929190613f4c565b60405180910390a150505b505050505b506001909301926113ab565b6117a3816060890135613755565b95508660400135861015611813576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f4d494e5f494e505554000000000000000000000000000000000000000000000060448201526064016102a1565b61184433308761182660208c018c613344565b73ffffffffffffffffffffffffffffffffffffffff16929190612a2f565b61185e6118576040890160208a01613344565b3388612615565b5050505060018081905550915091565b6002600154036118da576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016102a1565b60026001553360009081526067602090815260408083209084013592909161190490850185613344565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008360200135815260200190815260200160002060008282546119629190613768565b90915550506040517fadc7bd964a04a8a02261d33d2d09c6a7d9f539bc5eab77008e85fc6661ef1231906119999033908490613fab565b60405180910390a16119b8333060408401356118266020860186613344565b5060018055565b73ffffffffffffffffffffffffffffffffffffffff163b151590565b6000816040516020016119ee9190613fd5565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152919052805160209091012092915050565b6000806060806000611a3b896119db565b60408051600480825260a0820190925291925060009190816020015b6060815260200190600190039081611a57579050509050611aa9828b6000015173ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff16612b0b565b81600081518110611abc57611abc6135a1565b602090810291909101015260408051600480825260a08201909252908160200160208202803683370190505081600281518110611afb57611afb6135a1565b602090810291909101015260408051600480825260a08201909252908160200160208202803683370190505081600381518110611b3a57611b3a6135a1565b602002602001018190525089608001518981518110611b5b57611b5b6135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1681600281518110611b9057611b906135a1565b6020026020010151600081518110611baa57611baa6135a1565b6020026020010181815250508960a001518881518110611bcc57611bcc6135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1681600381518110611c0157611c016135a1565b6020026020010151600081518110611c1b57611c1b6135a1565b60200260200101818152505089608001518981518110611c3d57611c3d6135a1565b60200260200101516020015181600281518110611c5c57611c5c6135a1565b6020026020010151600181518110611c7657611c766135a1565b6020026020010181815250508960a001518881518110611c9857611c986135a1565b60200260200101516020015181600381518110611cb757611cb76135a1565b6020026020010151600181518110611cd157611cd16135a1565b602002602001018181525050606760008b6000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008b608001518b81518110611d3857611d386135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008b608001518b81518110611d9657611d966135a1565b60200260200101516020015181526020019081526020016000205481600281518110611dc457611dc46135a1565b6020026020010151600281518110611dde57611dde6135a1565b602002602001018181525050606760008b6000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008b60a001518a81518110611e4557611e456135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008b60a001518a81518110611ea357611ea36135a1565b60200260200101516020015181526020019081526020016000205481600381518110611ed157611ed16135a1565b6020026020010151600281518110611eeb57611eeb6135a1565b6020026020010181815250506000808b6020015173ffffffffffffffffffffffffffffffffffffffff1663be6575df8d6000015173ffffffffffffffffffffffffffffffffffffffff168e60400151866040518463ffffffff1660e01b8152600401611f5993929190613fe8565b600060405180830381865afa158015611f76573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052611fbc91908101906140d2565b815160200282017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810151905192945090925090604080516002808252606082018352939b5091995060009290602083019080368337019050509050888160008151811061202c5761202c6135a1565b602002602001018181525050878160018151811061204c5761204c6135a1565b602002602001018181525050808460018151811061206c5761206c6135a1565b602002602001018190525061215d606760008f6000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008f60a001518e815181106120d5576120d56135a1565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008f60a001518e81518110612133576121336135a1565b6020026020010151602001518152602001908152602001600020548a61218d90919063ffffffff16565b9d979c50929a509850949650505050505050565b60006121868383670de0b6b3a7640000612b48565b9392505050565b600081831061219c5781612186565b5090919050565b83826002815181106121b7576121b76135a1565b60200260200101516003815181106121d1576121d16135a1565b60200260200101818152505082826003815181106121f1576121f16135a1565b602002602001015160038151811061220b5761220b6135a1565b6020908102919091010152831561231057845173ffffffffffffffffffffffffffffffffffffffff16600090815260676020526040812083518692908590600290811061225a5761225a6135a1565b6020026020010151600081518110612274576122746135a1565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000846002815181106122cb576122cb6135a1565b60200260200101516001815181106122e5576122e56135a1565b60200260200101518152602001908152602001600020600082825461230a9190613768565b90915550505b821561240a57845173ffffffffffffffffffffffffffffffffffffffff166000908152606760205260408120835185929085906003908110612354576123546135a1565b602002602001015160008151811061236e5761236e6135a1565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000846003815181106123c5576123c56135a1565b60200260200101516001815181106123df576123df6135a1565b6020026020010151815260200190815260200160002060008282546124049190613755565b90915550505b8051156124a157602085015185516040517fbeb677ed00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9283169263beb677ed9261246e929116908590600401614136565b600060405180830381600087803b15801561248857600080fd5b505af115801561249c573d6000803e3d6000fd5b505050505b60608501511561260e576000856020015173ffffffffffffffffffffffffffffffffffffffff1663be6575df876000015173ffffffffffffffffffffffffffffffffffffffff168860600151866040518463ffffffff1660e01b815260040161250c93929190613fe8565b600060405180830381865afa158015612529573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820160405261256f91908101906140d2565b91505060008151111561260c57602086015186516040517fbeb677ed00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9283169263beb677ed926125d9929116908590600401614136565b600060405180830381600087803b1580156125f357600080fd5b505af1158015612607573d6000803e3d6000fd5b505050505b505b5050505050565b73ffffffffffffffffffffffffffffffffffffffff808416600090815260656020908152604080832093861683529290522054808211156126bd57801561268c5773ffffffffffffffffffffffffffffffffffffffff80851660009081526065602090815260408083209387168352929052908120555b6126b88361269a8385613755565b73ffffffffffffffffffffffffffffffffffffffff87169190612c15565b612707565b73ffffffffffffffffffffffffffffffffffffffff808516600090815260656020908152604080832093871683529290529081208054849290612701908490613755565b90915550505b50505050565b73ffffffffffffffffffffffffffffffffffffffff808416600090815260656020908152604080832093861683529290529081208054839290612751908490613768565b90915550612778905073ffffffffffffffffffffffffffffffffffffffff84168383612c15565b505050565b73ffffffffffffffffffffffffffffffffffffffff8083166000908152606560209081526040808320938516835292905220548015612822576127d873ffffffffffffffffffffffffffffffffffffffff8416833084612a2f565b73ffffffffffffffffffffffffffffffffffffffff80841660009081526065602090815260408083209386168352929052908120805483929061281c908490613755565b90915550505b73ffffffffffffffffffffffffffffffffffffffff80841660009081526065602090815260408083209386168352929052205415612778576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4241445f4445425400000000000000000000000000000000000000000000000060448201526064016102a1565b6040805160028082526060808301845292600092919060208301908036833750505060208101949094525050604082015290565b606073ffffffffffffffffffffffffffffffffffffffff83163b612996576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e7472616374000000000000000000000000000000000000000000000000000060648201526084016102a1565b6000808473ffffffffffffffffffffffffffffffffffffffff16846040516129be919061414f565b600060405180830381855af49150503d80600081146129f9576040519150601f19603f3d011682016040523d82523d6000602084013e6129fe565b606091505b5091509150612a2682826040518060600160405280602781526020016141c660279139612c6b565b95945050505050565b60405173ffffffffffffffffffffffffffffffffffffffff808516602483015283166044820152606481018290526127079085907f23b872dd00000000000000000000000000000000000000000000000000000000906084015b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152612cbe565b6040805160038082526080820190925260609160009190602082018480368337505050602081019590955250506040830191909152606082015290565b600080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff85870985870292508281108382030391505080600003612ba057838281612b9657612b96614161565b0492505050612186565b808411612bac57600080fd5b60008486880960026001871981018816978890046003810283188082028403028082028403028082028403028082028403028082028403029081029092039091026000889003889004909101858311909403939093029303949094049190911702949350505050565b60405173ffffffffffffffffffffffffffffffffffffffff83166024820152604481018290526127789084907fa9059cbb0000000000000000000000000000000000000000000000000000000090606401612a89565b60608315612c7a575081612186565b825115612c8a5782518084602001fd5b816040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016102a19190614190565b6000612d20826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65648152508573ffffffffffffffffffffffffffffffffffffffff16612dca9092919063ffffffff16565b8051909150156127785780806020019051810190612d3e91906141a3565b612778576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016102a1565b6060612dd98484600085612de1565b949350505050565b606082471015612e73576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016102a1565b73ffffffffffffffffffffffffffffffffffffffff85163b612ef1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016102a1565b6000808673ffffffffffffffffffffffffffffffffffffffff168587604051612f1a919061414f565b60006040518083038185875af1925050503d8060008114612f57576040519150601f19603f3d011682016040523d82523d6000602084013e612f5c565b606091505b5091509150612f6c828286612c6b565b979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405160c0810167ffffffffffffffff81118282101715612fc957612fc9612f77565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561301657613016612f77565b604052919050565b73ffffffffffffffffffffffffffffffffffffffff8116811461304057600080fd5b50565b803561304e8161301e565b919050565b600067ffffffffffffffff82111561306d5761306d612f77565b5060051b60200190565b60006040828403121561308957600080fd5b6040516040810181811067ffffffffffffffff821117156130ac576130ac612f77565b60405290508082356130bd8161301e565b8152602092830135920191909152919050565b600082601f8301126130e157600080fd5b813560206130f66130f183613053565b612fcf565b82815260069290921b8401810191818101908684111561311557600080fd5b8286015b848110156131395761312b8882613077565b835291830191604001613119565b509695505050505050565b600060c0828403121561315657600080fd5b61315e612fa6565b905061316982613043565b815261317760208301613043565b60208201526040820135604082015260608201356060820152608082013567ffffffffffffffff808211156131ab57600080fd5b6131b7858386016130d0565b608084015260a08401359150808211156131d057600080fd5b506131dd848285016130d0565b60a08301525092915050565b600060c082840312156131fb57600080fd5b50919050565b6000806000610100848603121561321757600080fd5b833567ffffffffffffffff8082111561322f57600080fd5b61323b87838801613144565b9450602086013591508082111561325157600080fd5b5061325e86828701613144565b92505061326e85604086016131e9565b90509250925092565b6000606082840312156131fb57600080fd5b60006060828403121561329b57600080fd5b6121868383613277565b6000806000806000608086880312156132bd57600080fd5b85356132c88161301e565b945060208601356132d88161301e565b935060408601359250606086013567ffffffffffffffff808211156132fc57600080fd5b818801915088601f83011261331057600080fd5b81358181111561331f57600080fd5b89602082850101111561333157600080fd5b9699959850939650602001949392505050565b60006020828403121561335657600080fd5b81356121868161301e565b60006020828403121561337357600080fd5b813567ffffffffffffffff81111561338a57600080fd5b612dd9848285016131e9565b6000602082840312156133a857600080fd5b813567ffffffffffffffff8111156133bf57600080fd5b820160a0818503121561218657600080fd5b600080602083850312156133e457600080fd5b823567ffffffffffffffff808211156133fc57600080fd5b818501915085601f83011261341057600080fd5b81358181111561341f57600080fd5b8660208260051b850101111561343457600080fd5b60209290920196919550909350505050565b60005b83811015613461578181015183820152602001613449565b50506000910152565b60008151808452613482816020860160208601613446565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b82811015613527577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc088860301845261351585835161346a565b945092850192908501906001016134db565b5092979650505050505050565b60008060006060848603121561354957600080fd5b83356135548161301e565b925060208401356135648161301e565b929592945050506040919091013590565b6000806040838503121561358857600080fd5b82356135938161301e565b946020939093013593505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600081518084526020808501945080840160005b83811015613621578151805173ffffffffffffffffffffffffffffffffffffffff16885283015183880152604090960195908201906001016135e4565b509495945050505050565b600073ffffffffffffffffffffffffffffffffffffffff808351168452806020840151166020850152506040820151604084015260608201516060840152608082015160c0608085015261368360c08501826135d0565b905060a083015184820360a0860152612a2682826135d0565b600061012073ffffffffffffffffffffffffffffffffffffffff871683528060208401526136cc8184018761362c565b905082810360408401526136e0818661362c565b9150508235606083015260208301356080830152604083013560a0830152606083013560c0830152608083013560e083015260a083013561010083015295945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b81810381811115610d1157610d11613726565b80820180821115610d1157610d11613726565b80356137868161301e565b73ffffffffffffffffffffffffffffffffffffffff16825260208181013590830152604090810135910152565b73ffffffffffffffffffffffffffffffffffffffff8416815260a081016137dd602083018561377b565b826080830152949350505050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b600073ffffffffffffffffffffffffffffffffffffffff808916835280881660208401525085604083015284606083015260a0608083015261387a60a0830184866137eb565b98975050505050505050565b60006020828403121561389857600080fd5b5051919050565b6000610d113683613144565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181126138e057600080fd5b830160208101925035905067ffffffffffffffff81111561390057600080fd5b8060061b360382131561391257600080fd5b9250929050565b8183526000602080850194508260005b8581101561362157813561393c8161301e565b73ffffffffffffffffffffffffffffffffffffffff168752818301358388015260409687019690910190600101613929565b600073ffffffffffffffffffffffffffffffffffffffff808616835260606020840152843561399c8161301e565b8116606084015260208501356139b18161301e565b81811660808501525050604084013560a0830152606084013560c08301526139dc60808501856138ab565b60c060e08501526139f261012085018284613919565b915050613a0260a08601866138ab565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa085840301610100860152613a38838284613919565b9350505050826040830152949350505050565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1833603018112613a7f57600080fd5b9190910192915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112613abe57600080fd5b830160208101925035905067ffffffffffffffff811115613ade57600080fd5b8060051b360382131561391257600080fd5b81835260007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff831115613b2257600080fd5b8260051b80836020870137939093016020019392505050565b600081518084526020808501945080840160005b8381101561362157815187529582019590820190600101613b4f565b60408152600060808201613b7f8586613a89565b6040808601528281845260a08601905060a08260051b87010193508260005b83811015613c4d577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6088870301835281357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1863603018112613bff57600080fd5b8501602081810191359067ffffffffffffffff821115613c1e57600080fd5b813603831315613c2d57600080fd5b613c388983856137eb565b98509485019493909301925050600101613b9e565b5050505050613c5f6020860186613a89565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0858403016060860152613c94838284613af0565b925050508281036020840152612a268185613b3b565b60008060408385031215613cbd57600080fd5b8251613cc88161301e565b6020939093015192949293505050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112613d0d57600080fd5b83018035915067ffffffffffffffff821115613d2857600080fd5b6020019150600581901b360382131561391257600080fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112613d7557600080fd5b83018035915067ffffffffffffffff821115613d9057600080fd5b60200191503681900382131561391257600080fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112613dda57600080fd5b83018035915067ffffffffffffffff821115613df557600080fd5b6020019150600681901b360382131561391257600080fd5b600060408284031215613e1f57600080fd5b6121868383613077565b73ffffffffffffffffffffffffffffffffffffffff84168152606060208201526000613e58606083018561362c565b9050826040830152949350505050565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203613e9957613e99613726565b5060010190565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa1833603018112613a7f57600080fd5b600060608236031215613ee657600080fd5b6040516060810167ffffffffffffffff8282108183111715613f0a57613f0a612f77565b816040528435915080821115613f1f57600080fd5b50613f2c36828601613144565b825250602083013560208201526040830135604082015280915050919050565b73ffffffffffffffffffffffffffffffffffffffff85168152608060208201526000845160606080840152613f8460e084018261362c565b602087015160a085015260409687015160c085015295830194909452506060015250919050565b73ffffffffffffffffffffffffffffffffffffffff8316815260808101612186602083018461377b565b602081526000612186602083018461362c565b600060608201858352602085818501526060604085015281855180845260808601915060808160051b870101935082870160005b82811015614068577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80888703018452614056868351613b3b565b9550928401929084019060010161401c565b50939998505050505050505050565b600082601f83011261408857600080fd5b815160206140986130f183613053565b82815260059290921b840181019181810190868411156140b757600080fd5b8286015b8481101561313957805183529183019183016140bb565b600080604083850312156140e557600080fd5b825167ffffffffffffffff808211156140fd57600080fd5b61410986838701614077565b9350602085015191508082111561411f57600080fd5b5061412c85828601614077565b9150509250929050565b828152604060208201526000612dd96040830184613b3b565b60008251613a7f818460208701613446565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b602081526000612186602083018461346a565b6000602082840312156141b557600080fd5b8151801515811461218657600080fdfe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220f77f57a158d1f5a30d97d2220b6f205d991848a6e40ac5ece40dd3b61bc8c56764736f6c63430008110033",
  "devdoc": {
    "events": {
      "Withdraw(address,(address,uint256,uint256),uint256)": {
        "params": {
          "amount": "The amount of tokens withdrawn, can be less than the config amount if the vault does not have the funds available to cover the config amount.",
          "config": "All config sent to the `withdraw` call.",
          "sender": "`msg.sender` withdrawing tokens."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "flashFee(address,uint256)": {
        "details": "The fee to be charged for a given loan.",
        "params": {
          "amount": "The amount of tokens lent.",
          "token": "The loan currency."
        },
        "returns": {
          "_0": "The amount of `token` to be charged for the loan, on top of the returned principal."
        }
      },
      "flashLoan(address,address,uint256,bytes)": {
        "details": "Initiate a flash loan.",
        "params": {
          "amount": "The amount of tokens lent.",
          "data": "Arbitrary data structure, intended to contain user-defined parameters.",
          "receiver": "The receiver of the tokens in the loan, and the receiver of the callback.",
          "token": "The loan currency."
        }
      },
      "maxFlashLoan(address)": {
        "details": "The amount of currency available to be lent.",
        "params": {
          "token": "The loan currency."
        },
        "returns": {
          "_0": "The amount of `token` that can be borrowed."
        }
      },
      "multicall(bytes[])": {
        "details": "Receives and executes a batch of function calls on this contract."
      },
      "withdraw((address,uint256,uint256))": {
        "params": {
          "config_": "All config required to withdraw. Notably if the amount is less than the current vault balance then the vault will be cleared to 0 rather than the withdraw transaction reverting."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "vaultBalance(address,address,uint256)": {
        "notice": "depositor => token => vault id => token amount."
      },
      "withdraw((address,uint256,uint256))": {
        "notice": "Allows the sender to withdraw any tokens from their own vaults."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 859,
        "contract": "contracts/orderbook/OrderBook.sol:OrderBook",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 862,
        "contract": "contracts/orderbook/OrderBook.sol:OrderBook",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 1017,
        "contract": "contracts/orderbook/OrderBook.sol:OrderBook",
        "label": "_status",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 1061,
        "contract": "contracts/orderbook/OrderBook.sol:OrderBook",
        "label": "__gap",
        "offset": 0,
        "slot": "2",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 6441,
        "contract": "contracts/orderbook/OrderBook.sol:OrderBook",
        "label": "__gap",
        "offset": 0,
        "slot": "51",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 30037,
        "contract": "contracts/orderbook/OrderBook.sol:OrderBook",
        "label": "activeFlashDebts",
        "offset": 0,
        "slot": "101",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 28757,
        "contract": "contracts/orderbook/OrderBook.sol:OrderBook",
        "label": "orders",
        "offset": 0,
        "slot": "102",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 28766,
        "contract": "contracts/orderbook/OrderBook.sol:OrderBook",
        "label": "vaultBalance",
        "offset": 0,
        "slot": "103",
        "type": "t_mapping(t_address,t_mapping(t_address,t_mapping(t_uint256,t_uint256)))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_mapping(t_address,t_mapping(t_uint256,t_uint256)))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => mapping(uint256 => uint256)))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_mapping(t_uint256,t_uint256))"
      },
      "t_mapping(t_address,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_uint256)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}