{
  "address": "0xE41eB8948993e749cF0a2f03D597C068785c0c55",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        }
      ],
      "name": "Implementation",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "child",
          "type": "address"
        }
      ],
      "name": "NewChild",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data_",
          "type": "bytes"
        }
      ],
      "name": "createChild",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "bytes[]",
                  "name": "sources",
                  "type": "bytes[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "constants",
                  "type": "uint256[]"
                }
              ],
              "internalType": "struct StateConfig",
              "name": "stateConfig",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "expressionDeployer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "interpreter",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes[]",
                      "name": "sources",
                      "type": "bytes[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "constants",
                      "type": "uint256[]"
                    }
                  ],
                  "internalType": "struct StateConfig[]",
                  "name": "flows",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct FlowCommonConfig",
              "name": "flowConfig",
              "type": "tuple"
            }
          ],
          "internalType": "struct FlowConfig",
          "name": "config_",
          "type": "tuple"
        }
      ],
      "name": "createChildTyped",
      "outputs": [
        {
          "internalType": "contract Flow",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "implementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "maybeChild_",
          "type": "address"
        }
      ],
      "name": "isChild",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x48e0a03aa2e0595450d2d2ed0cae7d445e844996cee3d8ae3268c152cea76546",
  "receipt": {
    "to": null,
    "from": "0xbF334f8BD1420a1CbFE15407f73919424934B1B3",
    "contractAddress": "0xE41eB8948993e749cF0a2f03D597C068785c0c55",
    "transactionIndex": 12,
    "gasUsed": "3967608",
    "logsBloom": "0x00080000000000020000000000000000000000000000002008000000800000000000000000000000000000000000000000008000000000008000000001000000000000000000000000000000000001800000000000000000000100000000000000000000000200000000000000000000000000000000000080000000010000000000080000000000000000000000000000000000000080000000000000000000200000000000000020000000000400000101000000000000000000000000004000000000000000000001000000040000000000000000000000100040000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x69acfdd331e2505da4eede6b985ec468c0336f6c860a4aca755676aa52059181",
    "transactionHash": "0x48e0a03aa2e0595450d2d2ed0cae7d445e844996cee3d8ae3268c152cea76546",
    "logs": [
      {
        "transactionIndex": 12,
        "blockNumber": 29770686,
        "transactionHash": "0x48e0a03aa2e0595450d2d2ed0cae7d445e844996cee3d8ae3268c152cea76546",
        "address": "0xE41eB8948993e749cF0a2f03D597C068785c0c55",
        "topics": [
          "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000000000000000ff",
        "logIndex": 36,
        "blockHash": "0x69acfdd331e2505da4eede6b985ec468c0336f6c860a4aca755676aa52059181"
      },
      {
        "transactionIndex": 12,
        "blockNumber": 29770686,
        "transactionHash": "0x48e0a03aa2e0595450d2d2ed0cae7d445e844996cee3d8ae3268c152cea76546",
        "address": "0x767EA2CF7e8c3269A1231966dCCF36d7B54987F6",
        "topics": [
          "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000000000000000ff",
        "logIndex": 37,
        "blockHash": "0x69acfdd331e2505da4eede6b985ec468c0336f6c860a4aca755676aa52059181"
      },
      {
        "transactionIndex": 12,
        "blockNumber": 29770686,
        "transactionHash": "0x48e0a03aa2e0595450d2d2ed0cae7d445e844996cee3d8ae3268c152cea76546",
        "address": "0xE41eB8948993e749cF0a2f03D597C068785c0c55",
        "topics": [
          "0x7fac34ecf0b1b374cd9659e3d17db602659d53f1162b1f20142e6c02694aed70"
        ],
        "data": "0x000000000000000000000000bf334f8bd1420a1cbfe15407f73919424934b1b3000000000000000000000000767ea2cf7e8c3269a1231966dccf36d7b54987f6",
        "logIndex": 38,
        "blockHash": "0x69acfdd331e2505da4eede6b985ec468c0336f6c860a4aca755676aa52059181"
      },
      {
        "transactionIndex": 12,
        "blockNumber": 29770686,
        "transactionHash": "0x48e0a03aa2e0595450d2d2ed0cae7d445e844996cee3d8ae3268c152cea76546",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000bf334f8bd1420a1cbfe15407f73919424934b1b3",
          "0x000000000000000000000000c26880a0af2ea0c7e8130e6ec47af756465452e8"
        ],
        "data": "0x000000000000000000000000000000000000000000000000005236fd1eaa90e0000000000000000000000000000000000000000000000000b38ac3855675fd51000000000000000000000000000000000000000000001879fff189e324a12f13000000000000000000000000000000000000000000000000b3388c8837cb6c7100000000000000000000000000000000000000000000187a0043c0e0434bbff3",
        "logIndex": 39,
        "blockHash": "0x69acfdd331e2505da4eede6b985ec468c0336f6c860a4aca755676aa52059181"
      }
    ],
    "blockNumber": 29770686,
    "cumulativeGasUsed": "9067277",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "b7470563c64757443ad855b79d2f29e1",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Implementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"child\",\"type\":\"address\"}],\"name\":\"NewChild\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"createChild\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"bytes[]\",\"name\":\"sources\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"internalType\":\"struct StateConfig\",\"name\":\"stateConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"expressionDeployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes[]\",\"name\":\"sources\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"internalType\":\"struct StateConfig[]\",\"name\":\"flows\",\"type\":\"tuple[]\"}],\"internalType\":\"struct FlowCommonConfig\",\"name\":\"flowConfig\",\"type\":\"tuple\"}],\"internalType\":\"struct FlowConfig\",\"name\":\"config_\",\"type\":\"tuple\"}],\"name\":\"createChildTyped\",\"outputs\":[{\"internalType\":\"contract Flow\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"maybeChild_\",\"type\":\"address\"}],\"name\":\"isChild\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"createChild(bytes)\":{\"params\":{\"data_\":\"Encoded data to pass down to child contract constructor.\"},\"returns\":{\"_0\":\"New child contract address.\"}},\"createChildTyped(((bytes[],uint256[]),(address,address,(bytes[],uint256[])[])))\":{\"params\":{\"config_\":\"`Flow` constructor configuration.\"},\"returns\":{\"_0\":\"New `Flow` child contract address.\"}},\"isChild(address)\":{\"params\":{\"maybeChild_\":\"Address of child contract to look up.\"},\"returns\":{\"_0\":\"Returns `true` if address is a contract created by this contract factory, otherwise `false`.\"}}},\"title\":\"FlowFactory\",\"version\":1},\"userdoc\":{\"events\":{\"Implementation(address,address)\":{\"notice\":\"Factories that clone a template contract MUST emit an event any time they set the implementation being cloned. Factories that deploy new contracts without cloning do NOT need to emit this.\"},\"NewChild(address,address)\":{\"notice\":\"Whenever a new child contract is deployed, a `NewChild` event containing the new child contract address MUST be emitted.\"}},\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"Build the reference implementation to clone for each child.\"},\"createChild(bytes)\":{\"notice\":\"Implements `IFactory`. Calls the `_createChild` hook that inheriting contracts must override. Registers child contract address such that `isChild` is `true`. Emits `NewChild` event.\"},\"createChildTyped(((bytes[],uint256[]),(address,address,(bytes[],uint256[])[])))\":{\"notice\":\"Allows calling `createChild` with `StateConfig` struct. Use original `Factory` `createChild` function signature if function parameters are already encoded.\"},\"implementation()\":{\"notice\":\"Template contract to clone. Deployed by the constructor.\"},\"isChild(address)\":{\"notice\":\"Implements `IFactory`. Checks if address is registered as a child contract of this factory.\"}},\"notice\":\"Factory for deploying and registering `Flow` contracts.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/flow/basic/FlowFactory.sol\":\"FlowFactory\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/interfaces/IERC1271Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271Upgradeable {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0x4473c09c087ee1a48c5547b23799c0474b2e08cde6fec5921c628171c4ebcdc0\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary ClonesUpgradeable {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x3734e36dc4de32780bfd344a94b85b6aab985fd6e42672983ed251ba7754a2e0\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0203dcadc5737d9ef2c211d6fa15d18ebc3b30dfa51903b64870b01a062b0b4e\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x8cc03c5ac17e8a7396e487cda41fc1f1dfdb91db7d528e6da84bee3b6dd7e167\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xffcb29612efb57efc8f0d4897deb5abaeac830022c59a3aa17446d698dbc856b\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x091a49ef99a2be002680781a10cc9dd74c0f348301ede5482c4ea625f79a8ffe\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {\\n    function __ERC1155Holder_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1155Holder_init_unchained() internal onlyInitializing {\\n    }\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xa8a1f16aa62b4d8c9e380057d9c3ee5c992e4a10dccc5650b26e38d4c61287d4\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\\n    function __ERC1155Receiver_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1155Receiver_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xa1b77d6d0f4591359c42b747a31375f20b0571b5e1fb62652d8184fb10f1d63a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4e733d3164f73f461eaf9d8087a7ad1ea180bdc8ba0d3d61b0e1ae16d8e63dff\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xcc70d8e2281fb3ff69e8ab242500f10142cd0a7fa8dd9e45882be270d4d09024\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/draft-IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf42efac0d704b136c4d85e970562d4dbc1160d726ee93b5133122eb14fe368df\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xbb2ed8106d94aeae6858e2551a1e7174df73994b77b13ebd120ccaaef80155f5\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x016298e66a5810253c6c905e61966bb31c8775c3f3517bf946ff56ee31d6c005\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\\n    function __ERC721Holder_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC721Holder_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xb7f90ab8af7dae0bd4acfa088f9e606ea039110face097ca7c8beef563f71e90\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x611aa3f23e59cfdd1863c536776407b3e33d695152a266fa7cfb34440a29a8a3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AddressUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract MulticallUpgradeable is Initializable {\\n    function __Multicall_init() internal onlyInitializing {\\n    }\\n\\n    function __Multicall_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract.\\n     */\\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = _functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return AddressUpgradeable.verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xb8709268fac307114f6cbb5e3cee798d91cd0adfea4d337c4920f8f0b2414f15\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0xea5339a7fff0ed42b45be56a88efdd0b2ddde9fa480dc99fef9a6a4c5b776863\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../StringsUpgradeable.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSAUpgradeable {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", StringsUpgradeable.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0xbf5daf926894541a40a64b43c3746aa1940c5a1b3b8d14a06465eea72a9b90cc\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/cryptography/SignatureCheckerUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.1) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSAUpgradeable.sol\\\";\\nimport \\\"../AddressUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IERC1271Upgradeable.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureCheckerUpgradeable {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (address recovered, ECDSAUpgradeable.RecoverError error) = ECDSAUpgradeable.tryRecover(hash, signature);\\n        if (error == ECDSAUpgradeable.RecoverError.NoError && recovered == signer) {\\n            return true;\\n        }\\n\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271Upgradeable.isValidSignature.selector, hash, signature)\\n        );\\n        return (success &&\\n            result.length == 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271Upgradeable.isValidSignature.selector));\\n    }\\n}\\n\",\"keccak256\":\"0xb6399c276ff8a17a82ec6ce5a225ccc698a34b893b4227d972819896776e3d27\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x9a3b990bd56d139df3e454a9edf1c64668530b5a77fc32eb063bc206f958274a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc6cef87559d0aeffdf0a99803de655938a7779ec0a3cd5d4383483ad85565a09\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` \\u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x3b39e1a87bb94b9145d91007bbd2c964438e99a659b4accc6ec6df6a1c62589a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCastUpgradeable {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248) {\\n        require(value >= type(int248).min && value <= type(int248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return int248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240) {\\n        require(value >= type(int240).min && value <= type(int240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return int240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232) {\\n        require(value >= type(int232).min && value <= type(int232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return int232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224) {\\n        require(value >= type(int224).min && value <= type(int224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return int224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216) {\\n        require(value >= type(int216).min && value <= type(int216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return int216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208) {\\n        require(value >= type(int208).min && value <= type(int208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return int208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200) {\\n        require(value >= type(int200).min && value <= type(int200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return int200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192) {\\n        require(value >= type(int192).min && value <= type(int192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return int192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184) {\\n        require(value >= type(int184).min && value <= type(int184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return int184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176) {\\n        require(value >= type(int176).min && value <= type(int176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return int176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168) {\\n        require(value >= type(int168).min && value <= type(int168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return int168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160) {\\n        require(value >= type(int160).min && value <= type(int160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return int160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152) {\\n        require(value >= type(int152).min && value <= type(int152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return int152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144) {\\n        require(value >= type(int144).min && value <= type(int144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return int144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136) {\\n        require(value >= type(int136).min && value <= type(int136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return int136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120) {\\n        require(value >= type(int120).min && value <= type(int120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return int120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112) {\\n        require(value >= type(int112).min && value <= type(int112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return int112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104) {\\n        require(value >= type(int104).min && value <= type(int104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return int104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96) {\\n        require(value >= type(int96).min && value <= type(int96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return int96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88) {\\n        require(value >= type(int88).min && value <= type(int88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return int88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80) {\\n        require(value >= type(int80).min && value <= type(int80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return int80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72) {\\n        require(value >= type(int72).min && value <= type(int72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return int72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56) {\\n        require(value >= type(int56).min && value <= type(int56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return int56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48) {\\n        require(value >= type(int48).min && value <= type(int48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return int48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40) {\\n        require(value >= type(int40).min && value <= type(int40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return int40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24) {\\n        require(value >= type(int24).min && value <= type(int24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return int24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0xd7ebe0f80affaa622b9efd95cc8db3e03e70d699176f7457b4a95e34a11f9834\",\"license\":\"MIT\"},\"contracts/array/LibUint256Array.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// @title Uint256Array\\n/// @notice Things we want to do carefully and efficiently with uint256 arrays\\n/// that Solidity doesn't give us native tools for.\\nlibrary LibUint256Array {\\n    using LibUint256Array for uint256[];\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ a single integer to build an array around.\\n    /// @return the newly allocated array including a_ as a single item.\\n    function arrayFrom(uint256 a_) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](1);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ the first integer to build an array around.\\n    /// @param b_ the second integer to build an array around.\\n    /// @return the newly allocated array including a_ and b_ as the only items.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](2);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n        }\\n        return array_;\\n    }\\n\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](3);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n        }\\n        return array_;\\n    }\\n\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](4);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n            mstore(add(array_, 0x80), d_)\\n        }\\n        return array_;\\n    }\\n\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_,\\n        uint256 e_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](5);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n            mstore(add(array_, 0x80), d_)\\n            mstore(add(array_, 0xA0), e_)\\n        }\\n        return array_;\\n    }\\n\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_,\\n        uint256 e_,\\n        uint f_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](6);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n            mstore(add(array_, 0x80), d_)\\n            mstore(add(array_, 0xA0), e_)\\n            mstore(add(array_, 0xC0), f_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ The head of the new array.\\n    /// @param tail_ The tail of the new array.\\n    /// @return The new array.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256[] memory tail_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](1);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n        }\\n        array_.extend(tail_);\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ The first item of the new array.\\n    /// @param b_ The second item of the new array.\\n    /// @param tail_ The tail of the new array.\\n    /// @return The new array.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256[] memory tail_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](2);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n        }\\n        array_.extend(tail_);\\n        return array_;\\n    }\\n\\n    function matrixFrom(\\n        uint256[] memory a_\\n    ) internal pure returns (uint256[][] memory) {\\n        uint256[][] memory matrix_ = new uint256[][](1);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(matrix_, 0x20), a_)\\n        }\\n        return matrix_;\\n    }\\n\\n    /// Solidity provides no way to change the length of in-memory arrays but\\n    /// it also does not deallocate memory ever. It is always safe to shrink an\\n    /// array that has already been allocated, with the caveat that the\\n    /// truncated items will effectively become inaccessible regions of memory.\\n    /// That is to say, we deliberately \\\"leak\\\" the truncated items, but that is\\n    /// no worse than Solidity's native behaviour of leaking everything always.\\n    /// The array is MUTATED in place so there is no return value and there is\\n    /// no new allocation or copying of data either.\\n    /// @param array_ The array to truncate.\\n    /// @param newLength_ The new length of the array after truncation.\\n    function truncate(\\n        uint256[] memory array_,\\n        uint256 newLength_\\n    ) internal pure {\\n        require(newLength_ <= array_.length, \\\"OOB_TRUNCATE\\\");\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(array_, newLength_)\\n        }\\n    }\\n\\n    /// Extends `base_` with `extend_` by allocating additional `extend_.length`\\n    /// uints onto `base_`. Reverts if some other memory has been allocated\\n    /// after `base_` already, in which case it is NOT safe to copy inline.\\n    /// If `base_` is large this MAY be significantly more efficient than\\n    /// allocating `base_.length + extend_.length` for an entirely new array and\\n    /// copying both `base_` and `extend_` into the new array one item at a\\n    /// time in Solidity.\\n    /// The Solidity compiler MAY rearrange sibling statements in a code block\\n    /// EVEN IF THE OPTIMIZER IS DISABLED such that it becomes unsafe to use\\n    /// `extend` for memory allocated in different code blocks. It is ONLY safe\\n    /// to `extend` arrays that were allocated in the same lexical scope and you\\n    /// WILL see subtle errors that revert transactions otherwise.\\n    /// i.e. the `new` keyword MUST appear in the same code block as `extend`.\\n    /// @param base_ The base integer array that will be extended by `extend_`.\\n    /// @param extend_ The integer array that extends `base_`.\\n    function extend(\\n        uint256[] memory base_,\\n        uint256[] memory extend_\\n    ) internal pure {\\n        uint256 freeMemoryPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            // Solidity stores free memory pointer at 0x40\\n            freeMemoryPointer_ := mload(0x40)\\n            let baseLength_ := mload(base_)\\n            let extendLength_ := mload(extend_)\\n\\n            // The freeMemoryPointer_ does NOT point to the end of `base_` so\\n            // it is NOT safe to copy `extend_` over the top of already\\n            // allocated memory. This happens whenever some memory is allocated\\n            // after `base_` is allocated but before `extend` is called.\\n            if gt(\\n                freeMemoryPointer_,\\n                add(base_, add(0x20, mul(0x20, baseLength_)))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            // Move the free memory pointer by the length of extend_, excluding\\n            // the length slot of extend as that will NOT be copied to `base_`.\\n            mstore(0x40, add(freeMemoryPointer_, mul(0x20, extendLength_)))\\n\\n            // Update the length of base to be the length of base+extend.\\n            mstore(base_, add(baseLength_, extendLength_))\\n        }\\n\\n        unsafeCopyValuesTo(extend_, freeMemoryPointer_);\\n    }\\n\\n    /// Copies `inputs_` to `outputCursor_` with NO attempt to check that this\\n    /// is safe to do so. The caller MUST ensure that there exists allocated\\n    /// memory at `outputCursor_` in which it is safe and appropriate to copy\\n    /// ALL `inputs_` to. Anything that was already written to memory at\\n    /// `[outputCursor_:outputCursor_+(inputs_.length * 32 bytes)]` will be\\n    /// overwritten. The length of `inputs_` is NOT copied to the output\\n    /// location, ONLY the `uint256` values of the `inputs_` array are copied.\\n    /// There is no return value as memory is modified directly.\\n    /// @param inputs_ The input array that will be copied from EXCLUDING the\\n    /// length at the start of the array in memory.\\n    /// @param outputCursor_ Location in memory that the values will be copied\\n    /// to linearly.\\n    function unsafeCopyValuesTo(\\n        uint256[] memory inputs_,\\n        uint256 outputCursor_\\n    ) internal pure {\\n        uint256 inputCursor_;\\n        assembly (\\\"memory-safe\\\") {\\n            inputCursor_ := add(inputs_, 0x20)\\n        }\\n        unsafeCopyValuesTo(inputCursor_, outputCursor_, inputs_.length);\\n    }\\n\\n    /// Copies `length_` 32 byte words from `inputCursor_` to a newly allocated\\n    /// uint256[] array with NO attempt to check that the inputs are sane.\\n    /// This function is safe in that the outputs are guaranteed to be copied\\n    /// to newly allocated memory so no existing data will be overwritten.\\n    /// This function is subtle in that the `inputCursor_` is NOT validated in\\n    /// any way so the caller MUST ensure it points to a sensible memory\\n    /// location to read (e.g. to exclude the length from input arrays etc.).\\n    /// @param inputCursor_ The start of the memory that will be copied to the\\n    /// newly allocated array.\\n    /// @param length_ Number of 32 byte words to copy starting at\\n    /// `inputCursor_` to the items of the newly allocated array.\\n    /// @return The newly allocated `uint256[]` array.\\n    function copyToNewUint256Array(\\n        uint256 inputCursor_,\\n        uint256 length_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory outputs_ = new uint256[](length_);\\n        uint256 outputCursor_;\\n        assembly (\\\"memory-safe\\\") {\\n            outputCursor_ := add(outputs_, 0x20)\\n        }\\n        unsafeCopyValuesTo(inputCursor_, outputCursor_, length_);\\n        return outputs_;\\n    }\\n\\n    /// Copies `length_` uint256 values starting from `inputsCursor_` to\\n    /// `outputCursor_` with NO attempt to check that this is safe to do so.\\n    /// The caller MUST ensure that there exists allocated memory at\\n    /// `outputCursor_` in which it is safe and appropriate to copy\\n    /// `length_ * 32` bytes to. Anything that was already written to memory at\\n    /// `[outputCursor_:outputCursor_+(length_ * 32 bytes)]` will be\\n    /// overwritten.\\n    /// There is no return value as memory is modified directly.\\n    /// @param inputCursor_ The starting position in memory that data will be\\n    /// copied from.\\n    /// @param outputCursor_ The starting position in memory that data will be\\n    /// copied to.\\n    /// @param length_ The number of 32 byte (i.e. `uint256`) values that will\\n    /// be copied.\\n    function unsafeCopyValuesTo(\\n        uint256 inputCursor_,\\n        uint256 outputCursor_,\\n        uint256 length_\\n    ) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n                let end_ := add(inputCursor_, mul(0x20, length_))\\n            } lt(inputCursor_, end_) {\\n                inputCursor_ := add(inputCursor_, 0x20)\\n                outputCursor_ := add(outputCursor_, 0x20)\\n            } {\\n                mstore(outputCursor_, mload(inputCursor_))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaa5c120cff396b2e133ec54e935d7b3ff3451528830118d2fc9afa11322a8997\",\"license\":\"CAL\"},\"contracts/bytes/LibBytes.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// @title LibBytes\\n/// @notice Things we want to do carefully and efficiently with `bytes` in memory\\n/// that Solidity doesn't give us native tools for.\\nlibrary LibBytes {\\n    /// Copy an arbitrary number of bytes from one location in memory to another.\\n    /// As we can only read/write bytes in 32 byte chunks we first have to loop\\n    /// over 32 byte values to copy then handle any unaligned remaining data. The\\n    /// remaining data will be appropriately masked with the existing data in the\\n    /// final chunk so as to not write past the desired length. Note that the\\n    /// final unaligned write will be more gas intensive than the prior aligned\\n    /// writes. The writes are completely unsafe, the caller MUST ensure that\\n    /// sufficient memory is allocated and reading/writing the requested number\\n    /// of bytes from/to the requested locations WILL NOT corrupt memory in the\\n    /// opinion of solidity or other subsequent read/write operations.\\n    /// @param inputCursor_ The starting location in memory to read from.\\n    /// @param outputCursor_ The starting location in memory to write to.\\n    /// @param remaining_ The number of bytes to read/write.\\n    function unsafeCopyBytesTo(\\n        uint256 inputCursor_,\\n        uint256 outputCursor_,\\n        uint256 remaining_\\n    ) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n\\n            } iszero(lt(remaining_, 0x20)) {\\n                remaining_ := sub(remaining_, 0x20)\\n                inputCursor_ := add(inputCursor_, 0x20)\\n                outputCursor_ := add(outputCursor_, 0x20)\\n            } {\\n                mstore(outputCursor_, mload(inputCursor_))\\n            }\\n\\n            if gt(remaining_, 0) {\\n                let mask_ := shr(\\n                    mul(remaining_, 8),\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n                // preserve existing bytes\\n                mstore(\\n                    outputCursor_,\\n                    or(\\n                        // input\\n                        and(mload(inputCursor_), not(mask_)),\\n                        and(mload(outputCursor_), mask_)\\n                    )\\n                )\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x613125e88688bca7d52cc48447a70fd2a17b3a120ef41c7c61092b3b523aa121\",\"license\":\"CAL\"},\"contracts/factory/Factory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport {IFactory} from \\\"./IFactory.sol\\\";\\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\n/// @title Factory\\n/// @notice Base contract for deploying and registering child contracts.\\nabstract contract Factory is IFactory, ReentrancyGuard {\\n    /// @dev state to track each deployed contract address. A `Factory` will\\n    /// never lie about deploying a child, unless `isChild` is overridden to do\\n    /// so.\\n    mapping(address => bool) private contracts;\\n\\n    constructor() {\\n        // Technically `ReentrancyGuard` is initializable but allowing it to be\\n        // initialized is a foot-gun as the status will be set to _NOT_ENTERED.\\n        // This would allow re-entrant behaviour upon initialization of the\\n        // `Factory` and is unnecessary as the reentrancy guard always restores\\n        // _NOT_ENTERED after every call anyway.\\n        _disableInitializers();\\n    }\\n\\n    /// Implements `IFactory`.\\n    ///\\n    /// `_createChild` hook must be overridden to actually create child\\n    /// contract.\\n    ///\\n    /// Implementers may want to overload this function with a typed equivalent\\n    /// to expose domain specific structs etc. to the compiled ABI consumed by\\n    /// tooling and other scripts. To minimise gas costs for deployment it is\\n    /// expected that the tooling will consume the typed ABI, then encode the\\n    /// arguments and pass them to this function directly.\\n    ///\\n    /// @param data_ ABI encoded data to pass to child contract constructor.\\n    function _createChild(\\n        bytes memory data_\\n    ) internal virtual returns (address);\\n\\n    /// Implements `IFactory`.\\n    ///\\n    /// Calls the `_createChild` hook that inheriting contracts must override.\\n    /// Registers child contract address such that `isChild` is `true`.\\n    /// Emits `NewChild` event.\\n    ///\\n    /// @param data_ Encoded data to pass down to child contract constructor.\\n    /// @return New child contract address.\\n    function createChild(\\n        bytes memory data_\\n    ) public virtual override nonReentrant returns (address) {\\n        // Create child contract using hook.\\n        address child_ = _createChild(data_);\\n        // Ensure the child at this address has not previously been deployed.\\n        require(!contracts[child_], \\\"DUPLICATE_CHILD\\\");\\n        // Register child contract address to `contracts` mapping.\\n        contracts[child_] = true;\\n        // Emit `NewChild` event with child contract address.\\n        emit IFactory.NewChild(msg.sender, child_);\\n        return child_;\\n    }\\n\\n    /// Implements `IFactory`.\\n    ///\\n    /// Checks if address is registered as a child contract of this factory.\\n    ///\\n    /// @param maybeChild_ Address of child contract to look up.\\n    /// @return Returns `true` if address is a contract created by this\\n    /// contract factory, otherwise `false`.\\n    function isChild(\\n        address maybeChild_\\n    ) external view virtual override returns (bool) {\\n        return contracts[maybeChild_];\\n    }\\n}\\n\",\"keccak256\":\"0x7dd0701cc5788bc3efb0d97088364e3e9bda8848f3316d09bf889fad40b53cc4\",\"license\":\"CAL\"},\"contracts/factory/IFactory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\ninterface IFactory {\\n    /// Whenever a new child contract is deployed, a `NewChild` event\\n    /// containing the new child contract address MUST be emitted.\\n    /// @param sender `msg.sender` that deployed the contract (factory).\\n    /// @param child address of the newly deployed child.\\n    event NewChild(address sender, address child);\\n\\n    /// Factories that clone a template contract MUST emit an event any time\\n    /// they set the implementation being cloned. Factories that deploy new\\n    /// contracts without cloning do NOT need to emit this.\\n    /// @param sender `msg.sender` that deployed the implementation (factory).\\n    /// @param implementation address of the implementation contract that will\\n    /// be used for future clones if relevant.\\n    event Implementation(address sender, address implementation);\\n\\n    /// Creates a new child contract.\\n    ///\\n    /// @param data_ Domain specific data for the child contract constructor.\\n    /// @return New child contract address.\\n    function createChild(bytes calldata data_) external returns (address);\\n\\n    /// Checks if address is registered as a child contract of this factory.\\n    ///\\n    /// Addresses that were not deployed by `createChild` MUST NOT return\\n    /// `true` from `isChild`. This is CRITICAL to the security guarantees for\\n    /// any contract implementing `IFactory`.\\n    ///\\n    /// @param maybeChild_ Address to check registration for.\\n    /// @return `true` if address was deployed by this contract factory,\\n    /// otherwise `false`.\\n    function isChild(address maybeChild_) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x3e9ca6613b0c19d98c4e19a7586d4109e498db2cf7d6e38e34fc2d2c0dbc32e2\",\"license\":\"CAL\"},\"contracts/flow/FlowCommon.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"./libraries/LibFlow.sol\\\";\\nimport \\\"../idempotent/LibIdempotentFlag.sol\\\";\\nimport \\\"../interpreter/deploy/IExpressionDeployerV1.sol\\\";\\nimport \\\"../interpreter/run/IInterpreterV1.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {MulticallUpgradeable as Multicall} from \\\"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\\\";\\nimport {ERC721HolderUpgradeable as ERC721Holder} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\\\";\\nimport {ERC1155HolderUpgradeable as ERC1155Holder} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\\\";\\nimport {SignatureCheckerUpgradeable as SignatureChecker} from \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/SignatureCheckerUpgradeable.sol\\\";\\nimport {ECDSAUpgradeable as ECDSA} from \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\\\";\\nimport \\\"../interpreter/run/LibEncodedDispatch.sol\\\";\\n\\nuint256 constant FLAG_COLUMN_FLOW_ID = 0;\\nuint256 constant FLAG_ROW_FLOW_ID = 0;\\nuint256 constant FLAG_COLUMN_FLOW_TIME = 0;\\nuint256 constant FLAG_ROW_FLOW_TIME = 2;\\n\\nuint256 constant MIN_FLOW_SENTINELS = 4;\\n\\nSourceIndex constant FLOW_ENTRYPOINT = SourceIndex.wrap(0);\\nuint constant FLOW_MAX_OUTPUTS = type(uint16).max;\\n\\nstruct SignedContext {\\n    address signer;\\n    bytes signature;\\n    uint256[] context;\\n}\\n\\nstruct FlowCommonConfig {\\n    address expressionDeployer;\\n    address interpreter;\\n    StateConfig[] flows;\\n}\\n\\ncontract FlowCommon is ERC721Holder, ERC1155Holder, Multicall {\\n    using LibIdempotentFlag for IdempotentFlag;\\n    using LibInterpreterState for InterpreterState;\\n    using LibStackTop for StackTop;\\n    using LibStackTop for uint256[];\\n    using LibUint256Array for uint256;\\n    using LibUint256Array for uint256[];\\n\\n    IInterpreterV1 internal _interpreter;\\n\\n    /// flow expression pointer => is registered\\n    mapping(EncodedDispatch => uint) internal _flows;\\n\\n    event FlowInitialized(\\n        address sender,\\n        address interpreter,\\n        EncodedDispatch dispatch\\n    );\\n\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __FlowCommon_init(\\n        FlowCommonConfig memory config_,\\n        uint flowMinOutputs_\\n    ) internal onlyInitializing {\\n        __ERC721Holder_init();\\n        __ERC1155Holder_init();\\n        __Multicall_init();\\n        require(flowMinOutputs_ >= MIN_FLOW_SENTINELS, \\\"BAD MIN STACKS LENGTH\\\");\\n        _interpreter = IInterpreterV1(config_.interpreter);\\n        for (uint256 i_ = 0; i_ < config_.flows.length; i_++) {\\n            (address expression_, ) = IExpressionDeployerV1(\\n                config_.expressionDeployer\\n            ).deployExpression(\\n                    config_.flows[i_],\\n                    LibUint256Array.arrayFrom(flowMinOutputs_)\\n                );\\n            EncodedDispatch dispatch_ = LibEncodedDispatch.encode(\\n                expression_,\\n                FLOW_ENTRYPOINT,\\n                FLOW_MAX_OUTPUTS\\n            );\\n            _flows[dispatch_] = 1;\\n            emit FlowInitialized(msg.sender, config_.interpreter, dispatch_);\\n        }\\n    }\\n\\n    function _buildFlowBaseContext(\\n        EncodedDispatch dispatch_,\\n        uint256 id_\\n    ) internal view returns (uint256[] memory) {\\n        // THIS IS A CRITICAL SECURITY CHECK. REMOVING THIS ALLOWS ARBITRARY\\n        // EXPRESSIONS TO BE BUILT AND RUN AS FLOWS.\\n        require(_flows[dispatch_] > 0, \\\"UNREGISTERED_FLOW\\\");\\n\\n        return LibUint256Array.arrayFrom(uint256(uint160(msg.sender)), id_);\\n    }\\n\\n    function flowStack(\\n        EncodedDispatch dispatch_,\\n        uint256 id_,\\n        SignedContext[] memory signedContexts_\\n    ) internal view returns (StackTop, StackTop, uint[] memory) {\\n        unchecked {\\n            uint256[] memory flowBaseContext_ = _buildFlowBaseContext(\\n                dispatch_,\\n                id_\\n            );\\n\\n            uint256[] memory signers_ = new uint256[](signedContexts_.length);\\n            uint256[][] memory flowContext_ = new uint256[][](\\n                signedContexts_.length + 2\\n            );\\n            for (uint256 i_ = 0; i_ < signedContexts_.length; i_++) {\\n                signers_[i_] = uint256(uint160(signedContexts_[i_].signer));\\n\\n                require(\\n                    SignatureChecker.isValidSignatureNow(\\n                        signedContexts_[i_].signer,\\n                        ECDSA.toEthSignedMessageHash(\\n                            keccak256(\\n                                abi.encodePacked(signedContexts_[i_].context)\\n                            )\\n                        ),\\n                        signedContexts_[i_].signature\\n                    ),\\n                    \\\"INVALID_SIGNATURE\\\"\\n                );\\n                flowContext_[i_ + 2] = signedContexts_[i_].context;\\n            }\\n\\n            flowContext_[0] = flowBaseContext_;\\n            flowContext_[1] = signers_;\\n\\n            IInterpreterV1 interpreter_ = _interpreter;\\n\\n            (\\n                uint256[] memory stack_,\\n                uint[] memory stateChanges_\\n            ) = interpreter_.eval(dispatch_, flowContext_);\\n            return (\\n                stack_.asStackTopUp(),\\n                stack_.asStackTopAfter(),\\n                stateChanges_\\n            );\\n        }\\n    }\\n\\n    receive() external payable virtual {}\\n}\\n\",\"keccak256\":\"0x3a7ce07f961d0597946f63316184d855479e7a4b3e1196c77d51489b9870b855\",\"license\":\"CAL\"},\"contracts/flow/basic/Flow.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"../FlowCommon.sol\\\";\\nimport \\\"../libraries/LibFlow.sol\\\";\\nimport \\\"../../array/LibUint256Array.sol\\\";\\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\nstruct FlowConfig {\\n    StateConfig stateConfig;\\n    FlowCommonConfig flowConfig;\\n}\\n\\ncontract Flow is ReentrancyGuard, FlowCommon {\\n    using LibInterpreterState for InterpreterState;\\n    using LibUint256Array for uint[];\\n\\n    event Initialize(address sender, FlowConfig config);\\n\\n    /// @param config_ allowed flows set at initialization.\\n    function initialize(FlowConfig calldata config_) external initializer {\\n        __FlowCommon_init(config_.flowConfig, MIN_FLOW_SENTINELS);\\n        emit Initialize(msg.sender, config_);\\n    }\\n\\n    function _previewFlow(\\n        EncodedDispatch dispatch_,\\n        uint256 id_,\\n        SignedContext[] memory signedContexts_\\n    ) internal view returns (FlowTransfer memory, uint[] memory) {\\n        (\\n            StackTop stackBottom_,\\n            StackTop stackTop_,\\n            uint[] memory stateChanges_\\n        ) = flowStack(dispatch_, id_, signedContexts_);\\n        return (LibFlow.stackToFlow(stackBottom_, stackTop_), stateChanges_);\\n    }\\n\\n    function previewFlow(\\n        EncodedDispatch dispatch_,\\n        uint256 id_,\\n        SignedContext[] memory signedContexts_\\n    ) external view virtual returns (FlowTransfer memory) {\\n        (FlowTransfer memory flowTransfer_, ) = _previewFlow(\\n            dispatch_,\\n            id_,\\n            signedContexts_\\n        );\\n        return flowTransfer_;\\n    }\\n\\n    function flow(\\n        EncodedDispatch dispatch_,\\n        uint256 id_,\\n        SignedContext[] memory signedContexts_\\n    ) external payable virtual nonReentrant {\\n        (\\n            FlowTransfer memory flowTransfer_,\\n            uint[] memory stateChanges_\\n        ) = _previewFlow(dispatch_, id_, signedContexts_);\\n        LibFlow.flow(flowTransfer_, _interpreter, stateChanges_);\\n    }\\n}\\n\",\"keccak256\":\"0xe503798e99425f236f7f01ffaab99e1092be0d803d3e00d27adf15c38285edb5\",\"license\":\"CAL\"},\"contracts/flow/basic/FlowFactory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport {Factory} from \\\"../../factory/Factory.sol\\\";\\nimport {Flow, FlowConfig} from \\\"./Flow.sol\\\";\\nimport {ClonesUpgradeable as Clones} from \\\"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\\\";\\nimport {LibInterpreterState} from \\\"../../interpreter/run/LibInterpreterState.sol\\\";\\n\\n/// @title FlowFactory\\n/// @notice Factory for deploying and registering `Flow` contracts.\\ncontract FlowFactory is Factory {\\n    /// Template contract to clone.\\n    /// Deployed by the constructor.\\n    address public immutable implementation;\\n\\n    /// Build the reference implementation to clone for each child.\\n    constructor() {\\n        address implementation_ = address(new Flow());\\n        emit Implementation(msg.sender, implementation_);\\n        implementation = implementation_;\\n    }\\n\\n    /// @inheritdoc Factory\\n    function _createChild(\\n        bytes memory data_\\n    ) internal virtual override returns (address) {\\n        FlowConfig memory config_ = abi.decode(data_, (FlowConfig));\\n        address clone_ = Clones.clone(implementation);\\n        Flow(payable(clone_)).initialize(config_);\\n        return clone_;\\n    }\\n\\n    /// Allows calling `createChild` with `StateConfig` struct.\\n    /// Use original `Factory` `createChild` function signature if function\\n    /// parameters are already encoded.\\n    ///\\n    /// @param config_ `Flow` constructor configuration.\\n    /// @return New `Flow` child contract address.\\n    function createChildTyped(\\n        FlowConfig memory config_\\n    ) external returns (Flow) {\\n        return Flow(payable(createChild(abi.encode(config_))));\\n    }\\n}\\n\",\"keccak256\":\"0xcbe453e4b0d7c2372006692710f7868563b86e03fc509993bef6423422e1f20a\",\"license\":\"CAL\"},\"contracts/flow/libraries/LibFlow.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../interpreter/run/LibStackTop.sol\\\";\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {SafeERC20Upgradeable as SafeERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport {IERC721Upgradeable as IERC721} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport {IERC1155Upgradeable as IERC1155} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\";\\nimport {AddressUpgradeable as Address} from \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../sentinel/LibSentinel.sol\\\";\\nimport {SafeCastUpgradeable as SafeCast} from \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n// We want a sentinel with the following properties:\\n// - Won't collide with token amounts (| with very large number)\\n// - Won't collide with token addresses\\n// - Won't collide with common values like type(uint).max and type(uint).min\\n// - Won't collide with other sentinels from unrelated contexts\\nuint256 constant RAIN_FLOW_SENTINEL = uint256(\\n    keccak256(bytes(\\\"RAIN_FLOW_SENTINEL\\\")) | SENTINEL_HIGH_BITS\\n);\\n\\nstruct NativeTransfer {\\n    address from;\\n    address to;\\n    uint256 amount;\\n}\\n\\nstruct ERC20Transfer {\\n    address token;\\n    address from;\\n    address to;\\n    uint256 amount;\\n}\\n\\nstruct ERC721Transfer {\\n    address token;\\n    address from;\\n    address to;\\n    uint256 id;\\n}\\n\\nstruct ERC1155Transfer {\\n    address token;\\n    address from;\\n    address to;\\n    uint256 id;\\n    uint256 amount;\\n}\\n\\nstruct FlowTransfer {\\n    NativeTransfer[] native;\\n    ERC20Transfer[] erc20;\\n    ERC721Transfer[] erc721;\\n    ERC1155Transfer[] erc1155;\\n}\\n\\nlibrary LibFlow {\\n    using Address for address payable;\\n    using SafeERC20 for IERC20;\\n    using LibStackTop for StackTop;\\n    using SafeCast for uint256;\\n    using LibFlow for FlowTransfer;\\n    using LibUint256Array for uint[];\\n\\n    function stackToFlow(\\n        StackTop stackBottom_,\\n        StackTop stackTop_\\n    ) internal pure returns (FlowTransfer memory) {\\n        unchecked {\\n            FlowTransfer memory transfer_;\\n            uint256[] memory refs_;\\n            // native\\n            (stackTop_, refs_) = stackTop_.consumeStructs(\\n                stackBottom_,\\n                RAIN_FLOW_SENTINEL,\\n                3\\n            );\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(transfer_, refs_)\\n            }\\n            // erc20\\n            (stackTop_, refs_) = stackTop_.consumeStructs(\\n                stackBottom_,\\n                RAIN_FLOW_SENTINEL,\\n                4\\n            );\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(add(transfer_, 0x20), refs_)\\n            }\\n            // erc721\\n            (stackTop_, refs_) = stackTop_.consumeStructs(\\n                stackBottom_,\\n                RAIN_FLOW_SENTINEL,\\n                4\\n            );\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(add(transfer_, 0x40), refs_)\\n            }\\n            // erc1155\\n            (stackTop_, refs_) = stackTop_.consumeStructs(\\n                stackBottom_,\\n                RAIN_FLOW_SENTINEL,\\n                5\\n            );\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(add(transfer_, 0x60), refs_)\\n            }\\n            return transfer_;\\n        }\\n    }\\n\\n    function flowNative(FlowTransfer memory flowTransfer_) internal {\\n        unchecked {\\n            uint256 youToMe_ = 0;\\n            uint256 meToYou_ = 0;\\n            NativeTransfer memory transfer_;\\n            for (uint256 i_ = 0; i_ < flowTransfer_.native.length; i_++) {\\n                transfer_ = flowTransfer_.native[i_];\\n                if (transfer_.from == msg.sender) {\\n                    require(\\n                        transfer_.to == address(this),\\n                        \\\"UNSUPPORTED_NATIVE_FLOW\\\"\\n                    );\\n                    youToMe_ += transfer_.amount;\\n                } else {\\n                    require(\\n                        transfer_.from == address(this),\\n                        \\\"UNSUPPORTED_NATIVE_FLOW\\\"\\n                    );\\n                    if (transfer_.to == msg.sender) {\\n                        meToYou_ += transfer_.amount;\\n                    } else {\\n                        payable(transfer_.to).sendValue(transfer_.amount);\\n                    }\\n                }\\n            }\\n\\n            if (youToMe_ > 0) {\\n                // This will overflow if the msg.value is less than youToMe_.\\n                // Will refund any excess incoming value.\\n                meToYou_ += msg.value - youToMe_;\\n            }\\n            if (meToYou_ > 0) {\\n                payable(msg.sender).sendValue(meToYou_);\\n            }\\n        }\\n    }\\n\\n    function flowERC20(FlowTransfer memory flowTransfer_) internal {\\n        unchecked {\\n            ERC20Transfer memory transfer_;\\n            for (uint256 i_ = 0; i_ < flowTransfer_.erc20.length; i_++) {\\n                transfer_ = flowTransfer_.erc20[i_];\\n                if (transfer_.from == msg.sender) {\\n                    IERC20(transfer_.token).safeTransferFrom(\\n                        msg.sender,\\n                        transfer_.to,\\n                        transfer_.amount\\n                    );\\n                } else if (transfer_.from == address(this)) {\\n                    IERC20(transfer_.token).safeTransfer(\\n                        transfer_.to,\\n                        transfer_.amount\\n                    );\\n                } else {\\n                    // We don't support `from` as anyone other than `you` or `me`\\n                    // as this would allow for all kinds of issues re: approvals.\\n                    revert(\\\"UNSUPPORTED_ERC20_FLOW\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function flowERC721(FlowTransfer memory flowTransfer_) internal {\\n        unchecked {\\n            ERC721Transfer memory transfer_;\\n            for (uint256 i_ = 0; i_ < flowTransfer_.erc721.length; i_++) {\\n                transfer_ = flowTransfer_.erc721[i_];\\n                require(\\n                    transfer_.from == msg.sender ||\\n                        transfer_.from == address(this),\\n                    \\\"UNSUPPORTED_ERC721_FLOW\\\"\\n                );\\n                IERC721(transfer_.token).safeTransferFrom(\\n                    transfer_.from,\\n                    transfer_.to,\\n                    transfer_.id\\n                );\\n            }\\n        }\\n    }\\n\\n    function flowERC1155(FlowTransfer memory flowTransfer_) internal {\\n        unchecked {\\n            ERC1155Transfer memory transfer_;\\n            for (uint256 i_ = 0; i_ < flowTransfer_.erc1155.length; i_++) {\\n                transfer_ = flowTransfer_.erc1155[i_];\\n                require(\\n                    transfer_.from == msg.sender ||\\n                        transfer_.from == address(this),\\n                    \\\"UNSUPPORTED_ERC1155_FLOW\\\"\\n                );\\n                // @todo safeBatchTransferFrom support.\\n                // @todo data support.\\n                IERC1155(transfer_.token).safeTransferFrom(\\n                    transfer_.from,\\n                    transfer_.to,\\n                    transfer_.id,\\n                    transfer_.amount,\\n                    \\\"\\\"\\n                );\\n            }\\n        }\\n    }\\n\\n    function flow(\\n        FlowTransfer memory flowTransfer_,\\n        IInterpreterV1 interpreter_,\\n        uint[] memory stateChanges_\\n    ) internal {\\n        if (stateChanges_.length > 0) {\\n            interpreter_.stateChanges(stateChanges_);\\n        }\\n        flowTransfer_.flowNative();\\n        flowTransfer_.flowERC20();\\n        flowTransfer_.flowERC721();\\n        flowTransfer_.flowERC1155();\\n    }\\n}\\n\",\"keccak256\":\"0x9a37c25b3c31aadb6288075ea969f1279d232d2ab1a26c62e494463abd857966\",\"license\":\"CAL\"},\"contracts/idempotent/LibIdempotentFlag.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../math/Binary.sol\\\";\\n\\ntype IdempotentFlag is uint256;\\n\\nlibrary LibIdempotentFlag {\\n    using LibIdempotentFlag for IdempotentFlag;\\n\\n    function get(\\n        IdempotentFlag flag_,\\n        uint256 index_\\n    ) internal pure returns (bool) {\\n        return (IdempotentFlag.unwrap(flag_) >> index_) & 0x01 > 0;\\n    }\\n\\n    function set(\\n        IdempotentFlag flag_,\\n        uint256 index_\\n    ) internal pure returns (IdempotentFlag) {\\n        return\\n            IdempotentFlag.wrap(\\n                IdempotentFlag.unwrap(flag_) | (0x01 << index_)\\n            );\\n    }\\n\\n    modifier only16x16(uint256 column_, uint256 row_) {\\n        require(column_ < 16, \\\"OOB_COLUMN\\\");\\n        require(row_ < 16, \\\"OOB_ROW\\\");\\n        _;\\n    }\\n\\n    function get16x16(\\n        IdempotentFlag flag_,\\n        uint256 column_,\\n        uint256 row_\\n    ) internal pure only16x16(column_, row_) returns (bool) {\\n        unchecked {\\n            return flag_.get(column_ * 16 + row_);\\n        }\\n    }\\n\\n    function set16x16(\\n        IdempotentFlag flag_,\\n        uint256 column_,\\n        uint256 row_\\n    ) internal pure only16x16(column_, row_) returns (IdempotentFlag) {\\n        unchecked {\\n            return flag_.set(column_ * 16 + row_);\\n        }\\n    }\\n\\n    function set16x16Column(\\n        IdempotentFlag flag_,\\n        uint column_\\n    ) internal pure only16x16(column_, 0) returns (IdempotentFlag) {\\n        unchecked {\\n            return\\n                IdempotentFlag.wrap(\\n                    IdempotentFlag.unwrap(flag_) |\\n                        (MASK_16BIT << (column_ * 16))\\n                );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9801e9d4e870ff660f8c77c5d10ecc7234e81ca8059ff1cc2ce87e0f9e655219\",\"license\":\"CAL\"},\"contracts/interpreter/deploy/IExpressionDeployerV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\n/// Config required to build a new `State`.\\n/// @param sources Sources verbatim.\\n/// @param constants Constants verbatim.\\nstruct StateConfig {\\n    bytes[] sources;\\n    uint256[] constants;\\n}\\n\\ninterface IExpressionDeployerV1 {\\n    function deployExpression(\\n        StateConfig memory config,\\n        uint[] memory minOutputs\\n    ) external returns (address expressionAddress, uint256 contextReads);\\n}\\n\",\"keccak256\":\"0x18d15ac73258fd9845212e31baeb8b5bd105cd815f7b622cf6450e1b7e007937\",\"license\":\"CAL\"},\"contracts/interpreter/deploy/IRainInterpreterIntegrity.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"./IExpressionDeployerV1.sol\\\";\\nimport \\\"./LibIntegrityState.sol\\\";\\n\\ninterface IRainInterpreterIntegrity {\\n    function ensureIntegrity(\\n        bytes[] memory sources,\\n        uint256 constantsLength,\\n        uint[] memory minStackOutputs\\n    ) external view returns (uint256 contextReads, uint256 stackLength);\\n}\\n\",\"keccak256\":\"0x7f14e32deab29142659dfc44f11bb20a2f98d0d9822dfaf3c9d58aed584a7a63\",\"license\":\"CAL\"},\"contracts/interpreter/deploy/LibIntegrityState.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../run/RainInterpreter.sol\\\";\\nimport \\\"../run/LibStackTop.sol\\\";\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\n\\nimport \\\"../run/IInterpreterV1.sol\\\";\\n\\nstruct IntegrityState {\\n    // Sources first as we read it in assembly.\\n    bytes[] sources;\\n    uint256 constantsLength;\\n    StackTop stackBottom;\\n    StackTop stackMaxTop;\\n    uint256 contextReads;\\n    function(IntegrityState memory, Operand, StackTop)\\n        view\\n        returns (StackTop)[] integrityFunctionPointers;\\n}\\n\\nlibrary LibIntegrityState {\\n    using LibIntegrityState for IntegrityState;\\n    using LibStackTop for StackTop;\\n    using Math for uint256;\\n\\n    function syncStackMaxTop(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_\\n    ) internal pure {\\n        if (\\n            StackTop.unwrap(stackTop_) >\\n            StackTop.unwrap(integrityState_.stackMaxTop)\\n        ) {\\n            integrityState_.stackMaxTop = stackTop_;\\n        }\\n    }\\n\\n    function ensureIntegrity(\\n        IntegrityState memory integrityState_,\\n        SourceIndex sourceIndex_,\\n        StackTop stackTop_,\\n        uint minStackOutputs_\\n    ) internal view returns (StackTop) {\\n        unchecked {\\n            uint256 cursor_;\\n            uint256 end_;\\n            assembly (\\\"memory-safe\\\") {\\n                cursor_ := mload(\\n                    add(\\n                        mload(integrityState_),\\n                        add(0x20, mul(0x20, sourceIndex_))\\n                    )\\n                )\\n                end_ := add(cursor_, mload(cursor_))\\n            }\\n\\n            // Loop until complete.\\n            while (cursor_ < end_) {\\n                uint256 opcode_;\\n                Operand operand_;\\n                cursor_ += 4;\\n                assembly (\\\"memory-safe\\\") {\\n                    let op_ := mload(cursor_)\\n                    operand_ := and(op_, 0xFFFF)\\n                    opcode_ := and(shr(16, op_), 0xFFFF)\\n                }\\n                // We index into the function pointers here to ensure that any\\n                // opcodes that we don't have a pointer for will error.\\n                stackTop_ = integrityState_.integrityFunctionPointers[opcode_](\\n                    integrityState_,\\n                    operand_,\\n                    stackTop_\\n                );\\n            }\\n            require(\\n                minStackOutputs_ <=\\n                    integrityState_.stackBottom.toIndex(stackTop_),\\n                \\\"MIN_FINAL_STACK\\\"\\n            );\\n            return stackTop_;\\n        }\\n    }\\n\\n    function push(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop stackTopAfter_) {\\n        stackTopAfter_ = stackTop_.up();\\n        integrityState_.syncStackMaxTop(stackTopAfter_);\\n    }\\n\\n    function push(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        uint256 n_\\n    ) internal pure returns (StackTop stackTopAfter_) {\\n        stackTopAfter_ = stackTop_.up(n_);\\n        integrityState_.syncStackMaxTop(stackTopAfter_);\\n    }\\n\\n    function popUnderflowCheck(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_\\n    ) internal pure {\\n        require(\\n            // Stack bottom may be non-zero so check we are above it.\\n            (StackTop.unwrap(stackTop_) >=\\n                StackTop.unwrap(integrityState_.stackBottom)) &&\\n                // If we underflowed zero then we will be above the stack max\\n                // top. Assumes that at least 1 item was popped so we can do a\\n                // strict inequality check here.\\n                (StackTop.unwrap(stackTop_) <\\n                    StackTop.unwrap(integrityState_.stackMaxTop)),\\n            \\\"STACK_UNDERFLOW\\\"\\n        );\\n    }\\n\\n    function pop(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop stackTopAfter_) {\\n        stackTopAfter_ = stackTop_.down();\\n        integrityState_.popUnderflowCheck(stackTopAfter_);\\n    }\\n\\n    function pop(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        uint256 n_\\n    ) internal pure returns (StackTop) {\\n        if (n_ > 0) {\\n            stackTop_ = stackTop_.down(n_);\\n            integrityState_.popUnderflowCheck(stackTop_);\\n        }\\n        return stackTop_;\\n    }\\n\\n    function applyFnN(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256, uint256) internal view returns (uint256),\\n        uint256 n_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(integrityState_.pop(stackTop_, n_));\\n    }\\n\\n    function applyFnN(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256) internal view,\\n        uint256 n_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.pop(stackTop_, n_);\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256) internal view returns (uint256)\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(integrityState_.pop(stackTop_));\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(Operand, uint256) internal view returns (uint256)\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(integrityState_.pop(stackTop_));\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256, uint256) internal view\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.pop(stackTop_, 2);\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256, uint256) internal view returns (uint256)\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(integrityState_.pop(stackTop_, 2));\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(Operand, uint256, uint256) internal view returns (uint256)\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(integrityState_.pop(stackTop_, 2));\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256, uint256, uint256) internal view returns (uint256)\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(integrityState_.pop(stackTop_, 3));\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256, uint256, uint256, uint)\\n            internal\\n            view\\n            returns (uint256)\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(integrityState_.pop(stackTop_, 4));\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256[] memory) internal view returns (uint256),\\n        uint256 length_\\n    ) internal pure returns (StackTop) {\\n        return integrityState_.push(integrityState_.pop(stackTop_, length_));\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256),\\n        uint256 length_\\n    ) internal pure returns (StackTop) {\\n        unchecked {\\n            return\\n                integrityState_.push(\\n                    integrityState_.pop(stackTop_, length_ + 2)\\n                );\\n        }\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256, uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256),\\n        uint256 length_\\n    ) internal pure returns (StackTop) {\\n        unchecked {\\n            return\\n                integrityState_.push(\\n                    integrityState_.pop(stackTop_, length_ + 3)\\n                );\\n        }\\n    }\\n\\n    function applyFn(\\n        IntegrityState memory integrityState_,\\n        StackTop stackTop_,\\n        function(uint256, uint256[] memory, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256[] memory),\\n        uint256 length_\\n    ) internal pure returns (StackTop) {\\n        unchecked {\\n            return\\n                integrityState_.push(\\n                    integrityState_.pop(stackTop_, length_ * 2 + 1),\\n                    length_\\n                );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x68bdd0b5272a70e797fbe2c7bcdcfb9beb8cdba6e0b864bc637c7632999be33f\",\"license\":\"CAL\"},\"contracts/interpreter/run/IInterpreterV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\ntype SourceIndex is uint;\\ntype EncodedDispatch is uint256;\\ntype StateNamespace is uint;\\n\\ninterface IInterpreterV1 {\\n    function functionPointers() external view returns (bytes memory);\\n\\n    function eval(\\n        EncodedDispatch dispatch,\\n        uint256[][] memory context\\n    )\\n        external\\n        view\\n        returns (uint256[] memory stack, uint[] memory stateChanges);\\n\\n    function stateChanges(uint[] memory stateChanges) external;\\n\\n    function evalWithNamespace(\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint[][] memory context\\n    ) external view returns (uint[] memory stack, uint[] memory stateChanges);\\n\\n    function stateChangesWithNamespace(\\n        StateNamespace namespace,\\n        uint[] memory stateChanges\\n    ) external;\\n}\\n\",\"keccak256\":\"0xcdf6d90a79eb3c7c3a2a67a919e176dac0a5c0ddbfc65fe2b63d6c99f132eec1\",\"license\":\"CAL\"},\"contracts/interpreter/run/LibEncodedDispatch.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\nlibrary LibEncodedDispatch {\\n    function encode(\\n        address expressionPointer_,\\n        SourceIndex sourceIndex_,\\n        uint maxOutputs_\\n    ) internal pure returns (EncodedDispatch) {\\n        return\\n            EncodedDispatch.wrap(\\n                (uint(uint160(expressionPointer_)) << 32) |\\n                    (SourceIndex.unwrap(sourceIndex_) << 16) |\\n                    maxOutputs_\\n            );\\n    }\\n\\n    function decode(\\n        EncodedDispatch dispatch_\\n    ) internal pure returns (address, SourceIndex, uint) {\\n        return (\\n            address(uint160(EncodedDispatch.unwrap(dispatch_) >> 32)),\\n            SourceIndex.wrap((EncodedDispatch.unwrap(dispatch_) >> 16) & 0xFF),\\n            EncodedDispatch.unwrap(dispatch_) & 0xFF\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x439aed0b49a12ace271052a2dc274854953c09508654ddcad35523f77e46b461\",\"license\":\"CAL\"},\"contracts/interpreter/run/LibInterpreterState.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../run/IInterpreterV1.sol\\\";\\nimport \\\"../deploy/IExpressionDeployerV1.sol\\\";\\nimport \\\"./LibStackTop.sol\\\";\\nimport \\\"../../type/LibCast.sol\\\";\\nimport \\\"../../type/LibConvert.sol\\\";\\nimport \\\"../../array/LibUint256Array.sol\\\";\\nimport \\\"../../memory/LibMemorySize.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\nimport {SafeCastUpgradeable as SafeCast} from \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\\\";\\nimport {Operand} from \\\"./RainInterpreter.sol\\\";\\nimport \\\"../../kv/LibMemoryKV.sol\\\";\\n\\nenum DebugStyle {\\n    Stack,\\n    Constant,\\n    Context,\\n    Source\\n}\\n\\n/// Everything required to evaluate and track the state of a Rain expression.\\n/// As this is a struct it will be in memory when passed to `RainInterpreter` and so\\n/// will be modified by reference internally. This is important for gas\\n/// efficiency; the stack, arguments and stackIndex will likely be mutated by\\n/// the running expression.\\n/// @param stackIndex Opcodes write to the stack at the stack index and can\\n/// consume from the stack by decrementing the index and reading between the\\n/// old and new stack index.\\n/// IMPORANT: The stack is never zeroed out so the index must be used to\\n/// find the \\\"top\\\" of the stack as the result of an `eval`.\\n/// @param stack Stack is the general purpose runtime state that opcodes can\\n/// read from and write to according to their functionality.\\n/// @param sources Sources available to be executed by `eval`.\\n/// Notably `ZIPMAP` can also select a source to execute by index.\\n/// @param constants Constants that can be copied to the stack by index by\\n/// `VAL`.\\n/// @param arguments `ZIPMAP` populates arguments which can be copied to the\\n/// stack by `VAL`.\\nstruct InterpreterState {\\n    StackTop stackBottom;\\n    StackTop constantsBottom;\\n    MemoryKV stateKV;\\n    StateNamespace stateNamespace;\\n    uint256[][] context;\\n    bytes[] compiledSources;\\n}\\n\\nstring constant DEBUG_DELIMETER = \\\"~~~\\\";\\n\\nlibrary LibInterpreterState {\\n    using SafeCast for uint256;\\n    using LibMemorySize for uint256;\\n    using LibMemorySize for uint256[];\\n    using LibMemorySize for bytes;\\n    using LibUint256Array for uint256[];\\n    using LibUint256Array for uint256;\\n    using LibInterpreterState for InterpreterState;\\n    using LibStackTop for uint256[];\\n    using LibStackTop for StackTop;\\n    using LibStackTop for bytes;\\n    using LibCast for uint256;\\n    using LibCast for function(InterpreterState memory, SourceIndex, StackTop)\\n        view\\n        returns (StackTop);\\n    using LibCast for function(InterpreterState memory, Operand, StackTop)\\n        view\\n        returns (StackTop)[];\\n    using LibConvert for uint256[];\\n\\n    function debugArray(uint256[] memory array_) internal view {\\n        console.log(DEBUG_DELIMETER);\\n        for (uint256 i_ = 0; i_ < array_.length; i_++) {\\n            console.log(i_, array_[i_]);\\n        }\\n        console.log(DEBUG_DELIMETER);\\n    }\\n\\n    function debugStack(\\n        StackTop stackBottom_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        uint256 length_ = stackBottom_.toIndex(stackTop_);\\n        debugArray(\\n            StackTop.unwrap(stackTop_.down(length_)).copyToNewUint256Array(\\n                length_\\n            )\\n        );\\n        return stackTop_;\\n    }\\n\\n    function debugStack(\\n        InterpreterState memory state_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        return debugStack(state_.stackBottom, stackTop_);\\n    }\\n\\n    /// Console log various aspects of the Interpreter state.\\n    /// Gas intensive and relies on hardhat console so not intended for\\n    /// production but great for debugging Rain expressions.\\n    function debug(\\n        InterpreterState memory state_,\\n        StackTop stackTop_,\\n        DebugStyle debugStyle_\\n    ) internal view returns (StackTop) {\\n        if (debugStyle_ == DebugStyle.Source) {\\n            for (uint256 i_ = 0; i_ < state_.compiledSources.length; i_++) {\\n                console.logBytes(state_.compiledSources[i_]);\\n            }\\n        } else {\\n            if (debugStyle_ == DebugStyle.Stack) {\\n                state_.debugStack(stackTop_);\\n            } else if (debugStyle_ == DebugStyle.Constant) {\\n                debugArray(state_.constantsBottom.down().asUint256Array());\\n            } else {\\n                for (uint256 i_ = 0; i_ < state_.context.length; i_++) {\\n                    debugArray(state_.context[i_]);\\n                }\\n            }\\n        }\\n        return stackTop_;\\n    }\\n\\n    function serialize(\\n        StateConfig memory config_,\\n        uint256 stackLength_,\\n        bytes memory opcodeFunctionPointers_\\n    ) internal pure returns (bytes memory) {\\n        unchecked {\\n            uint256 size_ = 0;\\n            size_ += stackLength_.size();\\n            size_ += config_.constants.size();\\n            for (uint256 i_ = 0; i_ < config_.sources.length; i_++) {\\n                size_ += config_.sources[i_].size();\\n            }\\n            bytes memory serialized_ = new bytes(size_);\\n            StackTop cursor_ = serialized_.asStackTop().up();\\n\\n            // Copy stack length.\\n            cursor_ = cursor_.push(stackLength_);\\n\\n            // Then the constants.\\n            cursor_ = cursor_.pushWithLength(config_.constants);\\n\\n            // Last the sources.\\n            bytes memory source_;\\n            for (uint256 i_ = 0; i_ < config_.sources.length; i_++) {\\n                source_ = config_.sources[i_];\\n                compile(source_, opcodeFunctionPointers_);\\n                cursor_ = cursor_.unalignedPushWithLength(source_);\\n            }\\n            return serialized_;\\n        }\\n    }\\n\\n    function deserialize(\\n        bytes memory serialized_\\n    ) internal pure returns (InterpreterState memory) {\\n        unchecked {\\n            InterpreterState memory state_;\\n\\n            // Context will probably be overridden by the caller according to the\\n            // context scratch that we deserialize so best to just set it empty\\n            // here.\\n            state_.context = new uint256[][](0);\\n\\n            StackTop cursor_ = serialized_.asStackTop().up();\\n            // The end of processing is the end of the state bytes.\\n            StackTop end_ = cursor_.upBytes(cursor_.peek());\\n\\n            // Read the stack length and build a stack.\\n            cursor_ = cursor_.up();\\n            uint256 stackLength_ = cursor_.peek();\\n\\n            // The stack is never stored in stack bytes so we allocate a new\\n            // array for it with length as per the indexes and point the state\\n            // at it.\\n            uint256[] memory stack_ = new uint256[](stackLength_);\\n            state_.stackBottom = stack_.asStackTopUp();\\n\\n            // Reference the constants array and move cursor past it.\\n            cursor_ = cursor_.up();\\n            state_.constantsBottom = cursor_;\\n            cursor_ = cursor_.up(cursor_.peek());\\n\\n            // Rebuild the sources array.\\n            uint256 i_ = 0;\\n            StackTop lengthCursor_ = cursor_;\\n            uint256 sourcesLength_ = 0;\\n            while (StackTop.unwrap(lengthCursor_) < StackTop.unwrap(end_)) {\\n                lengthCursor_ = lengthCursor_\\n                    .upBytes(lengthCursor_.peekUp())\\n                    .up();\\n                sourcesLength_++;\\n            }\\n            state_.compiledSources = new bytes[](sourcesLength_);\\n            while (StackTop.unwrap(cursor_) < StackTop.unwrap(end_)) {\\n                state_.compiledSources[i_] = cursor_.asBytes();\\n                cursor_ = cursor_.upBytes(cursor_.peekUp()).up();\\n                i_++;\\n            }\\n            return state_;\\n        }\\n    }\\n\\n    /// Given a source in opcodes compile to an equivalent source with real\\n    /// function pointers for a given Interpreter contract. The \\\"compilation\\\"\\n    /// involves simply replacing the opcode with the pointer at the index of\\n    /// the opcode. i.e. opcode 4 will be replaced with `pointers_[4]`.\\n    /// Relies heavily on the integrity checks ensuring opcodes used are not OOB\\n    /// and that the pointers provided are valid and in the correct order.\\n    /// Hopefully it goes without saying that the list of pointers MUST NOT be\\n    /// user defined, otherwise any source can be compiled with a completely\\n    /// different mapping between opcodes and dispatched functions.\\n    function compile(\\n        bytes memory source_,\\n        bytes memory pointers_\\n    ) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n                let replaceMask_ := 0xFFFF\\n                let preserveMask_ := not(replaceMask_)\\n                let sourceLength_ := mload(source_)\\n                let pointersBottom_ := add(pointers_, 2)\\n                let cursor_ := add(source_, 2)\\n                let end_ := add(source_, sourceLength_)\\n            } lt(cursor_, end_) {\\n                cursor_ := add(cursor_, 4)\\n            } {\\n                let data_ := mload(cursor_)\\n                let pointer_ := and(\\n                    replaceMask_,\\n                    mload(\\n                        add(pointersBottom_, mul(2, and(data_, replaceMask_)))\\n                    )\\n                )\\n                mstore(cursor_, or(and(data_, preserveMask_), pointer_))\\n            }\\n        }\\n    }\\n\\n    /// Evaluates a Rain expression.\\n    /// The main workhorse of the rain Interpreter, `eval` runs any core opcodes\\n    /// and dispatches anything it is unaware of to the implementing contract.\\n    /// For an expression to be useful the implementing contract must override\\n    /// `applyOp` and dispatch non-core opcodes to domain specific logic. This\\n    /// could be mathematical operations for a calculator, tier reports for\\n    /// a membership combinator, entitlements for a minting curve, etc.\\n    ///\\n    /// Everything required to coordinate the execution of a Rain expression to\\n    /// completion is contained in the `State`. The context and source index\\n    /// are provided so the caller can provide additional data and kickoff the\\n    /// opcode dispatch from the correct source in `sources`.\\n    function eval(\\n        InterpreterState memory state_,\\n        SourceIndex sourceIndex_,\\n        StackTop stackTop_\\n    ) internal view returns (StackTop) {\\n        unchecked {\\n            uint256 cursor_;\\n            uint256 end_;\\n            assembly (\\\"memory-safe\\\") {\\n                cursor_ := mload(\\n                    add(\\n                        mload(add(state_, 0xA0)),\\n                        add(0x20, mul(0x20, sourceIndex_))\\n                    )\\n                )\\n                end_ := add(cursor_, mload(cursor_))\\n            }\\n\\n            // Loop until complete.\\n            while (cursor_ < end_) {\\n                function(InterpreterState memory, Operand, StackTop)\\n                    internal\\n                    view\\n                    returns (StackTop) fn_;\\n                Operand operand_;\\n                cursor_ += 4;\\n                {\\n                    uint256 op_;\\n                    assembly (\\\"memory-safe\\\") {\\n                        op_ := mload(cursor_)\\n                        operand_ := and(op_, 0xFFFF)\\n                        fn_ := and(shr(16, op_), 0xFFFF)\\n                    }\\n                }\\n                stackTop_ = fn_(state_, operand_, stackTop_);\\n            }\\n            return stackTop_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6a2c956607ead01db0a1da9de42920fbf7e275205e4c55ab4dc2cc575d550423\",\"license\":\"CAL\"},\"contracts/interpreter/run/LibStackTop.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"./RainInterpreter.sol\\\";\\nimport \\\"../../array/LibUint256Array.sol\\\";\\nimport \\\"../../bytes/LibBytes.sol\\\";\\n\\n/// Custom type to point to memory ostensibly in a stack.\\ntype StackTop is uint256;\\n\\n/// @title LibStackTop\\n/// @notice A `StackTop` is just a pointer to some memory. Ostensibly it is the\\n/// top of some stack used by the `RainInterpreter` so that means it can move \\\"up\\\" and\\n/// \\\"down\\\" (increment and decrement) by `uint256` (32 bytes) increments. In\\n/// general we're abusing that concept a bit to extend to things like the bottom\\n/// of a stack or a hypothetical maximum stack or even treating an arbitrary\\n/// `uint256[]` array as \\\"a stack\\\". In the future it's likely this lib and\\n/// concept will be renamed to reflect that it is used much more generally than\\n/// simply the top of some stack.\\n/// All the functions in `LibStackTop` operate on memory to read/write what is\\n/// referenced but the pointers and values themselves are typically input/output\\n/// of the functions. I.e. the stack top itself is not being mutated in-place,\\n/// typically the caller would have both the input stack top and the output\\n/// stack top in scope after calling library functions.\\n/// Most of the functions in this library are equivalent to each other via\\n/// composition, i.e. everything could be achieved with just `up`, `down`,\\n/// `pop`, `push`, `peek`. The reason there is so much duplication of logic is\\n/// that the Solidity compiler seems to fail at inlining equivalent logic quite\\n/// a lot sadly. There appears to be effort upstream towards improving the\\n/// function inlining by the optimizer so we should expect a lot of this library\\n/// to become redundant or even counterproductive in the future.\\nlibrary LibStackTop {\\n    using LibStackTop for StackTop;\\n    using LibStackTop for uint256[];\\n    using LibStackTop for bytes;\\n    using LibUint256Array for uint256[];\\n    using LibBytes for uint256;\\n\\n    /// Reads the value above the stack top. If the stack top is the current\\n    /// true stack top this is an out of bounds read. This is only useful if\\n    /// the stack was first moved down and the value it moved past needs to be\\n    /// read as part of the current operation.\\n    /// @param stackTop_ Position to read past/above.\\n    function peekUp(StackTop stackTop_) internal pure returns (uint256 a_) {\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(stackTop_)\\n        }\\n    }\\n\\n    /// Read the value immediately below the given stack top. Equivalent to\\n    /// calling `pop` and discarding the `stackTopAfter_` value, so may be\\n    /// less gas than setting and discarding a value.\\n    /// @param stackTop_ The stack top to read below.\\n    /// @return a_ The value that was read.\\n    function peek(StackTop stackTop_) internal pure returns (uint256 a_) {\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(sub(stackTop_, 0x20))\\n        }\\n    }\\n\\n    /// Reads 2 values below the given stack top.\\n    /// The following statements are equivalent but A may use gas if the\\n    /// compiler fails to inline some function calls.\\n    /// A:\\n    /// ```\\n    /// (uint a_, uint b_) = stackTop_.peek2();\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// uint b_;\\n    /// (stackTop_, b_) = stackTop_.pop();\\n    /// uint a_ = stackTop_.peek();\\n    /// ```\\n    /// @param stackTop_ The stack top to peek below.\\n    function peek2(\\n        StackTop stackTop_\\n    ) internal pure returns (uint256 a_, uint256 b_) {\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(sub(stackTop_, 0x40))\\n            b_ := mload(sub(stackTop_, 0x20))\\n        }\\n    }\\n\\n    /// Read the value immediately below the given stack top and return the\\n    /// stack top that points to the value that was read alongside the value.\\n    /// The following are equivalent but A may be cheaper if the compiler\\n    /// fails to inline some function calls:\\n    /// A:\\n    /// ```\\n    /// uint a_;\\n    /// (stackTop_, a_) = stackTop_.pop();\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackTop_ = stackTop_.down();\\n    /// uint a_ = stackTop_.peekUp();\\n    /// ```\\n    /// @param stackTop_ The stack top to read below.\\n    /// @return stackTopAfter_ The stack top that points to the value that was\\n    /// read.\\n    /// @return a_ The value that was read.\\n    function pop(\\n        StackTop stackTop_\\n    ) internal pure returns (StackTop stackTopAfter_, uint256 a_) {\\n        assembly (\\\"memory-safe\\\") {\\n            stackTopAfter_ := sub(stackTop_, 0x20)\\n            a_ := mload(stackTopAfter_)\\n        }\\n    }\\n\\n    function consumeSentinel(\\n        StackTop stackTop_,\\n        StackTop stackBottom_,\\n        uint256 sentinel_,\\n        uint256 stepSize_\\n    ) internal pure returns (StackTop, uint256[] memory) {\\n        uint256[] memory array_;\\n        assembly (\\\"memory-safe\\\") {\\n            // Underflow is not allowed and pointing at position 0 in memory is\\n            // corrupt behaviour anyway.\\n            if iszero(stackBottom_) {\\n                revert(0, 0)\\n            }\\n            let sentinelLocation_ := 0\\n            let length_ := 0\\n            let step_ := mul(stepSize_, 0x20)\\n            for {\\n                stackTop_ := sub(stackTop_, 0x20)\\n                let end_ := sub(stackBottom_, 0x20)\\n            } gt(stackTop_, end_) {\\n                stackTop_ := sub(stackTop_, step_)\\n                length_ := add(length_, stepSize_)\\n            } {\\n                if eq(sentinel_, mload(stackTop_)) {\\n                    sentinelLocation_ := stackTop_\\n                    break\\n                }\\n            }\\n            // Sentinel MUST exist in the stack if consumer expects it to there.\\n            if iszero(sentinelLocation_) {\\n                revert(0, 0)\\n            }\\n            mstore(sentinelLocation_, length_)\\n            array_ := sentinelLocation_\\n        }\\n        return (stackTop_, array_);\\n    }\\n\\n    function consumeStructs(\\n        StackTop stackTop_,\\n        StackTop stackBottom_,\\n        uint256 sentinel_,\\n        uint256 structSize_\\n    ) internal pure returns (StackTop, uint256[] memory) {\\n        uint256[] memory tempArray_;\\n        (stackTop_, tempArray_) = stackTop_.consumeSentinel(\\n            stackBottom_,\\n            sentinel_,\\n            structSize_\\n        );\\n        uint256 structsLength_ = tempArray_.length / structSize_;\\n        uint256[] memory refs_ = new uint256[](structsLength_);\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n                let refCursor_ := add(refs_, 0x20)\\n                let refEnd_ := add(refCursor_, mul(structsLength_, 0x20))\\n                let tempCursor_ := add(tempArray_, 0x20)\\n                let tempStepSize_ := mul(structSize_, 0x20)\\n            } lt(refCursor_, refEnd_) {\\n                refCursor_ := add(refCursor_, 0x20)\\n                tempCursor_ := add(tempCursor_, tempStepSize_)\\n            } {\\n                mstore(refCursor_, tempCursor_)\\n            }\\n        }\\n        return (stackTop_, refs_);\\n    }\\n\\n    /// Write a value at the stack top location. Typically not useful if the\\n    /// given stack top is not subsequently moved past the written value , or\\n    /// if the given stack top is actually located somewhere below the \\\"true\\\"\\n    /// stack top.\\n    /// @param stackTop_ The stack top to write the value at.\\n    /// @param a_ The value to write.\\n    function set(StackTop stackTop_, uint256 a_) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackTop_, a_)\\n        }\\n    }\\n\\n    /// Store a `uint256` at the stack top position and return the stack top\\n    /// above the written value. The following statements are equivalent in\\n    /// functionality but A may be less gas if the compiler fails to inline\\n    /// some function calls.\\n    /// A:\\n    /// ```\\n    /// stackTop_ = stackTop_.push(a_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackTop_.set(a_);\\n    /// stackTop_ = stackTop_.up();\\n    /// ```\\n    /// @param stackTop_ The stack top to write at.\\n    /// @param a_ The value to write.\\n    /// @return The stack top above where `a_` was written to.\\n    function push(\\n        StackTop stackTop_,\\n        uint256 a_\\n    ) internal pure returns (StackTop) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackTop_, a_)\\n            stackTop_ := add(stackTop_, 0x20)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Store a `uint256[]` at the stack top position and return the stack top\\n    /// above the written values. The length of the array is NOT written to the\\n    /// stack, ONLY the array values are copied to the stack. The following\\n    /// statements are equivalent in functionality but A may be less gas if the\\n    /// compiler fails to inline some function calls.\\n    /// A:\\n    /// ```\\n    /// stackTop_ = stackTop_.push(array_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// unchecked {\\n    ///   for (uint i_ = 0; i_ < array_.length; i_++) {\\n    ///     stackTop_ = stackTop_.push(array_[i_]);\\n    ///   }\\n    /// }\\n    /// ```\\n    /// @param stackTop_ The stack top to write at.\\n    /// @param array_ The array of values to write.\\n    /// @return The stack top above the array.\\n    function push(\\n        StackTop stackTop_,\\n        uint256[] memory array_\\n    ) internal pure returns (StackTop) {\\n        array_.unsafeCopyValuesTo(StackTop.unwrap(stackTop_));\\n        return stackTop_.up(array_.length);\\n    }\\n\\n    /// Store a `uint256[]` at the stack top position and return the stack top\\n    /// above the written values. The length of the array IS written to the\\n    /// stack.\\n    /// @param stackTop_ The stack top to write at.\\n    /// @param array_ The array of values and length to write.\\n    /// @return The stack top above the array.\\n    function pushWithLength(\\n        StackTop stackTop_,\\n        uint256[] memory array_\\n    ) internal pure returns (StackTop) {\\n        return stackTop_.push(array_.length).push(array_);\\n    }\\n\\n    /// Store `bytes` at the stack top position and return the stack top above\\n    /// the written bytes. The length of the bytes is NOT written to the stack,\\n    /// ONLY the bytes are written. As `bytes` may be of arbitrary length, i.e.\\n    /// it MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\\n    /// ensure that this is safe in context of subsequent reads and writes.\\n    /// @param stackTop_ The stack top to write at.\\n    /// @param bytes_ The bytes to write at the stack top.\\n    /// @return The stack top above the written bytes.\\n    function unalignedPush(\\n        StackTop stackTop_,\\n        bytes memory bytes_\\n    ) internal pure returns (StackTop) {\\n        StackTop.unwrap(bytes_.asStackTop().up()).unsafeCopyBytesTo(\\n            StackTop.unwrap(stackTop_),\\n            bytes_.length\\n        );\\n        return stackTop_.upBytes(bytes_.length);\\n    }\\n\\n    /// Store `bytes` at the stack top position and return the stack top above\\n    /// the written bytes. The length of the bytes IS written to the stack in\\n    /// addition to the bytes. As `bytes` may be of arbitrary length, i.e. it\\n    /// MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\\n    /// ensure that this is safe in context of subsequent reads and writes.\\n    /// @param stackTop_ The stack top to write at.\\n    /// @param bytes_ The bytes to write with their length at the stack top.\\n    /// @return The stack top above the written bytes.\\n    function unalignedPushWithLength(\\n        StackTop stackTop_,\\n        bytes memory bytes_\\n    ) internal pure returns (StackTop) {\\n        return stackTop_.push(bytes_.length).unalignedPush(bytes_);\\n    }\\n\\n    /// Store 8x `uint256` at the stack top position and return the stack top\\n    /// above the written value. The following statements are equivalent in\\n    /// functionality but A may be cheaper if the compiler fails to\\n    /// inline some function calls.\\n    /// A:\\n    /// ```\\n    /// stackTop_ = stackTop_.push(a_, b_, c_, d_, e_, f_, g_, h_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackTop_ = stackTop_\\n    ///   .push(a_)\\n    ///   .push(b_)\\n    ///   .push(c_)\\n    ///   .push(d_)\\n    ///   .push(e_)\\n    ///   .push(f_)\\n    ///   .push(g_)\\n    ///   .push(h_);\\n    /// @param stackTop_ The stack top to write at.\\n    /// @param a_ The first value to write.\\n    /// @param b_ The second value to write.\\n    /// @param c_ The third value to write.\\n    /// @param d_ The fourth value to write.\\n    /// @param e_ The fifth value to write.\\n    /// @param f_ The sixth value to write.\\n    /// @param g_ The seventh value to write.\\n    /// @param h_ The eighth value to write.\\n    /// @return The stack top above where `h_` was written.\\n    function push(\\n        StackTop stackTop_,\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_,\\n        uint256 e_,\\n        uint256 f_,\\n        uint256 g_,\\n        uint256 h_\\n    ) internal pure returns (StackTop) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackTop_, a_)\\n            mstore(add(stackTop_, 0x20), b_)\\n            mstore(add(stackTop_, 0x40), c_)\\n            mstore(add(stackTop_, 0x60), d_)\\n            mstore(add(stackTop_, 0x80), e_)\\n            mstore(add(stackTop_, 0xA0), f_)\\n            mstore(add(stackTop_, 0xC0), g_)\\n            mstore(add(stackTop_, 0xE0), h_)\\n            stackTop_ := add(stackTop_, 0x100)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackTop) {\\n        uint256 a_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        a_ = fn_(a_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(Operand, uint256) internal view returns (uint256) fn_,\\n        Operand operand_\\n    ) internal view returns (StackTop) {\\n        uint256 a_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        a_ = fn_(operand_, a_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(uint256, uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackTop) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x20)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n        }\\n        a_ = fn_(a_, b_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Reduce a function N times, reading and writing inputs and the accumulated\\n    /// result on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param n_ The number of times to apply fn_ to accumulate a final result.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFnN(\\n        StackTop stackTop_,\\n        function(uint256, uint256) internal view returns (uint256) fn_,\\n        uint256 n_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        unchecked {\\n            uint256 bottom_;\\n            uint256 cursor_;\\n            uint256 a_;\\n            uint256 b_;\\n            assembly (\\\"memory-safe\\\") {\\n                bottom_ := sub(stackTop_, mul(n_, 0x20))\\n                a_ := mload(bottom_)\\n                stackTopAfter_ := add(bottom_, 0x20)\\n                cursor_ := stackTopAfter_\\n            }\\n            while (cursor_ < StackTop.unwrap(stackTop_)) {\\n                assembly (\\\"memory-safe\\\") {\\n                    b_ := mload(cursor_)\\n                }\\n                a_ = fn_(a_, b_);\\n                cursor_ += 0x20;\\n            }\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(bottom_, a_)\\n            }\\n        }\\n    }\\n\\n    function applyFnN(\\n        StackTop stackTop_,\\n        function(uint256) internal view fn_,\\n        uint256 n_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        uint256 cursor_;\\n        uint256 a_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTopAfter_ := sub(stackTop_, mul(n_, 0x20))\\n            cursor_ := stackTopAfter_\\n        }\\n        while (cursor_ < StackTop.unwrap(stackTop_)) {\\n            assembly (\\\"memory-safe\\\") {\\n                a_ := mload(cursor_)\\n                cursor_ := add(cursor_, 0x20)\\n            }\\n            fn_(a_);\\n        }\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(uint256, uint256, uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackTop) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 c_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x40)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n            c_ := mload(add(stackTop_, 0x20))\\n        }\\n        a_ = fn_(a_, b_, c_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(uint256, uint256, uint256, uint)\\n            internal\\n            view\\n            returns (uint256) fn_\\n    ) internal view returns (StackTop) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 c_;\\n        uint d_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x60)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n            c_ := mload(add(stackTop_, 0x20))\\n            d_ := mload(add(stackTop_, 0x40))\\n        }\\n        a_ = fn_(a_, b_, c_, d_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param operand_ Operand is passed from the source instead of the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(Operand, uint256, uint256) internal view returns (uint256) fn_,\\n        Operand operand_\\n    ) internal view returns (StackTop) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x20)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n        }\\n        a_ = fn_(operand_, a_, b_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(uint256[] memory) internal view returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        (uint256 a_, uint256[] memory tail_) = stackTop_.list(length_);\\n        uint256 b_ = fn_(tail_);\\n        return tail_.asStackTop().push(a_).push(b_);\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the array to pass to fn_ from the stack.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackTop stackTopAfter_) {\\n        (uint256 b_, uint256[] memory tail_) = stackTop_.list(length_);\\n        stackTopAfter_ = tail_.asStackTop();\\n        (StackTop location_, uint256 a_) = stackTopAfter_.pop();\\n        location_.set(fn_(a_, b_, tail_));\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the array to pass to fn_ from the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(uint256, uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackTop) {\\n        (uint256 c_, uint256[] memory tail_) = stackTop_.list(length_);\\n        (StackTop stackTopAfter_, uint256 b_) = tail_.asStackTop().pop();\\n        uint256 a_ = stackTopAfter_.peek();\\n        stackTopAfter_.down().set(fn_(a_, b_, c_, tail_));\\n        return stackTopAfter_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the arrays to pass to fn_ from the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackTop stackTop_,\\n        function(uint256, uint256[] memory, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256[] memory) fn_,\\n        uint256 length_\\n    ) internal view returns (StackTop) {\\n        StackTop csStart_ = stackTop_.down(length_);\\n        uint256[] memory cs_ = LibUint256Array.copyToNewUint256Array(\\n            StackTop.unwrap(csStart_),\\n            length_\\n        );\\n        (uint256 a_, uint256[] memory bs_) = csStart_.list(length_);\\n\\n        uint256[] memory results_ = fn_(a_, bs_, cs_);\\n        require(results_.length == length_, \\\"BAD_RESULT_LENGTH\\\");\\n        StackTop bottom_ = bs_.asStackTop();\\n        LibUint256Array.unsafeCopyValuesTo(results_, StackTop.unwrap(bottom_));\\n        return bottom_.up(length_);\\n    }\\n\\n    /// Returns `length_` values from the stack as an array without allocating\\n    /// new memory. As arrays always start with their length, this requires\\n    /// writing the length value to the stack below the array values. The value\\n    /// that is overwritten in the process is also returned so that data is not\\n    /// lost. For example, imagine a stack `[ A B C D ]` and we list 2 values.\\n    /// This will write the stack to look like `[ A 2 C D ]` and return both `B`\\n    /// and a pointer to `2` represented as a `uint256[]`.\\n    /// The returned array is ONLY valid for as long as the stack DOES NOT move\\n    /// back into its memory. As soon as the stack moves up again and writes into\\n    /// the array it will be corrupt. The caller MUST ensure that it does not\\n    /// read from the returned array after it has been corrupted by subsequent\\n    /// stack writes.\\n    /// @param stackTop_ The stack top to read the values below into an array.\\n    /// @param length_ The number of values to include in the returned array.\\n    /// @return head_ The value that was overwritten with the length.\\n    /// @return tail_ The array constructed from the stack memory.\\n    function list(\\n        StackTop stackTop_,\\n        uint256 length_\\n    ) internal pure returns (uint256 head_, uint256[] memory tail_) {\\n        assembly (\\\"memory-safe\\\") {\\n            tail_ := sub(stackTop_, add(0x20, mul(length_, 0x20)))\\n            head_ := mload(tail_)\\n            mstore(tail_, length_)\\n        }\\n    }\\n\\n    /// Cast a `uint256[]` array to a stack top. The stack top will point to the\\n    /// length of the array, NOT its first value.\\n    /// @param array_ The array to cast to a stack top.\\n    /// @return stackTop_ The stack top that points to the length of the array.\\n    function asStackTop(\\n        uint256[] memory array_\\n    ) internal pure returns (StackTop stackTop_) {\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := array_\\n        }\\n    }\\n\\n    /// Cast a stack top to an array. The value immediately above the stack top\\n    /// will be treated as the length of the array, so the proceeding length\\n    /// values will be the items of the array. The caller MUST ensure the values\\n    /// above the stack top constitute a valid array. The retured array will be\\n    /// corrupt if/when the stack subsequently moves into it and writes to those\\n    /// memory locations. The caller MUST ensure that it does NOT read from the\\n    /// returned array after the stack writes over it.\\n    /// @param stackTop_ The stack top that will be cast to an array.\\n    /// @return array_ The array above the stack top.\\n    function asUint256Array(\\n        StackTop stackTop_\\n    ) internal pure returns (uint256[] memory array_) {\\n        assembly (\\\"memory-safe\\\") {\\n            array_ := stackTop_\\n        }\\n    }\\n\\n    /// Cast a stack top to bytes. The value immediately above the stack top will\\n    /// be treated as the length of the `bytes`, so the proceeding length bytes\\n    /// will be the data of the `bytes`. The caller MUST ensure the length and\\n    /// bytes above the stack top constitute valid `bytes` data. The returned\\n    /// `bytes` will be corrupt if/when the stack subsequently moves into it and\\n    /// writes to those memory locations. The caller MUST ensure that it does\\n    /// NOT read from the returned bytes after the stack writes over it.\\n    /// @param stackTop_ The stack top that will be cast to bytes.\\n    /// @return bytes_ The bytes above the stack top.\\n    function asBytes(\\n        StackTop stackTop_\\n    ) internal pure returns (bytes memory bytes_) {\\n        assembly (\\\"memory-safe\\\") {\\n            bytes_ := stackTop_\\n        }\\n    }\\n\\n    /// Cast a `uint256[]` array to a stack top after its length. The stack top\\n    /// will point to the first item of the array, NOT its length.\\n    /// @param array_ The array to cast to a stack top.\\n    /// @return stackTop_ The stack top that points to the first item of the array.\\n    function asStackTopUp(\\n        uint256[] memory array_\\n    ) internal pure returns (StackTop stackTop_) {\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := add(array_, 0x20)\\n        }\\n    }\\n\\n    function asStackTopAfter(\\n        uint256[] memory array_\\n    ) internal pure returns (StackTop stackTop_) {\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := add(array_, add(0x20, mul(mload(array_), 0x20)))\\n        }\\n    }\\n\\n    /// Cast `bytes` to a stack top. The stack top will point to the length of\\n    /// the `bytes`, NOT the first byte.\\n    /// @param bytes_ The `bytes` to cast to a stack top.\\n    /// @return stackTop_ The stack top that points to the length of the bytes.\\n    function asStackTop(\\n        bytes memory bytes_\\n    ) internal pure returns (StackTop stackTop_) {\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := bytes_\\n        }\\n    }\\n\\n    /// Returns the stack top 32 bytes above/past the passed stack top.\\n    /// @param stackTop_ The stack top at the starting position.\\n    /// @return The stack top 32 bytes above the passed stack top.\\n    function up(StackTop stackTop_) internal pure returns (StackTop) {\\n        unchecked {\\n            return StackTop.wrap(StackTop.unwrap(stackTop_) + 0x20);\\n        }\\n    }\\n\\n    /// Returns the stack top `n_ * 32` bytes above/past the passed stack top.\\n    /// @param stackTop_ The stack top at the starting position.\\n    /// @param n_ The multiplier on the stack movement. MAY be zero.\\n    /// @return The stack top `n_ * 32` bytes above/past the passed stack top.\\n    function up(\\n        StackTop stackTop_,\\n        uint256 n_\\n    ) internal pure returns (StackTop) {\\n        unchecked {\\n            return StackTop.wrap(StackTop.unwrap(stackTop_) + 0x20 * n_);\\n        }\\n    }\\n\\n    /// Returns the stack top `n_` bytes above/past the passed stack top.\\n    /// The returned stack top MAY NOT be aligned with the passed stack top for\\n    /// subsequent 32 byte reads and writes. The caller MUST ensure that it is\\n    /// safe to read and write data relative to the returned stack top.\\n    /// @param stackTop_ The stack top at the starting position.\\n    /// @param n_ The number of bytes to move.\\n    /// @return The stack top `n_` bytes above/past the passed stack top.\\n    function upBytes(\\n        StackTop stackTop_,\\n        uint256 n_\\n    ) internal pure returns (StackTop) {\\n        unchecked {\\n            return StackTop.wrap(StackTop.unwrap(stackTop_) + n_);\\n        }\\n    }\\n\\n    /// Returns the stack top 32 bytes below/before the passed stack top.\\n    /// @param stackTop_ The stack top at the starting position.\\n    /// @return The stack top 32 bytes below/before the passed stack top.\\n    function down(StackTop stackTop_) internal pure returns (StackTop) {\\n        unchecked {\\n            return StackTop.wrap(StackTop.unwrap(stackTop_) - 0x20);\\n        }\\n    }\\n\\n    /// Returns the stack top `n_ * 32` bytes below/before the passed stack top.\\n    /// @param stackTop_ The stack top at the starting position.\\n    /// @param n_ The multiplier on the movement.\\n    /// @return The stack top `n_ * 32` bytes below/before the passed stack top.\\n    function down(\\n        StackTop stackTop_,\\n        uint256 n_\\n    ) internal pure returns (StackTop) {\\n        unchecked {\\n            return StackTop.wrap(StackTop.unwrap(stackTop_) - 0x20 * n_);\\n        }\\n    }\\n\\n    /// Convert two stack top values to a single stack index. A stack index is\\n    /// the distance in 32 byte increments between two stack positions. The\\n    /// calculations assumes the two stack positions are aligned. The caller MUST\\n    /// ensure the alignment of both values. The calculation is unchecked and MAY\\n    /// underflow. The caller MUST ensure that the stack top is always above the\\n    /// stack bottom.\\n    /// @param stackBottom_ The lower of the two values.\\n    /// @param stackTop_ The higher of the two values.\\n    /// @return The stack index as 32 byte distance between the two stack\\n    /// positions.\\n    function toIndex(\\n        StackTop stackBottom_,\\n        StackTop stackTop_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            return\\n                (StackTop.unwrap(stackTop_) - StackTop.unwrap(stackBottom_)) /\\n                0x20;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3365a67cfc54be5907d50e79ebaf071152eae5293576f56a0455b4794f513f4a\",\"license\":\"CAL\"},\"contracts/interpreter/run/RainInterpreter.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\nimport \\\"../../math/SaturatingMath.sol\\\";\\nimport \\\"../../type/LibCast.sol\\\";\\nimport \\\"./LibStackTop.sol\\\";\\nimport \\\"./LibInterpreterState.sol\\\";\\nimport \\\"../../array/LibUint256Array.sol\\\";\\nimport \\\"../../sstore2/SSTORE2.sol\\\";\\nimport \\\"../deploy/IRainInterpreterIntegrity.sol\\\";\\nimport {SafeCastUpgradeable as SafeCast} from \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\\\";\\n\\ntype Operand is uint256;\\n\\n/// @title RainInterpreter\\n/// @notice Interpreter for implementing and executing custom contract DSLs.\\n/// Libraries and contracts map opcodes to `view` functionality then\\n/// `RainInterpreter` runs Rain expressions using these opcodes. Rain expressions\\n/// dispatch as pairs of bytes. The first byte is an opcode to run and the\\n/// second byte is a value the opcode can use contextually to inform how to run.\\n/// Typically opcodes will read/write to the stack to produce some meaningful\\n/// final state after all opcodes have been dispatched.\\n///\\n/// The only thing required to run a Rain expression is a `State` struct to pass\\n/// to `eval`, and the index of the source to run. Additional context can\\n/// optionally be provided to be used by opcodes. For example, an `ITierV2`\\n/// contract can take the input of `report`, abi encode it as context, then\\n/// expose a local opcode that copies this account to the stack. The state will\\n/// be mutated by reference rather than returned by `eval`, this is to make it\\n/// very clear to implementers that the inline mutation is occurring.\\n///\\n/// Rain expressions run \\\"top to bottom\\\", i.e. \\\"left to right\\\".\\n/// See the tests for examples on how to construct Rain expression in JavaScript\\n/// then pass to `ImmutableSource` contracts deployed by a factory that then\\n/// run `eval` to produce a final value.\\n///\\n/// There are only 4 \\\"core\\\" opcodes for `RainInterpreter`:\\n/// - `0`: Copy value from either `constants` at index `operand` to the top of\\n///   the stack.\\n/// - `1`: Duplicates the value at stack index `operand_` to the top of the\\n///   stack.\\n/// - `2`: Zipmap takes N values from the stack, interprets each as an array of\\n///   configurable length, then zips them into `arguments` and maps a source\\n///   from `sources` over these. See `zipmap` for more details.\\n/// - `3`: Debug prints the state to the console log as per hardhat.\\n///\\n/// To do anything useful the contract that inherits `RainInterpreter` needs to provide\\n/// opcodes to build up an internal DSL. This may sound complex but it only\\n/// requires mapping opcode integers to functions to call, and reading/writing\\n/// values to the stack as input/output for these functions. Further, opcode\\n/// packs are provided in rain that any inheriting contract can use as a normal\\n/// solidity library. See `MathOps.sol` opcode pack and the\\n/// `CalculatorTest.sol` test contract for an example of how to dispatch\\n/// opcodes and handle the results in a wrapping contract.\\n///\\n/// RainInterpreter natively has no concept of branching logic such as `if` or loops.\\n/// An opcode pack could implement these similar to the core zipmap by lazily\\n/// evaluating a source from `sources` based on some condition, etc. Instead\\n/// some simpler, eagerly evaluated selection tools such as `min` and `max` in\\n/// the `MathOps` opcode pack are provided. Future versions of `RainInterpreter` MAY\\n/// implement lazy `if` and other similar patterns.\\n///\\n/// The `eval` function is `view` because Rain expressions are expected to\\n/// compute results only without modifying any state. The contract wrapping the\\n/// Interpreter is free to mutate as usual. This model encourages exposing only\\n/// read-only functionality to end-user deployers who provide expressions to an\\n/// interpreter factory. Removing all writes removes a lot of potential\\n/// foot-guns for expression authors and allows contract authors to reason more\\n/// clearly about the input/output of the wrapping solidity code.\\n///\\n/// Internally `RainInterpreter` makes heavy use of unchecked math and assembly\\n/// logic as the opcode dispatch logic runs on a tight loop and so gas costs can\\n/// ramp up very quickly.\\nabstract contract RainInterpreter {\\n    using Math for uint256;\\n    using SaturatingMath for uint256;\\n    using LibCast for uint256;\\n    using LibInterpreterState for InterpreterState;\\n    using LibStackTop for uint256[];\\n    using LibStackTop for bytes;\\n    using LibStackTop for StackTop;\\n    using LibCast for function(InterpreterState memory, SourceIndex, StackTop)\\n        internal\\n        view\\n        returns (StackTop);\\n    using LibCast for function(InterpreterState memory, Operand, StackTop)\\n        internal\\n        view\\n        returns (StackTop)[];\\n    using LibConvert for uint256[];\\n    using LibInterpreterState for StateConfig;\\n\\n    /// Expose all the function pointers for every opcode as 2-byte pointers in\\n    /// a bytes list. The implementing Interpreter MUST ensure each pointer is\\n    /// to a `function(uint256,uint256) view returns (uint256)` function as this\\n    /// is the ONLY supported signature for opcodes. Pointers for the core\\n    /// opcodes must be provided in the packed pointers list but will be ignored\\n    /// at runtime.\\n    function opcodeFunctionPointers()\\n        internal\\n        view\\n        virtual\\n        returns (\\n            function(InterpreterState memory, Operand, StackTop)\\n                internal\\n                view\\n                returns (StackTop)[]\\n                memory\\n        );\\n\\n    /// Builds a new `State` bytes from `StateConfig`.\\n    /// Empty stack and arguments with stack index 0.\\n    /// @param config_ State config to build the new `State`.\\n    function buildStateBytes(\\n        IRainInterpreterIntegrity interpreterIntegrity_,\\n        StateConfig memory config_,\\n        uint[] memory minStackOutputs_\\n    ) internal view returns (bytes memory) {\\n        unchecked {\\n            (, uint256 stackLength_) = interpreterIntegrity_.ensureIntegrity(\\n                config_.sources,\\n                config_.constants.length,\\n                minStackOutputs_\\n            );\\n\\n            return\\n                config_.serialize(\\n                    stackLength_,\\n                    opcodeFunctionPointers()\\n                        .asUint256Array()\\n                        .unsafeTo16BitBytes()\\n                );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd5c680686bb532a56d10c1cdaa767ad9b9e6f30362ff47f248711b91bfbcf6b1\",\"license\":\"CAL\"},\"contracts/kv/LibMemoryKV.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../math/Binary.sol\\\";\\n\\ntype MemoryKV is uint;\\ntype MemoryKVKey is uint;\\ntype MemoryKVPtr is uint;\\ntype MemoryKVVal is uint;\\n\\nlibrary LibMemoryKV {\\n    function readPtrVal(MemoryKVPtr ptr_) internal pure returns (MemoryKVVal) {\\n        // This is ALWAYS a bug. It means the caller did not check if the ptr is\\n        // nonzero before trying to read from it.\\n        require(MemoryKVPtr.unwrap(ptr_) > 0, \\\"INVALID_PTR\\\");\\n        MemoryKVVal v_;\\n        assembly (\\\"memory-safe\\\") {\\n            v_ := mload(add(ptr_, 0x20))\\n        }\\n        return v_;\\n    }\\n\\n    function getPtr(\\n        MemoryKV kv_,\\n        MemoryKVKey k_\\n    ) internal pure returns (MemoryKVPtr) {\\n        uint mask_ = MASK_16BIT;\\n        MemoryKVPtr ptr_;\\n        assembly (\\\"memory-safe\\\") {\\n            // loop until k found or give up if ptr is zero\\n            for {\\n                ptr_ := and(kv_, mask_)\\n            } iszero(iszero(ptr_)) {\\n                ptr_ := mload(add(ptr_, 0x40))\\n            } {\\n                if eq(k_, mload(ptr_)) {\\n                    break\\n                }\\n            }\\n        }\\n        return ptr_;\\n    }\\n\\n    function setVal(\\n        MemoryKV kv_,\\n        MemoryKVKey k_,\\n        MemoryKVVal v_\\n    ) internal pure returns (MemoryKV) {\\n        MemoryKVPtr ptr_ = getPtr(kv_, k_);\\n        uint mask_ = MASK_16BIT;\\n        // update\\n        if (MemoryKVPtr.unwrap(ptr_) > 0) {\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(add(ptr_, 0x20), v_)\\n            }\\n        }\\n        // insert\\n        else {\\n            assembly (\\\"memory-safe\\\") {\\n                // allocate new memory\\n                ptr_ := mload(0x40)\\n                mstore(0x40, add(ptr_, 0x60))\\n                // set k/v/ptr\\n                mstore(ptr_, k_)\\n                mstore(add(ptr_, 0x20), v_)\\n                mstore(add(ptr_, 0x40), and(kv_, mask_))\\n                // kv must point to new insertion and update array len\\n                kv_ := or(\\n                    // inc len by 2\\n                    shl(16, add(shr(16, kv_), 2)),\\n                    // set ptr\\n                    ptr_\\n                )\\n            }\\n        }\\n        return kv_;\\n    }\\n\\n    function toUint256Array(\\n        MemoryKV kv_\\n    ) internal pure returns (uint[] memory) {\\n        unchecked {\\n            uint ptr_ = MemoryKV.unwrap(kv_) & MASK_16BIT;\\n            uint length_ = MemoryKV.unwrap(kv_) >> 16;\\n            uint[] memory arr_ = new uint[](length_);\\n            assembly (\\\"memory-safe\\\") {\\n                for {\\n                    let cursor_ := add(arr_, 0x20)\\n                    let end_ := add(cursor_, mul(mload(arr_), 0x20))\\n                } lt(cursor_, end_) {\\n                    cursor_ := add(cursor_, 0x20)\\n                    ptr_ := mload(add(ptr_, 0x40))\\n                } {\\n                    // key\\n                    mstore(cursor_, mload(ptr_))\\n                    cursor_ := add(cursor_, 0x20)\\n                    // value\\n                    mstore(cursor_, mload(add(ptr_, 0x20)))\\n                }\\n            }\\n            return arr_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x312fd2f1eddee6df3a2b94b3bbc5e159a940422e8c7dc2d636a55ba926fc2f83\",\"license\":\"CAL\"},\"contracts/math/Binary.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// @dev Binary 1.\\nuint constant B_1 = 2 ** 1 - 1;\\n/// @dev Binary 11.\\nuint constant B_11 = 2 ** 2 - 1;\\n/// @dev Binary 111.\\nuint constant B_111 = 2 ** 3 - 1;\\n/// @dev Binary 1111.\\nuint constant B_1111 = 2 ** 4 - 1;\\n/// @dev Binary 11111.\\nuint constant B_11111 = 2 ** 5 - 1;\\n/// @dev Binary 111111.\\nuint constant B_111111 = 2 ** 6 - 1;\\n/// @dev Binary 1111111.\\nuint constant B_1111111 = 2 ** 7 - 1;\\n/// @dev Binary 11111111.\\nuint constant B_11111111 = 2 ** 8 - 1;\\n/// @dev Binary 111111111.\\nuint constant B_111111111 = 2 ** 9 - 1;\\n/// @dev Binary 1111111111.\\nuint constant B_1111111111 = 2 ** 10 - 1;\\n/// @dev Binary 11111111111.\\nuint constant B_11111111111 = 2 ** 11 - 1;\\n/// @dev Binary 111111111111.\\nuint constant B_111111111111 = 2 ** 12 - 1;\\n/// @dev Binary 1111111111111.\\nuint constant B_1111111111111 = 2 ** 13 - 1;\\n/// @dev Binary 11111111111111.\\nuint constant B_11111111111111 = 2 ** 14 - 1;\\n/// @dev Binary 111111111111111.\\nuint constant B_111111111111111 = 2 ** 15 - 1;\\n/// @dev Binary 1111111111111111.\\nuint constant B_1111111111111111 = 2 ** 16 - 1;\\n\\n/// @dev Bitmask for 1 bit.\\nuint constant MASK_1BIT = B_1;\\n/// @dev Bitmask for 2 bits.\\nuint constant MASK_2BIT = B_11;\\n/// @dev Bitmask for 3 bits.\\nuint constant MASK_3BIT = B_111;\\n/// @dev Bitmask for 4 bits.\\nuint constant MASK_4BIT = B_1111;\\n/// @dev Bitmask for 5 bits.\\nuint constant MASK_5BIT = B_11111;\\n/// @dev Bitmask for 6 bits.\\nuint constant MASK_6BIT = B_111111;\\n/// @dev Bitmask for 7 bits.\\nuint constant MASK_7BIT = B_1111111;\\n/// @dev Bitmask for 8 bits.\\nuint constant MASK_8BIT = B_11111111;\\n/// @dev Bitmask for 9 bits.\\nuint constant MASK_9BIT = B_111111111;\\n/// @dev Bitmask for 10 bits.\\nuint constant MASK_10BIT = B_1111111111;\\n/// @dev Bitmask for 11 bits.\\nuint constant MASK_11BIT = B_11111111111;\\n/// @dev Bitmask for 12 bits.\\nuint constant MASK_12BIT = B_111111111111;\\n/// @dev Bitmask for 13 bits.\\nuint constant MASK_13BIT = B_1111111111111;\\n/// @dev Bitmask for 14 bits.\\nuint constant MASK_14BIT = B_11111111111111;\\n/// @dev Bitmask for 15 bits.\\nuint constant MASK_15BIT = B_111111111111111;\\n/// @dev Bitmask for 16 bits.\\nuint constant MASK_16BIT = B_1111111111111111;\\n\",\"keccak256\":\"0xb6b19cdc224817f0240f4452792570c812e299ae6c254cdb4c0f5f2766327b0c\",\"license\":\"CAL\"},\"contracts/math/SaturatingMath.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// @title SaturatingMath\\n/// @notice Sometimes we neither want math operations to error nor wrap around\\n/// on an overflow or underflow. In the case of transferring assets an error\\n/// may cause assets to be locked in an irretrievable state within the erroring\\n/// contract, e.g. due to a tiny rounding/calculation error. We also can't have\\n/// assets underflowing and attempting to approve/transfer \\\"infinity\\\" when we\\n/// wanted \\\"almost or exactly zero\\\" but some calculation bug underflowed zero.\\n/// Ideally there are no calculation mistakes, but in guarding against bugs it\\n/// may be safer pragmatically to saturate arithmatic at the numeric bounds.\\n/// Note that saturating div is not supported because 0/0 is undefined.\\nlibrary SaturatingMath {\\n    /// Saturating addition.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return Minimum of a_ + b_ and max uint256.\\n    function saturatingAdd(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 c_ = a_ + b_;\\n            return c_ < a_ ? type(uint256).max : c_;\\n        }\\n    }\\n\\n    /// Saturating subtraction.\\n    /// @param a_ Minuend.\\n    /// @param b_ Subtrahend.\\n    /// @return Maximum of a_ - b_ and 0.\\n    function saturatingSub(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            return a_ > b_ ? a_ - b_ : 0;\\n        }\\n    }\\n\\n    /// Saturating multiplication.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return Minimum of a_ * b_ and max uint256.\\n    function saturatingMul(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being\\n            // zero, but the benefit is lost if 'b' is also tested.\\n            // https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a_ == 0) return 0;\\n            uint256 c_ = a_ * b_;\\n            return c_ / a_ != b_ ? type(uint256).max : c_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5ffcfd7be86bf2a4e28bc55aceeae041b1c014e0a0d7394107238d607ace352a\",\"license\":\"CAL\"},\"contracts/memory/LibMemorySize.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.10;\\n\\n/// @title LibMemorySize\\n/// @notice Reports the size in bytes of type data that represents contigious\\n/// regions of memory. Pointers to regions of memory that may not be congigious\\n/// are not supported, e.g. fields on structs may point to dynamic data that is\\n/// separate to the struct. Length slots for dynamic data are included in the\\n/// size and the size is always measured in bytes.\\nlibrary LibMemorySize {\\n    /// Reports the size of a `uint256` in bytes. Is always 32.\\n    /// @return 32.\\n    function size(uint256) internal pure returns (uint256) {\\n        return 0x20;\\n    }\\n\\n    /// Reports the size of a `uint256[]` in bytes. Is the size of the length\\n    /// slot (32 bytes) plus the length of the array multiplied by 32 bytes per\\n    /// item.\\n    /// @return The size of the array data including its length slot size.\\n    function size(uint256[] memory array_) internal pure returns (uint256) {\\n        unchecked {\\n            return 0x20 + (array_.length * 0x20);\\n        }\\n    }\\n\\n    /// Reports the size of `bytes` data. Is the size of the length slot\\n    /// (32 bytes) plus the number of bytes as per its length.\\n    /// @return The size of the `bytes` data including its length slot size.\\n    function size(bytes memory bytes_) internal pure returns (uint256) {\\n        unchecked {\\n            return 0x20 + bytes_.length;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8d83afcdf42bce8f16b93f7c00f7059e02d86234e78f97ed9d2e19651da616d5\",\"license\":\"CAL\"},\"contracts/sentinel/LibSentinel.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nbytes32 constant SENTINEL_HIGH_BITS = bytes32(\\n    0xF000000000000000000000000000000000000000000000000000000000000000\\n);\\n\",\"keccak256\":\"0xd25db816643a702af32a6e0b14bc4ec4ed1acc7cb81c2e7c99f5bec324761c52\",\"license\":\"CAL\"},\"contracts/sstore2/SSTORE2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport \\\"./utils/Bytecode.sol\\\";\\n\\n/**\\n  @title A key-value storage with auto-generated keys for storing chunks of\\n  data with a lower write & read cost.\\n  @author Agustin Aguilar <aa@horizon.io>\\n\\n  Readme: https://github.com/0xsequence/sstore2#readme\\n*/\\nlibrary SSTORE2 {\\n    error WriteError();\\n\\n    /**\\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\\n    @dev The pointer is a contract address with `_data` as code\\n    @param _data to be written\\n    @return pointer Pointer to the written `_data`\\n  */\\n    function write(bytes memory _data) internal returns (address pointer) {\\n        // Append 00 to _data so contract can't be called\\n        // Build init code\\n        bytes memory code = Bytecode.creationCodeFor(\\n            abi.encodePacked(hex\\\"00\\\", _data)\\n        );\\n\\n        // Deploy contract using create\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := create(0, add(code, 32), mload(code))\\n        }\\n\\n        // Address MUST be non-zero\\n        if (pointer == address(0)) revert WriteError();\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first\\n    byte\\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @return data read from `_pointer` contract\\n  */\\n    function read(address _pointer) internal view returns (bytes memory) {\\n        return Bytecode.codeAt(_pointer, 1, type(uint256).max);\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first\\n    byte\\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @param _start number of bytes to skip\\n    @return data read from `_pointer` contract\\n  */\\n    function read(\\n        address _pointer,\\n        uint256 _start\\n    ) internal view returns (bytes memory) {\\n        return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first\\n    byte\\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @param _start number of bytes to skip\\n    @param _end index before which to end extraction\\n    @return data read from `_pointer` contract\\n  */\\n    function read(\\n        address _pointer,\\n        uint256 _start,\\n        uint256 _end\\n    ) internal view returns (bytes memory) {\\n        return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\\n    }\\n}\\n\",\"keccak256\":\"0x86864b4de9a76a67da6c19fd1f921e08bb5c31de2eddef161117e4a8aea97ddd\",\"license\":\"MIT\"},\"contracts/sstore2/utils/Bytecode.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nlibrary Bytecode {\\n    error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\\n\\n    /**\\n    @notice Generate a creation code that results on a contract with `_code` as\\n    bytecode\\n    @param _code The returning value of the resulting `creationCode`\\n    @return creationCode (constructor) for new contract\\n  */\\n    function creationCodeFor(\\n        bytes memory _code\\n    ) internal pure returns (bytes memory) {\\n        /*\\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\\n      0x01    0x80         0x80        DUP1                size size\\n      0x02    0x60         0x600e      PUSH1 14            14 size size\\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\\n      0x04    0x39         0x39        CODECOPY            size\\n      0x05    0x60         0x6000      PUSH1 00            0 size\\n      0x06    0xf3         0xf3        RETURN\\n      <CODE>\\n    */\\n\\n        return\\n            abi.encodePacked(\\n                hex\\\"63\\\",\\n                uint32(_code.length),\\n                hex\\\"80_60_0E_60_00_39_60_00_F3\\\",\\n                _code\\n            );\\n    }\\n\\n    /**\\n    @notice Returns the size of the code on a given address\\n    @param _addr Address that may or may not contain code\\n    @return size of the code on the given `_addr`\\n  */\\n    function codeSize(address _addr) internal view returns (uint256 size) {\\n        assembly (\\\"memory-safe\\\") {\\n            size := extcodesize(_addr)\\n        }\\n    }\\n\\n    /**\\n    @notice Returns the code of a given address\\n    @dev It will fail if `_end < _start`\\n    @param _addr Address that may or may not contain code\\n    @param _start number of bytes of code to skip on read\\n    @param _end index before which to end extraction\\n    @return oCode read from `_addr` deployed bytecode\\n\\n    Forked: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\\n  */\\n    function codeAt(\\n        address _addr,\\n        uint256 _start,\\n        uint256 _end\\n    ) internal view returns (bytes memory oCode) {\\n        uint256 csize = codeSize(_addr);\\n        if (csize == 0) return bytes(\\\"\\\");\\n\\n        if (_start > csize) return bytes(\\\"\\\");\\n        if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end);\\n\\n        unchecked {\\n            uint256 reqSize = _end - _start;\\n            uint256 maxSize = csize - _start;\\n\\n            uint256 size = maxSize < reqSize ? maxSize : reqSize;\\n\\n            assembly (\\\"memory-safe\\\") {\\n                // allocate output byte array - this could also be done without\\n                // assembly\\n                // by using o_code = new bytes(size)\\n                oCode := mload(0x40)\\n                // new \\\"memory end\\\" including padding\\n                mstore(\\n                    0x40,\\n                    add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f)))\\n                )\\n                // store length in memory\\n                mstore(oCode, size)\\n                // actually retrieve the code, this needs assembly\\n                extcodecopy(_addr, add(oCode, 0x20), _start, size)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x81b3a2d7c4ca79e6a6e8d097ce05e20432485d9603f2e651f83da90006e6ebc9\",\"license\":\"MIT\"},\"contracts/type/LibCast.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../interpreter/run/LibStackTop.sol\\\";\\nimport \\\"../interpreter/run/LibInterpreterState.sol\\\";\\nimport \\\"../interpreter/deploy/LibIntegrityState.sol\\\";\\nimport \\\"../interpreter/run/RainInterpreter.sol\\\";\\n\\n/// @title LibCast\\n/// @notice Additional type casting logic that the Solidity compiler doesn't\\n/// give us by default. A type cast (vs. conversion) is considered one where the\\n/// structure is unchanged by the cast. The cast does NOT (can't) check that the\\n/// input is a valid output, for example any integer MAY be cast to a function\\n/// pointer but almost all integers are NOT valid function pointers. It is the\\n/// calling context that MUST ensure the validity of the data, the cast will\\n/// merely retype the data in place, generally without additional checks.\\n/// As most structures in solidity have the same memory structure as a `uint256`\\n/// or fixed/dynamic array of `uint256` there are many conversions that can be\\n/// done with near zero or minimal overhead.\\nlibrary LibCast {\\n    /// Retype an integer to an opcode function pointer.\\n    /// @param u_ The integer to cast to an opcode function pointer.\\n    /// @return fn_ The opcode function pointer.\\n    function asOpFunctionPointer(\\n        uint256 u_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(InterpreterState memory, Operand, StackTop)\\n                view\\n                returns (StackTop) fn_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fn_ := u_\\n        }\\n    }\\n\\n    /// Retype an array of integers to an array of opcode function pointers.\\n    /// @param us_ The array of integers to cast to an array of opcode fuction\\n    /// pointers.\\n    /// @return fns_ The array of opcode function pointers.\\n    function asOpcodeFunctionPointers(\\n        uint256[] memory us_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(InterpreterState memory, Operand, StackTop)\\n                view\\n                returns (StackTop)[]\\n                memory fns_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fns_ := us_\\n        }\\n    }\\n\\n    /// Retype an integer to an integrity function pointer.\\n    /// @param u_ The integer to cast to an integrity function pointer.\\n    /// @return fn_ The integrity function pointer.\\n    function asIntegrityFunctionPointer(\\n        uint256 u_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(IntegrityState memory, Operand, StackTop)\\n                internal\\n                view\\n                returns (StackTop) fn_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fn_ := u_\\n        }\\n    }\\n\\n    /// Retype an integer to a pointer to the interpreter eval function.\\n    /// @param u_ The integer to cast to the eval function.\\n    /// @return fn_ The eval function.\\n    function asEvalFunctionPointer(\\n        uint256 u_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(InterpreterState memory, SourceIndex, StackTop)\\n                view\\n                returns (StackTop) fn_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fn_ := u_\\n        }\\n    }\\n\\n    /// Retype a stack move function pointer to an integer.\\n    /// Provided the origin of the function pointer is solidity and NOT yul, the\\n    /// returned integer will be valid to run if retyped back via yul. If the\\n    /// origin of the function pointer is yul then we cannot guarantee anything\\n    /// about the validity beyond the correctness of the yul code in question.\\n    ///\\n    /// Function pointers as integers are NOT portable across contracts as the\\n    /// code in different contracts is different so function pointers will point\\n    /// to a different, incompatible part of the code.\\n    ///\\n    /// Function pointers as integers lose the information about their signature\\n    /// so MUST ONLY be called in an appropriate context once restored.\\n    /// @param fn_ The stack move function pointer to integerify.\\n    /// @return u_ The integer of the function pointer.\\n    function asUint256(\\n        function(uint256) view returns (uint256) fn_\\n    ) internal pure returns (uint256 u_) {\\n        assembly (\\\"memory-safe\\\") {\\n            u_ := fn_\\n        }\\n    }\\n\\n    function asUint256(\\n        function(IntegrityState memory, Operand, StackTop)\\n            internal\\n            view\\n            returns (StackTop) fn_\\n    ) internal pure returns (uint256 u_) {\\n        assembly (\\\"memory-safe\\\") {\\n            u_ := fn_\\n        }\\n    }\\n\\n    function asUint256Array(\\n        function(IntegrityState memory, Operand, StackTop)\\n            internal\\n            view\\n            returns (StackTop)[]\\n            memory fns_\\n    ) internal pure returns (uint256[] memory us_) {\\n        assembly (\\\"memory-safe\\\") {\\n            us_ := fns_\\n        }\\n    }\\n\\n    function asUint256(bool bool_) internal pure returns (uint256 u_) {\\n        assembly (\\\"memory-safe\\\") {\\n            u_ := bool_\\n        }\\n    }\\n\\n    function asUint256(\\n        function(InterpreterState memory, SourceIndex, StackTop)\\n            view\\n            returns (StackTop) fn_\\n    ) internal pure returns (uint256 u_) {\\n        assembly (\\\"memory-safe\\\") {\\n            u_ := fn_\\n        }\\n    }\\n\\n    function asUint256Array(\\n        function(InterpreterState memory, Operand, StackTop)\\n            view\\n            returns (StackTop)[]\\n            memory fns_\\n    ) internal pure returns (uint256[] memory us_) {\\n        assembly (\\\"memory-safe\\\") {\\n            us_ := fns_\\n        }\\n    }\\n\\n    function asUint256Array(\\n        function(uint256) pure returns (uint256)[] memory fns_\\n    ) internal pure returns (uint256[] memory us_) {\\n        assembly (\\\"memory-safe\\\") {\\n            us_ := fns_\\n        }\\n    }\\n\\n    function asAddresses(\\n        uint256[] memory us_\\n    ) internal pure returns (address[] memory addresses_) {\\n        assembly (\\\"memory-safe\\\") {\\n            addresses_ := us_\\n        }\\n    }\\n\\n    function asIntegrityPointers(\\n        uint256[] memory us_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(IntegrityState memory, Operand, StackTop)\\n                view\\n                returns (StackTop)[]\\n                memory fns_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fns_ := us_\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x54b89011034a91d942cc1657759a77e01398af8d60f6b0ae75b7fc43f429952d\",\"license\":\"CAL\"},\"contracts/type/LibConvert.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// @title LibConvert\\n/// @notice Type conversions that require additional structural changes to\\n/// complete safely. These are NOT mere type casts and involve additional\\n/// reads and writes to complete, such as recalculating the length of an array.\\n/// The convention \\\"toX\\\" is adopted from Rust to imply the additional costs and\\n/// consumption of the source to produce the target.\\nlibrary LibConvert {\\n    /// Convert an array of integers to `bytes` data. This requires modifying\\n    /// the length in situ as the integer array length is measured in 32 byte\\n    /// increments while the length of `bytes` is the literal number of bytes.\\n    /// @return bytes_ The integer array converted to `bytes` data.\\n    function toBytes(\\n        uint256[] memory is_\\n    ) internal pure returns (bytes memory bytes_) {\\n        assembly (\\\"memory-safe\\\") {\\n            bytes_ := is_\\n            // Length in bytes is 32x the length in uint256\\n            mstore(bytes_, mul(0x20, mload(bytes_)))\\n        }\\n    }\\n\\n    function unsafeTo16BitBytes(\\n        uint256[] memory is_\\n    ) internal pure returns (bytes memory) {\\n        unchecked {\\n            // We will keep 2 bytes (16 bits) from each integer.\\n            bytes memory bytes_ = new bytes(is_.length * 2);\\n            assembly (\\\"memory-safe\\\") {\\n                let replaceMask_ := 0xFFFF\\n                let preserveMask_ := not(replaceMask_)\\n                for {\\n                    let cursor_ := add(is_, 0x20)\\n                    let end_ := add(cursor_, mul(mload(is_), 0x20))\\n                    let bytesCursor_ := add(bytes_, 0x02)\\n                } lt(cursor_, end_) {\\n                    cursor_ := add(cursor_, 0x20)\\n                    bytesCursor_ := add(bytesCursor_, 0x02)\\n                } {\\n                    let data_ := mload(bytesCursor_)\\n                    mstore(\\n                        bytesCursor_,\\n                        or(and(preserveMask_, data_), mload(cursor_))\\n                    )\\n                }\\n            }\\n            return bytes_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x24554781af9e5a79f0405133741bd4890bef21e6c63c4587d90659d5803bdcb0\",\"license\":\"CAL\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x60b0215121bf25612a6739fb2f1ec35f31ee82e4a8216c032c8243d904ab3aa9\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b50610019610099565b600060405161002790610159565b604051809103906000f080158015610043573d6000803e3d6000fd5b50604080513381526001600160a01b03831660208201529192507f7fac34ecf0b1b374cd9659e3d17db602659d53f1162b1f20142e6c02694aed70910160405180910390a16001600160a01b0316608052610166565b600054610100900460ff16156101055760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b60005460ff9081161015610157576000805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b61381280610fea83390190565b608051610e63610187600039600081816093015261030a0152610e636000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c80632ea72a49146100515780635c60da1b1461008e578063745e1b1b146100b5578063fc91a897146100c8575b600080fd5b61006461005f366004610605565b610111565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b6100647f000000000000000000000000000000000000000000000000000000000000000081565b6100646100c33660046107d1565b6102ba565b6101016100d6366004610927565b73ffffffffffffffffffffffffffffffffffffffff1660009081526033602052604090205460ff1690565b6040519015158152602001610085565b6000600260015403610184576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064015b60405180910390fd5b60026001556000610194836102ea565b73ffffffffffffffffffffffffffffffffffffffff811660009081526033602052604090205490915060ff1615610227576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f4455504c49434154455f4348494c440000000000000000000000000000000000604482015260640161017b565b73ffffffffffffffffffffffffffffffffffffffff811660008181526033602090815260409182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790558151338152908101929092527f7da70c4e5387d7038610b79ca7d304caaef815826e51e67cf247135387a79bce910160405180910390a16001805592915050565b60006102e4826040516020016102d09190610a7d565b604051602081830303815290604052610111565b92915050565b600080828060200190518101906103019190610cf0565b9050600061032e7f00000000000000000000000000000000000000000000000000000000000000006103bd565b6040517f81e6a71100000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff8216906381e6a71190610383908590600401610a7d565b600060405180830381600087803b15801561039d57600080fd5b505af11580156103b1573d6000803e3d6000fd5b50929695505050505050565b60006040517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081528260601b60148201527f5af43d82803e903d91602b57fd5bf3000000000000000000000000000000000060288201526037816000f091505073ffffffffffffffffffffffffffffffffffffffff811661049a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f455243313136373a20637265617465206661696c656400000000000000000000604482015260640161017b565b919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156104f1576104f161049f565b60405290565b6040516060810167ffffffffffffffff811182821017156104f1576104f161049f565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156105615761056161049f565b604052919050565b600067ffffffffffffffff8211156105835761058361049f565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b600082601f8301126105c057600080fd5b81356105d36105ce82610569565b61051a565b8181528460208386010111156105e857600080fd5b816020850160208301376000918101602001919091529392505050565b60006020828403121561061757600080fd5b813567ffffffffffffffff81111561062e57600080fd5b61063a848285016105af565b949350505050565b600067ffffffffffffffff82111561065c5761065c61049f565b5060051b60200190565b600082601f83011261067757600080fd5b813560206106876105ce83610642565b82815260059290921b840181019181810190868411156106a657600080fd5b8286015b848110156106c157803583529183019183016106aa565b509695505050505050565b6000604082840312156106de57600080fd5b6106e66104ce565b9050813567ffffffffffffffff8082111561070057600080fd5b818401915084601f83011261071457600080fd5b813560206107246105ce83610642565b82815260059290921b8401810191818101908884111561074357600080fd5b8286015b8481101561077b5780358681111561075f5760008081fd5b61076d8b86838b01016105af565b845250918301918301610747565b508652508581013593508284111561079257600080fd5b61079e87858801610666565b818601525050505092915050565b73ffffffffffffffffffffffffffffffffffffffff811681146107ce57600080fd5b50565b600060208083850312156107e457600080fd5b823567ffffffffffffffff808211156107fc57600080fd5b908401906040828703121561081057600080fd5b6108186104ce565b82358281111561082757600080fd5b610833888286016106cc565b825250838301358281111561084757600080fd5b92909201916060838803121561085c57600080fd5b6108646104f7565b833561086f816107ac565b81528385013561087e816107ac565b8186015260408401358381111561089457600080fd5b80850194505087601f8501126108a957600080fd5b83356108b76105ce82610642565b81815260059190911b8501860190868101908a8311156108d657600080fd5b8787015b8381101561090e578035878111156108f25760008081fd5b6109008d8b838c01016106cc565b8452509188019188016108da565b5060408401525050938101939093525090949350505050565b60006020828403121561093957600080fd5b8135610944816107ac565b9392505050565b60005b8381101561096657818101518382015260200161094e565b50506000910152565b600081518084526020808501945080840160005b8381101561099f57815187529582019590820190600101610983565b509495945050505050565b60006040830182516040855281815180845260608701915060608160051b88010193506020808401935060005b82811015610a59577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa089870301845284518051808852610a1c81858a0186850161094b565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016969096018201955093810193928101926001016109d7565b5080870151935087850381890152505050610a74828261096f565b95945050505050565b600060208083528351604082850152610a9960608501826109aa565b9050818501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08583030160408601526060820173ffffffffffffffffffffffffffffffffffffffff8083511684528085840151168585015250604082015191506060604084015280825180835260808501915060808160051b8601019250858401935060005b81811015610b6c577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80868503018352610b5a8486516109aa565b94870194935091860191600101610b20565b509198975050505050505050565b600082601f830112610b8b57600080fd5b81516020610b9b6105ce83610642565b82815260059290921b84018101918181019086841115610bba57600080fd5b8286015b848110156106c15780518352918301918301610bbe565b60006040808385031215610be857600080fd5b610bf06104ce565b9150825167ffffffffffffffff80821115610c0a57600080fd5b818501915085601f830112610c1e57600080fd5b81516020610c2e6105ce83610642565b82815260059290921b84018101918181019089841115610c4d57600080fd5b8286015b84811015610cbe57805186811115610c695760008081fd5b8701603f81018c13610c7b5760008081fd5b84810151610c8b6105ce82610569565b8181528d8b838501011115610ca05760008081fd5b610caf828883018d860161094b565b85525050918301918301610c51565b5087525086810151945082851115610cd557600080fd5b610ce188868901610b7a565b81870152505050505092915050565b60006020808385031215610d0357600080fd5b825167ffffffffffffffff80821115610d1b57600080fd5b9084019060408287031215610d2f57600080fd5b610d376104ce565b825182811115610d4657600080fd5b610d5288828601610bd5565b8252508383015182811115610d6657600080fd5b929092019160608388031215610d7b57600080fd5b610d836104f7565b8351610d8e816107ac565b815283850151610d9d816107ac565b81860152604084015183811115610db357600080fd5b80850194505087601f850112610dc857600080fd5b8351610dd66105ce82610642565b81815260059190911b8501860190868101908a831115610df557600080fd5b8787015b8381101561090e57805187811115610e115760008081fd5b610e1f8d8b838c0101610bd5565b845250918801918801610df956fea26469706673582212206a85797bf8c3956f5119699558478b79545d485828f06ace94403fa0282e13b864736f6c6343000811003360806040523480156200001157600080fd5b506200001c62000022565b620000e4565b600054610100900460ff16156200008f5760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b60005460ff9081161015620000e2576000805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b61371e80620000f46000396000f3fe60806040526004361061007f5760003560e01c8063a81db8f01161004e578063a81db8f014610184578063ac9650d814610197578063bc197c81146101c4578063f23a6e611461020957600080fd5b806301ffc9a71461008b578063150b7a02146100c057806371a4ddab1461013557806381e6a7111461016257600080fd5b3661008657005b600080fd5b34801561009757600080fd5b506100ab6100a636600461246d565b61024e565b60405190151581526020015b60405180910390f35b3480156100cc57600080fd5b506101046100db36600461262c565b7f150b7a0200000000000000000000000000000000000000000000000000000000949350505050565b6040517fffffffff0000000000000000000000000000000000000000000000000000000090911681526020016100b7565b34801561014157600080fd5b50610155610150366004612727565b6102e7565b6040516100b79190612967565b34801561016e57600080fd5b5061018261017d366004612a5c565b61032b565b005b610182610192366004612727565b610514565b3480156101a357600080fd5b506101b76101b2366004612a97565b6105c9565b6040516100b79190612bcf565b3480156101d057600080fd5b506101046101df366004612be2565b7fbc197c810000000000000000000000000000000000000000000000000000000095945050505050565b34801561021557600080fd5b50610104610224366004612c90565b7ff23a6e610000000000000000000000000000000000000000000000000000000095945050505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f4e2312e00000000000000000000000000000000000000000000000000000000014806102e157507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b6103126040518060800160405280606081526020016060815260200160608152602001606081525090565b600061031f8585856106be565b509150505b9392505050565b600054610100900460ff161580801561034b5750600054600160ff909116105b806103655750303b158015610365575060005460ff166001145b6103f6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a656400000000000000000000000000000000000060648201526084015b60405180910390fd5b600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00166001179055801561045457600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff166101001790555b6104746104646020840184612cf9565b61046d90612d37565b6004610718565b7fb8d34ea9112583c0d2407f9fed96f7cead0ef0015a7c3e6da620e7b95e13eb8d33836040516104a5929190613131565b60405180910390a1801561051057600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5050565b600260015403610580576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016103ed565b60026001556000806105938585856106be565b61012d5491935091506105be90839073ffffffffffffffffffffffffffffffffffffffff16836109eb565b505060018055505050565b60608167ffffffffffffffff8111156105e4576105e46124d4565b60405190808252806020026020018201604052801561061757816020015b60608152602001906001900390816106025790505b50905060005b828110156106b7576106873085858481811061063b5761063b613292565b905060200281019061064d91906132c1565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610a9b92505050565b82828151811061069957610699613292565b602002602001018190525080806106af90613326565b91505061061d565b5092915050565b6106e96040518060800160405280606081526020016060815260200160608152602001606081525090565b606060008060006106fb888888610bda565b92509250925061070b8383610fb3565b9890975095505050505050565b600054610100900460ff166107af576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e6700000000000000000000000000000000000000000060648201526084016103ed565b6107b76111bf565b6107bf6111bf565b6107c76111bf565b6004811015610832576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f424144204d494e20535441434b53204c454e475448000000000000000000000060448201526064016103ed565b602082015161012d80547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff90921691909117905560005b8260400151518110156109e6576000836000015173ffffffffffffffffffffffffffffffffffffffff16631ed061d9856040015184815181106108c4576108c4613292565b60200260200101516108d586611258565b6040518363ffffffff1660e01b81526004016108f29291906133b5565b60408051808303816000875af1158015610910573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109349190613420565b5090506000602082901b77ffffffffffffffffffffffffffffffffffffffff000000001661ffff17600081815261012e60209081526040918290206001905587810151825133815273ffffffffffffffffffffffffffffffffffffffff909116918101919091529081018290529091507f0392789afa55e5b564b41f5e52285c849fc771b31ccc0e222999b6de72bc55949060600160405180910390a1505080806109de90613326565b91505061087f565b505050565b805115610a77576040517fce0dd62800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83169063ce0dd62890610a4490849060040161344e565b600060405180830381600087803b158015610a5e57600080fd5b505af1158015610a72573d6000803e3d6000fd5b505050505b610a808361128a565b610a89836114be565b610a928361164c565b6109e683611809565b606073ffffffffffffffffffffffffffffffffffffffff83163b610b41576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e7472616374000000000000000000000000000000000000000000000000000060648201526084016103ed565b6000808473ffffffffffffffffffffffffffffffffffffffff1684604051610b699190613461565b600060405180830381855af49150503d8060008114610ba4576040519150601f19603f3d011682016040523d82523d6000602084013e610ba9565b606091505b5091509150610bd182826040518060600160405280602781526020016136c2602791396119e5565b95945050505050565b60008060606000610beb8787611a38565b90506000855167ffffffffffffffff811115610c0957610c096124d4565b604051908082528060200260200182016040528015610c32578160200160208202803683370190505b5090506000865160020167ffffffffffffffff811115610c5457610c546124d4565b604051908082528060200260200182016040528015610c8757816020015b6060815260200190600190039081610c725790505b50905060005b8751811015610e8757878181518110610ca857610ca8613292565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff16838281518110610cdc57610cdc613292565b602002602001018181525050610ddb888281518110610cfd57610cfd613292565b602002602001015160000151610db88a8481518110610d1e57610d1e613292565b602002602001015160400151604051602001610d3a9190613473565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815282825280516020918201207f19457468657265756d205369676e6564204d6573736167653a0a33320000000084830152603c8085019190915282518085039091018152605c909301909152815191012090565b8a8481518110610dca57610dca613292565b602002602001015160200151611abb565b610e41576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f494e56414c49445f5349474e415455524500000000000000000000000000000060448201526064016103ed565b878181518110610e5357610e53613292565b602002602001015160400151828260020181518110610e7457610e74613292565b6020908102919091010152600101610c8d565b508281600081518110610e9c57610e9c613292565b60200260200101819052508181600181518110610ebb57610ebb613292565b602090810291909101015261012d546040517f90e7d00b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff90911690600090819083906390e7d00b90610f26908f9088906004016134a9565b600060405180830381865afa158015610f43573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052610f89919081019061358c565b91509150610f978260200190565b8251909d6020918202909301019b509950975050505050505050565b610fde6040518060800160405280606081526020016060815260200160608152602001606081525090565b6110096040518060800160405280606081526020016060815260200160608152602001606081525090565b60408051808201909152601281527f5241494e5f464c4f575f53454e54494e454c0000000000000000000000000000602090910152606061106d84867ffea74d0c9bf4a3c28f0dd0674db22a3d7f8bf259c56af19f4ac1e735b156974f6003611c88565b80845260408051808201909152601281527f5241494e5f464c4f575f53454e54494e454c000000000000000000000000000060209091015290945090506110d784867ffea74d0c9bf4a3c28f0dd0674db22a3d7f8bf259c56af19f4ac1e735b156974f6004611c88565b602084810182905260408051808201909152601281527f5241494e5f464c4f575f53454e54494e454c0000000000000000000000000000910152909450905061114384867ffea74d0c9bf4a3c28f0dd0674db22a3d7f8bf259c56af19f4ac1e735b156974f6004611c88565b60408481018290528051808201909152601281527f5241494e5f464c4f575f53454e54494e454c000000000000000000000000000060209091015290945090506111b084867ffea74d0c9bf4a3c28f0dd0674db22a3d7f8bf259c56af19f4ac1e735b156974f6005611c88565b60608401525090949350505050565b600054610100900460ff16611256576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e6700000000000000000000000000000000000000000060648201526084016103ed565b565b604080516001808252818301909252606091600091906020808301908036833750505060208101939093525090919050565b60408051606081018252600080825260208201819052918101829052819060005b8451518110156114995784518051829081106112c9576112c9613292565b602002602001015191503373ffffffffffffffffffffffffffffffffffffffff16826000015173ffffffffffffffffffffffffffffffffffffffff160361139b57602082015173ffffffffffffffffffffffffffffffffffffffff16301461138d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f554e535550504f525445445f4e41544956455f464c4f5700000000000000000060448201526064016103ed565b816040015184019350611491565b815173ffffffffffffffffffffffffffffffffffffffff16301461141b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f554e535550504f525445445f4e41544956455f464c4f5700000000000000000060448201526064016103ed565b3373ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff160361146057816040015183019250611491565b6114918260400151836020015173ffffffffffffffffffffffffffffffffffffffff16611d3a90919063ffffffff16565b6001016112ab565b5082156114a857823403820191505b81156114b8576114b83383611d3a565b50505050565b6040805160808101825260008082526020820181905291810182905260608101829052905b8260200151518110156109e6578260200151818151811061150657611506613292565b602002602001015191503373ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff160361157d576040820151606083015183516115789273ffffffffffffffffffffffffffffffffffffffff90911691339190611e94565b611644565b3073ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff16036115e2576040820151606083015183516115789273ffffffffffffffffffffffffffffffffffffffff90911691611f70565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f554e535550504f525445445f45524332305f464c4f570000000000000000000060448201526064016103ed565b6001016114e3565b6040805160808101825260008082526020820181905291810182905260608101829052905b8260400151518110156109e6578260400151818151811061169457611694613292565b602002602001015191503373ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff1614806116f55750602082015173ffffffffffffffffffffffffffffffffffffffff1630145b61175b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f554e535550504f525445445f4552433732315f464c4f5700000000000000000060448201526064016103ed565b81516020830151604080850151606086015191517f42842e0e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9384166004820152908316602482015260448101919091529116906342842e0e90606401600060405180830381600087803b1580156117e557600080fd5b505af11580156117f9573d6000803e3d6000fd5b5050600190920191506116719050565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101829052905b8260600151518110156109e6578260600151818151811061185857611858613292565b602002602001015191503373ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff1614806118b95750602082015173ffffffffffffffffffffffffffffffffffffffff1630145b61191f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f554e535550504f525445445f455243313135355f464c4f57000000000000000060448201526064016103ed565b815160208301516040808501516060860151608087015192517ff242432a00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff948516600482015291841660248301526044820152606481019190915260a06084820152600060a482015291169063f242432a9060c401600060405180830381600087803b1580156119c157600080fd5b505af11580156119d5573d6000803e3d6000fd5b5050600190920191506118359050565b606083156119f4575081610324565b825115611a045782518084602001fd5b816040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103ed91906135f0565b600082815261012e6020526040902054606090611ab1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f554e524547495354455245445f464c4f5700000000000000000000000000000060448201526064016103ed565b6103243383611fc6565b6000806000611aca8585611ffa565b90925090506000816004811115611ae357611ae3613603565b148015611b1b57508573ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b15611b2b57600192505050610324565b6000808773ffffffffffffffffffffffffffffffffffffffff16631626ba7e60e01b8888604051602401611b60929190613632565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909416939093179092529051611be99190613461565b600060405180830381855afa9150503d8060008114611c24576040519150601f19603f3d011682016040523d82523d6000602084013e611c29565b606091505b5091509150818015611c3c575080516020145b8015611c7c575080517f1626ba7e0000000000000000000000000000000000000000000000000000000090611c7a908301602090810190840161364b565b145b98975050505050505050565b6000606080611c998787878761203f565b80519198509150600090611cae908690613664565b905060008167ffffffffffffffff811115611ccb57611ccb6124d4565b604051908082528060200260200182016040528015611cf4578160200160208202803683370190505b5090506020810160208302810160208501602089025b82841015611d245781845260209093019290810190611d0a565b508b975092955050505050505b94509492505050565b80471015611da4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a20696e73756666696369656e742062616c616e636500000060448201526064016103ed565b60008273ffffffffffffffffffffffffffffffffffffffff168260405160006040518083038185875af1925050503d8060008114611dfe576040519150601f19603f3d011682016040523d82523d6000602084013e611e03565b606091505b50509050806109e6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f416464726573733a20756e61626c6520746f2073656e642076616c75652c207260448201527f6563697069656e74206d6179206861766520726576657274656400000000000060648201526084016103ed565b60405173ffffffffffffffffffffffffffffffffffffffff808516602483015283166044820152606481018290526114b89085907f23b872dd00000000000000000000000000000000000000000000000000000000906084015b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff000000000000000000000000000000000000000000000000000000009093169290921790915261209f565b60405173ffffffffffffffffffffffffffffffffffffffff83166024820152604481018290526109e69084907fa9059cbb0000000000000000000000000000000000000000000000000000000090606401611eee565b6040805160028082526060808301845292600092919060208301908036833750505060208101949094525050604082015290565b60008082516041036120305760208301516040840151606085015160001a612024878285856121ab565b94509450505050612038565b506000905060025b9250929050565b60006060808561204e57600080fd5b6000806020860260208a039950602089035b808b1115612086578a518903612078578a9350612086565b998190039991870191612060565b50508161209257600080fd5b8152969795505050505050565b6000612101826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65648152508573ffffffffffffffffffffffffffffffffffffffff166122c09092919063ffffffff16565b8051909150156109e6578080602001905181019061211f919061369f565b6109e6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016103ed565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08311156121e25750600090506003611d31565b8460ff16601b141580156121fa57508460ff16601c14155b1561220b5750600090506004611d31565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa15801561225f573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff81166122b357600060019250925050611d31565b9660009650945050505050565b60606122cf84846000856122d7565b949350505050565b606082471015612369576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016103ed565b73ffffffffffffffffffffffffffffffffffffffff85163b6123e7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016103ed565b6000808673ffffffffffffffffffffffffffffffffffffffff1685876040516124109190613461565b60006040518083038185875af1925050503d806000811461244d576040519150601f19603f3d011682016040523d82523d6000602084013e612452565b606091505b50915091506124628282866119e5565b979650505050505050565b60006020828403121561247f57600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461032457600080fd5b73ffffffffffffffffffffffffffffffffffffffff811681146124d157600080fd5b50565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516060810167ffffffffffffffff81118282101715612526576125266124d4565b60405290565b6040805190810167ffffffffffffffff81118282101715612526576125266124d4565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715612596576125966124d4565b604052919050565b600082601f8301126125af57600080fd5b813567ffffffffffffffff8111156125c9576125c96124d4565b6125fa60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160161254f565b81815284602083860101111561260f57600080fd5b816020850160208301376000918101602001919091529392505050565b6000806000806080858703121561264257600080fd5b843561264d816124af565b9350602085013561265d816124af565b925060408501359150606085013567ffffffffffffffff81111561268057600080fd5b61268c8782880161259e565b91505092959194509250565b600067ffffffffffffffff8211156126b2576126b26124d4565b5060051b60200190565b600082601f8301126126cd57600080fd5b813560206126e26126dd83612698565b61254f565b82815260059290921b8401810191818101908684111561270157600080fd5b8286015b8481101561271c5780358352918301918301612705565b509695505050505050565b60008060006060848603121561273c57600080fd5b833592506020808501359250604085013567ffffffffffffffff8082111561276357600080fd5b818701915087601f83011261277757600080fd5b81356127856126dd82612698565b81815260059190911b8301840190848101908a8311156127a457600080fd5b8585015b83811015612867578035858111156127c05760008081fd5b86016060818e037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe00112156127f55760008081fd5b6127fd612503565b8882013561280a816124af565b815260408201358781111561281f5760008081fd5b61282d8f8b8386010161259e565b8a830152506060820135878111156128455760008081fd5b6128538f8b838601016126bc565b6040830152508452509186019186016127a8565b508096505050505050509250925092565b600081518084526020808501945080840160005b838110156128e5578151805173ffffffffffffffffffffffffffffffffffffffff9081168952848201518116858a015260408083015190911690890152606090810151908801526080909601959082019060010161288c565b509495945050505050565b600081518084526020808501945080840160005b838110156128e5578151805173ffffffffffffffffffffffffffffffffffffffff9081168952848201518116858a015260408083015190911690890152606080820151908901526080908101519088015260a09096019590820190600101612904565b60208082528251608083830152805160a0840181905260009291820190839060c08601905b808310156129db578351805173ffffffffffffffffffffffffffffffffffffffff908116845286820151168684015260409081015190830152928401926001929092019160609091019061298c565b508387015193507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0925082868203016040870152612a198185612878565b93505050604085015181858403016060860152612a368382612878565b925050606085015181858403016080860152612a5283826128f0565b9695505050505050565b600060208284031215612a6e57600080fd5b813567ffffffffffffffff811115612a8557600080fd5b82016040818503121561032457600080fd5b60008060208385031215612aaa57600080fd5b823567ffffffffffffffff80821115612ac257600080fd5b818501915085601f830112612ad657600080fd5b813581811115612ae557600080fd5b8660208260051b8501011115612afa57600080fd5b60209290920196919550909350505050565b60005b83811015612b27578181015183820152602001612b0f565b50506000910152565b60008151808452612b48816020860160208601612b0c565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b600081518084526020808501808196508360051b8101915082860160005b85811015612bc2578284038952612bb0848351612b30565b98850198935090840190600101612b98565b5091979650505050505050565b6020815260006103246020830184612b7a565b600080600080600060a08688031215612bfa57600080fd5b8535612c05816124af565b94506020860135612c15816124af565b9350604086013567ffffffffffffffff80821115612c3257600080fd5b612c3e89838a016126bc565b94506060880135915080821115612c5457600080fd5b612c6089838a016126bc565b93506080880135915080821115612c7657600080fd5b50612c838882890161259e565b9150509295509295909350565b600080600080600060a08688031215612ca857600080fd5b8535612cb3816124af565b94506020860135612cc3816124af565b93506040860135925060608601359150608086013567ffffffffffffffff811115612ced57600080fd5b612c838882890161259e565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa1833603018112612d2d57600080fd5b9190910192915050565b600060608236031215612d4957600080fd5b612d51612503565b612d5b83356124af565b82358152602080840135612d6e816124af565b8282015260408481013567ffffffffffffffff80821115612d8e57600080fd5b9086019036601f830112612da157600080fd5b8135612daf6126dd82612698565b81815260059190911b83018501908581019036831115612dce57600080fd5b8685015b83811015612ee4578481351115612de857600080fd5b80358601877fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0823603011215612e1d57600080fd5b612e2561252c565b8982013587811115612e3657600080fd5b820136603f820112612e4757600080fd5b8a810135612e576126dd82612698565b81815260059190911b82018b01908c81019036831115612e7657600080fd5b8c84015b83811015612eac578b81351115612e9057600080fd5b612e9f368f833588010161259e565b8352918e01918e01612e7a565b5084525050508189013587811115612ec357600080fd5b612ed1368c838601016126bc565b828c015250845250918701918701612dd2565b509487019490945250939695505050505050565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1833603018112612f2c57600080fd5b90910192915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112612f6a57600080fd5b830160208101925035905067ffffffffffffffff811115612f8a57600080fd5b8060051b360382131561203857600080fd5b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b81835260007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83111561301757600080fd5b8260051b80836020870137939093016020019392505050565b6000604083016130408384612f35565b604086528281845260608701905060608260051b88010193508260005b8381101561310c577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa089870301835281357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18636030181126130be57600080fd5b8501602081810191359067ffffffffffffffff8211156130dd57600080fd5b8136038313156130ec57600080fd5b6130f7898385612f9c565b9850948501949390930192505060010161305d565b505050505061311e6020840184612f35565b8583036020870152612a52838284612fe5565b600073ffffffffffffffffffffffffffffffffffffffff8085168352602060408185015261315f8586612ef8565b6040808601526131726080860182613030565b9050818601357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa18736030181126131a857600080fd5b86810190507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08683030160608701526060820181356131e6816124af565b85168352818401356131f7816124af565b85168385015261320a6040830183612f35565b95509150606060408401528085825260808401905060808660051b85010191508260005b87811015613282577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808685030183526132708461326b8488612ef8565b613030565b9350918601919086019060010161322e565b50919a9950505050505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181126132f657600080fd5b83018035915067ffffffffffffffff82111561331157600080fd5b60200191503681900382131561203857600080fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361337e577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b5060010190565b600081518084526020808501945080840160005b838110156128e557815187529582019590820190600101613399565b60408152600083516040808401526133d06080840182612b7a565b905060208501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc084830301606085015261340b8282613385565b9150508281036020840152610bd18185613385565b6000806040838503121561343357600080fd5b825161343e816124af565b6020939093015192949293505050565b6020815260006103246020830184613385565b60008251612d2d818460208701612b0c565b815160009082906020808601845b8381101561349d57815185529382019390820190600101613481565b50929695505050505050565b600060408201848352602060408185015281855180845260608601915060608160051b870101935082870160005b82811015613523577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0888703018452613511868351613385565b955092840192908401906001016134d7565b509398975050505050505050565b600082601f83011261354257600080fd5b815160206135526126dd83612698565b82815260059290921b8401810191818101908684111561357157600080fd5b8286015b8481101561271c5780518352918301918301613575565b6000806040838503121561359f57600080fd5b825167ffffffffffffffff808211156135b757600080fd5b6135c386838701613531565b935060208501519150808211156135d957600080fd5b506135e685828601613531565b9150509250929050565b6020815260006103246020830184612b30565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b8281526040602082015260006122cf6040830184612b30565b60006020828403121561365d57600080fd5b5051919050565b60008261369a577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b6000602082840312156136b157600080fd5b8151801515811461032457600080fdfe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a264697066735822122047a34e3c5b53f2ce2e5abdd3de1e9d328e318b8bf65f6f0cdeebd0f922468e0564736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c80632ea72a49146100515780635c60da1b1461008e578063745e1b1b146100b5578063fc91a897146100c8575b600080fd5b61006461005f366004610605565b610111565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b6100647f000000000000000000000000000000000000000000000000000000000000000081565b6100646100c33660046107d1565b6102ba565b6101016100d6366004610927565b73ffffffffffffffffffffffffffffffffffffffff1660009081526033602052604090205460ff1690565b6040519015158152602001610085565b6000600260015403610184576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064015b60405180910390fd5b60026001556000610194836102ea565b73ffffffffffffffffffffffffffffffffffffffff811660009081526033602052604090205490915060ff1615610227576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f4455504c49434154455f4348494c440000000000000000000000000000000000604482015260640161017b565b73ffffffffffffffffffffffffffffffffffffffff811660008181526033602090815260409182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790558151338152908101929092527f7da70c4e5387d7038610b79ca7d304caaef815826e51e67cf247135387a79bce910160405180910390a16001805592915050565b60006102e4826040516020016102d09190610a7d565b604051602081830303815290604052610111565b92915050565b600080828060200190518101906103019190610cf0565b9050600061032e7f00000000000000000000000000000000000000000000000000000000000000006103bd565b6040517f81e6a71100000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff8216906381e6a71190610383908590600401610a7d565b600060405180830381600087803b15801561039d57600080fd5b505af11580156103b1573d6000803e3d6000fd5b50929695505050505050565b60006040517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081528260601b60148201527f5af43d82803e903d91602b57fd5bf3000000000000000000000000000000000060288201526037816000f091505073ffffffffffffffffffffffffffffffffffffffff811661049a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f455243313136373a20637265617465206661696c656400000000000000000000604482015260640161017b565b919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156104f1576104f161049f565b60405290565b6040516060810167ffffffffffffffff811182821017156104f1576104f161049f565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156105615761056161049f565b604052919050565b600067ffffffffffffffff8211156105835761058361049f565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b600082601f8301126105c057600080fd5b81356105d36105ce82610569565b61051a565b8181528460208386010111156105e857600080fd5b816020850160208301376000918101602001919091529392505050565b60006020828403121561061757600080fd5b813567ffffffffffffffff81111561062e57600080fd5b61063a848285016105af565b949350505050565b600067ffffffffffffffff82111561065c5761065c61049f565b5060051b60200190565b600082601f83011261067757600080fd5b813560206106876105ce83610642565b82815260059290921b840181019181810190868411156106a657600080fd5b8286015b848110156106c157803583529183019183016106aa565b509695505050505050565b6000604082840312156106de57600080fd5b6106e66104ce565b9050813567ffffffffffffffff8082111561070057600080fd5b818401915084601f83011261071457600080fd5b813560206107246105ce83610642565b82815260059290921b8401810191818101908884111561074357600080fd5b8286015b8481101561077b5780358681111561075f5760008081fd5b61076d8b86838b01016105af565b845250918301918301610747565b508652508581013593508284111561079257600080fd5b61079e87858801610666565b818601525050505092915050565b73ffffffffffffffffffffffffffffffffffffffff811681146107ce57600080fd5b50565b600060208083850312156107e457600080fd5b823567ffffffffffffffff808211156107fc57600080fd5b908401906040828703121561081057600080fd5b6108186104ce565b82358281111561082757600080fd5b610833888286016106cc565b825250838301358281111561084757600080fd5b92909201916060838803121561085c57600080fd5b6108646104f7565b833561086f816107ac565b81528385013561087e816107ac565b8186015260408401358381111561089457600080fd5b80850194505087601f8501126108a957600080fd5b83356108b76105ce82610642565b81815260059190911b8501860190868101908a8311156108d657600080fd5b8787015b8381101561090e578035878111156108f25760008081fd5b6109008d8b838c01016106cc565b8452509188019188016108da565b5060408401525050938101939093525090949350505050565b60006020828403121561093957600080fd5b8135610944816107ac565b9392505050565b60005b8381101561096657818101518382015260200161094e565b50506000910152565b600081518084526020808501945080840160005b8381101561099f57815187529582019590820190600101610983565b509495945050505050565b60006040830182516040855281815180845260608701915060608160051b88010193506020808401935060005b82811015610a59577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa089870301845284518051808852610a1c81858a0186850161094b565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016969096018201955093810193928101926001016109d7565b5080870151935087850381890152505050610a74828261096f565b95945050505050565b600060208083528351604082850152610a9960608501826109aa565b9050818501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08583030160408601526060820173ffffffffffffffffffffffffffffffffffffffff8083511684528085840151168585015250604082015191506060604084015280825180835260808501915060808160051b8601019250858401935060005b81811015610b6c577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80868503018352610b5a8486516109aa565b94870194935091860191600101610b20565b509198975050505050505050565b600082601f830112610b8b57600080fd5b81516020610b9b6105ce83610642565b82815260059290921b84018101918181019086841115610bba57600080fd5b8286015b848110156106c15780518352918301918301610bbe565b60006040808385031215610be857600080fd5b610bf06104ce565b9150825167ffffffffffffffff80821115610c0a57600080fd5b818501915085601f830112610c1e57600080fd5b81516020610c2e6105ce83610642565b82815260059290921b84018101918181019089841115610c4d57600080fd5b8286015b84811015610cbe57805186811115610c695760008081fd5b8701603f81018c13610c7b5760008081fd5b84810151610c8b6105ce82610569565b8181528d8b838501011115610ca05760008081fd5b610caf828883018d860161094b565b85525050918301918301610c51565b5087525086810151945082851115610cd557600080fd5b610ce188868901610b7a565b81870152505050505092915050565b60006020808385031215610d0357600080fd5b825167ffffffffffffffff80821115610d1b57600080fd5b9084019060408287031215610d2f57600080fd5b610d376104ce565b825182811115610d4657600080fd5b610d5288828601610bd5565b8252508383015182811115610d6657600080fd5b929092019160608388031215610d7b57600080fd5b610d836104f7565b8351610d8e816107ac565b815283850151610d9d816107ac565b81860152604084015183811115610db357600080fd5b80850194505087601f850112610dc857600080fd5b8351610dd66105ce82610642565b81815260059190911b8501860190868101908a831115610df557600080fd5b8787015b8381101561090e57805187811115610e115760008081fd5b610e1f8d8b838c0101610bd5565b845250918801918801610df956fea26469706673582212206a85797bf8c3956f5119699558478b79545d485828f06ace94403fa0282e13b864736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "createChild(bytes)": {
        "params": {
          "data_": "Encoded data to pass down to child contract constructor."
        },
        "returns": {
          "_0": "New child contract address."
        }
      },
      "createChildTyped(((bytes[],uint256[]),(address,address,(bytes[],uint256[])[])))": {
        "params": {
          "config_": "`Flow` constructor configuration."
        },
        "returns": {
          "_0": "New `Flow` child contract address."
        }
      },
      "isChild(address)": {
        "params": {
          "maybeChild_": "Address of child contract to look up."
        },
        "returns": {
          "_0": "Returns `true` if address is a contract created by this contract factory, otherwise `false`."
        }
      }
    },
    "title": "FlowFactory",
    "version": 1
  },
  "userdoc": {
    "events": {
      "Implementation(address,address)": {
        "notice": "Factories that clone a template contract MUST emit an event any time they set the implementation being cloned. Factories that deploy new contracts without cloning do NOT need to emit this."
      },
      "NewChild(address,address)": {
        "notice": "Whenever a new child contract is deployed, a `NewChild` event containing the new child contract address MUST be emitted."
      }
    },
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "Build the reference implementation to clone for each child."
      },
      "createChild(bytes)": {
        "notice": "Implements `IFactory`. Calls the `_createChild` hook that inheriting contracts must override. Registers child contract address such that `isChild` is `true`. Emits `NewChild` event."
      },
      "createChildTyped(((bytes[],uint256[]),(address,address,(bytes[],uint256[])[])))": {
        "notice": "Allows calling `createChild` with `StateConfig` struct. Use original `Factory` `createChild` function signature if function parameters are already encoded."
      },
      "implementation()": {
        "notice": "Template contract to clone. Deployed by the constructor."
      },
      "isChild(address)": {
        "notice": "Implements `IFactory`. Checks if address is registered as a child contract of this factory."
      }
    },
    "notice": "Factory for deploying and registering `Flow` contracts.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 859,
        "contract": "contracts/flow/basic/FlowFactory.sol:FlowFactory",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 862,
        "contract": "contracts/flow/basic/FlowFactory.sol:FlowFactory",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 1017,
        "contract": "contracts/flow/basic/FlowFactory.sol:FlowFactory",
        "label": "_status",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 1061,
        "contract": "contracts/flow/basic/FlowFactory.sol:FlowFactory",
        "label": "__gap",
        "offset": 0,
        "slot": "2",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 13285,
        "contract": "contracts/flow/basic/FlowFactory.sol:FlowFactory",
        "label": "contracts",
        "offset": 0,
        "slot": "51",
        "type": "t_mapping(t_address,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}