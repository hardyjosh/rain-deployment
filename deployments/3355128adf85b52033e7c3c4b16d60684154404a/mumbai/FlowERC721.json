{
  "address": "0x2F8F809D7E5073C7871f94e044BC2373608863eC",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "i",
          "type": "uint256"
        }
      ],
      "name": "InvalidSignature",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "approved",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "interpreter",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "EncodedDispatch",
          "name": "dispatch",
          "type": "uint256"
        }
      ],
      "name": "FlowInitialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "symbol",
              "type": "string"
            },
            {
              "components": [
                {
                  "internalType": "bytes[]",
                  "name": "sources",
                  "type": "bytes[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "constants",
                  "type": "uint256[]"
                }
              ],
              "internalType": "struct StateConfig",
              "name": "stateConfig",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "expressionDeployer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "interpreter",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes[]",
                      "name": "sources",
                      "type": "bytes[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "constants",
                      "type": "uint256[]"
                    }
                  ],
                  "internalType": "struct StateConfig[]",
                  "name": "flows",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct FlowCommonConfig",
              "name": "flowConfig",
              "type": "tuple"
            }
          ],
          "indexed": false,
          "internalType": "struct FlowERC721Config",
          "name": "config",
          "type": "tuple"
        }
      ],
      "name": "Initialize",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "EncodedDispatch",
          "name": "dispatch_",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "callerContext_",
          "type": "uint256[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "signer",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            },
            {
              "internalType": "uint256[]",
              "name": "context",
              "type": "uint256[]"
            }
          ],
          "internalType": "struct SignedContext[]",
          "name": "signedContexts_",
          "type": "tuple[]"
        }
      ],
      "name": "flow",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "account",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ERC721SupplyChange[]",
              "name": "mints",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "account",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ERC721SupplyChange[]",
              "name": "burns",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "from",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "to",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "amount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct NativeTransfer[]",
                  "name": "native",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "from",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "to",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "amount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct ERC20Transfer[]",
                  "name": "erc20",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "from",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "to",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "id",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct ERC721Transfer[]",
                  "name": "erc721",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "from",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "to",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "id",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "amount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct ERC1155Transfer[]",
                  "name": "erc1155",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct FlowTransfer",
              "name": "flow",
              "type": "tuple"
            }
          ],
          "internalType": "struct FlowERC721IO",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getApproved",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "symbol",
              "type": "string"
            },
            {
              "components": [
                {
                  "internalType": "bytes[]",
                  "name": "sources",
                  "type": "bytes[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "constants",
                  "type": "uint256[]"
                }
              ],
              "internalType": "struct StateConfig",
              "name": "stateConfig",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "expressionDeployer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "interpreter",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes[]",
                      "name": "sources",
                      "type": "bytes[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "constants",
                      "type": "uint256[]"
                    }
                  ],
                  "internalType": "struct StateConfig[]",
                  "name": "flows",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct FlowCommonConfig",
              "name": "flowConfig",
              "type": "tuple"
            }
          ],
          "internalType": "struct FlowERC721Config",
          "name": "config_",
          "type": "tuple"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes[]",
          "name": "data",
          "type": "bytes[]"
        }
      ],
      "name": "multicall",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "results",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onERC1155BatchReceived",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onERC1155Received",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onERC721Received",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "EncodedDispatch",
          "name": "dispatch_",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "callerContext_",
          "type": "uint256[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "signer",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            },
            {
              "internalType": "uint256[]",
              "name": "context",
              "type": "uint256[]"
            }
          ],
          "internalType": "struct SignedContext[]",
          "name": "signedContexts_",
          "type": "tuple[]"
        }
      ],
      "name": "previewFlow",
      "outputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "account",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ERC721SupplyChange[]",
              "name": "mints",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "account",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ERC721SupplyChange[]",
              "name": "burns",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "from",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "to",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "amount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct NativeTransfer[]",
                  "name": "native",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "from",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "to",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "amount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct ERC20Transfer[]",
                  "name": "erc20",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "from",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "to",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "id",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct ERC721Transfer[]",
                  "name": "erc721",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "token",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "from",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "to",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "id",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "amount",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct ERC1155Transfer[]",
                  "name": "erc1155",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct FlowTransfer",
              "name": "flow",
              "type": "tuple"
            }
          ],
          "internalType": "struct FlowERC721IO",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "tokenURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x912c6ca60c5bb6a74e7c338d7394137797fdf474136bf4c66de0937d86a485b2",
  "receipt": {
    "to": null,
    "from": "0xbF334f8BD1420a1CbFE15407f73919424934B1B3",
    "contractAddress": "0x15919F00D60bB3c086CdC963e3E7887b8Ab954DA",
    "transactionIndex": 0,
    "gasUsed": "6160159",
    "logsBloom": "0x00000000000000020000000000000000000000000000002008000010800000010000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000200000000000200000000000000000000000000000000000080000000011020000000000000000000000080000000000000000000000080000000000000000000200000000000000020000000000400000001000000000000000000000000004000000000000000000001000000040000000000000000000000100040000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x90b43e79f896c950bd6c49418783026bc67b4d9cfefd5afff3ce8ee980547b8e",
    "transactionHash": "0x912c6ca60c5bb6a74e7c338d7394137797fdf474136bf4c66de0937d86a485b2",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 30456794,
        "transactionHash": "0x912c6ca60c5bb6a74e7c338d7394137797fdf474136bf4c66de0937d86a485b2",
        "address": "0x15919F00D60bB3c086CdC963e3E7887b8Ab954DA",
        "topics": [
          "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000000000000000ff",
        "logIndex": 0,
        "blockHash": "0x90b43e79f896c950bd6c49418783026bc67b4d9cfefd5afff3ce8ee980547b8e"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 30456794,
        "transactionHash": "0x912c6ca60c5bb6a74e7c338d7394137797fdf474136bf4c66de0937d86a485b2",
        "address": "0x2F8F809D7E5073C7871f94e044BC2373608863eC",
        "topics": [
          "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000000000000000ff",
        "logIndex": 1,
        "blockHash": "0x90b43e79f896c950bd6c49418783026bc67b4d9cfefd5afff3ce8ee980547b8e"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 30456794,
        "transactionHash": "0x912c6ca60c5bb6a74e7c338d7394137797fdf474136bf4c66de0937d86a485b2",
        "address": "0x15919F00D60bB3c086CdC963e3E7887b8Ab954DA",
        "topics": [
          "0x7fac34ecf0b1b374cd9659e3d17db602659d53f1162b1f20142e6c02694aed70"
        ],
        "data": "0x000000000000000000000000bf334f8bd1420a1cbfe15407f73919424934b1b30000000000000000000000002f8f809d7e5073c7871f94e044bc2373608863ec",
        "logIndex": 2,
        "blockHash": "0x90b43e79f896c950bd6c49418783026bc67b4d9cfefd5afff3ce8ee980547b8e"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 30456794,
        "transactionHash": "0x912c6ca60c5bb6a74e7c338d7394137797fdf474136bf4c66de0937d86a485b2",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000bf334f8bd1420a1cbfe15407f73919424934b1b3",
          "0x000000000000000000000000c26880a0af2ea0c7e8130e6ec47af756465452e8"
        ],
        "data": "0x000000000000000000000000000000000000000000000000009a35c2180625ee000000000000000000000000000000000000000000000000a4f2446a9faf506e0000000000000000000000000000000000000000000018b7533487693d5ab286000000000000000000000000000000000000000000000000a4580ea887a92a800000000000000000000000000000000000000000000018b753cebd2b5560d874",
        "logIndex": 3,
        "blockHash": "0x90b43e79f896c950bd6c49418783026bc67b4d9cfefd5afff3ce8ee980547b8e"
      }
    ],
    "blockNumber": 30456794,
    "cumulativeGasUsed": "6160159",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "bytecode": "0x60806040523480156200001157600080fd5b506200001c62000022565b620000e4565b600054610100900460ff16156200008f5760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b60005460ff9081161015620000e2576000805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b615dd580620000f46000396000f3fe6080604052600436106101635760003560e01c806370a08231116100c0578063b88d4fde11610074578063c87b56dd11610059578063c87b56dd14610433578063e985e9c514610453578063f23a6e61146104aa57600080fd5b8063b88d4fde146103ce578063bc197c81146103ee57600080fd5b8063a22cb465116100a5578063a22cb46514610361578063ac9650d814610381578063ae910b3d146103ae57600080fd5b806370a082311461031e57806395d89b411461034c57600080fd5b806323b872dd1161011757806342842e0e116100fc57806342842e0e146102be578063522fb10b146102de5780636352211e146102fe57600080fd5b806323b872dd1461027e5780632f50e4be1461029e57600080fd5b8063081812fc11610148578063081812fc146101c6578063095ea7b31461020b578063150b7a021461022d57600080fd5b806301ffc9a71461016f57806306fdde03146101a457600080fd5b3661016a57005b600080fd5b34801561017b57600080fd5b5061018f61018a366004614697565b6104ef565b60405190151581526020015b60405180910390f35b3480156101b057600080fd5b506101b9610500565b60405161019b9190614722565b3480156101d257600080fd5b506101e66101e1366004614735565b610593565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161019b565b34801561021757600080fd5b5061022b610226366004614770565b6105c8565b005b34801561023957600080fd5b5061024d6102483660046148f4565b610759565b6040517fffffffff00000000000000000000000000000000000000000000000000000000909116815260200161019b565b34801561028a57600080fd5b5061022b610299366004614960565b610783565b3480156102aa57600080fd5b5061022b6102b93660046149a1565b610824565b3480156102ca57600080fd5b5061022b6102d9366004614960565b610b7b565b6102f16102ec366004614a60565b610b96565b60405161019b9190614d0c565b34801561030a57600080fd5b506101e6610319366004614735565b610bb3565b34801561032a57600080fd5b5061033e610339366004614e2d565b610c40565b60405190815260200161019b565b34801561035857600080fd5b506101b9610d0f565b34801561036d57600080fd5b5061022b61037c366004614e58565b610d1f565b34801561038d57600080fd5b506103a161039c366004614e91565b610d2a565b60405161019b9190614f5b565b3480156103ba57600080fd5b506102f16103c9366004614a60565b610e1f565b3480156103da57600080fd5b5061022b6103e93660046148f4565b610e3e565b3480156103fa57600080fd5b5061024d610409366004614f6e565b7fbc197c810000000000000000000000000000000000000000000000000000000095945050505050565b34801561043f57600080fd5b506101b961044e366004614735565b610ee6565b34801561045f57600080fd5b5061018f61046e36600461501c565b73ffffffffffffffffffffffffffffffffffffffff91821660009081526101666020908152604080832093909416825291909152205460ff1690565b3480156104b657600080fd5b5061024d6104c536600461504a565b7ff23a6e610000000000000000000000000000000000000000000000000000000095945050505050565b60006104fa82610f59565b92915050565b60606101618054610510906150b3565b80601f016020809104026020016040519081016040528092919081815260200182805461053c906150b3565b80156105895780601f1061055e57610100808354040283529160200191610589565b820191906000526020600020905b81548152906001019060200180831161056c57829003601f168201915b5050505050905090565b600061059e82610ffb565b506000908152610165602052604090205473ffffffffffffffffffffffffffffffffffffffff1690565b60006105d382610bb3565b90508073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610695576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602160248201527f4552433732313a20617070726f76616c20746f2063757272656e74206f776e6560448201527f720000000000000000000000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff821614806106be57506106be813361046e565b61074a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603d60248201527f4552433732313a20617070726f76652063616c6c6572206973206e6f7420746f60448201527f6b656e206f776e6572206f7220617070726f76656420666f7220616c6c000000606482015260840161068c565b610754838361108a565b505050565b7f150b7a02000000000000000000000000000000000000000000000000000000005b949350505050565b61078d338261112b565b610819576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f4552433732313a2063616c6c6572206973206e6f7420746f6b656e206f776e6560448201527f72206f7220617070726f76656400000000000000000000000000000000000000606482015260840161068c565b6107548383836111eb565b600054610100900460ff16158080156108445750600054600160ff909116105b8061085e5750303b15801561085e575060005460ff166001145b6108ea576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161068c565b600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00166001179055801561094857600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff166101001790555b7fe4fa4811d3444f99c056e3c3577b1c349bd70fb1a5719ccf5e76f8572fbca95f3383604051610979929190615342565b60405180910390a16109896114fe565b610a1261099683806154ef565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506109d89250505060208501856154ef565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061159f92505050565b6000610a216060840184615554565b610a2f906020810190614e2d565b73ffffffffffffffffffffffffffffffffffffffff16631ed061d9610a576040860186615592565b610a616001611640565b6040518363ffffffff1660e01b8152600401610a7e9291906155f6565b6020604051808303816000875af1158015610a9d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ac1919061561b565b9050602081901b77ffffffffffffffffffffffffffffffffffffffff000000001660011761019355610b13610af96060850185615554565b610b0290615638565b610b0e60046002615828565b611672565b508015610b7757600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5050565b61075483838360405180602001604052806000815250610e3e565b610b9e614620565b610ba9848484611940565b90505b9392505050565b6000818152610163602052604081205473ffffffffffffffffffffffffffffffffffffffff16806104fa576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f4552433732313a20696e76616c696420746f6b656e2049440000000000000000604482015260640161068c565b600073ffffffffffffffffffffffffffffffffffffffff8216610ce5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f4552433732313a2061646472657373207a65726f206973206e6f74206120766160448201527f6c6964206f776e65720000000000000000000000000000000000000000000000606482015260840161068c565b5073ffffffffffffffffffffffffffffffffffffffff166000908152610164602052604090205490565b60606101628054610510906150b3565b610b77338383611b01565b60608167ffffffffffffffff811115610d4557610d4561479c565b604051908082528060200260200182016040528015610d7857816020015b6060815260200190600190039081610d635790505b50905060005b82811015610e1857610de830858584818110610d9c57610d9c61583b565b9050602002810190610dae91906154ef565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611c2f92505050565b828281518110610dfa57610dfa61583b565b60200260200101819052508080610e109061586a565b915050610d7e565b5092915050565b610e27614620565b6000610e34858585611d6e565b5095945050505050565b610e48338361112b565b610ed4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f4552433732313a2063616c6c6572206973206e6f7420746f6b656e206f776e6560448201527f72206f7220617070726f76656400000000000000000000000000000000000000606482015260840161068c565b610ee084848484611e8d565b50505050565b6060610ef182610ffb565b6000610f0860408051602081019091526000815290565b90506000815111610f285760405180602001604052806000815250610bac565b80610f3284611f30565b604051602001610f439291906158a2565b6040516020818303038152906040529392505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f80ac58cd000000000000000000000000000000000000000000000000000000001480610fec57507fffffffff0000000000000000000000000000000000000000000000000000000082167f5b5e139f00000000000000000000000000000000000000000000000000000000145b806104fa57506104fa82611fee565b6000818152610163602052604090205473ffffffffffffffffffffffffffffffffffffffff16611087576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f4552433732313a20696e76616c696420746f6b656e2049440000000000000000604482015260640161068c565b50565b60008181526101656020526040902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff841690811790915581906110e582610bb3565b73ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45050565b60008061113783610bb3565b90508073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614806111a6575073ffffffffffffffffffffffffffffffffffffffff8082166000908152610166602090815260408083209388168352929052205460ff165b8061077b57508373ffffffffffffffffffffffffffffffffffffffff166111cc84610593565b73ffffffffffffffffffffffffffffffffffffffff1614949350505050565b8273ffffffffffffffffffffffffffffffffffffffff1661120b82610bb3565b73ffffffffffffffffffffffffffffffffffffffff16146112ae576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f4552433732313a207472616e736665722066726f6d20696e636f72726563742060448201527f6f776e6572000000000000000000000000000000000000000000000000000000606482015260840161068c565b73ffffffffffffffffffffffffffffffffffffffff8216611350576040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f4552433732313a207472616e7366657220746f20746865207a65726f2061646460448201527f7265737300000000000000000000000000000000000000000000000000000000606482015260840161068c565b61135d8383836001612085565b8273ffffffffffffffffffffffffffffffffffffffff1661137d82610bb3565b73ffffffffffffffffffffffffffffffffffffffff1614611420576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f4552433732313a207472616e736665722066726f6d20696e636f72726563742060448201527f6f776e6572000000000000000000000000000000000000000000000000000000606482015260840161068c565b60008181526101656020908152604080832080547fffffffffffffffffffffffff000000000000000000000000000000000000000090811690915573ffffffffffffffffffffffffffffffffffffffff878116808652610164855283862080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190559087168086528386208054600101905586865261016390945282852080549092168417909155905184937fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a46107548383836001612143565b600054610100900460ff16611595576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161068c565b61159d612443565b565b600054610100900460ff16611636576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161068c565b610b7782826124e0565b604080516001808252818301909252606091600091906020808301908036833750505060208101939093525090919050565b600054610100900460ff16611709576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161068c565b611711612592565b611719612592565b611721612592565b600481101561178c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f424144204d494e20535441434b53204c454e4754480000000000000000000000604482015260640161068c565b602082015161015f80547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff90921691909117905560005b826040015151811015610754576000836000015173ffffffffffffffffffffffffffffffffffffffff16631ed061d98560400151848151811061181e5761181e61583b565b602002602001015161182f86611640565b6040518363ffffffff1660e01b815260040161184c9291906158d1565b6020604051808303816000875af115801561186b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061188f919061561b565b90506000602082901b77ffffffffffffffffffffffffffffffffffffffff000000001661ffff17600081815261016060209081526040918290206001905587810151825133815273ffffffffffffffffffffffffffffffffffffffff909116918101919091529081018290529091507f0392789afa55e5b564b41f5e52285c849fc771b31ccc0e222999b6de72bc55949060600160405180910390a1505080806119389061586a565b9150506117d9565b611948614620565b611950612629565b60008061195e868686611d6e565b9150915060005b8251518110156119c3576119bb836000015182815181106119885761198861583b565b602002602001015160000151846000015183815181106119aa576119aa61583b565b60200260200101516020015161269c565b600101611965565b5060005b826020015151811015611aca576000836020015182815181106119ec576119ec61583b565b602002602001015160200151905083602001518281518110611a1057611a1061583b565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff16611a3b82610bb3565b73ffffffffffffffffffffffffffffffffffffffff1614611ab8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f4e4f545f4f574e45520000000000000000000000000000000000000000000000604482015260640161068c565b611ac1816126b6565b506001016119c7565b50604082015161015f54611af5919073ffffffffffffffffffffffffffffffffffffffff16836127a9565b509050610bac60018055565b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603611b96576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f4552433732313a20617070726f766520746f2063616c6c657200000000000000604482015260640161068c565b73ffffffffffffffffffffffffffffffffffffffff8381166000818152610166602090815260408083209487168084529482529182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b606073ffffffffffffffffffffffffffffffffffffffff83163b611cd5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e74726163740000000000000000000000000000000000000000000000000000606482015260840161068c565b6000808473ffffffffffffffffffffffffffffffffffffffff1684604051611cfd919061593c565b600060405180830381855af49150503d8060008114611d38576040519150601f19603f3d011682016040523d82523d6000602084013e611d3d565b606091505b5091509150611d658282604051806060016040528060278152602001615d7960279139612859565b95945050505050565b611d76614620565b606080611d81614620565b6000806000611d918a8a8a612872565b60408051808201909152601981527f5241494e5f464c4f575f4552433732315f53454e54494e454c0000000000000060209091015291945092509050611dfa82847ffe90d819490b07580877ce7c3005704048c62af96c6745886d7e356e0b63924a60026129fa565b80865260408051808201909152601981527f5241494e5f464c4f575f4552433732315f53454e54494e454c0000000000000060209091015295509150611e6382847ffe90d819490b07580877ce7c3005704048c62af96c6745886d7e356e0b63924a60026129fa565b6020860181905295509150611e788383612aab565b60408501529299929850919650505050505050565b611e988484846111eb565b611ea484848484612cb7565b610ee0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603260248201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560448201527f63656976657220696d706c656d656e7465720000000000000000000000000000606482015260840161068c565b60606000611f3d83612ea7565b600101905060008167ffffffffffffffff811115611f5d57611f5d61479c565b6040519080825280601f01601f191660200182016040528015611f87576020820181803683370190505b5090508181016020015b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff017f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8504945084611f9157509392505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f4e2312e00000000000000000000000000000000000000000000000000000000014806104fa57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316146104fa565b6001811115610ee05773ffffffffffffffffffffffffffffffffffffffff8416156120e65773ffffffffffffffffffffffffffffffffffffffff841660009081526101646020526040812080548392906120e090849061594e565b90915550505b73ffffffffffffffffffffffffffffffffffffffff831615610ee05773ffffffffffffffffffffffffffffffffffffffff83166000908152610164602052604081208054839290612138908490615828565b909155505050505050565b73ffffffffffffffffffffffffffffffffffffffff8416158061217a575073ffffffffffffffffffffffffffffffffffffffff8316155b610ee05760006121b88573ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff168585612f89565b6101935461015f54604080516000808252602082019092529394509192829173ffffffffffffffffffffffffffffffffffffffff16906390e7d00b9085906122809085612215565b60608152602001906001900390816122005790505b50604080516000808252602082019092528a9161227a565b6122676040518060600160405280600073ffffffffffffffffffffffffffffffffffffffff16815260200160608152602001606081525090565b81526020019060019003908161222d5790505b50612fcc565b6040518363ffffffff1660e01b815260040161229d929190615961565b600060405180830381865afa1580156122ba573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682016040526123009190810190615a44565b91509150600061234161231b84805160209081029091010190565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015190565b116123a8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f494e56414c49445f5452414e5346455200000000000000000000000000000000604482015260640161068c565b8051156124395761015f546040517fce0dd62800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9091169063ce0dd62890612406908490600401615aa8565b600060405180830381600087803b15801561242057600080fd5b505af1158015612434573d6000803e3d6000fd5b505050505b5050505050505050565b600054610100900460ff166124da576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161068c565b60018055565b600054610100900460ff16612577576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161068c565b6101616125848382615b09565b506101626107548282615b09565b600054610100900460ff1661159d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161068c565b600260015403612695576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015260640161068c565b6002600155565b610b77828260405180602001604052806000815250613336565b60006126c182610bb3565b90506126d1816000846001612085565b6126da82610bb3565b60008381526101656020908152604080832080547fffffffffffffffffffffffff000000000000000000000000000000000000000090811690915573ffffffffffffffffffffffffffffffffffffffff8516808552610164845282852080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff019055878552610163909352818420805490911690555192935084927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908390a4610b77816000846001612143565b805115612835576040517fce0dd62800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83169063ce0dd62890612802908490600401615aa8565b600060405180830381600087803b15801561281c57600080fd5b505af1158015612830573d6000803e3d6000fd5b505050505b61283e836133d9565b61284783613607565b61285083613795565b61075483613952565b60608315612868575081610bac565b610bac8383613b2e565b60008381526101606020526040812054819060609086906128ef576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f554e524547495354455245445f464c4f57000000000000000000000000000000604482015260640161068c565b61015f54600090819073ffffffffffffffffffffffffffffffffffffffff166390e7d00b8a6129538460405190808252806020026020018201604052801561294b57816020015b60608152602001906001900390816129365790505b508c8c612fcc565b6040518363ffffffff1660e01b8152600401612970929190615961565b600060405180830381865afa15801561298d573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682016040526129d39190810190615a44565b915091506129e18260200190565b8251909a60209182029093010198509650945050505050565b600060608180612a0c88888888613b72565b915091506000858251612a1f9190615c23565b905060008167ffffffffffffffff811115612a3c57612a3c61479c565b604051908082528060200260200182016040528015612a65578160200160208202803683370190505b509050602081016020830281016020850160208a025b82841015612a955781845260209093019290810190612a7b565b5095975091955050505050505b94509492505050565b612ad66040518060800160405280606081526020016060815260200160608152602001606081525090565b612b016040518060800160405280606081526020016060815260200160608152602001606081525090565b60408051808201909152601281527f5241494e5f464c4f575f53454e54494e454c00000000000000000000000000006020909101526060612b6584867ffea74d0c9bf4a3c28f0dd0674db22a3d7f8bf259c56af19f4ac1e735b156974f60036129fa565b80845260408051808201909152601281527f5241494e5f464c4f575f53454e54494e454c00000000000000000000000000006020909101529094509050612bcf84867ffea74d0c9bf4a3c28f0dd0674db22a3d7f8bf259c56af19f4ac1e735b156974f60046129fa565b602084810182905260408051808201909152601281527f5241494e5f464c4f575f53454e54494e454c00000000000000000000000000009101529094509050612c3b84867ffea74d0c9bf4a3c28f0dd0674db22a3d7f8bf259c56af19f4ac1e735b156974f60046129fa565b60408481018290528051808201909152601281527f5241494e5f464c4f575f53454e54494e454c00000000000000000000000000006020909101529094509050612ca884867ffea74d0c9bf4a3c28f0dd0674db22a3d7f8bf259c56af19f4ac1e735b156974f60056129fa565b60608401525090949350505050565b600073ffffffffffffffffffffffffffffffffffffffff84163b15612e9f576040517f150b7a0200000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff85169063150b7a0290612d2e903390899088908890600401615c5e565b6020604051808303816000875af1925050508015612d87575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252612d8491810190615ca7565b60015b612e54573d808015612db5576040519150601f19603f3d011682016040523d82523d6000602084013e612dba565b606091505b508051600003612e4c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603260248201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560448201527f63656976657220696d706c656d656e7465720000000000000000000000000000606482015260840161068c565b805181602001fd5b7fffffffff00000000000000000000000000000000000000000000000000000000167f150b7a020000000000000000000000000000000000000000000000000000000014905061077b565b50600161077b565b6000807a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008310612ef0577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000830492506040015b6d04ee2d6d415b85acef81000000008310612f1c576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc100008310612f3a57662386f26fc10000830492506010015b6305f5e1008310612f52576305f5e100830492506008015b6127108310612f6657612710830492506004015b60648310612f78576064830492506002015b600a83106104fa5760010192915050565b60408051600480825260a0820190925260609160009190602082016080803683375050506020810196909652505060408401929092526060830152608082015290565b60606000825167ffffffffffffffff811115612fea57612fea61479c565b604051908082528060200260200182016040528015613013578160200160208202803683370190505b50905060008084511161302757600061302d565b83516001015b865101600201905060008167ffffffffffffffff8111156130505761305061479c565b60405190808252806020026020018201604052801561308357816020015b606081526020019060019003908161306e5790505b5090506000613090613bd2565b8282815181106130a2576130a261583b565b602002602001018190525060005b88518110156131005781806001019250508881815181106130d3576130d361583b565b60200260200101518383815181106130ed576130ed61583b565b60209081029190910101526001016130b0565b5080806001019150508682828151811061311c5761311c61583b565b602090810291909101015285511561332b578080600101915050838282815181106131495761314961583b565b602002602001018190525060005b8651811015613329576132538782815181106131755761317561583b565b6020026020010151600001516132308984815181106131965761319661583b565b6020026020010151604001516040516020016131b29190615cc4565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815282825280516020918201207f19457468657265756d205369676e6564204d6573736167653a0a33320000000084830152603c8085019190915282518085039091018152605c909301909152815191012090565b8984815181106132425761324261583b565b602002602001015160200151613be3565b61328c576040517f52bf98480000000000000000000000000000000000000000000000000000000081526004810182905260240161068c565b86818151811061329e5761329e61583b565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff168582815181106132d2576132d261583b565b60200260200101818152505081806001019250508681815181106132f8576132f861583b565b6020026020010151604001518383815181106133165761331661583b565b6020908102919091010152600101613157565b505b509695505050505050565b6133408383613db0565b61334d6000848484612cb7565b610754576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603260248201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560448201527f63656976657220696d706c656d656e7465720000000000000000000000000000606482015260840161068c565b60408051606081018252600080825260208201819052918101829052819060005b8451518110156135e85784518051829081106134185761341861583b565b602002602001015191503373ffffffffffffffffffffffffffffffffffffffff16826000015173ffffffffffffffffffffffffffffffffffffffff16036134ea57602082015173ffffffffffffffffffffffffffffffffffffffff1630146134dc576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f554e535550504f525445445f4e41544956455f464c4f57000000000000000000604482015260640161068c565b8160400151840193506135e0565b815173ffffffffffffffffffffffffffffffffffffffff16301461356a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f554e535550504f525445445f4e41544956455f464c4f57000000000000000000604482015260640161068c565b3373ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff16036135af578160400151830192506135e0565b6135e08260400151836020015173ffffffffffffffffffffffffffffffffffffffff16613ff190919063ffffffff16565b6001016133fa565b5082156135f757823403820191505b8115610ee057610ee03383613ff1565b6040805160808101825260008082526020820181905291810182905260608101829052905b826020015151811015610754578260200151818151811061364f5761364f61583b565b602002602001015191503373ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff16036136c6576040820151606083015183516136c19273ffffffffffffffffffffffffffffffffffffffff9091169133919061414b565b61378d565b3073ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff160361372b576040820151606083015183516136c19273ffffffffffffffffffffffffffffffffffffffff90911691614227565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f554e535550504f525445445f45524332305f464c4f5700000000000000000000604482015260640161068c565b60010161362c565b6040805160808101825260008082526020820181905291810182905260608101829052905b82604001515181101561075457826040015181815181106137dd576137dd61583b565b602002602001015191503373ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff16148061383e5750602082015173ffffffffffffffffffffffffffffffffffffffff1630145b6138a4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f554e535550504f525445445f4552433732315f464c4f57000000000000000000604482015260640161068c565b81516020830151604080850151606086015191517f42842e0e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9384166004820152908316602482015260448101919091529116906342842e0e90606401600060405180830381600087803b15801561392e57600080fd5b505af1158015613942573d6000803e3d6000fd5b5050600190920191506137ba9050565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101829052905b82606001515181101561075457826060015181815181106139a1576139a161583b565b602002602001015191503373ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff161480613a025750602082015173ffffffffffffffffffffffffffffffffffffffff1630145b613a68576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f554e535550504f525445445f455243313135355f464c4f570000000000000000604482015260640161068c565b815160208301516040808501516060860151608087015192517ff242432a00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff948516600482015291841660248301526044820152606481019190915260a06084820152600060a482015291169063f242432a9060c401600060405180830381600087803b158015613b0a57600080fd5b505af1158015613b1e573d6000803e3d6000fd5b50506001909201915061397e9050565b815115613b3e5781518083602001fd5b806040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161068c9190614722565b600060608085613b8157600080fd5b6000806020860260208a039950602089035b808b1115613bb9578a518903613bab578a9350613bb9565b998190039991870191613b93565b505081613bc557600080fd5b8152969795505050505050565b6060613bde333061427d565b905090565b6000806000613bf285856142b1565b90925090506000816004811115613c0b57613c0b615cfa565b148015613c4357508573ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b15613c5357600192505050610bac565b6000808773ffffffffffffffffffffffffffffffffffffffff16631626ba7e60e01b8888604051602401613c88929190615d29565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909416939093179092529051613d11919061593c565b600060405180830381855afa9150503d8060008114613d4c576040519150601f19603f3d011682016040523d82523d6000602084013e613d51565b606091505b5091509150818015613d64575080516020145b8015613da4575080517f1626ba7e0000000000000000000000000000000000000000000000000000000090613da29083016020908101908401615d42565b145b98975050505050505050565b73ffffffffffffffffffffffffffffffffffffffff8216613e2d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4552433732313a206d696e7420746f20746865207a65726f2061646472657373604482015260640161068c565b6000818152610163602052604090205473ffffffffffffffffffffffffffffffffffffffff1615613eba576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e74656400000000604482015260640161068c565b613ec8600083836001612085565b6000818152610163602052604090205473ffffffffffffffffffffffffffffffffffffffff1615613f55576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e74656400000000604482015260640161068c565b73ffffffffffffffffffffffffffffffffffffffff82166000818152610164602090815260408083208054600101905584835261016390915280822080547fffffffffffffffffffffffff0000000000000000000000000000000000000000168417905551839291907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a4610b77600083836001612143565b8047101561405b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a20696e73756666696369656e742062616c616e6365000000604482015260640161068c565b60008273ffffffffffffffffffffffffffffffffffffffff168260405160006040518083038185875af1925050503d80600081146140b5576040519150601f19603f3d011682016040523d82523d6000602084013e6140ba565b606091505b5050905080610754576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f416464726573733a20756e61626c6520746f2073656e642076616c75652c207260448201527f6563697069656e74206d61792068617665207265766572746564000000000000606482015260840161068c565b60405173ffffffffffffffffffffffffffffffffffffffff80851660248301528316604482015260648101829052610ee09085907f23b872dd00000000000000000000000000000000000000000000000000000000906084015b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909316929092179091526142f6565b60405173ffffffffffffffffffffffffffffffffffffffff83166024820152604481018290526107549084907fa9059cbb00000000000000000000000000000000000000000000000000000000906064016141a5565b6040805160028082526060808301845292600092919060208301908036833750505060208101949094525050604082015290565b60008082516041036142e75760208301516040840151606085015160001a6142db87828585614402565b945094505050506142ef565b506000905060025b9250929050565b6000614358826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65648152508573ffffffffffffffffffffffffffffffffffffffff166144ee9092919063ffffffff16565b80519091501561075457808060200190518101906143769190615d5b565b610754576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f74207375636365656400000000000000000000000000000000000000000000606482015260840161068c565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08311156144395750600090506003612aa2565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa15801561448d573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff81166144e157600060019250925050612aa2565b9660009650945050505050565b6060610ba98484600085856000808673ffffffffffffffffffffffffffffffffffffffff168587604051614522919061593c565b60006040518083038185875af1925050503d806000811461455f576040519150601f19603f3d011682016040523d82523d6000602084013e614564565b606091505b509150915061457587838387614580565b979650505050505050565b6060831561461657825160000361460f5773ffffffffffffffffffffffffffffffffffffffff85163b61460f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161068c565b508161077b565b61077b8383613b2e565b604051806060016040528060608152602001606081526020016146646040518060800160405280606081526020016060815260200160608152602001606081525090565b905290565b7fffffffff000000000000000000000000000000000000000000000000000000008116811461108757600080fd5b6000602082840312156146a957600080fd5b8135610bac81614669565b60005b838110156146cf5781810151838201526020016146b7565b50506000910152565b600081518084526146f08160208601602086016146b4565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000610bac60208301846146d8565b60006020828403121561474757600080fd5b5035919050565b73ffffffffffffffffffffffffffffffffffffffff8116811461108757600080fd5b6000806040838503121561478357600080fd5b823561478e8161474e565b946020939093013593505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516060810167ffffffffffffffff811182821017156147ee576147ee61479c565b60405290565b6040805190810167ffffffffffffffff811182821017156147ee576147ee61479c565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561485e5761485e61479c565b604052919050565b600082601f83011261487757600080fd5b813567ffffffffffffffff8111156148915761489161479c565b6148c260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601614817565b8181528460208386010111156148d757600080fd5b816020850160208301376000918101602001919091529392505050565b6000806000806080858703121561490a57600080fd5b84356149158161474e565b935060208501356149258161474e565b925060408501359150606085013567ffffffffffffffff81111561494857600080fd5b61495487828801614866565b91505092959194509250565b60008060006060848603121561497557600080fd5b83356149808161474e565b925060208401356149908161474e565b929592945050506040919091013590565b6000602082840312156149b357600080fd5b813567ffffffffffffffff8111156149ca57600080fd5b820160808185031215610bac57600080fd5b600067ffffffffffffffff8211156149f6576149f661479c565b5060051b60200190565b600082601f830112614a1157600080fd5b81356020614a26614a21836149dc565b614817565b82815260059290921b84018101918181019086841115614a4557600080fd5b8286015b8481101561332b5780358352918301918301614a49565b600080600060608486031215614a7557600080fd5b8335925060208085013567ffffffffffffffff80821115614a9557600080fd5b614aa188838901614a00565b94506040870135915080821115614ab757600080fd5b818701915087601f830112614acb57600080fd5b8135614ad9614a21826149dc565b81815260059190911b8301840190848101908a831115614af857600080fd5b8585015b83811015614bbb57803585811115614b145760008081fd5b86016060818e037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0011215614b495760008081fd5b614b516147cb565b88820135614b5e8161474e565b8152604082013587811115614b735760008081fd5b614b818f8b83860101614866565b8a83015250606082013587811115614b995760008081fd5b614ba78f8b83860101614a00565b604083015250845250918601918601614afc565b508096505050505050509250925092565b600081518084526020808501945080840160005b83811015614c1d578151805173ffffffffffffffffffffffffffffffffffffffff1688528301518388015260409096019590820190600101614be0565b509495945050505050565b600081518084526020808501945080840160005b83811015614c1d578151805173ffffffffffffffffffffffffffffffffffffffff9081168952848201518116858a0152604080830151909116908901526060908101519088015260809096019590820190600101614c3c565b600081518084526020808501945080840160005b83811015614c1d578151805173ffffffffffffffffffffffffffffffffffffffff9081168952848201518116858a015260408083015190911690890152606080820151908901526080908101519088015260a09096019590820190600101614ca9565b60006020808352835160608083860152614d296080860183614bcc565b9150828601517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe06040818886030181890152614d658584614bcc565b89820151898203909301858a01528251608080835281519083018190529196509293509186019160009060a08701905b80831015614ddf578451805173ffffffffffffffffffffffffffffffffffffffff90811684528a820151168a84015284015184830152938801936001929092019190860190614d95565b5087850151935086810388880152614df78185614c28565b975050508083015191508486038186015250614e138582614c28565b945050818101519050828403828401526145758482614c95565b600060208284031215614e3f57600080fd5b8135610bac8161474e565b801515811461108757600080fd5b60008060408385031215614e6b57600080fd5b8235614e768161474e565b91506020830135614e8681614e4a565b809150509250929050565b60008060208385031215614ea457600080fd5b823567ffffffffffffffff80821115614ebc57600080fd5b818501915085601f830112614ed057600080fd5b813581811115614edf57600080fd5b8660208260051b8501011115614ef457600080fd5b60209290920196919550909350505050565b600081518084526020808501808196508360051b8101915082860160005b85811015614f4e578284038952614f3c8483516146d8565b98850198935090840190600101614f24565b5091979650505050505050565b602081526000610bac6020830184614f06565b600080600080600060a08688031215614f8657600080fd5b8535614f918161474e565b94506020860135614fa18161474e565b9350604086013567ffffffffffffffff80821115614fbe57600080fd5b614fca89838a01614a00565b94506060880135915080821115614fe057600080fd5b614fec89838a01614a00565b9350608088013591508082111561500257600080fd5b5061500f88828901614866565b9150509295509295909350565b6000806040838503121561502f57600080fd5b823561503a8161474e565b91506020830135614e868161474e565b600080600080600060a0868803121561506257600080fd5b853561506d8161474e565b9450602086013561507d8161474e565b93506040860135925060608601359150608086013567ffffffffffffffff8111156150a757600080fd5b61500f88828901614866565b600181811c908216806150c757607f821691505b602082108103615100577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261513b57600080fd5b830160208101925035905067ffffffffffffffff81111561515b57600080fd5b8036038213156142ef57600080fd5b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc18336030181126151e757600080fd5b90910192915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261522557600080fd5b830160208101925035905067ffffffffffffffff81111561524557600080fd5b8060051b36038213156142ef57600080fd5b60006040830161526783846151f0565b604086528281845260608701905060608260051b88010193508260005b838110156152df577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa08987030183526152bd8286615106565b6152c888828461516a565b975050506020928301929190910190600101615284565b50505050506152f160208401846151f0565b85830360208701528083527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81111561532957600080fd5b60051b8082602085013791909101602001949350505050565b600073ffffffffffffffffffffffffffffffffffffffff808516835260206040818501526153708586615106565b6080604087015261538560c08701828461516a565b91505061539482870187615106565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0808885030160608901526153ca84838561516a565b93506153d960408a018a6151b3565b9250808885030160808901526153ef8484615257565b9350606089013592507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa189360301831261542857600080fd5b8784030160a08801525086016060820181356154438161474e565b85168352818401356154548161474e565b85168385015261546760408301836151f0565b95509150606060408401528085825260808401905060808660051b85010191508260005b878110156154df577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808685030183526154cd846154c884886151b3565b615257565b9350918601919086019060010161548b565b50919a9950505050505050505050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261552457600080fd5b83018035915067ffffffffffffffff82111561553f57600080fd5b6020019150368190038213156142ef57600080fd5b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa183360301811261558857600080fd5b9190910192915050565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc183360301811261558857600080fd5b600081518084526020808501945080840160005b83811015614c1d578151875295820195908201906001016155da565b6040815260006156096040830185615257565b8281036020840152611d6581856155c6565b60006020828403121561562d57600080fd5b8151610bac8161474e565b60006060823603121561564a57600080fd5b6156526147cb565b61565c833561474e565b8235815260208084013561566f8161474e565b8282015260408481013567ffffffffffffffff8082111561568f57600080fd5b9086019036601f8301126156a257600080fd5b81356156b0614a21826149dc565b81815260059190911b830185019085810190368311156156cf57600080fd5b8685015b838110156157e55784813511156156e957600080fd5b80358601877fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe082360301121561571e57600080fd5b6157266147f4565b898201358781111561573757600080fd5b820136603f82011261574857600080fd5b8a810135615758614a21826149dc565b81815260059190911b82018b01908c8101903683111561577757600080fd5b8c84015b838110156157ad578b8135111561579157600080fd5b6157a0368f8335880101614866565b8352918e01918e0161577b565b50845250505081890135878111156157c457600080fd5b6157d2368c83860101614a00565b828c0152508452509187019187016156d3565b509487019490945250939695505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b808201808211156104fa576104fa6157f9565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361589b5761589b6157f9565b5060010190565b600083516158b48184602088016146b4565b8351908301906158c88183602088016146b4565b01949350505050565b60408152600083516040808401526158ec6080840182614f06565b905060208501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc084830301606085015261592782826155c6565b9150508281036020840152611d6581856155c6565b600082516155888184602087016146b4565b818103818111156104fa576104fa6157f9565b600060408201848352602060408185015281855180845260608601915060608160051b870101935082870160005b828110156159db577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa08887030184526159c98683516155c6565b9550928401929084019060010161598f565b509398975050505050505050565b600082601f8301126159fa57600080fd5b81516020615a0a614a21836149dc565b82815260059290921b84018101918181019086841115615a2957600080fd5b8286015b8481101561332b5780518352918301918301615a2d565b60008060408385031215615a5757600080fd5b825167ffffffffffffffff80821115615a6f57600080fd5b615a7b868387016159e9565b93506020850151915080821115615a9157600080fd5b50615a9e858286016159e9565b9150509250929050565b602081526000610bac60208301846155c6565b601f82111561075457600081815260208120601f850160051c81016020861015615ae25750805b601f850160051c820191505b81811015615b0157828155600101615aee565b505050505050565b815167ffffffffffffffff811115615b2357615b2361479c565b615b3781615b3184546150b3565b84615abb565b602080601f831160018114615b8a5760008415615b545750858301515b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600386901b1c1916600185901b178555615b01565b6000858152602081207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08616915b82811015615bd757888601518255948401946001909101908401615bb8565b5085821015615c1357878501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600388901b60f8161c191681555b5050505050600190811b01905550565b600082615c59577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b600073ffffffffffffffffffffffffffffffffffffffff808716835280861660208401525083604083015260806060830152615c9d60808301846146d8565b9695505050505050565b600060208284031215615cb957600080fd5b8151610bac81614669565b815160009082906020808601845b83811015615cee57815185529382019390820190600101615cd2565b50929695505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b828152604060208201526000610ba960408301846146d8565b600060208284031215615d5457600080fd5b5051919050565b600060208284031215615d6d57600080fd5b8151610bac81614e4a56fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220a2130e625e8599d3d38d5705fa7629f4ad1901d1da798a0bce9180f6276c564264736f6c63430008110033",
  "deployedBytecode": "0x6080604052600436106101635760003560e01c806370a08231116100c0578063b88d4fde11610074578063c87b56dd11610059578063c87b56dd14610433578063e985e9c514610453578063f23a6e61146104aa57600080fd5b8063b88d4fde146103ce578063bc197c81146103ee57600080fd5b8063a22cb465116100a5578063a22cb46514610361578063ac9650d814610381578063ae910b3d146103ae57600080fd5b806370a082311461031e57806395d89b411461034c57600080fd5b806323b872dd1161011757806342842e0e116100fc57806342842e0e146102be578063522fb10b146102de5780636352211e146102fe57600080fd5b806323b872dd1461027e5780632f50e4be1461029e57600080fd5b8063081812fc11610148578063081812fc146101c6578063095ea7b31461020b578063150b7a021461022d57600080fd5b806301ffc9a71461016f57806306fdde03146101a457600080fd5b3661016a57005b600080fd5b34801561017b57600080fd5b5061018f61018a366004614697565b6104ef565b60405190151581526020015b60405180910390f35b3480156101b057600080fd5b506101b9610500565b60405161019b9190614722565b3480156101d257600080fd5b506101e66101e1366004614735565b610593565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161019b565b34801561021757600080fd5b5061022b610226366004614770565b6105c8565b005b34801561023957600080fd5b5061024d6102483660046148f4565b610759565b6040517fffffffff00000000000000000000000000000000000000000000000000000000909116815260200161019b565b34801561028a57600080fd5b5061022b610299366004614960565b610783565b3480156102aa57600080fd5b5061022b6102b93660046149a1565b610824565b3480156102ca57600080fd5b5061022b6102d9366004614960565b610b7b565b6102f16102ec366004614a60565b610b96565b60405161019b9190614d0c565b34801561030a57600080fd5b506101e6610319366004614735565b610bb3565b34801561032a57600080fd5b5061033e610339366004614e2d565b610c40565b60405190815260200161019b565b34801561035857600080fd5b506101b9610d0f565b34801561036d57600080fd5b5061022b61037c366004614e58565b610d1f565b34801561038d57600080fd5b506103a161039c366004614e91565b610d2a565b60405161019b9190614f5b565b3480156103ba57600080fd5b506102f16103c9366004614a60565b610e1f565b3480156103da57600080fd5b5061022b6103e93660046148f4565b610e3e565b3480156103fa57600080fd5b5061024d610409366004614f6e565b7fbc197c810000000000000000000000000000000000000000000000000000000095945050505050565b34801561043f57600080fd5b506101b961044e366004614735565b610ee6565b34801561045f57600080fd5b5061018f61046e36600461501c565b73ffffffffffffffffffffffffffffffffffffffff91821660009081526101666020908152604080832093909416825291909152205460ff1690565b3480156104b657600080fd5b5061024d6104c536600461504a565b7ff23a6e610000000000000000000000000000000000000000000000000000000095945050505050565b60006104fa82610f59565b92915050565b60606101618054610510906150b3565b80601f016020809104026020016040519081016040528092919081815260200182805461053c906150b3565b80156105895780601f1061055e57610100808354040283529160200191610589565b820191906000526020600020905b81548152906001019060200180831161056c57829003601f168201915b5050505050905090565b600061059e82610ffb565b506000908152610165602052604090205473ffffffffffffffffffffffffffffffffffffffff1690565b60006105d382610bb3565b90508073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603610695576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602160248201527f4552433732313a20617070726f76616c20746f2063757272656e74206f776e6560448201527f720000000000000000000000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b3373ffffffffffffffffffffffffffffffffffffffff821614806106be57506106be813361046e565b61074a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603d60248201527f4552433732313a20617070726f76652063616c6c6572206973206e6f7420746f60448201527f6b656e206f776e6572206f7220617070726f76656420666f7220616c6c000000606482015260840161068c565b610754838361108a565b505050565b7f150b7a02000000000000000000000000000000000000000000000000000000005b949350505050565b61078d338261112b565b610819576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f4552433732313a2063616c6c6572206973206e6f7420746f6b656e206f776e6560448201527f72206f7220617070726f76656400000000000000000000000000000000000000606482015260840161068c565b6107548383836111eb565b600054610100900460ff16158080156108445750600054600160ff909116105b8061085e5750303b15801561085e575060005460ff166001145b6108ea576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161068c565b600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00166001179055801561094857600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff166101001790555b7fe4fa4811d3444f99c056e3c3577b1c349bd70fb1a5719ccf5e76f8572fbca95f3383604051610979929190615342565b60405180910390a16109896114fe565b610a1261099683806154ef565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506109d89250505060208501856154ef565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061159f92505050565b6000610a216060840184615554565b610a2f906020810190614e2d565b73ffffffffffffffffffffffffffffffffffffffff16631ed061d9610a576040860186615592565b610a616001611640565b6040518363ffffffff1660e01b8152600401610a7e9291906155f6565b6020604051808303816000875af1158015610a9d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ac1919061561b565b9050602081901b77ffffffffffffffffffffffffffffffffffffffff000000001660011761019355610b13610af96060850185615554565b610b0290615638565b610b0e60046002615828565b611672565b508015610b7757600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5050565b61075483838360405180602001604052806000815250610e3e565b610b9e614620565b610ba9848484611940565b90505b9392505050565b6000818152610163602052604081205473ffffffffffffffffffffffffffffffffffffffff16806104fa576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f4552433732313a20696e76616c696420746f6b656e2049440000000000000000604482015260640161068c565b600073ffffffffffffffffffffffffffffffffffffffff8216610ce5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f4552433732313a2061646472657373207a65726f206973206e6f74206120766160448201527f6c6964206f776e65720000000000000000000000000000000000000000000000606482015260840161068c565b5073ffffffffffffffffffffffffffffffffffffffff166000908152610164602052604090205490565b60606101628054610510906150b3565b610b77338383611b01565b60608167ffffffffffffffff811115610d4557610d4561479c565b604051908082528060200260200182016040528015610d7857816020015b6060815260200190600190039081610d635790505b50905060005b82811015610e1857610de830858584818110610d9c57610d9c61583b565b9050602002810190610dae91906154ef565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611c2f92505050565b828281518110610dfa57610dfa61583b565b60200260200101819052508080610e109061586a565b915050610d7e565b5092915050565b610e27614620565b6000610e34858585611d6e565b5095945050505050565b610e48338361112b565b610ed4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f4552433732313a2063616c6c6572206973206e6f7420746f6b656e206f776e6560448201527f72206f7220617070726f76656400000000000000000000000000000000000000606482015260840161068c565b610ee084848484611e8d565b50505050565b6060610ef182610ffb565b6000610f0860408051602081019091526000815290565b90506000815111610f285760405180602001604052806000815250610bac565b80610f3284611f30565b604051602001610f439291906158a2565b6040516020818303038152906040529392505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f80ac58cd000000000000000000000000000000000000000000000000000000001480610fec57507fffffffff0000000000000000000000000000000000000000000000000000000082167f5b5e139f00000000000000000000000000000000000000000000000000000000145b806104fa57506104fa82611fee565b6000818152610163602052604090205473ffffffffffffffffffffffffffffffffffffffff16611087576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f4552433732313a20696e76616c696420746f6b656e2049440000000000000000604482015260640161068c565b50565b60008181526101656020526040902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff841690811790915581906110e582610bb3565b73ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45050565b60008061113783610bb3565b90508073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614806111a6575073ffffffffffffffffffffffffffffffffffffffff8082166000908152610166602090815260408083209388168352929052205460ff165b8061077b57508373ffffffffffffffffffffffffffffffffffffffff166111cc84610593565b73ffffffffffffffffffffffffffffffffffffffff1614949350505050565b8273ffffffffffffffffffffffffffffffffffffffff1661120b82610bb3565b73ffffffffffffffffffffffffffffffffffffffff16146112ae576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f4552433732313a207472616e736665722066726f6d20696e636f72726563742060448201527f6f776e6572000000000000000000000000000000000000000000000000000000606482015260840161068c565b73ffffffffffffffffffffffffffffffffffffffff8216611350576040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f4552433732313a207472616e7366657220746f20746865207a65726f2061646460448201527f7265737300000000000000000000000000000000000000000000000000000000606482015260840161068c565b61135d8383836001612085565b8273ffffffffffffffffffffffffffffffffffffffff1661137d82610bb3565b73ffffffffffffffffffffffffffffffffffffffff1614611420576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f4552433732313a207472616e736665722066726f6d20696e636f72726563742060448201527f6f776e6572000000000000000000000000000000000000000000000000000000606482015260840161068c565b60008181526101656020908152604080832080547fffffffffffffffffffffffff000000000000000000000000000000000000000090811690915573ffffffffffffffffffffffffffffffffffffffff878116808652610164855283862080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190559087168086528386208054600101905586865261016390945282852080549092168417909155905184937fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a46107548383836001612143565b600054610100900460ff16611595576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161068c565b61159d612443565b565b600054610100900460ff16611636576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161068c565b610b7782826124e0565b604080516001808252818301909252606091600091906020808301908036833750505060208101939093525090919050565b600054610100900460ff16611709576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161068c565b611711612592565b611719612592565b611721612592565b600481101561178c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f424144204d494e20535441434b53204c454e4754480000000000000000000000604482015260640161068c565b602082015161015f80547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff90921691909117905560005b826040015151811015610754576000836000015173ffffffffffffffffffffffffffffffffffffffff16631ed061d98560400151848151811061181e5761181e61583b565b602002602001015161182f86611640565b6040518363ffffffff1660e01b815260040161184c9291906158d1565b6020604051808303816000875af115801561186b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061188f919061561b565b90506000602082901b77ffffffffffffffffffffffffffffffffffffffff000000001661ffff17600081815261016060209081526040918290206001905587810151825133815273ffffffffffffffffffffffffffffffffffffffff909116918101919091529081018290529091507f0392789afa55e5b564b41f5e52285c849fc771b31ccc0e222999b6de72bc55949060600160405180910390a1505080806119389061586a565b9150506117d9565b611948614620565b611950612629565b60008061195e868686611d6e565b9150915060005b8251518110156119c3576119bb836000015182815181106119885761198861583b565b602002602001015160000151846000015183815181106119aa576119aa61583b565b60200260200101516020015161269c565b600101611965565b5060005b826020015151811015611aca576000836020015182815181106119ec576119ec61583b565b602002602001015160200151905083602001518281518110611a1057611a1061583b565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff16611a3b82610bb3565b73ffffffffffffffffffffffffffffffffffffffff1614611ab8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600960248201527f4e4f545f4f574e45520000000000000000000000000000000000000000000000604482015260640161068c565b611ac1816126b6565b506001016119c7565b50604082015161015f54611af5919073ffffffffffffffffffffffffffffffffffffffff16836127a9565b509050610bac60018055565b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603611b96576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f4552433732313a20617070726f766520746f2063616c6c657200000000000000604482015260640161068c565b73ffffffffffffffffffffffffffffffffffffffff8381166000818152610166602090815260408083209487168084529482529182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b606073ffffffffffffffffffffffffffffffffffffffff83163b611cd5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e74726163740000000000000000000000000000000000000000000000000000606482015260840161068c565b6000808473ffffffffffffffffffffffffffffffffffffffff1684604051611cfd919061593c565b600060405180830381855af49150503d8060008114611d38576040519150601f19603f3d011682016040523d82523d6000602084013e611d3d565b606091505b5091509150611d658282604051806060016040528060278152602001615d7960279139612859565b95945050505050565b611d76614620565b606080611d81614620565b6000806000611d918a8a8a612872565b60408051808201909152601981527f5241494e5f464c4f575f4552433732315f53454e54494e454c0000000000000060209091015291945092509050611dfa82847ffe90d819490b07580877ce7c3005704048c62af96c6745886d7e356e0b63924a60026129fa565b80865260408051808201909152601981527f5241494e5f464c4f575f4552433732315f53454e54494e454c0000000000000060209091015295509150611e6382847ffe90d819490b07580877ce7c3005704048c62af96c6745886d7e356e0b63924a60026129fa565b6020860181905295509150611e788383612aab565b60408501529299929850919650505050505050565b611e988484846111eb565b611ea484848484612cb7565b610ee0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603260248201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560448201527f63656976657220696d706c656d656e7465720000000000000000000000000000606482015260840161068c565b60606000611f3d83612ea7565b600101905060008167ffffffffffffffff811115611f5d57611f5d61479c565b6040519080825280601f01601f191660200182016040528015611f87576020820181803683370190505b5090508181016020015b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff017f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8504945084611f9157509392505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f4e2312e00000000000000000000000000000000000000000000000000000000014806104fa57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316146104fa565b6001811115610ee05773ffffffffffffffffffffffffffffffffffffffff8416156120e65773ffffffffffffffffffffffffffffffffffffffff841660009081526101646020526040812080548392906120e090849061594e565b90915550505b73ffffffffffffffffffffffffffffffffffffffff831615610ee05773ffffffffffffffffffffffffffffffffffffffff83166000908152610164602052604081208054839290612138908490615828565b909155505050505050565b73ffffffffffffffffffffffffffffffffffffffff8416158061217a575073ffffffffffffffffffffffffffffffffffffffff8316155b610ee05760006121b88573ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff168585612f89565b6101935461015f54604080516000808252602082019092529394509192829173ffffffffffffffffffffffffffffffffffffffff16906390e7d00b9085906122809085612215565b60608152602001906001900390816122005790505b50604080516000808252602082019092528a9161227a565b6122676040518060600160405280600073ffffffffffffffffffffffffffffffffffffffff16815260200160608152602001606081525090565b81526020019060019003908161222d5790505b50612fcc565b6040518363ffffffff1660e01b815260040161229d929190615961565b600060405180830381865afa1580156122ba573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682016040526123009190810190615a44565b91509150600061234161231b84805160209081029091010190565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015190565b116123a8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f494e56414c49445f5452414e5346455200000000000000000000000000000000604482015260640161068c565b8051156124395761015f546040517fce0dd62800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9091169063ce0dd62890612406908490600401615aa8565b600060405180830381600087803b15801561242057600080fd5b505af1158015612434573d6000803e3d6000fd5b505050505b5050505050505050565b600054610100900460ff166124da576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161068c565b60018055565b600054610100900460ff16612577576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161068c565b6101616125848382615b09565b506101626107548282615b09565b600054610100900460ff1661159d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161068c565b600260015403612695576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015260640161068c565b6002600155565b610b77828260405180602001604052806000815250613336565b60006126c182610bb3565b90506126d1816000846001612085565b6126da82610bb3565b60008381526101656020908152604080832080547fffffffffffffffffffffffff000000000000000000000000000000000000000090811690915573ffffffffffffffffffffffffffffffffffffffff8516808552610164845282852080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff019055878552610163909352818420805490911690555192935084927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908390a4610b77816000846001612143565b805115612835576040517fce0dd62800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83169063ce0dd62890612802908490600401615aa8565b600060405180830381600087803b15801561281c57600080fd5b505af1158015612830573d6000803e3d6000fd5b505050505b61283e836133d9565b61284783613607565b61285083613795565b61075483613952565b60608315612868575081610bac565b610bac8383613b2e565b60008381526101606020526040812054819060609086906128ef576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f554e524547495354455245445f464c4f57000000000000000000000000000000604482015260640161068c565b61015f54600090819073ffffffffffffffffffffffffffffffffffffffff166390e7d00b8a6129538460405190808252806020026020018201604052801561294b57816020015b60608152602001906001900390816129365790505b508c8c612fcc565b6040518363ffffffff1660e01b8152600401612970929190615961565b600060405180830381865afa15801561298d573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682016040526129d39190810190615a44565b915091506129e18260200190565b8251909a60209182029093010198509650945050505050565b600060608180612a0c88888888613b72565b915091506000858251612a1f9190615c23565b905060008167ffffffffffffffff811115612a3c57612a3c61479c565b604051908082528060200260200182016040528015612a65578160200160208202803683370190505b509050602081016020830281016020850160208a025b82841015612a955781845260209093019290810190612a7b565b5095975091955050505050505b94509492505050565b612ad66040518060800160405280606081526020016060815260200160608152602001606081525090565b612b016040518060800160405280606081526020016060815260200160608152602001606081525090565b60408051808201909152601281527f5241494e5f464c4f575f53454e54494e454c00000000000000000000000000006020909101526060612b6584867ffea74d0c9bf4a3c28f0dd0674db22a3d7f8bf259c56af19f4ac1e735b156974f60036129fa565b80845260408051808201909152601281527f5241494e5f464c4f575f53454e54494e454c00000000000000000000000000006020909101529094509050612bcf84867ffea74d0c9bf4a3c28f0dd0674db22a3d7f8bf259c56af19f4ac1e735b156974f60046129fa565b602084810182905260408051808201909152601281527f5241494e5f464c4f575f53454e54494e454c00000000000000000000000000009101529094509050612c3b84867ffea74d0c9bf4a3c28f0dd0674db22a3d7f8bf259c56af19f4ac1e735b156974f60046129fa565b60408481018290528051808201909152601281527f5241494e5f464c4f575f53454e54494e454c00000000000000000000000000006020909101529094509050612ca884867ffea74d0c9bf4a3c28f0dd0674db22a3d7f8bf259c56af19f4ac1e735b156974f60056129fa565b60608401525090949350505050565b600073ffffffffffffffffffffffffffffffffffffffff84163b15612e9f576040517f150b7a0200000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff85169063150b7a0290612d2e903390899088908890600401615c5e565b6020604051808303816000875af1925050508015612d87575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252612d8491810190615ca7565b60015b612e54573d808015612db5576040519150601f19603f3d011682016040523d82523d6000602084013e612dba565b606091505b508051600003612e4c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603260248201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560448201527f63656976657220696d706c656d656e7465720000000000000000000000000000606482015260840161068c565b805181602001fd5b7fffffffff00000000000000000000000000000000000000000000000000000000167f150b7a020000000000000000000000000000000000000000000000000000000014905061077b565b50600161077b565b6000807a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008310612ef0577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000830492506040015b6d04ee2d6d415b85acef81000000008310612f1c576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc100008310612f3a57662386f26fc10000830492506010015b6305f5e1008310612f52576305f5e100830492506008015b6127108310612f6657612710830492506004015b60648310612f78576064830492506002015b600a83106104fa5760010192915050565b60408051600480825260a0820190925260609160009190602082016080803683375050506020810196909652505060408401929092526060830152608082015290565b60606000825167ffffffffffffffff811115612fea57612fea61479c565b604051908082528060200260200182016040528015613013578160200160208202803683370190505b50905060008084511161302757600061302d565b83516001015b865101600201905060008167ffffffffffffffff8111156130505761305061479c565b60405190808252806020026020018201604052801561308357816020015b606081526020019060019003908161306e5790505b5090506000613090613bd2565b8282815181106130a2576130a261583b565b602002602001018190525060005b88518110156131005781806001019250508881815181106130d3576130d361583b565b60200260200101518383815181106130ed576130ed61583b565b60209081029190910101526001016130b0565b5080806001019150508682828151811061311c5761311c61583b565b602090810291909101015285511561332b578080600101915050838282815181106131495761314961583b565b602002602001018190525060005b8651811015613329576132538782815181106131755761317561583b565b6020026020010151600001516132308984815181106131965761319661583b565b6020026020010151604001516040516020016131b29190615cc4565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815282825280516020918201207f19457468657265756d205369676e6564204d6573736167653a0a33320000000084830152603c8085019190915282518085039091018152605c909301909152815191012090565b8984815181106132425761324261583b565b602002602001015160200151613be3565b61328c576040517f52bf98480000000000000000000000000000000000000000000000000000000081526004810182905260240161068c565b86818151811061329e5761329e61583b565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff168582815181106132d2576132d261583b565b60200260200101818152505081806001019250508681815181106132f8576132f861583b565b6020026020010151604001518383815181106133165761331661583b565b6020908102919091010152600101613157565b505b509695505050505050565b6133408383613db0565b61334d6000848484612cb7565b610754576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603260248201527f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560448201527f63656976657220696d706c656d656e7465720000000000000000000000000000606482015260840161068c565b60408051606081018252600080825260208201819052918101829052819060005b8451518110156135e85784518051829081106134185761341861583b565b602002602001015191503373ffffffffffffffffffffffffffffffffffffffff16826000015173ffffffffffffffffffffffffffffffffffffffff16036134ea57602082015173ffffffffffffffffffffffffffffffffffffffff1630146134dc576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f554e535550504f525445445f4e41544956455f464c4f57000000000000000000604482015260640161068c565b8160400151840193506135e0565b815173ffffffffffffffffffffffffffffffffffffffff16301461356a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f554e535550504f525445445f4e41544956455f464c4f57000000000000000000604482015260640161068c565b3373ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff16036135af578160400151830192506135e0565b6135e08260400151836020015173ffffffffffffffffffffffffffffffffffffffff16613ff190919063ffffffff16565b6001016133fa565b5082156135f757823403820191505b8115610ee057610ee03383613ff1565b6040805160808101825260008082526020820181905291810182905260608101829052905b826020015151811015610754578260200151818151811061364f5761364f61583b565b602002602001015191503373ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff16036136c6576040820151606083015183516136c19273ffffffffffffffffffffffffffffffffffffffff9091169133919061414b565b61378d565b3073ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff160361372b576040820151606083015183516136c19273ffffffffffffffffffffffffffffffffffffffff90911691614227565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f554e535550504f525445445f45524332305f464c4f5700000000000000000000604482015260640161068c565b60010161362c565b6040805160808101825260008082526020820181905291810182905260608101829052905b82604001515181101561075457826040015181815181106137dd576137dd61583b565b602002602001015191503373ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff16148061383e5750602082015173ffffffffffffffffffffffffffffffffffffffff1630145b6138a4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f554e535550504f525445445f4552433732315f464c4f57000000000000000000604482015260640161068c565b81516020830151604080850151606086015191517f42842e0e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9384166004820152908316602482015260448101919091529116906342842e0e90606401600060405180830381600087803b15801561392e57600080fd5b505af1158015613942573d6000803e3d6000fd5b5050600190920191506137ba9050565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101829052905b82606001515181101561075457826060015181815181106139a1576139a161583b565b602002602001015191503373ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff161480613a025750602082015173ffffffffffffffffffffffffffffffffffffffff1630145b613a68576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f554e535550504f525445445f455243313135355f464c4f570000000000000000604482015260640161068c565b815160208301516040808501516060860151608087015192517ff242432a00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff948516600482015291841660248301526044820152606481019190915260a06084820152600060a482015291169063f242432a9060c401600060405180830381600087803b158015613b0a57600080fd5b505af1158015613b1e573d6000803e3d6000fd5b50506001909201915061397e9050565b815115613b3e5781518083602001fd5b806040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161068c9190614722565b600060608085613b8157600080fd5b6000806020860260208a039950602089035b808b1115613bb9578a518903613bab578a9350613bb9565b998190039991870191613b93565b505081613bc557600080fd5b8152969795505050505050565b6060613bde333061427d565b905090565b6000806000613bf285856142b1565b90925090506000816004811115613c0b57613c0b615cfa565b148015613c4357508573ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b15613c5357600192505050610bac565b6000808773ffffffffffffffffffffffffffffffffffffffff16631626ba7e60e01b8888604051602401613c88929190615d29565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909416939093179092529051613d11919061593c565b600060405180830381855afa9150503d8060008114613d4c576040519150601f19603f3d011682016040523d82523d6000602084013e613d51565b606091505b5091509150818015613d64575080516020145b8015613da4575080517f1626ba7e0000000000000000000000000000000000000000000000000000000090613da29083016020908101908401615d42565b145b98975050505050505050565b73ffffffffffffffffffffffffffffffffffffffff8216613e2d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4552433732313a206d696e7420746f20746865207a65726f2061646472657373604482015260640161068c565b6000818152610163602052604090205473ffffffffffffffffffffffffffffffffffffffff1615613eba576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e74656400000000604482015260640161068c565b613ec8600083836001612085565b6000818152610163602052604090205473ffffffffffffffffffffffffffffffffffffffff1615613f55576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f4552433732313a20746f6b656e20616c7265616479206d696e74656400000000604482015260640161068c565b73ffffffffffffffffffffffffffffffffffffffff82166000818152610164602090815260408083208054600101905584835261016390915280822080547fffffffffffffffffffffffff0000000000000000000000000000000000000000168417905551839291907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a4610b77600083836001612143565b8047101561405b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a20696e73756666696369656e742062616c616e6365000000604482015260640161068c565b60008273ffffffffffffffffffffffffffffffffffffffff168260405160006040518083038185875af1925050503d80600081146140b5576040519150601f19603f3d011682016040523d82523d6000602084013e6140ba565b606091505b5050905080610754576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f416464726573733a20756e61626c6520746f2073656e642076616c75652c207260448201527f6563697069656e74206d61792068617665207265766572746564000000000000606482015260840161068c565b60405173ffffffffffffffffffffffffffffffffffffffff80851660248301528316604482015260648101829052610ee09085907f23b872dd00000000000000000000000000000000000000000000000000000000906084015b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909316929092179091526142f6565b60405173ffffffffffffffffffffffffffffffffffffffff83166024820152604481018290526107549084907fa9059cbb00000000000000000000000000000000000000000000000000000000906064016141a5565b6040805160028082526060808301845292600092919060208301908036833750505060208101949094525050604082015290565b60008082516041036142e75760208301516040840151606085015160001a6142db87828585614402565b945094505050506142ef565b506000905060025b9250929050565b6000614358826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65648152508573ffffffffffffffffffffffffffffffffffffffff166144ee9092919063ffffffff16565b80519091501561075457808060200190518101906143769190615d5b565b610754576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f74207375636365656400000000000000000000000000000000000000000000606482015260840161068c565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08311156144395750600090506003612aa2565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa15801561448d573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff81166144e157600060019250925050612aa2565b9660009650945050505050565b6060610ba98484600085856000808673ffffffffffffffffffffffffffffffffffffffff168587604051614522919061593c565b60006040518083038185875af1925050503d806000811461455f576040519150601f19603f3d011682016040523d82523d6000602084013e614564565b606091505b509150915061457587838387614580565b979650505050505050565b6060831561461657825160000361460f5773ffffffffffffffffffffffffffffffffffffffff85163b61460f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161068c565b508161077b565b61077b8383613b2e565b604051806060016040528060608152602001606081526020016146646040518060800160405280606081526020016060815260200160608152602001606081525090565b905290565b7fffffffff000000000000000000000000000000000000000000000000000000008116811461108757600080fd5b6000602082840312156146a957600080fd5b8135610bac81614669565b60005b838110156146cf5781810151838201526020016146b7565b50506000910152565b600081518084526146f08160208601602086016146b4565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000610bac60208301846146d8565b60006020828403121561474757600080fd5b5035919050565b73ffffffffffffffffffffffffffffffffffffffff8116811461108757600080fd5b6000806040838503121561478357600080fd5b823561478e8161474e565b946020939093013593505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516060810167ffffffffffffffff811182821017156147ee576147ee61479c565b60405290565b6040805190810167ffffffffffffffff811182821017156147ee576147ee61479c565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561485e5761485e61479c565b604052919050565b600082601f83011261487757600080fd5b813567ffffffffffffffff8111156148915761489161479c565b6148c260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f84011601614817565b8181528460208386010111156148d757600080fd5b816020850160208301376000918101602001919091529392505050565b6000806000806080858703121561490a57600080fd5b84356149158161474e565b935060208501356149258161474e565b925060408501359150606085013567ffffffffffffffff81111561494857600080fd5b61495487828801614866565b91505092959194509250565b60008060006060848603121561497557600080fd5b83356149808161474e565b925060208401356149908161474e565b929592945050506040919091013590565b6000602082840312156149b357600080fd5b813567ffffffffffffffff8111156149ca57600080fd5b820160808185031215610bac57600080fd5b600067ffffffffffffffff8211156149f6576149f661479c565b5060051b60200190565b600082601f830112614a1157600080fd5b81356020614a26614a21836149dc565b614817565b82815260059290921b84018101918181019086841115614a4557600080fd5b8286015b8481101561332b5780358352918301918301614a49565b600080600060608486031215614a7557600080fd5b8335925060208085013567ffffffffffffffff80821115614a9557600080fd5b614aa188838901614a00565b94506040870135915080821115614ab757600080fd5b818701915087601f830112614acb57600080fd5b8135614ad9614a21826149dc565b81815260059190911b8301840190848101908a831115614af857600080fd5b8585015b83811015614bbb57803585811115614b145760008081fd5b86016060818e037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0011215614b495760008081fd5b614b516147cb565b88820135614b5e8161474e565b8152604082013587811115614b735760008081fd5b614b818f8b83860101614866565b8a83015250606082013587811115614b995760008081fd5b614ba78f8b83860101614a00565b604083015250845250918601918601614afc565b508096505050505050509250925092565b600081518084526020808501945080840160005b83811015614c1d578151805173ffffffffffffffffffffffffffffffffffffffff1688528301518388015260409096019590820190600101614be0565b509495945050505050565b600081518084526020808501945080840160005b83811015614c1d578151805173ffffffffffffffffffffffffffffffffffffffff9081168952848201518116858a0152604080830151909116908901526060908101519088015260809096019590820190600101614c3c565b600081518084526020808501945080840160005b83811015614c1d578151805173ffffffffffffffffffffffffffffffffffffffff9081168952848201518116858a015260408083015190911690890152606080820151908901526080908101519088015260a09096019590820190600101614ca9565b60006020808352835160608083860152614d296080860183614bcc565b9150828601517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe06040818886030181890152614d658584614bcc565b89820151898203909301858a01528251608080835281519083018190529196509293509186019160009060a08701905b80831015614ddf578451805173ffffffffffffffffffffffffffffffffffffffff90811684528a820151168a84015284015184830152938801936001929092019190860190614d95565b5087850151935086810388880152614df78185614c28565b975050508083015191508486038186015250614e138582614c28565b945050818101519050828403828401526145758482614c95565b600060208284031215614e3f57600080fd5b8135610bac8161474e565b801515811461108757600080fd5b60008060408385031215614e6b57600080fd5b8235614e768161474e565b91506020830135614e8681614e4a565b809150509250929050565b60008060208385031215614ea457600080fd5b823567ffffffffffffffff80821115614ebc57600080fd5b818501915085601f830112614ed057600080fd5b813581811115614edf57600080fd5b8660208260051b8501011115614ef457600080fd5b60209290920196919550909350505050565b600081518084526020808501808196508360051b8101915082860160005b85811015614f4e578284038952614f3c8483516146d8565b98850198935090840190600101614f24565b5091979650505050505050565b602081526000610bac6020830184614f06565b600080600080600060a08688031215614f8657600080fd5b8535614f918161474e565b94506020860135614fa18161474e565b9350604086013567ffffffffffffffff80821115614fbe57600080fd5b614fca89838a01614a00565b94506060880135915080821115614fe057600080fd5b614fec89838a01614a00565b9350608088013591508082111561500257600080fd5b5061500f88828901614866565b9150509295509295909350565b6000806040838503121561502f57600080fd5b823561503a8161474e565b91506020830135614e868161474e565b600080600080600060a0868803121561506257600080fd5b853561506d8161474e565b9450602086013561507d8161474e565b93506040860135925060608601359150608086013567ffffffffffffffff8111156150a757600080fd5b61500f88828901614866565b600181811c908216806150c757607f821691505b602082108103615100577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261513b57600080fd5b830160208101925035905067ffffffffffffffff81111561515b57600080fd5b8036038213156142ef57600080fd5b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc18336030181126151e757600080fd5b90910192915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261522557600080fd5b830160208101925035905067ffffffffffffffff81111561524557600080fd5b8060051b36038213156142ef57600080fd5b60006040830161526783846151f0565b604086528281845260608701905060608260051b88010193508260005b838110156152df577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa08987030183526152bd8286615106565b6152c888828461516a565b975050506020928301929190910190600101615284565b50505050506152f160208401846151f0565b85830360208701528083527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81111561532957600080fd5b60051b8082602085013791909101602001949350505050565b600073ffffffffffffffffffffffffffffffffffffffff808516835260206040818501526153708586615106565b6080604087015261538560c08701828461516a565b91505061539482870187615106565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc0808885030160608901526153ca84838561516a565b93506153d960408a018a6151b3565b9250808885030160808901526153ef8484615257565b9350606089013592507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa189360301831261542857600080fd5b8784030160a08801525086016060820181356154438161474e565b85168352818401356154548161474e565b85168385015261546760408301836151f0565b95509150606060408401528085825260808401905060808660051b85010191508260005b878110156154df577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808685030183526154cd846154c884886151b3565b615257565b9350918601919086019060010161548b565b50919a9950505050505050505050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261552457600080fd5b83018035915067ffffffffffffffff82111561553f57600080fd5b6020019150368190038213156142ef57600080fd5b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa183360301811261558857600080fd5b9190910192915050565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc183360301811261558857600080fd5b600081518084526020808501945080840160005b83811015614c1d578151875295820195908201906001016155da565b6040815260006156096040830185615257565b8281036020840152611d6581856155c6565b60006020828403121561562d57600080fd5b8151610bac8161474e565b60006060823603121561564a57600080fd5b6156526147cb565b61565c833561474e565b8235815260208084013561566f8161474e565b8282015260408481013567ffffffffffffffff8082111561568f57600080fd5b9086019036601f8301126156a257600080fd5b81356156b0614a21826149dc565b81815260059190911b830185019085810190368311156156cf57600080fd5b8685015b838110156157e55784813511156156e957600080fd5b80358601877fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe082360301121561571e57600080fd5b6157266147f4565b898201358781111561573757600080fd5b820136603f82011261574857600080fd5b8a810135615758614a21826149dc565b81815260059190911b82018b01908c8101903683111561577757600080fd5b8c84015b838110156157ad578b8135111561579157600080fd5b6157a0368f8335880101614866565b8352918e01918e0161577b565b50845250505081890135878111156157c457600080fd5b6157d2368c83860101614a00565b828c0152508452509187019187016156d3565b509487019490945250939695505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b808201808211156104fa576104fa6157f9565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361589b5761589b6157f9565b5060010190565b600083516158b48184602088016146b4565b8351908301906158c88183602088016146b4565b01949350505050565b60408152600083516040808401526158ec6080840182614f06565b905060208501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc084830301606085015261592782826155c6565b9150508281036020840152611d6581856155c6565b600082516155888184602087016146b4565b818103818111156104fa576104fa6157f9565b600060408201848352602060408185015281855180845260608601915060608160051b870101935082870160005b828110156159db577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa08887030184526159c98683516155c6565b9550928401929084019060010161598f565b509398975050505050505050565b600082601f8301126159fa57600080fd5b81516020615a0a614a21836149dc565b82815260059290921b84018101918181019086841115615a2957600080fd5b8286015b8481101561332b5780518352918301918301615a2d565b60008060408385031215615a5757600080fd5b825167ffffffffffffffff80821115615a6f57600080fd5b615a7b868387016159e9565b93506020850151915080821115615a9157600080fd5b50615a9e858286016159e9565b9150509250929050565b602081526000610bac60208301846155c6565b601f82111561075457600081815260208120601f850160051c81016020861015615ae25750805b601f850160051c820191505b81811015615b0157828155600101615aee565b505050505050565b815167ffffffffffffffff811115615b2357615b2361479c565b615b3781615b3184546150b3565b84615abb565b602080601f831160018114615b8a5760008415615b545750858301515b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600386901b1c1916600185901b178555615b01565b6000858152602081207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08616915b82811015615bd757888601518255948401946001909101908401615bb8565b5085821015615c1357878501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600388901b60f8161c191681555b5050505050600190811b01905550565b600082615c59577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b600073ffffffffffffffffffffffffffffffffffffffff808716835280861660208401525083604083015260806060830152615c9d60808301846146d8565b9695505050505050565b600060208284031215615cb957600080fd5b8151610bac81614669565b815160009082906020808601845b83811015615cee57815185529382019390820190600101615cd2565b50929695505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b828152604060208201526000610ba960408301846146d8565b600060208284031215615d5457600080fd5b5051919050565b600060208284031215615d6d57600080fd5b8151610bac81614e4a56fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220a2130e625e8599d3d38d5705fa7629f4ad1901d1da798a0bce9180f6276c564264736f6c63430008110033",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"EncodedDispatch\",\"name\":\"dispatch\",\"type\":\"uint256\"}],\"name\":\"FlowInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"bytes[]\",\"name\":\"sources\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"internalType\":\"struct StateConfig\",\"name\":\"stateConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"expressionDeployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes[]\",\"name\":\"sources\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"internalType\":\"struct StateConfig[]\",\"name\":\"flows\",\"type\":\"tuple[]\"}],\"internalType\":\"struct FlowCommonConfig\",\"name\":\"flowConfig\",\"type\":\"tuple\"}],\"indexed\":false,\"internalType\":\"struct FlowERC721Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"Initialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"EncodedDispatch\",\"name\":\"dispatch_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"callerContext_\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"context\",\"type\":\"uint256[]\"}],\"internalType\":\"struct SignedContext[]\",\"name\":\"signedContexts_\",\"type\":\"tuple[]\"}],\"name\":\"flow\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC721SupplyChange[]\",\"name\":\"mints\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC721SupplyChange[]\",\"name\":\"burns\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct NativeTransfer[]\",\"name\":\"native\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC20Transfer[]\",\"name\":\"erc20\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC721Transfer[]\",\"name\":\"erc721\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC1155Transfer[]\",\"name\":\"erc1155\",\"type\":\"tuple[]\"}],\"internalType\":\"struct FlowTransfer\",\"name\":\"flow\",\"type\":\"tuple\"}],\"internalType\":\"struct FlowERC721IO\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"bytes[]\",\"name\":\"sources\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"internalType\":\"struct StateConfig\",\"name\":\"stateConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"expressionDeployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes[]\",\"name\":\"sources\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"internalType\":\"struct StateConfig[]\",\"name\":\"flows\",\"type\":\"tuple[]\"}],\"internalType\":\"struct FlowCommonConfig\",\"name\":\"flowConfig\",\"type\":\"tuple\"}],\"internalType\":\"struct FlowERC721Config\",\"name\":\"config_\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"EncodedDispatch\",\"name\":\"dispatch_\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"callerContext_\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"context\",\"type\":\"uint256[]\"}],\"internalType\":\"struct SignedContext[]\",\"name\":\"signedContexts_\",\"type\":\"tuple[]\"}],\"name\":\"previewFlow\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC721SupplyChange[]\",\"name\":\"mints\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC721SupplyChange[]\",\"name\":\"burns\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct NativeTransfer[]\",\"name\":\"native\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC20Transfer[]\",\"name\":\"erc20\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC721Transfer[]\",\"name\":\"erc721\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC1155Transfer[]\",\"name\":\"erc1155\",\"type\":\"tuple[]\"}],\"internalType\":\"struct FlowTransfer\",\"name\":\"flow\",\"type\":\"tuple\"}],\"internalType\":\"struct FlowERC721IO\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"events\":{\"Initialize(address,(string,string,(bytes[],uint256[]),(address,address,(bytes[],uint256[])[])))\":{\"params\":{\"config\":\"All initialized config.\",\"sender\":\"`msg.sender` initializing the contract (factory).\"}}},\"kind\":\"dev\",\"methods\":{\"approve(address,uint256)\":{\"details\":\"See {IERC721-approve}.\"},\"balanceOf(address)\":{\"details\":\"See {IERC721-balanceOf}.\"},\"getApproved(uint256)\":{\"details\":\"See {IERC721-getApproved}.\"},\"initialize((string,string,(bytes[],uint256[]),(address,address,(bytes[],uint256[])[])))\":{\"params\":{\"config_\":\"source and token config. Also controls delegated claims.\"}},\"isApprovedForAll(address,address)\":{\"details\":\"See {IERC721-isApprovedForAll}.\"},\"multicall(bytes[])\":{\"details\":\"Receives and executes a batch of function calls on this contract.\"},\"name()\":{\"details\":\"See {IERC721Metadata-name}.\"},\"onERC721Received(address,address,uint256,bytes)\":{\"details\":\"See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`.\"},\"ownerOf(uint256)\":{\"details\":\"See {IERC721-ownerOf}.\"},\"safeTransferFrom(address,address,uint256)\":{\"details\":\"See {IERC721-safeTransferFrom}.\"},\"safeTransferFrom(address,address,uint256,bytes)\":{\"details\":\"See {IERC721-safeTransferFrom}.\"},\"setApprovalForAll(address,bool)\":{\"details\":\"See {IERC721-setApprovalForAll}.\"},\"symbol()\":{\"details\":\"See {IERC721Metadata-symbol}.\"},\"tokenURI(uint256)\":{\"details\":\"See {IERC721Metadata-tokenURI}.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"See {IERC721-transferFrom}.\"}},\"title\":\"FlowERC721\",\"version\":1},\"userdoc\":{\"errors\":{\"InvalidSignature(uint256)\":[{\"notice\":\"Thrown when the ith signature from a list of signed contexts is invalid.\"}]},\"events\":{\"Initialize(address,(string,string,(bytes[],uint256[]),(address,address,(bytes[],uint256[])[])))\":{\"notice\":\"Contract has initialized.\"}},\"kind\":\"user\",\"methods\":{\"supportsInterface(bytes4)\":{\"notice\":\"Needed here to fix Open Zeppelin implementing `supportsInterface` on multiple base contracts.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/flow/erc721/FlowERC721.sol\":\"FlowERC721\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000000},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\",\"keccak256\":\"0x6e6e4b0835904509406b070ee173b5bc8f677c19421b76be38aea3b1b3d30846\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC1271Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271Upgradeable {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0x4473c09c087ee1a48c5547b23799c0474b2e08cde6fec5921c628171c4ebcdc0\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0xe798cadb41e2da274913e4b3183a80f50fb057a42238fe8467e077268100ec27\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x2b3005a0064cfc558bdf64b2bae94b565f4574a536aadd61c13838d4f2157790\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xffcb29612efb57efc8f0d4897deb5abaeac830022c59a3aa17446d698dbc856b\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x091a49ef99a2be002680781a10cc9dd74c0f348301ede5482c4ea625f79a8ffe\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {\\n    function __ERC1155Holder_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1155Holder_init_unchained() internal onlyInitializing {\\n    }\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xa8a1f16aa62b4d8c9e380057d9c3ee5c992e4a10dccc5650b26e38d4c61287d4\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\\n    function __ERC1155Receiver_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1155Receiver_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xa1b77d6d0f4591359c42b747a31375f20b0571b5e1fb62652d8184fb10f1d63a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\",\"keccak256\":\"0xb1d9e69cf8073efa574b31b1f840e20709139c19bfb27e60b16393d6073f3d42\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4e733d3164f73f461eaf9d8087a7ad1ea180bdc8ba0d3d61b0e1ae16d8e63dff\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/extensions/ERC20Snapshot.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/ArraysUpgradeable.sol\\\";\\nimport \\\"../../../utils/CountersUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\\n * total supply at the time are recorded for later access.\\n *\\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\\n * In naive implementations it's possible to perform a \\\"double spend\\\" attack by reusing the same balance from different\\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\\n * used to create an efficient ERC20 forking mechanism.\\n *\\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\\n * and the account address.\\n *\\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\\n * return `block.number` will trigger the creation of snapshot at the beginning of each new block. When overriding this\\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\\n *\\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\\n * alternative consider {ERC20Votes}.\\n *\\n * ==== Gas Costs\\n *\\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\\n *\\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\\n * transfers will have normal cost until the next snapshot, and so on.\\n */\\n\\nabstract contract ERC20SnapshotUpgradeable is Initializable, ERC20Upgradeable {\\n    function __ERC20Snapshot_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC20Snapshot_init_unchained() internal onlyInitializing {\\n    }\\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\\n    // https://github.com/Giveth/minime/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\\n\\n    using ArraysUpgradeable for uint256[];\\n    using CountersUpgradeable for CountersUpgradeable.Counter;\\n\\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\\n    // Snapshot struct, but that would impede usage of functions that work on an array.\\n    struct Snapshots {\\n        uint256[] ids;\\n        uint256[] values;\\n    }\\n\\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\\n    Snapshots private _totalSupplySnapshots;\\n\\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\\n    CountersUpgradeable.Counter private _currentSnapshotId;\\n\\n    /**\\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\\n     */\\n    event Snapshot(uint256 id);\\n\\n    /**\\n     * @dev Creates a new snapshot and returns its snapshot id.\\n     *\\n     * Emits a {Snapshot} event that contains the same id.\\n     *\\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\\n     *\\n     * [WARNING]\\n     * ====\\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\\n     * you must consider that it can potentially be used by attackers in two ways.\\n     *\\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\\n     * section above.\\n     *\\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\\n     * ====\\n     */\\n    function _snapshot() internal virtual returns (uint256) {\\n        _currentSnapshotId.increment();\\n\\n        uint256 currentId = _getCurrentSnapshotId();\\n        emit Snapshot(currentId);\\n        return currentId;\\n    }\\n\\n    /**\\n     * @dev Get the current snapshotId\\n     */\\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\\n        return _currentSnapshotId.current();\\n    }\\n\\n    /**\\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\\n     */\\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\\n\\n        return snapshotted ? value : balanceOf(account);\\n    }\\n\\n    /**\\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\\n     */\\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\\n\\n        return snapshotted ? value : totalSupply();\\n    }\\n\\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        if (from == address(0)) {\\n            // mint\\n            _updateAccountSnapshot(to);\\n            _updateTotalSupplySnapshot();\\n        } else if (to == address(0)) {\\n            // burn\\n            _updateAccountSnapshot(from);\\n            _updateTotalSupplySnapshot();\\n        } else {\\n            // transfer\\n            _updateAccountSnapshot(from);\\n            _updateAccountSnapshot(to);\\n        }\\n    }\\n\\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\\n        require(snapshotId > 0, \\\"ERC20Snapshot: id is 0\\\");\\n        require(snapshotId <= _getCurrentSnapshotId(), \\\"ERC20Snapshot: nonexistent id\\\");\\n\\n        // When a valid snapshot is queried, there are three possibilities:\\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\\n        //  to this id is the current one.\\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\\n        //  requested id, and its value is the one to return.\\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\\n        //  larger than the requested one.\\n        //\\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\\n        // exactly this.\\n\\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\\n\\n        if (index == snapshots.ids.length) {\\n            return (false, 0);\\n        } else {\\n            return (true, snapshots.values[index]);\\n        }\\n    }\\n\\n    function _updateAccountSnapshot(address account) private {\\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\\n    }\\n\\n    function _updateTotalSupplySnapshot() private {\\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\\n    }\\n\\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\\n        uint256 currentId = _getCurrentSnapshotId();\\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\\n            snapshots.ids.push(currentId);\\n            snapshots.values.push(currentValue);\\n        }\\n    }\\n\\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\\n        if (ids.length == 0) {\\n            return 0;\\n        } else {\\n            return ids[ids.length - 1];\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[46] private __gap;\\n}\\n\",\"keccak256\":\"0x42da8099f59958af496f6c8f0d9c1ce0a929151e02f877e4be23aca4cc440cbe\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x605434219ebbe4653f703640f06969faa5a1d78f0bfef878e5ddbb1ca369ceeb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xcc70d8e2281fb3ff69e8ab242500f10142cd0a7fa8dd9e45882be270d4d09024\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/draft-IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x220c4a5af915e656be2aaa85ca57505d102418e476b1e2ef6c62e0c6ac143871\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721Upgradeable.sol\\\";\\nimport \\\"./IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"./extensions/IERC721MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\\n    using AddressUpgradeable for address;\\n    using StringsUpgradeable for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC721_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return\\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: address zero is not a valid owner\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _ownerOf(tokenId);\\n        require(owner != address(0), \\\"ERC721: invalid token ID\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not token owner or approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\\n     */\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _ownerOf(tokenId) != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\\n\\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        unchecked {\\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\\n            // Given that tokens are minted one by one, it is impossible in practice that\\n            // this ever happens. Might change if we allow batch minting.\\n            // The ERC fails to describe this case.\\n            _balances[to] += 1;\\n        }\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\\n\\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\\n        owner = ERC721Upgradeable.ownerOf(tokenId);\\n\\n        // Clear approvals\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // Cannot overflow, as that would require more tokens to be burned/transferred\\n            // out than the owner initially received through minting and transferring in.\\n            _balances[owner] -= 1;\\n        }\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId, 1);\\n\\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n\\n        // Clear approvals from the previous owner\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\\n            // `from`'s balance is the number of token held, which is at least one before the current\\n            // transfer.\\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\\n            // all 2**256 token ids to be minted, which in practice is impossible.\\n            _balances[from] -= 1;\\n            _balances[to] += 1;\\n        }\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        require(_exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\\n     * - When `from` is zero, the tokens will be minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256, /* firstTokenId */\\n        uint256 batchSize\\n    ) internal virtual {\\n        if (batchSize > 1) {\\n            if (from != address(0)) {\\n                _balances[from] -= batchSize;\\n            }\\n            if (to != address(0)) {\\n                _balances[to] += batchSize;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\\n     * - When `from` is zero, the tokens were minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens were burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[44] private __gap;\\n}\\n\",\"keccak256\":\"0x2a6a0b9fd2d316dcb4141159a9d13be92654066d6c0ae92757ed908ecdfecff0\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xbb2ed8106d94aeae6858e2551a1e7174df73994b77b13ebd120ccaaef80155f5\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x2c0b89cef83f353c6f9488c013d8a5968587ffdd6dfc26aad53774214b97e229\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x95a471796eb5f030fdc438660bebec121ad5d063763e64d92376ffb4b5ce8b70\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\\n    function __ERC721Holder_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC721Holder_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xb7f90ab8af7dae0bd4acfa088f9e606ea039110face097ca7c8beef563f71e90\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2edcb41c121abc510932e8d83ff8b82cf9cdde35e7c297622f5c29ef0af25183\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ArraysUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Arrays.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./StorageSlotUpgradeable.sol\\\";\\nimport \\\"./math/MathUpgradeable.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to array types.\\n */\\nlibrary ArraysUpgradeable {\\n    using StorageSlotUpgradeable for bytes32;\\n\\n    /**\\n     * @dev Searches a sorted `array` and returns the first index that contains\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\n     * values in the array are strictly less than `element`), the array length is\\n     * returned. Time complexity O(log n).\\n     *\\n     * `array` is expected to be sorted in ascending order, and to contain no\\n     * repeated elements.\\n     */\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        if (array.length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        while (low < high) {\\n            uint256 mid = MathUpgradeable.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds down (it does integer division with truncation).\\n            if (unsafeAccess(array, mid).value > element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlotUpgradeable.AddressSlot storage) {\\n        bytes32 slot;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0, arr.slot)\\n            slot := add(keccak256(0, 0x20), pos)\\n        }\\n        return slot.getAddressSlot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlotUpgradeable.Bytes32Slot storage) {\\n        bytes32 slot;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0, arr.slot)\\n            slot := add(keccak256(0, 0x20), pos)\\n        }\\n        return slot.getBytes32Slot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlotUpgradeable.Uint256Slot storage) {\\n        bytes32 slot;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0, arr.slot)\\n            slot := add(keccak256(0, 0x20), pos)\\n        }\\n        return slot.getUint256Slot();\\n    }\\n}\\n\",\"keccak256\":\"0xc3821e9d41b2b19b612238b308dcc8f4ab46afcd0f6b3bd174e89789bbf59e26\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary CountersUpgradeable {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\",\"keccak256\":\"0x798741e231b22b81e2dd2eddaaf8832dee4baf5cd8e2dbaa5c1dd12a1c053c4d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AddressUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract MulticallUpgradeable is Initializable {\\n    function __Multicall_init() internal onlyInitializing {\\n    }\\n\\n    function __Multicall_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract.\\n     */\\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = _functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return AddressUpgradeable.verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xb8709268fac307114f6cbb5e3cee798d91cd0adfea4d337c4920f8f0b2414f15\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x09864aea84f01e39313375b5610c73a3c1c68abbdc51e5ccdd25ff977fdadf9a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/MathUpgradeable.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = MathUpgradeable.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0x6b9a5d35b744b25529a2856a8093e7c03fb35a34b1c4fb5499e560f8ade140da\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../StringsUpgradeable.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSAUpgradeable {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", StringsUpgradeable.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0x12f297cafe6e2847ae0378502f155654d0764b532a9873c8afe4350950fa7971\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/cryptography/SignatureCheckerUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSAUpgradeable.sol\\\";\\nimport \\\"../AddressUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IERC1271Upgradeable.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureCheckerUpgradeable {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (address recovered, ECDSAUpgradeable.RecoverError error) = ECDSAUpgradeable.tryRecover(hash, signature);\\n        if (error == ECDSAUpgradeable.RecoverError.NoError && recovered == signer) {\\n            return true;\\n        }\\n\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271Upgradeable.isValidSignature.selector, hash, signature)\\n        );\\n        return (success &&\\n            result.length == 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271Upgradeable.isValidSignature.selector));\\n    }\\n}\\n\",\"keccak256\":\"0x5f6f34a77bdf88981d8985a33ebdb727df972172df6bdbb2a1bd480ce0bd43cb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x9a3b990bd56d139df3e454a9edf1c64668530b5a77fc32eb063bc206f958274a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc6cef87559d0aeffdf0a99803de655938a7779ec0a3cd5d4383483ad85565a09\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc1bd5b53319c68f84e3becd75694d941e8f4be94049903232cd8bc7c535aaa5a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCastUpgradeable {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0xcef50f95b43b038aa40aed25b62fc45906c681a5c1d504a4fdcf3bc6330a8d4b\",\"license\":\"MIT\"},\"contracts/array/LibUint256Array.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// Thrown if a truncated length is longer than the array being truncated. It is\\n/// not possible to truncate something and increase its length as the memory\\n/// region after the array MAY be allocated for something else already.\\nerror OutOfBoundsTruncate(uint256 arrayLength, uint256 truncatedLength);\\n\\n/// @title Uint256Array\\n/// @notice Things we want to do carefully and efficiently with uint256 arrays\\n/// that Solidity doesn't give us native tools for.\\nlibrary LibUint256Array {\\n    using LibUint256Array for uint256[];\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ a single integer to build an array around.\\n    /// @return the newly allocated array including a_ as a single item.\\n    function arrayFrom(uint256 a_) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](1);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ the first integer to build an array around.\\n    /// @param b_ the second integer to build an array around.\\n    /// @return the newly allocated array including a_ and b_ as the only items.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](2);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ the first integer to build an array around.\\n    /// @param b_ the second integer to build an array around.\\n    /// @param c_ the third integer to build an array around.\\n    /// @return the newly allocated array including a_, b_ and c_ as the only\\n    /// items.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](3);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ the first integer to build an array around.\\n    /// @param b_ the second integer to build an array around.\\n    /// @param c_ the third integer to build an array around.\\n    /// @param d_ the fourth integer to build an array around.\\n    /// @return the newly allocated array including a_, b_, c_ and d_ as the only\\n    /// items.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](4);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n            mstore(add(array_, 0x80), d_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ the first integer to build an array around.\\n    /// @param b_ the second integer to build an array around.\\n    /// @param c_ the third integer to build an array around.\\n    /// @param d_ the fourth integer to build an array around.\\n    /// @param e_ the fifth integer to build an array around.\\n    /// @return the newly allocated array including a_, b_, c_, d_ and e_ as the\\n    /// only items.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_,\\n        uint256 e_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](5);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n            mstore(add(array_, 0x80), d_)\\n            mstore(add(array_, 0xA0), e_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ the first integer to build an array around.\\n    /// @param b_ the second integer to build an array around.\\n    /// @param c_ the third integer to build an array around.\\n    /// @param d_ the fourth integer to build an array around.\\n    /// @param e_ the fifth integer to build an array around.\\n    /// @param f_ the sixth integer to build an array around.\\n    /// @return the newly allocated array including a_, b_, c_, d_, e_ and f_ as\\n    /// the only items.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_,\\n        uint256 e_,\\n        uint256 f_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](6);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n            mstore(add(array_, 0x80), d_)\\n            mstore(add(array_, 0xA0), e_)\\n            mstore(add(array_, 0xC0), f_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ The head of the new array.\\n    /// @param tail_ The tail of the new array.\\n    /// @return The new array.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256[] memory tail_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](1);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n        }\\n        array_.extend(tail_);\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ The first item of the new array.\\n    /// @param b_ The second item of the new array.\\n    /// @param tail_ The tail of the new array.\\n    /// @return The new array.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256[] memory tail_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](2);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n        }\\n        array_.extend(tail_);\\n        return array_;\\n    }\\n\\n    /// 2-dimensional analogue of `arrayFrom`. Takes a 1-dimensional array and\\n    /// coerces it to a 2-dimensional matrix where the first and only item in the\\n    /// matrix is the 1-dimensional array.\\n    /// @param a_ The 1-dimensional array to coerce.\\n    /// @return The 2-dimensional matrix containing `a_`.\\n    function matrixFrom(\\n        uint256[] memory a_\\n    ) internal pure returns (uint256[][] memory) {\\n        uint256[][] memory matrix_ = new uint256[][](1);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(matrix_, 0x20), a_)\\n        }\\n        return matrix_;\\n    }\\n\\n    /// Solidity provides no way to change the length of in-memory arrays but\\n    /// it also does not deallocate memory ever. It is always safe to shrink an\\n    /// array that has already been allocated, with the caveat that the\\n    /// truncated items will effectively become inaccessible regions of memory.\\n    /// That is to say, we deliberately \\\"leak\\\" the truncated items, but that is\\n    /// no worse than Solidity's native behaviour of leaking everything always.\\n    /// The array is MUTATED in place so there is no return value and there is\\n    /// no new allocation or copying of data either.\\n    /// @param array_ The array to truncate.\\n    /// @param newLength_ The new length of the array after truncation.\\n    function truncate(\\n        uint256[] memory array_,\\n        uint256 newLength_\\n    ) internal pure {\\n        if (newLength_ > array_.length) {\\n            revert OutOfBoundsTruncate(array_.length, newLength_);\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(array_, newLength_)\\n        }\\n    }\\n\\n    /// Extends `base_` with `extend_` by allocating additional `extend_.length`\\n    /// uints onto `base_`. Reverts if some other memory has been allocated\\n    /// after `base_` already, in which case it is NOT safe to copy inline.\\n    /// If `base_` is large this MAY be significantly more efficient than\\n    /// allocating `base_.length + extend_.length` for an entirely new array and\\n    /// copying both `base_` and `extend_` into the new array one item at a\\n    /// time in Solidity.\\n    /// The Solidity compiler MAY rearrange sibling statements in a code block\\n    /// EVEN IF THE OPTIMIZER IS DISABLED such that it becomes unsafe to use\\n    /// `extend` for memory allocated in different code blocks. It is ONLY safe\\n    /// to `extend` arrays that were allocated in the same lexical scope and you\\n    /// WILL see subtle errors that revert transactions otherwise.\\n    /// i.e. the `new` keyword MUST appear in the same code block as `extend`.\\n    /// @param base_ The base integer array that will be extended by `extend_`.\\n    /// @param extend_ The integer array that extends `base_`.\\n    function extend(\\n        uint256[] memory base_,\\n        uint256[] memory extend_\\n    ) internal pure {\\n        uint256 freeMemoryPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            // Solidity stores free memory pointer at 0x40\\n            freeMemoryPointer_ := mload(0x40)\\n            let baseLength_ := mload(base_)\\n            let extendLength_ := mload(extend_)\\n\\n            // The freeMemoryPointer_ does NOT point to the end of `base_` so\\n            // it is NOT safe to copy `extend_` over the top of already\\n            // allocated memory. This happens whenever some memory is allocated\\n            // after `base_` is allocated but before `extend` is called.\\n            if gt(\\n                freeMemoryPointer_,\\n                add(base_, add(0x20, mul(0x20, baseLength_)))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            // Move the free memory pointer by the length of extend_, excluding\\n            // the length slot of extend as that will NOT be copied to `base_`.\\n            mstore(0x40, add(freeMemoryPointer_, mul(0x20, extendLength_)))\\n\\n            // Update the length of base to be the length of base+extend.\\n            mstore(base_, add(baseLength_, extendLength_))\\n        }\\n\\n        unsafeCopyValuesTo(extend_, freeMemoryPointer_);\\n    }\\n\\n    /// Copies `inputs_` to `outputCursor_` with NO attempt to check that this\\n    /// is safe to do so. The caller MUST ensure that there exists allocated\\n    /// memory at `outputCursor_` in which it is safe and appropriate to copy\\n    /// ALL `inputs_` to. Anything that was already written to memory at\\n    /// `[outputCursor_:outputCursor_+(inputs_.length * 32 bytes)]` will be\\n    /// overwritten. The length of `inputs_` is NOT copied to the output\\n    /// location, ONLY the `uint256` values of the `inputs_` array are copied.\\n    /// There is no return value as memory is modified directly.\\n    /// @param inputs_ The input array that will be copied from EXCLUDING the\\n    /// length at the start of the array in memory.\\n    /// @param outputCursor_ Location in memory that the values will be copied\\n    /// to linearly.\\n    function unsafeCopyValuesTo(\\n        uint256[] memory inputs_,\\n        uint256 outputCursor_\\n    ) internal pure {\\n        uint256 inputCursor_;\\n        assembly (\\\"memory-safe\\\") {\\n            inputCursor_ := add(inputs_, 0x20)\\n        }\\n        unsafeCopyValuesTo(inputCursor_, outputCursor_, inputs_.length);\\n    }\\n\\n    /// Copies `length_` 32 byte words from `inputCursor_` to a newly allocated\\n    /// uint256[] array with NO attempt to check that the inputs are sane.\\n    /// This function is safe in that the outputs are guaranteed to be copied\\n    /// to newly allocated memory so no existing data will be overwritten.\\n    /// This function is subtle in that the `inputCursor_` is NOT validated in\\n    /// any way so the caller MUST ensure it points to a sensible memory\\n    /// location to read (e.g. to exclude the length from input arrays etc.).\\n    /// @param inputCursor_ The start of the memory that will be copied to the\\n    /// newly allocated array.\\n    /// @param length_ Number of 32 byte words to copy starting at\\n    /// `inputCursor_` to the items of the newly allocated array.\\n    /// @return The newly allocated `uint256[]` array.\\n    function copyToNewUint256Array(\\n        uint256 inputCursor_,\\n        uint256 length_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory outputs_ = new uint256[](length_);\\n        uint256 outputCursor_;\\n        assembly (\\\"memory-safe\\\") {\\n            outputCursor_ := add(outputs_, 0x20)\\n        }\\n        unsafeCopyValuesTo(inputCursor_, outputCursor_, length_);\\n        return outputs_;\\n    }\\n\\n    /// Copies `length_` uint256 values starting from `inputsCursor_` to\\n    /// `outputCursor_` with NO attempt to check that this is safe to do so.\\n    /// The caller MUST ensure that there exists allocated memory at\\n    /// `outputCursor_` in which it is safe and appropriate to copy\\n    /// `length_ * 32` bytes to. Anything that was already written to memory at\\n    /// `[outputCursor_:outputCursor_+(length_ * 32 bytes)]` will be\\n    /// overwritten.\\n    /// There is no return value as memory is modified directly.\\n    /// @param inputCursor_ The starting position in memory that data will be\\n    /// copied from.\\n    /// @param outputCursor_ The starting position in memory that data will be\\n    /// copied to.\\n    /// @param length_ The number of 32 byte (i.e. `uint256`) values that will\\n    /// be copied.\\n    function unsafeCopyValuesTo(\\n        uint256 inputCursor_,\\n        uint256 outputCursor_,\\n        uint256 length_\\n    ) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n                let end_ := add(inputCursor_, mul(0x20, length_))\\n            } lt(inputCursor_, end_) {\\n                inputCursor_ := add(inputCursor_, 0x20)\\n                outputCursor_ := add(outputCursor_, 0x20)\\n            } {\\n                mstore(outputCursor_, mload(inputCursor_))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x118cb5bba9671ac311c8e196984e6213390334712f53dea901284fa4ba208b84\",\"license\":\"CAL\"},\"contracts/bytes/LibBytes.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// @title LibBytes\\n/// @notice Things we want to do carefully and efficiently with `bytes` in memory\\n/// that Solidity doesn't give us native tools for.\\nlibrary LibBytes {\\n    /// Copy an arbitrary number of bytes from one location in memory to another.\\n    /// As we can only read/write bytes in 32 byte chunks we first have to loop\\n    /// over 32 byte values to copy then handle any unaligned remaining data. The\\n    /// remaining data will be appropriately masked with the existing data in the\\n    /// final chunk so as to not write past the desired length. Note that the\\n    /// final unaligned write will be more gas intensive than the prior aligned\\n    /// writes. The writes are completely unsafe, the caller MUST ensure that\\n    /// sufficient memory is allocated and reading/writing the requested number\\n    /// of bytes from/to the requested locations WILL NOT corrupt memory in the\\n    /// opinion of solidity or other subsequent read/write operations.\\n    /// @param inputCursor_ The starting location in memory to read from.\\n    /// @param outputCursor_ The starting location in memory to write to.\\n    /// @param remaining_ The number of bytes to read/write.\\n    function unsafeCopyBytesTo(\\n        uint256 inputCursor_,\\n        uint256 outputCursor_,\\n        uint256 remaining_\\n    ) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n\\n            } iszero(lt(remaining_, 0x20)) {\\n                remaining_ := sub(remaining_, 0x20)\\n                inputCursor_ := add(inputCursor_, 0x20)\\n                outputCursor_ := add(outputCursor_, 0x20)\\n            } {\\n                mstore(outputCursor_, mload(inputCursor_))\\n            }\\n\\n            if gt(remaining_, 0) {\\n                let mask_ := shr(\\n                    mul(remaining_, 8),\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n                // preserve existing bytes\\n                mstore(\\n                    outputCursor_,\\n                    or(\\n                        // input\\n                        and(mload(inputCursor_), not(mask_)),\\n                        and(mload(outputCursor_), mask_)\\n                    )\\n                )\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x613125e88688bca7d52cc48447a70fd2a17b3a120ef41c7c61092b3b523aa121\",\"license\":\"CAL\"},\"contracts/chainlink/LibChainlink.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../math/FixedPointMath.sol\\\";\\n\\n/// Thrown if a price is zero or negative as this is probably not anticipated or\\n/// useful for most users of a price feed. Of course there are use cases where\\n/// zero or negative _oracle values_ in general are useful, such as negative\\n/// temperatures from a thermometer, but these are unlikely to be useful _prices_\\n/// for assets. Zero value prices are likely to result in division by zero\\n/// downstream or giving away assets for free, negative price values could result\\n/// in even weirder behaviour due to token amounts being `uint256` and the\\n/// subtleties of signed vs. unsigned integer conversions.\\n/// @param price The price that is not a positive integer.\\nerror NotPosIntPrice(int256 price);\\n\\n/// Thrown when the updatedAt time from the Chainlink oracle is more than\\n/// staleAfter seconds prior to the current block timestamp. Prevents stale\\n/// prices from being used within the constraints set by the caller.\\n/// @param updatedAt The latest time the oracle was updated according to the\\n/// oracle.\\n/// @param staleAfter The maximum number of seconds the caller allows between\\n/// the block timestamp and the updated time.\\nerror StalePrice(uint256 updatedAt, uint256 staleAfter);\\n\\nlibrary LibChainlink {\\n    using SafeCast for int256;\\n    using FixedPointMath for uint256;\\n\\n    function price(\\n        address feed_,\\n        uint256 staleAfter_\\n    ) internal view returns (uint256) {\\n        (, int256 answer_, , uint256 updatedAt_, ) = AggregatorV3Interface(\\n            feed_\\n        ).latestRoundData();\\n\\n        if (answer_ <= 0) {\\n            revert NotPosIntPrice(answer_);\\n        }\\n\\n        // Checked time comparison ensures no updates from the future as that\\n        // would overflow, and no stale prices.\\n        // solhint-disable-next-line not-rely-on-time\\n        if (block.timestamp - updatedAt_ > staleAfter_) {\\n            revert StalePrice(updatedAt_, staleAfter_);\\n        }\\n\\n        // Safely cast the answer to uint256 and scale it to 18 decimal FP.\\n        return\\n            answer_.toUint256().scale18(\\n                AggregatorV3Interface(feed_).decimals()\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x3ff6ddc5c8209e59dce4be84215c8b0421c60e338f87b778b6fde234870594a5\",\"license\":\"CAL\"},\"contracts/flow/FlowCommon.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"./libraries/LibFlow.sol\\\";\\nimport \\\"../interpreter/deploy/IExpressionDeployerV1.sol\\\";\\nimport \\\"../interpreter/run/IInterpreterV1.sol\\\";\\nimport \\\"../interpreter/run/LibEncodedDispatch.sol\\\";\\nimport \\\"../interpreter/run/LibContext.sol\\\";\\nimport \\\"../interpreter/run/LibInterpreterState.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {MulticallUpgradeable as Multicall} from \\\"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\\\";\\nimport {ERC721HolderUpgradeable as ERC721Holder} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\\\";\\nimport {ERC1155HolderUpgradeable as ERC1155Holder} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\\\";\\n\\nuint256 constant FLAG_COLUMN_FLOW_ID = 0;\\nuint256 constant FLAG_ROW_FLOW_ID = 0;\\nuint256 constant FLAG_COLUMN_FLOW_TIME = 0;\\nuint256 constant FLAG_ROW_FLOW_TIME = 2;\\n\\nuint256 constant MIN_FLOW_SENTINELS = 4;\\n\\nSourceIndex constant FLOW_ENTRYPOINT = SourceIndex.wrap(0);\\nuint256 constant FLOW_MAX_OUTPUTS = type(uint16).max;\\n\\nstruct FlowCommonConfig {\\n    address expressionDeployer;\\n    address interpreter;\\n    StateConfig[] flows;\\n}\\n\\ncontract FlowCommon is ERC721Holder, ERC1155Holder, Multicall {\\n    using LibInterpreterState for InterpreterState;\\n    using LibStackPointer for StackPointer;\\n    using LibStackPointer for uint256[];\\n    using LibUint256Array for uint256;\\n    using LibUint256Array for uint256[];\\n\\n    IInterpreterV1 internal _interpreter;\\n\\n    /// flow expression pointer => is registered\\n    mapping(EncodedDispatch => uint256) internal _flows;\\n\\n    event FlowInitialized(\\n        address sender,\\n        address interpreter,\\n        EncodedDispatch dispatch\\n    );\\n\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __FlowCommon_init(\\n        FlowCommonConfig memory config_,\\n        uint256 flowMinOutputs_\\n    ) internal onlyInitializing {\\n        __ERC721Holder_init();\\n        __ERC1155Holder_init();\\n        __Multicall_init();\\n        require(flowMinOutputs_ >= MIN_FLOW_SENTINELS, \\\"BAD MIN STACKS LENGTH\\\");\\n        _interpreter = IInterpreterV1(config_.interpreter);\\n        for (uint256 i_ = 0; i_ < config_.flows.length; i_++) {\\n            address expression_ = IExpressionDeployerV1(\\n                config_.expressionDeployer\\n            ).deployExpression(\\n                    config_.flows[i_],\\n                    LibUint256Array.arrayFrom(flowMinOutputs_)\\n                );\\n            EncodedDispatch dispatch_ = LibEncodedDispatch.encode(\\n                expression_,\\n                FLOW_ENTRYPOINT,\\n                FLOW_MAX_OUTPUTS\\n            );\\n            _flows[dispatch_] = 1;\\n            emit FlowInitialized(msg.sender, config_.interpreter, dispatch_);\\n        }\\n    }\\n\\n    modifier onlyRegisteredDispatch(EncodedDispatch dispatch_) {\\n        require(_flows[dispatch_] > 0, \\\"UNREGISTERED_FLOW\\\");\\n        _;\\n    }\\n\\n    function flowStack(\\n        EncodedDispatch dispatch_,\\n        uint256[] memory callerContext_,\\n        SignedContext[] memory signedContexts_\\n    )\\n        internal\\n        view\\n        onlyRegisteredDispatch(dispatch_)\\n        returns (StackPointer, StackPointer, uint256[] memory)\\n    {\\n        (uint256[] memory stack_, uint256[] memory stateChanges_) = _interpreter\\n            .eval(\\n                dispatch_,\\n                LibContext.build(\\n                    new uint256[][](0),\\n                    callerContext_,\\n                    signedContexts_\\n                )\\n            );\\n        return (\\n            stack_.asStackPointerUp(),\\n            stack_.asStackPointerAfter(),\\n            stateChanges_\\n        );\\n    }\\n\\n    receive() external payable virtual {}\\n}\\n\",\"keccak256\":\"0x9f0799da019c4b88d8e2088764202caf60102cbea2603843b35f2013039e6976\",\"license\":\"CAL\"},\"contracts/flow/erc721/FlowERC721.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"../../interpreter/deploy/IExpressionDeployerV1.sol\\\";\\nimport {AllStandardOps} from \\\"../../interpreter/ops/AllStandardOps.sol\\\";\\nimport {ERC721Upgradeable as ERC721} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\\\";\\nimport \\\"../../array/LibUint256Array.sol\\\";\\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"../libraries/LibFlow.sol\\\";\\nimport \\\"../../math/FixedPointMath.sol\\\";\\nimport \\\"../FlowCommon.sol\\\";\\nimport \\\"../../sentinel/LibSentinel.sol\\\";\\nimport {ERC1155ReceiverUpgradeable as ERC1155Receiver} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"../../interpreter/run/LibEncodedDispatch.sol\\\";\\n\\nuint256 constant RAIN_FLOW_ERC721_SENTINEL = uint256(\\n    keccak256(bytes(\\\"RAIN_FLOW_ERC721_SENTINEL\\\")) | SENTINEL_HIGH_BITS\\n);\\n\\n/// Constructor config.\\n/// @param Constructor config for the ERC721 token minted according to flow\\n/// schedule in `flow`.\\n/// @param Constructor config for the `ImmutableSource` that defines the\\n/// emissions schedule for claiming.\\nstruct FlowERC721Config {\\n    string name;\\n    string symbol;\\n    StateConfig stateConfig;\\n    FlowCommonConfig flowConfig;\\n}\\n\\nstruct ERC721SupplyChange {\\n    address account;\\n    uint256 id;\\n}\\n\\nstruct FlowERC721IO {\\n    ERC721SupplyChange[] mints;\\n    ERC721SupplyChange[] burns;\\n    FlowTransfer flow;\\n}\\n\\nSourceIndex constant CAN_TRANSFER_ENTRYPOINT = SourceIndex.wrap(0);\\nuint256 constant CAN_TRANSFER_MIN_OUTPUTS = 1;\\nuint256 constant CAN_TRANSFER_MAX_OUTPUTS = 1;\\n\\n/// @title FlowERC721\\ncontract FlowERC721 is ReentrancyGuard, FlowCommon, ERC721 {\\n    using LibStackPointer for uint256[];\\n    using LibStackPointer for StackPointer;\\n    using LibUint256Array for uint256;\\n    using LibUint256Array for uint256[];\\n    using LibInterpreterState for InterpreterState;\\n    using FixedPointMath for uint256;\\n\\n    /// Contract has initialized.\\n    /// @param sender `msg.sender` initializing the contract (factory).\\n    /// @param config All initialized config.\\n    event Initialize(address sender, FlowERC721Config config);\\n\\n    EncodedDispatch internal _dispatch;\\n\\n    /// @param config_ source and token config. Also controls delegated claims.\\n    function initialize(\\n        FlowERC721Config calldata config_\\n    ) external initializer {\\n        emit Initialize(msg.sender, config_);\\n        __ReentrancyGuard_init();\\n        __ERC721_init(config_.name, config_.symbol);\\n        address expression_ = IExpressionDeployerV1(\\n            config_.flowConfig.expressionDeployer\\n        ).deployExpression(\\n                config_.stateConfig,\\n                LibUint256Array.arrayFrom(CAN_TRANSFER_MIN_OUTPUTS)\\n            );\\n        _dispatch = LibEncodedDispatch.encode(\\n            expression_,\\n            CAN_TRANSFER_ENTRYPOINT,\\n            CAN_TRANSFER_MAX_OUTPUTS\\n        );\\n        __FlowCommon_init(config_.flowConfig, MIN_FLOW_SENTINELS + 2);\\n    }\\n\\n    /// Needed here to fix Open Zeppelin implementing `supportsInterface` on\\n    /// multiple base contracts.\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC721, ERC1155Receiver) returns (bool) {\\n        return super.supportsInterface(interfaceId);\\n    }\\n\\n    /// @inheritdoc ERC721\\n    function _afterTokenTransfer(\\n        address from_,\\n        address to_,\\n        uint256 tokenId_,\\n        uint256 batchSize_\\n    ) internal virtual override {\\n        super._afterTokenTransfer(from_, to_, tokenId_, batchSize_);\\n        // Mint and burn access MUST be handled by CAN_FLOW.\\n        // CAN_TRANSFER will only restrict subsequent transfers.\\n        if (!(from_ == address(0) || to_ == address(0))) {\\n            uint256[] memory callerContext_ = LibUint256Array.arrayFrom(\\n                uint256(uint160(from_)),\\n                uint256(uint160(to_)),\\n                tokenId_,\\n                batchSize_\\n            );\\n            EncodedDispatch dispatch_ = _dispatch;\\n            (\\n                uint256[] memory stack_,\\n                uint256[] memory stateChanges_\\n            ) = _interpreter.eval(\\n                    dispatch_,\\n                    LibContext.build(\\n                        new uint256[][](0),\\n                        callerContext_,\\n                        new SignedContext[](0)\\n                    )\\n                );\\n            require(\\n                stack_.asStackPointerAfter().peek() > 0,\\n                \\\"INVALID_TRANSFER\\\"\\n            );\\n            if (stateChanges_.length > 0) {\\n                _interpreter.stateChanges(stateChanges_);\\n            }\\n        }\\n    }\\n\\n    function _previewFlow(\\n        EncodedDispatch dispatch_,\\n        uint256[] memory callerContext_,\\n        SignedContext[] memory signedContexts_\\n    ) internal view returns (FlowERC721IO memory, uint256[] memory) {\\n        uint256[] memory refs_;\\n        FlowERC721IO memory flowIO_;\\n        (\\n            StackPointer stackBottom_,\\n            StackPointer stackTop_,\\n            uint256[] memory stateChanges_\\n        ) = flowStack(dispatch_, callerContext_, signedContexts_);\\n        // mints\\n        (stackTop_, refs_) = stackTop_.consumeStructs(\\n            stackBottom_,\\n            RAIN_FLOW_ERC721_SENTINEL,\\n            2\\n        );\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(flowIO_, refs_)\\n        }\\n        // burns\\n        (stackTop_, refs_) = stackTop_.consumeStructs(\\n            stackBottom_,\\n            RAIN_FLOW_ERC721_SENTINEL,\\n            2\\n        );\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(flowIO_, 0x20), refs_)\\n        }\\n        flowIO_.flow = LibFlow.stackToFlow(stackBottom_, stackTop_);\\n        return (flowIO_, stateChanges_);\\n    }\\n\\n    function _flow(\\n        EncodedDispatch dispatch_,\\n        uint256[] memory callerContext_,\\n        SignedContext[] memory signedContexts_\\n    ) internal virtual nonReentrant returns (FlowERC721IO memory) {\\n        unchecked {\\n            (\\n                FlowERC721IO memory flowIO_,\\n                uint256[] memory stateChanges_\\n            ) = _previewFlow(dispatch_, callerContext_, signedContexts_);\\n            for (uint256 i_ = 0; i_ < flowIO_.mints.length; i_++) {\\n                _safeMint(flowIO_.mints[i_].account, flowIO_.mints[i_].id);\\n            }\\n            for (uint256 i_ = 0; i_ < flowIO_.burns.length; i_++) {\\n                uint256 burnId_ = flowIO_.burns[i_].id;\\n                require(\\n                    ERC721.ownerOf(burnId_) == flowIO_.burns[i_].account,\\n                    \\\"NOT_OWNER\\\"\\n                );\\n                _burn(burnId_);\\n            }\\n            LibFlow.flow(flowIO_.flow, _interpreter, stateChanges_);\\n            return flowIO_;\\n        }\\n    }\\n\\n    function previewFlow(\\n        EncodedDispatch dispatch_,\\n        uint256[] memory callerContext_,\\n        SignedContext[] memory signedContexts_\\n    ) external view virtual returns (FlowERC721IO memory) {\\n        (FlowERC721IO memory flowERC721IO_, ) = _previewFlow(\\n            dispatch_,\\n            callerContext_,\\n            signedContexts_\\n        );\\n        return flowERC721IO_;\\n    }\\n\\n    function flow(\\n        EncodedDispatch dispatch_,\\n        uint256[] memory callerContext_,\\n        SignedContext[] memory signedContexts_\\n    ) external payable virtual returns (FlowERC721IO memory) {\\n        return _flow(dispatch_, callerContext_, signedContexts_);\\n    }\\n}\\n\",\"keccak256\":\"0x1a1c30d35e5948afd71ac3617dac907649fdf68170355c7b387a41b51c54b2b9\",\"license\":\"CAL\"},\"contracts/flow/libraries/LibFlow.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../interpreter/run/LibStackPointer.sol\\\";\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {SafeERC20Upgradeable as SafeERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport {IERC721Upgradeable as IERC721} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport {IERC1155Upgradeable as IERC1155} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\";\\nimport {AddressUpgradeable as Address} from \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../sentinel/LibSentinel.sol\\\";\\nimport {SafeCastUpgradeable as SafeCast} from \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\\\";\\n\\n/// @dev We want a sentinel with the following properties:\\n/// - Won't collide with token amounts (| with very large number)\\n/// - Won't collide with token addresses\\n/// - Won't collide with common values like `type(uint256).max` and\\n///   `type(uint256).min`\\n/// - Won't collide with other sentinels from unrelated contexts\\nuint256 constant RAIN_FLOW_SENTINEL = uint256(\\n    keccak256(bytes(\\\"RAIN_FLOW_SENTINEL\\\")) | SENTINEL_HIGH_BITS\\n);\\n\\nstruct NativeTransfer {\\n    address from;\\n    address to;\\n    uint256 amount;\\n}\\n\\nstruct ERC20Transfer {\\n    address token;\\n    address from;\\n    address to;\\n    uint256 amount;\\n}\\n\\nstruct ERC721Transfer {\\n    address token;\\n    address from;\\n    address to;\\n    uint256 id;\\n}\\n\\nstruct ERC1155Transfer {\\n    address token;\\n    address from;\\n    address to;\\n    uint256 id;\\n    uint256 amount;\\n}\\n\\nstruct FlowTransfer {\\n    NativeTransfer[] native;\\n    ERC20Transfer[] erc20;\\n    ERC721Transfer[] erc721;\\n    ERC1155Transfer[] erc1155;\\n}\\n\\nlibrary LibFlow {\\n    using Address for address payable;\\n    using SafeERC20 for IERC20;\\n    using LibStackPointer for StackPointer;\\n    using SafeCast for uint256;\\n    using LibFlow for FlowTransfer;\\n    using LibUint256Array for uint256[];\\n\\n    function stackToFlow(\\n        StackPointer stackBottom_,\\n        StackPointer stackTop_\\n    ) internal pure returns (FlowTransfer memory) {\\n        unchecked {\\n            FlowTransfer memory transfer_;\\n            uint256[] memory refs_;\\n            // native\\n            (stackTop_, refs_) = stackTop_.consumeStructs(\\n                stackBottom_,\\n                RAIN_FLOW_SENTINEL,\\n                3\\n            );\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(transfer_, refs_)\\n            }\\n            // erc20\\n            (stackTop_, refs_) = stackTop_.consumeStructs(\\n                stackBottom_,\\n                RAIN_FLOW_SENTINEL,\\n                4\\n            );\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(add(transfer_, 0x20), refs_)\\n            }\\n            // erc721\\n            (stackTop_, refs_) = stackTop_.consumeStructs(\\n                stackBottom_,\\n                RAIN_FLOW_SENTINEL,\\n                4\\n            );\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(add(transfer_, 0x40), refs_)\\n            }\\n            // erc1155\\n            (stackTop_, refs_) = stackTop_.consumeStructs(\\n                stackBottom_,\\n                RAIN_FLOW_SENTINEL,\\n                5\\n            );\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(add(transfer_, 0x60), refs_)\\n            }\\n            return transfer_;\\n        }\\n    }\\n\\n    function flowNative(FlowTransfer memory flowTransfer_) internal {\\n        unchecked {\\n            uint256 youToMe_ = 0;\\n            uint256 meToYou_ = 0;\\n            NativeTransfer memory transfer_;\\n            for (uint256 i_ = 0; i_ < flowTransfer_.native.length; i_++) {\\n                transfer_ = flowTransfer_.native[i_];\\n                if (transfer_.from == msg.sender) {\\n                    require(\\n                        transfer_.to == address(this),\\n                        \\\"UNSUPPORTED_NATIVE_FLOW\\\"\\n                    );\\n                    youToMe_ += transfer_.amount;\\n                } else {\\n                    require(\\n                        transfer_.from == address(this),\\n                        \\\"UNSUPPORTED_NATIVE_FLOW\\\"\\n                    );\\n                    if (transfer_.to == msg.sender) {\\n                        meToYou_ += transfer_.amount;\\n                    } else {\\n                        payable(transfer_.to).sendValue(transfer_.amount);\\n                    }\\n                }\\n            }\\n\\n            if (youToMe_ > 0) {\\n                // This will overflow if the msg.value is less than youToMe_.\\n                // Will refund any excess incoming value.\\n                meToYou_ += msg.value - youToMe_;\\n            }\\n            if (meToYou_ > 0) {\\n                payable(msg.sender).sendValue(meToYou_);\\n            }\\n        }\\n    }\\n\\n    function flowERC20(FlowTransfer memory flowTransfer_) internal {\\n        unchecked {\\n            ERC20Transfer memory transfer_;\\n            for (uint256 i_ = 0; i_ < flowTransfer_.erc20.length; i_++) {\\n                transfer_ = flowTransfer_.erc20[i_];\\n                if (transfer_.from == msg.sender) {\\n                    IERC20(transfer_.token).safeTransferFrom(\\n                        msg.sender,\\n                        transfer_.to,\\n                        transfer_.amount\\n                    );\\n                } else if (transfer_.from == address(this)) {\\n                    IERC20(transfer_.token).safeTransfer(\\n                        transfer_.to,\\n                        transfer_.amount\\n                    );\\n                } else {\\n                    // We don't support `from` as anyone other than `you` or `me`\\n                    // as this would allow for all kinds of issues re: approvals.\\n                    revert(\\\"UNSUPPORTED_ERC20_FLOW\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function flowERC721(FlowTransfer memory flowTransfer_) internal {\\n        unchecked {\\n            ERC721Transfer memory transfer_;\\n            for (uint256 i_ = 0; i_ < flowTransfer_.erc721.length; i_++) {\\n                transfer_ = flowTransfer_.erc721[i_];\\n                require(\\n                    transfer_.from == msg.sender ||\\n                        transfer_.from == address(this),\\n                    \\\"UNSUPPORTED_ERC721_FLOW\\\"\\n                );\\n                IERC721(transfer_.token).safeTransferFrom(\\n                    transfer_.from,\\n                    transfer_.to,\\n                    transfer_.id\\n                );\\n            }\\n        }\\n    }\\n\\n    function flowERC1155(FlowTransfer memory flowTransfer_) internal {\\n        unchecked {\\n            ERC1155Transfer memory transfer_;\\n            for (uint256 i_ = 0; i_ < flowTransfer_.erc1155.length; i_++) {\\n                transfer_ = flowTransfer_.erc1155[i_];\\n                require(\\n                    transfer_.from == msg.sender ||\\n                        transfer_.from == address(this),\\n                    \\\"UNSUPPORTED_ERC1155_FLOW\\\"\\n                );\\n                // @todo safeBatchTransferFrom support.\\n                // @todo data support.\\n                IERC1155(transfer_.token).safeTransferFrom(\\n                    transfer_.from,\\n                    transfer_.to,\\n                    transfer_.id,\\n                    transfer_.amount,\\n                    \\\"\\\"\\n                );\\n            }\\n        }\\n    }\\n\\n    function flow(\\n        FlowTransfer memory flowTransfer_,\\n        IInterpreterV1 interpreter_,\\n        uint256[] memory stateChanges_\\n    ) internal {\\n        if (stateChanges_.length > 0) {\\n            interpreter_.stateChanges(stateChanges_);\\n        }\\n        flowTransfer_.flowNative();\\n        flowTransfer_.flowERC20();\\n        flowTransfer_.flowERC721();\\n        flowTransfer_.flowERC1155();\\n    }\\n}\\n\",\"keccak256\":\"0x209d2b27c7bcf64cb185d6a9240c2602b16b7a8bb35746e2f553e9a43aa12487\",\"license\":\"CAL\"},\"contracts/interpreter/deploy/IExpressionDeployerV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\n/// Config required to build a new `State`.\\n/// @param sources Sources verbatim. These sources MUST be provided in their\\n/// sequential/index opcode form as the deployment process will need to index\\n/// into BOTH the integrity check and the final runtime function pointers.\\n/// This will be emitted in an event for offchain processing to use the indexed\\n/// opcode sources. The first N sources are considered entrypoints and will be\\n/// integrity checked by the expression deployer against a starting stack height\\n/// of 0. Non-entrypoint sources MAY be provided for internal use such as the\\n/// `call` opcode but will NOT be integrity checked UNLESS entered by an opcode\\n/// in an entrypoint.\\n/// @param constants Constants verbatim. Constants are provided alongside sources\\n/// rather than inline as it allows us to avoid variable length opcodes and can\\n/// be more memory efficient if the same constant is referenced several times\\n/// from the sources.\\nstruct StateConfig {\\n    bytes[] sources;\\n    uint256[] constants;\\n}\\n\\n/// @title IExpressionDeployerV1\\n/// @notice Companion to `IInterpreterV1` responsible for onchain static code\\n/// analysis and deploying expressions. Each `IExpressionDeployerV1` is tightly\\n/// coupled at the bytecode level to some interpreter that it knows how to\\n/// analyse and deploy expressions for. The expression deployer can perform an\\n/// integrity check \\\"dry run\\\" of candidate source code for the intepreter. The\\n/// critical analysis/transformation includes:\\n///\\n/// - Enforcement of no out of bounds memory reads/writes\\n/// - Calculation of memory required to eval the stack with a single allocation\\n/// - Replacing index based opcodes with absolute interpreter function pointers\\n/// - Enforcement that all opcodes and operands used exist and are valid\\n///\\n/// This analysis is highly sensitive to the specific implementation and position\\n/// of all opcodes and function pointers as compiled into the interpreter. This\\n/// is what makes the coupling between an interpreter and expression deployer\\n/// so tight. Ideally all responsibilities would be handled by a single contract\\n/// but this introduces code size issues quickly by roughly doubling the compiled\\n/// logic of each opcode (half for the integrity check and half for evaluation).\\n///\\n/// Interpreters MUST assume that expression deployers are malicious and fail\\n/// gracefully if the integrity check is corrupt/bypassed and/or function\\n/// pointers are incorrect, etc. i.e. the interpreter MUST always return a stack\\n/// from `eval` in a read only way or error. I.e. it is the expression deployer's\\n/// responsibility to do everything it can to prevent undefined behaviour in the\\n/// interpreter, and the interpreter's responsibility to handle the expression\\n/// deployer completely failing to do so.\\ninterface IExpressionDeployerV1 {\\n    /// Expressions are expected to be deployed onchain as immutable contract\\n    /// code with a first class address like any other contract or account.\\n    /// Technically this is optional in the sense that all the tools required to\\n    /// eval some expression and define all its opcodes are available as libraries.\\n    ///\\n    /// In practise there are enough advantages to deploying the sources directly\\n    /// onchain as contract data and loading them from the interpreter at eval time:\\n    ///\\n    /// - Loading and storing binary data is gas efficient as immutable contract data\\n    /// - Expressions need to be immutable between their deploy time integrity check\\n    ///   and runtime evaluation\\n    /// - Passing the address of an expression through calldata to an interpreter is\\n    ///   cheaper than passing an entire expression through calldata\\n    /// - Conceptually a very simple approach, even if implementations like SSTORE2\\n    ///   are subtle under the hood\\n    ///\\n    /// The expression deployer MUST perform an integrity check of the source code\\n    /// before it puts the expression onchain at a known address. The integrity check\\n    /// MUST at a minimum (it is free to do additional static analysis) calculate the\\n    /// memory required to be allocated for the stack in total, and that no out of\\n    /// bounds memory reads/writes occur within this stack. A simple example of an\\n    /// invalid source would be one that pushes one value to the stack then attempts\\n    /// to pops two values, clearly we cannot remove more values than we added. The\\n    /// `IExpressionDeployerV1` MUST revert in the case of any integrity failure, all\\n    /// integrity checks MUST pass in order for the deployment to complete.\\n    ///\\n    /// Once the integrity check is complete the `IExpressionDeployerV1` MUST do any\\n    /// additional processing required by its paired interpreter. For example, the\\n    /// `IExpressionDeployerV1` MAY NEED to replace the indexed opcodes in the\\n    /// `StateConfig` sources with real function pointers from the corresponding\\n    /// interpreter.\\n    ///\\n    /// @param config All the state config associated with an expression.\\n    /// @param minOutputs The first N sources on the state config are entrypoints to\\n    /// the expression where N is the length of the `minOutputs` array. Each item in\\n    /// the `minOutputs` array specifies the number of outputs that MUST be present\\n    /// on the final stack for an evaluation of each entrypoint. The minimum output\\n    /// for some entrypoint MAY be zero if the expectation is that the expression\\n    /// only applies checks and error logic. Non-entrypoint sources MUST NOT have a\\n    /// minimum outputs length specified.\\n    /// @return expression The onchain address of the deployed expression.\\n    function deployExpression(\\n        StateConfig memory config,\\n        uint256[] memory minOutputs\\n    ) external returns (address expression);\\n}\\n\",\"keccak256\":\"0x90685338765adf8780a7ccc6990a2b2e312d595b37858e18319bf80e2e559f40\",\"license\":\"CAL\"},\"contracts/interpreter/deploy/LibIntegrityCheck.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../run/LibStackPointer.sol\\\";\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\n\\nimport \\\"./IExpressionDeployerV1.sol\\\";\\nimport \\\"../run/IInterpreterV1.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @dev The virtual stack pointers are never read or written so don't need to\\n/// point to a real location in memory. We only care that the stack never moves\\n/// below its starting point at the stack bottom. For the virtual stack used by\\n/// the integrity check we can start it in the middle of the `uint256` range and\\n/// achieve something analogous to signed integers with unsigned integer types.\\nStackPointer constant INITIAL_STACK_BOTTOM = StackPointer.wrap(\\n    type(uint256).max / 2\\n);\\n\\n/// It is a misconfiguration to set the initial stack bottom to zero or some\\n/// small value as this trivially exposes the integrity check to potential\\n/// underflow issues that are gas intensive to repeatedly guard against on every\\n/// pop. The initial stack bottom for an `IntegrityCheckState` should be\\n/// `INITIAL_STACK_BOTTOM` to safely avoid the need for underflow checks due to\\n/// pops and pushes.\\nerror MinStackBottom();\\n\\n/// The virtual stack top has underflowed the stack highwater (or zero) during an\\n/// integrity check. The highwater will initially be the stack bottom but MAY\\n/// move higher due to certain operations such as placing multiple outputs on the\\n/// stack or copying from a stack position. The highwater prevents subsequent\\n/// popping of values that are considered immutable.\\n/// @param stackHighwaterIndex Index of the stack highwater at the moment of\\n/// underflow.\\n/// @param stackTopIndex Index of the stack top at the moment of underflow.\\nerror StackPopUnderflow(uint256 stackHighwaterIndex, uint256 stackTopIndex);\\n\\n/// The final stack produced by some source did not hit the minimum required for\\n/// its calling context.\\n/// @param minStackOutputs The required minimum stack height.\\n/// @param actualStackOutputs The final stack height after evaluating a source.\\n/// Will be less than the min stack outputs if this error is thrown.\\nerror MinFinalStack(uint256 minStackOutputs, uint256 actualStackOutputs);\\n\\n/// Running an integrity check is a stateful operation. As well as the basic\\n/// configuration of what is being checked such as the sources and size of the\\n/// constants, the current and maximum stack height is being recomputed on every\\n/// checked opcode. The stack is virtual during the integrity check so whatever\\n/// the `StackPointer` values are during the check, it's always undefined\\n/// behaviour to actually try to read/write to them.\\n///\\n/// @param sources All the sources of the expression are provided to the\\n/// integrity check as any entrypoint and non-entrypoint can `call` into some\\n/// other source at any time, provided the overall inputs and outputs to the\\n/// stack are valid.\\n/// @param constantsLength The integrity check assumes the existence of some\\n/// opcode that will read from a predefined list of constants. Technically this\\n/// opcode MAY NOT exist in some interpreter but it seems highly likely to be\\n/// included in most setups. The integrity check only needs the length of the\\n/// constants array to check for out of bounds reads, which allows runtime\\n/// behaviour to read without additional gas for OOB index checks.\\n/// @param stackBottom Pointer to the bottom of the virtual stack that the\\n/// integrity check uses to simulate a real eval.\\n/// @param stackMaxTop Pointer to the maximum height the virtual stack has\\n/// reached during the integrity check. The current virtual stack height will\\n/// be handled separately to the state during the check.\\n/// @param integrityFunctionPointers We pass an array of all the function\\n/// pointers to per-opcode integrity checks around with the state to facilitate\\n/// simple recursive integrity checking.\\nstruct IntegrityCheckState {\\n    // Sources in zeroth position as we read from it in assembly without paying\\n    // gas to calculate offsets.\\n    bytes[] sources;\\n    uint256 constantsLength;\\n    StackPointer stackBottom;\\n    StackPointer stackHighwater;\\n    StackPointer stackMaxTop;\\n    function(IntegrityCheckState memory, Operand, StackPointer)\\n        view\\n        returns (StackPointer)[] integrityFunctionPointers;\\n}\\n\\n/// @title LibIntegrityCheck\\n/// @notice \\\"Dry run\\\" versions of the key logic from `LibStackPointer` that\\n/// allows us to simulate a virtual stack based on the Solidity type system\\n/// itself. The core loop of an integrity check is to dispatch an integrity-only\\n/// version of a runtime opcode that then uses `LibIntegrityCheck` to apply a\\n/// function that simulates a stack movement. The simulated stack movement will\\n/// move a pointer to memory in the same way as a real pop/push would at runtime\\n/// but without any associated logic or even allocating and writing data in\\n/// memory on the other side of the pointer. Every pop is checked for out of\\n/// bounds reads, even if it is an intermediate pop within the logic of a single\\n/// opcode. The _gross_ stack movement is just as important as the net movement.\\n/// For example, consider a simple ERC20 total supply read. The _net_ movement\\n/// of a total supply read is 0, it pops the token address then pushes the total\\n/// supply. However the _gross_ movement is first -1 then +1, so we have to guard\\n/// against the -1 underflowing while reading the token address _during_ the\\n/// simulated opcode dispatch. In general this can be subtle, complex and error\\n/// prone, which is why `LibIntegrityCheck` and `LibStackPointer` take function\\n/// signatures as arguments, so that the overloading mechanism in Solidity itself\\n/// enforces correct pop/push calculations for every opcode.\\nlibrary LibIntegrityCheck {\\n    using LibIntegrityCheck for IntegrityCheckState;\\n    using LibStackPointer for StackPointer;\\n    using Math for uint256;\\n\\n    function newState(\\n        StateConfig memory config_,\\n        function(IntegrityCheckState memory, Operand, StackPointer)\\n            view\\n            returns (StackPointer)[]\\n            memory integrityFns_\\n    ) internal pure returns (IntegrityCheckState memory) {\\n        return\\n            IntegrityCheckState(\\n                config_.sources,\\n                config_.constants.length,\\n                INITIAL_STACK_BOTTOM,\\n                // Highwater starts underneath stack bottom as it errors on an\\n                // greater than _or equal to_ check.\\n                INITIAL_STACK_BOTTOM.down(),\\n                INITIAL_STACK_BOTTOM,\\n                integrityFns_\\n            );\\n    }\\n\\n    /// If the given stack pointer is above the current state of the max stack\\n    /// top, the max stack top will be moved to the stack pointer.\\n    /// i.e. this works like `stackMaxTop = stackMaxTop.max(stackPointer_)` but\\n    /// with the type unwrapping boilerplate included for convenience.\\n    /// @param integrityCheckState_ The state of the current integrity check\\n    /// including the current max stack top.\\n    /// @param stackPointer_ The stack pointer to compare and potentially swap\\n    /// the max stack top for.\\n    function syncStackMaxTop(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackPointer_\\n    ) internal pure {\\n        if (\\n            StackPointer.unwrap(stackPointer_) >\\n            StackPointer.unwrap(integrityCheckState_.stackMaxTop)\\n        ) {\\n            integrityCheckState_.stackMaxTop = stackPointer_;\\n        }\\n    }\\n\\n    /// The main integrity check loop. Designed so that it can be called\\n    /// recursively by the dispatched integrity opcodes to support arbitrary\\n    /// nesting of sources and substacks, loops, etc.\\n    /// If ANY of the integrity checks for ANY opcode fails the entire integrity\\n    /// check will revert.\\n    /// @param integrityCheckState_ Current state of the integrity check passed\\n    /// by reference to allow for recursive/nested integrity checking.\\n    /// @param sourceIndex_ The source to check the integrity of which can be\\n    /// either an entrypoint or a non-entrypoint source if this is a recursive\\n    /// call to `ensureIntegrity`.\\n    /// @param stackTop_ The current top of the virtual stack as a pointer. This\\n    /// can be manipulated to create effective substacks/scoped/immutable\\n    /// runtime values by restricting how the `stackTop_` can move at deploy\\n    /// time.\\n    /// @param minStackOutputs_ The minimum stack height required by the end of\\n    /// this integrity check. The caller MUST ensure that it sets this value high\\n    /// enough so that it can safely read enough values from the final stack\\n    /// without out of bounds reads. The external interface to the expression\\n    /// deployer accepts an array of minimum stack heights against entrypoints,\\n    /// but the internal checks can be recursive against non-entrypoints and each\\n    /// opcode such as `call` can build scoped stacks, etc. so here we just put\\n    /// defining the requirements back on the caller.\\n    function ensureIntegrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        SourceIndex sourceIndex_,\\n        StackPointer stackTop_,\\n        uint256 minStackOutputs_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            // It's generally more efficient to ensure the stack bottom has\\n            // plenty of headroom to make underflows from pops impossible rather\\n            // than guard every single pop against underflow.\\n            if (\\n                StackPointer.unwrap(integrityCheckState_.stackBottom) <\\n                StackPointer.unwrap(INITIAL_STACK_BOTTOM)\\n            ) {\\n                revert MinStackBottom();\\n            }\\n            uint256 cursor_;\\n            uint256 end_;\\n            assembly (\\\"memory-safe\\\") {\\n                cursor_ := mload(\\n                    add(\\n                        mload(integrityCheckState_),\\n                        add(0x20, mul(0x20, sourceIndex_))\\n                    )\\n                )\\n                end_ := add(cursor_, mload(cursor_))\\n            }\\n\\n            // Loop until complete.\\n            while (cursor_ < end_) {\\n                uint256 opcode_;\\n                Operand operand_;\\n                cursor_ += 4;\\n                assembly (\\\"memory-safe\\\") {\\n                    let op_ := mload(cursor_)\\n                    operand_ := and(op_, 0xFFFF)\\n                    opcode_ := and(shr(16, op_), 0xFFFF)\\n                }\\n                // We index into the function pointers here to ensure that any\\n                // opcodes that we don't have a pointer for will error.\\n                stackTop_ = integrityCheckState_.integrityFunctionPointers[\\n                    opcode_\\n                ](integrityCheckState_, operand_, stackTop_);\\n            }\\n            uint256 finalStackOutputs_ = integrityCheckState_\\n                .stackBottom\\n                .toIndex(stackTop_);\\n            if (minStackOutputs_ > finalStackOutputs_) {\\n                revert MinFinalStack(minStackOutputs_, finalStackOutputs_);\\n            }\\n            return stackTop_;\\n        }\\n    }\\n\\n    /// Push a single virtual item onto the virtual stack.\\n    /// Simply moves the stack top up one and syncs the interpreter max stack\\n    /// height with it if needed.\\n    /// @param integrityCheckState_ The state of the current integrity check.\\n    /// @param stackTop_ The pointer to the virtual stack top for the current\\n    /// integrity check.\\n    /// @return The stack top after it has pushed an item.\\n    function push(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        stackTop_ = stackTop_.up();\\n        integrityCheckState_.syncStackMaxTop(stackTop_);\\n        return stackTop_;\\n    }\\n\\n    /// Overloaded `push` to support `n_` pushes in a single movement.\\n    /// `n_` MAY be 0 and this is a virtual noop stack movement.\\n    /// @param integrityCheckState_ as per `push`.\\n    /// @param stackTop_ as per `push`.\\n    /// @param n_ The number of items to push to the virtual stack.\\n    function push(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        stackTop_ = stackTop_.up(n_);\\n        // Any time we push more than 1 item to the stack we move the highwater\\n        // _past_ it as nested multioutput is disallowed.\\n        if (\\n            n_ > 1 &&\\n            StackPointer.unwrap(stackTop_) >\\n            StackPointer.unwrap(integrityCheckState_.stackHighwater)\\n        ) {\\n            integrityCheckState_.stackHighwater = stackTop_;\\n        }\\n        integrityCheckState_.syncStackMaxTop(stackTop_);\\n        return stackTop_;\\n    }\\n\\n    /// As push for 0+ values. Does NOT move the highwater. This may be useful if\\n    /// the highwater is already calculated somehow by the caller.\\n    function pushIgnoreHighwater(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        stackTop_ = stackTop_.up(n_);\\n        integrityCheckState_.syncStackMaxTop(stackTop_);\\n        return stackTop_;\\n    }\\n\\n    /// Move the stock top down one item then check that it hasn't underflowed\\n    /// the stack bottom. If all virtual stack movements are defined in terms\\n    /// of pops and pushes this will enforce that the gross stack movements do\\n    /// not underflow, which would lead to out of bounds stack reads at runtime.\\n    /// @param integrityCheckState_ The state of the current integrity check.\\n    /// @param stackTop_ The virtual stack top before an item is popped.\\n    /// @return The virtual stack top after the pop.\\n    function pop(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        stackTop_ = stackTop_.down();\\n        integrityCheckState_.popUnderflowCheck(stackTop_);\\n        return stackTop_;\\n    }\\n\\n    /// Overloaded `pop` to support `n_` pops in a single movement.\\n    /// `n_` MAY be 0 and this is a virtual noop stack movement.\\n    /// @param integrityCheckState_ as per `pop`.\\n    /// @param stackTop_ as per `pop`.\\n    /// @param n_ The number of items to pop off the virtual stack.\\n    function pop(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        uint256 n_\\n    ) internal view returns (StackPointer) {\\n        console.log(\\\"pop\\\", n_, StackPointer.unwrap(stackTop_));\\n        if (n_ > 0) {\\n            stackTop_ = stackTop_.down(n_);\\n            integrityCheckState_.popUnderflowCheck(stackTop_);\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Ensures that pops have not underflowed the stack, i.e. that the stack\\n    /// top is not below the stack bottom. We set a large stack bottom that is\\n    /// impossible to underflow within gas limits with realistic pops so that\\n    /// we don't have to deal with a numeric underflow of the stack top.\\n    /// @param integrityCheckState_ As per `pop`.\\n    /// @param stackTop_ as per `pop`.\\n    function popUnderflowCheck(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_\\n    ) internal view {\\n        console.log(\\\"puc\\\", StackPointer.unwrap(stackTop_), StackPointer.unwrap(integrityCheckState_.stackHighwater));\\n        if (\\n            StackPointer.unwrap(stackTop_) <=\\n            StackPointer.unwrap(integrityCheckState_.stackHighwater)\\n        ) {\\n            revert StackPopUnderflow(\\n                integrityCheckState_.stackBottom.toIndex(\\n                    integrityCheckState_.stackHighwater\\n                ),\\n                integrityCheckState_.stackBottom.toIndex(stackTop_)\\n            );\\n        }\\n    }\\n\\n    /// Maps `function(uint256, uint256) internal view returns (uint256)` to pops\\n    /// and pushes repeatedly N times. The function itself is irrelevant we only\\n    /// care about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param n_ The number of times the function is applied to the stack.\\n    /// @return The stack top after the function has been applied n times.\\n    function applyFnN(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256) internal view returns (uint256),\\n        uint256 n_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, n_));\\n    }\\n\\n    /// Maps `function(uint256) internal view` to pops and pushes repeatedly N\\n    /// times. The function itself is irrelevant we only care about the\\n    /// signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param n_ The number of times the function is applied to the stack.\\n    /// @return The stack top after the function has been applied n times.\\n    function applyFnN(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256) internal view,\\n        uint256 n_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.pop(stackTop_, n_);\\n    }\\n\\n    /// Maps `function(uint256) internal view returns (uint256)` to pops and\\n    /// pushes once. The function itself is irrelevant we only care about the\\n    /// signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256) internal view returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.push(integrityCheckState_.pop(stackTop_));\\n    }\\n\\n    /// Maps `function(uint256, uint256) internal view` to pops and pushes once.\\n    /// The function itself is irrelevant we only care about the signature to\\n    /// know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256) internal view\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.pop(stackTop_, 2);\\n    }\\n\\n    /// Maps `function(uint256, uint256) internal view returns (uint256)` to\\n    /// pops and pushes once. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256) internal view returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, 2));\\n    }\\n\\n    /// Maps\\n    /// `function(uint256, uint256, uint256) internal view returns (uint256)` to\\n    /// pops and pushes once. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256) internal view returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, 3));\\n    }\\n\\n    /// Maps\\n    /// ```\\n    /// function(uint256, uint256, uint256, uint256)\\n    ///     internal\\n    ///     view\\n    ///     returns (uint256)\\n    /// ```\\n    /// to pops and pushes once. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256, uint256)\\n            internal\\n            view\\n            returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, 4));\\n    }\\n\\n    /// Maps `function(uint256[] memory) internal view returns (uint256)` to\\n    /// pops and pushes once given that we know the length of the dynamic array\\n    /// at deploy time. The function itself is irrelevant we only care about the\\n    /// signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param length_ The length of the dynamic input array.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256[] memory) internal view returns (uint256),\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(\\n                integrityCheckState_.pop(stackTop_, length_)\\n            );\\n    }\\n\\n    /// Maps\\n    /// ```\\n    /// function(uint256, uint256, uint256[] memory)\\n    ///     internal\\n    ///     view\\n    ///     returns (uint256)\\n    /// ```\\n    /// to pops and pushes once given that we know the length of the dynamic\\n    /// array at deploy time. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param length_ The length of the dynamic input array.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256),\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            return\\n                integrityCheckState_.push(\\n                    integrityCheckState_.pop(stackTop_, length_ + 2)\\n                );\\n        }\\n    }\\n\\n    /// Maps\\n    /// ```\\n    /// function(uint256, uint256, uint256, uint256[] memory)\\n    ///     internal\\n    ///     view\\n    ///     returns (uint256)\\n    /// ```\\n    /// to pops and pushes once given that we know the length of the dynamic\\n    /// array at deploy time. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param length_ The length of the dynamic input array.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256),\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            return\\n                integrityCheckState_.push(\\n                    integrityCheckState_.pop(stackTop_, length_ + 3)\\n                );\\n        }\\n    }\\n\\n    /// Maps\\n    /// ```\\n    /// function(uint256, uint256[] memory, uint256[] memory)\\n    ///     internal\\n    ///     view\\n    ///     returns (uint256[] memory)\\n    /// ```\\n    /// to pops and pushes once given that we know the length of the dynamic\\n    /// array at deploy time. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param length_ The length of the dynamic input array.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256[] memory, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256[] memory),\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            return\\n                integrityCheckState_.push(\\n                    integrityCheckState_.pop(stackTop_, length_ * 2 + 1),\\n                    length_\\n                );\\n        }\\n    }\\n\\n    /// Maps `function(Operand, uint256) internal view returns (uint256)` to\\n    /// pops and pushes once. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    ///\\n    /// The operand MUST NOT influence the stack movements if this application\\n    /// is to be valid.\\n    ///\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(Operand, uint256) internal view returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.push(integrityCheckState_.pop(stackTop_));\\n    }\\n\\n    /// Maps\\n    /// `function(Operand, uint256, uint256) internal view returns (uint256)` to\\n    /// pops and pushes once. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    ///\\n    /// The operand MUST NOT influence the stack movements if this application\\n    /// is to be valid.\\n    ///\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(Operand, uint256, uint256) internal view returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, 2));\\n    }\\n}\\n\",\"keccak256\":\"0x8f15d85e24237a4905e2a96def5b31d508950440f3da8bf18c8f4cc7c002f8b5\",\"license\":\"CAL\"},\"contracts/interpreter/ops/AllStandardOps.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"../../type/LibCast.sol\\\";\\nimport \\\"../../type/LibConvert.sol\\\";\\nimport \\\"../../array/LibUint256Array.sol\\\";\\nimport \\\"./chainlink/OpChainlinkOraclePrice.sol\\\";\\nimport \\\"./core/OpCall.sol\\\";\\nimport \\\"./core/OpSet.sol\\\";\\nimport \\\"./core/OpContext.sol\\\";\\nimport \\\"./core/OpContextRow.sol\\\";\\nimport \\\"./core/OpDebug.sol\\\";\\nimport \\\"./core/OpDoWhile.sol\\\";\\nimport \\\"./core/OpFoldContext.sol\\\";\\nimport \\\"./core/OpLoopN.sol\\\";\\nimport \\\"./core/OpReadMemory.sol\\\";\\nimport \\\"./crypto/OpHash.sol\\\";\\nimport \\\"./erc20/OpERC20BalanceOf.sol\\\";\\nimport \\\"./erc20/OpERC20TotalSupply.sol\\\";\\nimport \\\"./erc20/snapshot/OpERC20SnapshotBalanceOfAt.sol\\\";\\nimport \\\"./erc20/snapshot/OpERC20SnapshotTotalSupplyAt.sol\\\";\\nimport \\\"./erc721/OpERC721BalanceOf.sol\\\";\\nimport \\\"./erc721/OpERC721OwnerOf.sol\\\";\\nimport \\\"./erc1155/OpERC1155BalanceOf.sol\\\";\\nimport \\\"./erc1155/OpERC1155BalanceOfBatch.sol\\\";\\nimport \\\"./error/OpEnsure.sol\\\";\\nimport \\\"./evm/OpBlockNumber.sol\\\";\\nimport \\\"./evm/OpTimestamp.sol\\\";\\nimport \\\"./list/OpExplode32.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScale18.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScale18Div.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScale18Mul.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScaleBy.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScaleN.sol\\\";\\nimport \\\"./math/logic/OpAny.sol\\\";\\nimport \\\"./math/logic/OpEagerIf.sol\\\";\\nimport \\\"./math/logic/OpEqualTo.sol\\\";\\nimport \\\"./math/logic/OpEvery.sol\\\";\\nimport \\\"./math/logic/OpGreaterThan.sol\\\";\\nimport \\\"./math/logic/OpIsZero.sol\\\";\\nimport \\\"./math/logic/OpLessThan.sol\\\";\\nimport \\\"./math/saturating/OpSaturatingAdd.sol\\\";\\nimport \\\"./math/saturating/OpSaturatingMul.sol\\\";\\nimport \\\"./math/saturating/OpSaturatingSub.sol\\\";\\nimport \\\"./math/OpAdd.sol\\\";\\nimport \\\"./math/OpDiv.sol\\\";\\nimport \\\"./math/OpExp.sol\\\";\\nimport \\\"./math/OpMax.sol\\\";\\nimport \\\"./math/OpMin.sol\\\";\\nimport \\\"./math/OpMod.sol\\\";\\nimport \\\"./math/OpMul.sol\\\";\\nimport \\\"./math/OpSub.sol\\\";\\nimport \\\"./rain/IOrderBookV1/OpIOrderBookV1VaultBalance.sol\\\";\\nimport \\\"./rain/ISaleV2/OpISaleV2RemainingTokenInventory.sol\\\";\\nimport \\\"./rain/ISaleV2/OpISaleV2Reserve.sol\\\";\\nimport \\\"./rain/ISaleV2/OpISaleV2SaleStatus.sol\\\";\\nimport \\\"./rain/ISaleV2/OpISaleV2Token.sol\\\";\\nimport \\\"./rain/ISaleV2/OpISaleV2TotalReserveReceived.sol\\\";\\nimport \\\"./rain/IVerifyV1/OpIVerifyV1AccountStatusAtTime.sol\\\";\\nimport \\\"./tier/OpITierV2Report.sol\\\";\\nimport \\\"./tier/OpITierV2ReportTimeForTier.sol\\\";\\nimport \\\"./tier/OpSaturatingDiff.sol\\\";\\nimport \\\"./tier/OpSelectLte.sol\\\";\\nimport \\\"./tier/OpUpdateTimesForTierRange.sol\\\";\\n\\n/// Thrown when a dynamic length array is NOT 1 more than a fixed length array.\\n/// Should never happen outside a major breaking change to memory layouts.\\nerror BadDynamicLength(uint256 dynamicLength, uint256 standardOpsLength);\\n\\n/// @dev Number of ops currently provided by `AllStandardOps`.\\nuint256 constant ALL_STANDARD_OPS_LENGTH = 58;\\n\\n/// @title AllStandardOps\\n/// @notice Every opcode available from the core repository laid out as a single\\n/// array to easily build function pointers for `IInterpreterV1`.\\nlibrary AllStandardOps {\\n    using LibCast for uint256;\\n    using LibCast for function(uint256) pure returns (uint256);\\n    using LibCast for function(InterpreterState memory, uint256, StackPointer)\\n        view\\n        returns (StackPointer);\\n    using LibCast for function(InterpreterState memory, uint256, StackPointer)\\n        pure\\n        returns (StackPointer);\\n    using LibCast for function(InterpreterState memory, uint256, StackPointer)\\n        view\\n        returns (StackPointer)[];\\n\\n    using AllStandardOps for function(\\n        IntegrityCheckState memory,\\n        Operand,\\n        StackPointer\\n    ) view returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1];\\n    using AllStandardOps for function(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer\\n    ) view returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1];\\n\\n    using AllStandardOps for uint256[ALL_STANDARD_OPS_LENGTH + 1];\\n\\n    using LibUint256Array for uint256[];\\n    using LibConvert for uint256[];\\n    using LibCast for uint256[];\\n    using LibCast for function(\\n        IntegrityCheckState memory,\\n        Operand,\\n        StackPointer\\n    ) view returns (StackPointer);\\n    using LibCast for function(\\n        IntegrityCheckState memory,\\n        Operand,\\n        StackPointer\\n    ) pure returns (StackPointer);\\n    using LibCast for function(\\n        IntegrityCheckState memory,\\n        Operand,\\n        StackPointer\\n    ) view returns (StackPointer)[];\\n    using LibCast for function(InterpreterState memory, Operand, StackPointer)\\n        view\\n        returns (StackPointer)[];\\n\\n    /// An oddly specific length conversion between a fixed and dynamic `uint256`\\n    /// array. This is useful for the purpose of building metadata for bounds\\n    /// checks and dispatch of all the standard ops provided by `Rainterpreter`.\\n    /// The cast will fail if the length of the dynamic array doesn't match the\\n    /// first item of the fixed array; it relies on differences in memory\\n    /// layout in Solidity that MAY change in the future. The rollback guards\\n    /// against changes in Solidity memory layout silently breaking this cast.\\n    /// @param fixed_ The fixed size `uint256` array to cast to a dynamic\\n    /// `uint256` array. Specifically the size is fixed to match the number of\\n    /// standard ops.\\n    /// @param dynamic_ The dynamic `uint256` array with length of the standard\\n    /// ops.\\n    function asUint256Array(\\n        function(IntegrityCheckState memory, Operand, StackPointer)\\n            view\\n            returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1]\\n            memory fixed_\\n    ) internal pure returns (uint256[] memory dynamic_) {\\n        assembly (\\\"memory-safe\\\") {\\n            dynamic_ := fixed_\\n        }\\n        if (dynamic_.length != ALL_STANDARD_OPS_LENGTH) {\\n            revert BadDynamicLength(dynamic_.length, ALL_STANDARD_OPS_LENGTH);\\n        }\\n    }\\n\\n    /// An oddly specific conversion between a fixed and dynamic `uint256` array.\\n    /// This is useful for the purpose of building function pointers for the\\n    /// runtime dispatch of all the standard ops provided by `Rainterpreter`.\\n    /// The cast will fail if the length of the dynamic array doesn't match the\\n    /// first item of the fixed array; it relies on differences in memory\\n    /// layout in Solidity that MAY change in the future. The rollback guards\\n    /// against changes in Solidity memory layout silently breaking this cast.\\n    /// @param fixed_ The fixed size `uint256` array to cast to a dynamic\\n    /// `uint256` array. Specifically the size is fixed to match the number of\\n    /// standard ops.\\n    /// @param dynamic_ The dynamic `uint256` array with length of the standard\\n    /// ops.\\n    function asUint256Array(\\n        function(InterpreterState memory, Operand, StackPointer)\\n            view\\n            returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1]\\n            memory fixed_\\n    ) internal pure returns (uint256[] memory dynamic_) {\\n        assembly (\\\"memory-safe\\\") {\\n            dynamic_ := fixed_\\n        }\\n        if (dynamic_.length != ALL_STANDARD_OPS_LENGTH) {\\n            revert BadDynamicLength(dynamic_.length, ALL_STANDARD_OPS_LENGTH);\\n        }\\n    }\\n\\n    function integrityFunctionPointers(\\n        function(IntegrityCheckState memory, Operand, StackPointer)\\n            view\\n            returns (StackPointer)[]\\n            memory locals_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(IntegrityCheckState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer)[]\\n                memory\\n        )\\n    {\\n        unchecked {\\n            function(IntegrityCheckState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1]\\n                memory pointersFixed_ = [\\n                    ALL_STANDARD_OPS_LENGTH.asIntegrityFunctionPointer(),\\n                    OpChainlinkOraclePrice.integrity,\\n                    OpCall.integrity,\\n                    OpContext.integrity,\\n                    OpContextRow.integrity,\\n                    OpDebug.integrity,\\n                    OpDoWhile.integrity,\\n                    OpFoldContext.integrity,\\n                    OpLoopN.integrity,\\n                    OpReadMemory.integrity,\\n                    OpSet.integrity,\\n                    OpHash.integrity,\\n                    OpERC20BalanceOf.integrity,\\n                    OpERC20TotalSupply.integrity,\\n                    OpERC20SnapshotBalanceOfAt.integrity,\\n                    OpERC20SnapshotTotalSupplyAt.integrity,\\n                    OpERC721BalanceOf.integrity,\\n                    OpERC721OwnerOf.integrity,\\n                    OpERC1155BalanceOf.integrity,\\n                    OpERC1155BalanceOfBatch.integrity,\\n                    OpEnsure.integrity,\\n                    OpBlockNumber.integrity,\\n                    OpTimestamp.integrity,\\n                    OpExplode32.integrity,\\n                    OpFixedPointScale18.integrity,\\n                    OpFixedPointScale18Div.integrity,\\n                    OpFixedPointScale18Mul.integrity,\\n                    OpFixedPointScaleBy.integrity,\\n                    OpFixedPointScaleN.integrity,\\n                    OpAny.integrity,\\n                    OpEagerIf.integrity,\\n                    OpEqualTo.integrity,\\n                    OpEvery.integrity,\\n                    OpGreaterThan.integrity,\\n                    OpIsZero.integrity,\\n                    OpLessThan.integrity,\\n                    OpSaturatingAdd.integrity,\\n                    OpSaturatingMul.integrity,\\n                    OpSaturatingSub.integrity,\\n                    OpAdd.integrity,\\n                    OpDiv.integrity,\\n                    OpExp.integrity,\\n                    OpMax.integrity,\\n                    OpMin.integrity,\\n                    OpMod.integrity,\\n                    OpMul.integrity,\\n                    OpSub.integrity,\\n                    OpIOrderBookV1VaultBalance.integrity,\\n                    OpISaleV2RemainingTokenInventory.integrity,\\n                    OpISaleV2Reserve.integrity,\\n                    OpISaleV2SaleStatus.integrity,\\n                    OpISaleV2Token.integrity,\\n                    OpISaleV2TotalReserveReceived.integrity,\\n                    OpIVerifyV1AccountStatusAtTime.integrity,\\n                    OpITierV2Report.integrity,\\n                    OpITierV2ReportTimeForTier.integrity,\\n                    OpSaturatingDiff.integrity,\\n                    OpSelectLte.integrity,\\n                    OpUpdateTimesForTierRange.integrity\\n                ];\\n            uint256[] memory pointers_ = pointersFixed_.asUint256Array();\\n            pointers_.extend(locals_.asUint256Array());\\n            return pointers_.asIntegrityPointers();\\n        }\\n    }\\n\\n    function opcodeFunctionPointers(\\n        function(InterpreterState memory, Operand, StackPointer)\\n            view\\n            returns (StackPointer)[]\\n            memory locals_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(InterpreterState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer)[]\\n                memory opcodeFunctionPointers_\\n        )\\n    {\\n        unchecked {\\n            function(InterpreterState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1]\\n                memory pointersFixed_ = [\\n                    ALL_STANDARD_OPS_LENGTH.asOpFunctionPointer(),\\n                    OpChainlinkOraclePrice.run,\\n                    OpCall.run,\\n                    OpContext.run,\\n                    OpContextRow.run,\\n                    OpDebug.run,\\n                    OpDoWhile.run,\\n                    OpFoldContext.run,\\n                    OpLoopN.run,\\n                    OpReadMemory.run,\\n                    OpSet.run,\\n                    OpHash.run,\\n                    OpERC20BalanceOf.run,\\n                    OpERC20TotalSupply.run,\\n                    OpERC20SnapshotBalanceOfAt.run,\\n                    OpERC20SnapshotTotalSupplyAt.run,\\n                    OpERC721BalanceOf.run,\\n                    OpERC721OwnerOf.run,\\n                    OpERC1155BalanceOf.run,\\n                    OpERC1155BalanceOfBatch.run,\\n                    OpEnsure.run,\\n                    OpBlockNumber.run,\\n                    OpTimestamp.run,\\n                    OpExplode32.run,\\n                    OpFixedPointScale18.run,\\n                    OpFixedPointScale18Div.run,\\n                    OpFixedPointScale18Mul.run,\\n                    OpFixedPointScaleBy.run,\\n                    OpFixedPointScaleN.run,\\n                    OpAny.run,\\n                    OpEagerIf.run,\\n                    OpEqualTo.run,\\n                    OpEvery.run,\\n                    OpGreaterThan.run,\\n                    OpIsZero.run,\\n                    OpLessThan.run,\\n                    OpSaturatingAdd.run,\\n                    OpSaturatingMul.run,\\n                    OpSaturatingSub.run,\\n                    OpAdd.run,\\n                    OpDiv.run,\\n                    OpExp.run,\\n                    OpMax.run,\\n                    OpMin.run,\\n                    OpMod.run,\\n                    OpMul.run,\\n                    OpSub.run,\\n                    OpIOrderBookV1VaultBalance.run,\\n                    OpISaleV2RemainingTokenInventory.run,\\n                    OpISaleV2Reserve.run,\\n                    OpISaleV2SaleStatus.run,\\n                    OpISaleV2Token.run,\\n                    OpISaleV2TotalReserveReceived.run,\\n                    OpIVerifyV1AccountStatusAtTime.run,\\n                    OpITierV2Report.run,\\n                    OpITierV2ReportTimeForTier.run,\\n                    OpSaturatingDiff.run,\\n                    OpSelectLte.run,\\n                    OpUpdateTimesForTierRange.run\\n                ];\\n            uint256[] memory pointers_ = pointersFixed_.asUint256Array();\\n            pointers_.extend(locals_.asUint256Array());\\n            opcodeFunctionPointers_ = pointers_.asOpcodeFunctionPointers();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x909d817a745759b57877e191e7d8fa8184a5372b75c71e762e9f70aeb18c73c3\",\"license\":\"CAL\"},\"contracts/interpreter/ops/chainlink/OpChainlinkOraclePrice.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {LibChainlink} from \\\"../../../chainlink/LibChainlink.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpChainlinkOraclePrice\\n/// @notice Opcode for chainlink oracle prices.\\nlibrary OpChainlinkOraclePrice {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 feed_,\\n        uint256 staleAfter_\\n    ) internal view returns (uint256) {\\n        return LibChainlink.price(address(uint160(feed_)), staleAfter_);\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x5ca6f91bcf9eaddcc75fe5d44f90ae4189452dc6ca685a119bfd46a08c257e31\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpCall.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"../../../math/Binary.sol\\\";\\n\\n/// @title OpCall\\n/// @notice Opcode for calling eval with a new scope. The construction of this\\n/// scope is split across integrity and runtime responsibilities. When the\\n/// integrity checks are done the expression being called has all its integrity\\n/// logic run, recursively if needed. The integrity checks are run against the\\n/// integrity state as it is but with the stack bottom set below the inputs to\\n/// the called source. This ensures that the sub-integrity checks do not\\n/// underflow what they perceive as a fresh stack, and it ensures that we set the\\n/// stack length long enough to cover all sub-executions as a single array in\\n/// memory. At runtime we trust the integrity checks have allocated enough runway\\n/// in the stack for all our recursive sub-calls so we simply move the stack\\n/// bottom in the state below the inputs during the call and move it back to\\n/// where it was after the call. Notably this means that reading from the stack\\n/// in the called source will 0 index from the first input, NOT the bottom of\\n/// the calling stack.\\nlibrary OpCall {\\n    using LibIntegrityCheck for IntegrityCheckState;\\n    using LibStackPointer for StackPointer;\\n    using LibInterpreterState for InterpreterState;\\n    using LibUint256Array for uint256;\\n\\n    /// Interpreter integrity logic.\\n    /// The basic movements on the outer stack are to pop the inputs and push the\\n    /// outputs, but the called source doesn't have access to a separately\\n    /// allocated region of memory. There's only a single shared memory\\n    /// allocation for all executions and sub-executions, so we recursively run\\n    /// integrity checks on the called source relative to the current stack\\n    /// position.\\n    /// @param integrityCheckState_ The state of the current integrity check.\\n    /// @param operand_ The operand associated with this call.\\n    /// @param stackTop_ The current stack top within the integrity check.\\n    /// @return stackTopAfter_ The stack top after the call movements are applied.\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        // Unpack the operand to get IO and the source to be called.\\n        uint256 inputs_ = Operand.unwrap(operand_) & MASK_4BIT;\\n        uint256 outputs_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\\n        SourceIndex callSourceIndex_ = SourceIndex.wrap(\\n            Operand.unwrap(operand_) >> 8\\n        );\\n\\n        // Remember the outer stack bottom and highwater.\\n        StackPointer stackBottom_ = integrityCheckState_.stackBottom;\\n        StackPointer stackHighwater_ = integrityCheckState_.stackHighwater;\\n\\n        // Set the inner stack bottom to below the inputs and highwater to\\n        // protect the inputs from being popped internally.\\n        integrityCheckState_.stackBottom = integrityCheckState_.pop(\\n            stackTop_,\\n            inputs_\\n        );\\n        integrityCheckState_.stackHighwater = stackTop_.down();\\n\\n        // Ensure the integrity of the inner source on the current state using\\n        // the stack top above the inputs as the starting stack top.\\n        // Contraints namespace is irrelevant here.\\n        integrityCheckState_.ensureIntegrity(\\n            callSourceIndex_,\\n            stackTop_,\\n            outputs_\\n        );\\n\\n        // Reinstate the original highwater before handling outputs as single\\n        // outputs can be nested but multioutput will move the highwater.\\n        integrityCheckState_.stackHighwater = stackHighwater_;\\n\\n        // The outer stack top will move above the outputs relative to the inner\\n        // stack bottom. At runtime any values that are not outputs will be\\n        // removed so they do not need to be accounted for here.\\n        stackTopAfter_ = integrityCheckState_.push(\\n            integrityCheckState_.stackBottom,\\n            outputs_\\n        );\\n\\n        // Reinstate the outer stack bottom.\\n        integrityCheckState_.stackBottom = stackBottom_;\\n    }\\n\\n    /// Call eval with a new scope.\\n    /// @param state_ The state of the current evaluation.\\n    /// @param operand_ The operand associated with this call.\\n    /// @param stackTop_ The current stack top within the evaluation.\\n    /// @return stackTopAfter_ The stack top after the call is evaluated.\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        // Unpack the operand to get IO and the source to be called.\\n        uint256 inputs_ = Operand.unwrap(operand_) & MASK_4BIT;\\n        uint256 outputs_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\\n        SourceIndex callSourceIndex_ = SourceIndex.wrap(\\n            Operand.unwrap(operand_) >> 8\\n        );\\n\\n        // Remember the outer stack bottom.\\n        StackPointer stackBottom_ = state_.stackBottom;\\n\\n        // Set the inner stack bottom to below the inputs.\\n        state_.stackBottom = stackTop_.down(inputs_);\\n\\n        // Eval the source from the operand on the current state using the stack\\n        // top above the inputs as the starting stack top. The final stack top\\n        // is where we will read outputs from below.\\n        StackPointer stackTopEval_ = state_.eval(callSourceIndex_, stackTop_);\\n        // Normalize the inner final stack so that it contains only the outputs\\n        // starting from the inner stack bottom.\\n        LibUint256Array.unsafeCopyValuesTo(\\n            StackPointer.unwrap(stackTopEval_.down(outputs_)),\\n            StackPointer.unwrap(state_.stackBottom),\\n            outputs_\\n        );\\n\\n        // The outer stack top should now point above the outputs.\\n        stackTopAfter_ = state_.stackBottom.up(outputs_);\\n\\n        // The outer stack bottom needs to be reinstated as it was before eval.\\n        state_.stackBottom = stackBottom_;\\n    }\\n}\\n\",\"keccak256\":\"0x4f1036707ef6cb3932d5809f1a915fec781bffb3fc1a8e400b9c88e4255fe65d\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpContext.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"../../../math/Binary.sol\\\";\\n\\n/// @title OpContext\\n/// @notice Opcode for stacking from the context. Context requires slightly\\n/// different handling to other memory reads as it is working with data that\\n/// is provided at runtime from the calling contract on a per-eval basis so\\n/// cannot be predicted at deploy time.\\nlibrary OpContext {\\n    using LibStackPointer for StackPointer;\\n    using LibInterpreterState for InterpreterState;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    /// Interpreter integrity logic.\\n    /// Context pushes a single value to the stack from the context array.\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        // Note that a expression with context can error at runtime due to OOB\\n        // reads that we don't know about here.\\n        return integrityCheckState_.push(stackTop_);\\n    }\\n\\n    /// Stack a value from the context WITH OOB checks from solidity.\\n    /// The bounds checks are done at runtime because context MAY be provided\\n    /// by the end user with arbitrary length.\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        // The indexing syntax here enforces OOB checks at runtime.\\n        return\\n            stackTop_.push(\\n                state_.context[Operand.unwrap(operand_) >> 8][\\n                    Operand.unwrap(operand_) & MASK_8BIT\\n                ]\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x3b3d94b3b6c60e0f20e415a57ac114974751c411b820f53e18780a8c1989a8d5\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpContextRow.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"../../../math/Binary.sol\\\";\\n\\n/// @title OpContextRow\\n/// @notice Opcode for stacking a dynamic row from the context. Context requires\\n/// slightly different handling to other memory reads as it is working with data\\n/// that is provided at runtime. `OpContextRow` works exactly like `OpContext`\\n/// but the row is provided from the stack instead of the operand. We rely on\\n/// Solidity OOB checks at runtime to enforce that the index from the stack is\\n/// within bounds at runtime. As we do NOT know statically which row will be read\\n/// the context reads is set to the entire column.\\nlibrary OpContextRow {\\n    using LibStackPointer for StackPointer;\\n    using LibInterpreterState for InterpreterState;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    /// Interpreter integrity logic.\\n    /// Context pushes a single value to the stack from memory.\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        // Note that a expression with context can error at runtime due to OOB\\n        // reads that we don't know about here.\\n        function(uint256) internal pure returns (uint256) fn_;\\n        return integrityCheckState_.applyFn(stackTop_, fn_);\\n    }\\n\\n    /// Stack a value from the context WITH OOB checks from solidity.\\n    /// The bounds checks are done at runtime because context MAY be provided\\n    /// by the end user with arbitrary length.\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        // The indexing syntax here enforces OOB checks at runtime.\\n        (StackPointer location_, uint256 row_) = stackTop_.pop();\\n        location_.set(state_.context[Operand.unwrap(operand_)][row_]);\\n        return stackTop_;\\n    }\\n}\\n\",\"keccak256\":\"0xb21eb981a50d7cce88e6c0a5baa82b934935697323f4ddd3ec444df029425418\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpDebug.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpDebug\\n/// @notice Opcode for debugging state. Uses the standard debugging logic from\\n/// InterpreterState.debug.\\nlibrary OpDebug {\\n    using LibStackPointer for StackPointer;\\n    using LibInterpreterState for InterpreterState;\\n\\n    /// Interpreter integrity for debug.\\n    /// Debug doesn't modify the stack.\\n    function integrity(\\n        IntegrityCheckState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        // Try to build a debug style from the operand to ensure we can enumerate\\n        // it.\\n        DebugStyle(Operand.unwrap(operand_));\\n        return stackTop_;\\n    }\\n\\n    /// Debug the current state.\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        DebugStyle debugStyle_ = DebugStyle(Operand.unwrap(operand_));\\n\\n        state_.debug(stackTop_, debugStyle_);\\n\\n        return stackTop_;\\n    }\\n}\\n\",\"keccak256\":\"0x98bf9ef4a0d7c83a6a9fbcc22adc3b18833df761a3c5af22ac786df19546f872\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpDoWhile.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"./OpCall.sol\\\";\\n\\n/// More inputs were encoded in the operand than can be dispatched internally by\\n/// a do-while loop.\\nerror DoWhileMaxInputs(uint256 inputs);\\n\\n/// @title OpDoWhile\\n/// @notice Opcode for looping while the stack top is nonzero. As we pre-allocate\\n/// all the memory for execution during integrity checks we have an apparent\\n/// contradiction here. If we do not know how many times the loop will run then\\n/// we cannot calculate the final stack height or intermediate pops and pushes.\\n/// To solve this we simply wrap `OpCall` which already has fixed inputs and\\n/// outputs and enforce that the outputs of each iteration is 1 more than the\\n/// inputs. We then consume the extra output as the condition for the decision\\n/// to loop again, thus the outputs = inputs for every iteration. If the stack\\n/// height does not change between iterations we do not care how many times we\\n/// loop (although the user paying gas might).\\nlibrary OpDoWhile {\\n    using LibIntegrityCheck for IntegrityCheckState;\\n    using LibStackPointer for StackPointer;\\n    using LibInterpreterState for InterpreterState;\\n\\n    /// Interpreter integrity for do while.\\n    /// The loop itself pops a single value from the stack to determine whether\\n    /// it should run another iteration of the loop. The source called by the\\n    /// loop must then put a value back on the stack in the same position to\\n    /// either continue or break the loop.\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\\n            /// We need outputs to be _larger than_ inputs so inputs must be\\n            /// _strictly less than_ the max value possible in 4 bits or outputs\\n            /// will overflow.\\n            if (inputs_ >= MASK_4BIT) {\\n                revert DoWhileMaxInputs(inputs_);\\n            }\\n            uint256 outputs_ = inputs_ + 1;\\n            Operand callOperand_ = Operand.wrap(\\n                Operand.unwrap(operand_) | (outputs_ << 4)\\n            );\\n            // Stack height changes are deterministic so if we call once we've\\n            // called a thousand times. Also we pop one output off the result of\\n            // the call to check the while condition.\\n            return\\n                integrityCheckState_.pop(\\n                    OpCall.integrity(\\n                        integrityCheckState_,\\n                        callOperand_,\\n                        stackTop_\\n                    )\\n                );\\n        }\\n    }\\n\\n    /// Loop the stack while the stack top is true.\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\\n            uint256 outputs_ = inputs_ + 1;\\n            Operand callOperand_ = Operand.wrap(\\n                Operand.unwrap(operand_) | (outputs_ << 4)\\n            );\\n            uint256 do_;\\n            (stackTop_, do_) = stackTop_.pop();\\n            while (do_ > 0) {\\n                stackTop_ = OpCall.run(state_, callOperand_, stackTop_);\\n                (stackTop_, do_) = stackTop_.pop();\\n            }\\n            return stackTop_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1b782373c5c8243cd083dd6fd6aa38d19658680dceaafe9750fcf7d59ec99eb3\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpFoldContext.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"./OpCall.sol\\\";\\n\\n/// @title OpFoldContext\\n/// Folds over columns of context from their start to end. Expressions do not\\n/// have a good way of handling dynamic lengths of things, and that is\\n/// intentional to avoid end users having to write out looping constructs of the\\n/// form `i = 0; i < length; i++` is is so tedious and error prone in software\\n/// development generally. It is very easy to implement \\\"off by one\\\" errors in\\n/// this form, and requires sourcing a length from somewhere. This opcode exposes\\n/// a pretty typical fold as found elsewhere in functional programming. A start\\n/// column and width of columns can be specified, the rows will be iterated and\\n/// pushed to the stack on top of any additional inputs specified by the\\n/// expression. The additional inputs are the accumulators and so the number of\\n/// outputs in the called source needs to match the number of accumulator inputs.\\nlibrary OpFoldContext {\\n    using LibIntegrityCheck for IntegrityCheckState;\\n    using LibStackPointer for StackPointer;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 sourceIndex_ = Operand.unwrap(operand_) & MASK_4BIT;\\n            // We don't use the column for anything in the integrity check.\\n            // uint256 column_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\\n            uint256 width_ = (Operand.unwrap(operand_) >> 8) & MASK_4BIT;\\n            uint256 inputs_ = Operand.unwrap(operand_) >> 12;\\n            uint256 callInputs_ = width_ + inputs_;\\n\\n            // Outputs for call is the same as the inputs.\\n            Operand callOperand_ = Operand.wrap(\\n                (sourceIndex_ << 8) | (inputs_ << 4) | callInputs_\\n            );\\n\\n            // First the width of the context columns being folded is pushed to\\n            // the stack. Ignore the highwater here as `OpCall.integrity` has its\\n            // own internal highwater handling over all its inputs and outputs.\\n            stackTop_ = integrityCheckState_.pushIgnoreHighwater(\\n                stackTop_,\\n                width_\\n            );\\n            // Then we loop over call taking the width and extra inputs, then\\n            // returning the same number of outputs as non-width inputs.\\n            return\\n                OpCall.integrity(integrityCheckState_, callOperand_, stackTop_);\\n        }\\n    }\\n\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 sourceIndex_ = Operand.unwrap(operand_) & MASK_4BIT;\\n            uint256 column_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\\n            uint256 width_ = (Operand.unwrap(operand_) >> 8) & MASK_4BIT;\\n            uint256 inputs_ = Operand.unwrap(operand_) >> 12;\\n            // Call will take the width of the context rows being copied and the\\n            // base inputs that will be the accumulators of the fold.\\n            uint256 callInputs_ = width_ + inputs_;\\n\\n            // Fold over the entire context. This will error with an OOB index\\n            // if the context columns are not of the same length.\\n            for (uint256 i_ = 0; i_ < state_.context[column_].length; i_++) {\\n                // Push the width of the context columns onto the stack as rows.\\n                for (uint256 j_ = 0; j_ < width_; j_++) {\\n                    stackTop_ = stackTop_.push(\\n                        state_.context[column_ + j_][i_]\\n                    );\\n                }\\n                // The outputs of call are the same as the base inputs, this is\\n                // similar to `OpDoWhile` so that we don't have to care how many\\n                // iterations there are in order to calculate the stack.\\n                Operand callOperand_ = Operand.wrap(\\n                    (sourceIndex_ << 8) | (inputs_ << 4) | callInputs_\\n                );\\n                stackTop_ = OpCall.run(state_, callOperand_, stackTop_);\\n            }\\n\\n            return stackTop_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x64f3040161d7cbee8b17325af7d40efc23392f413c3fd152be3b416d5d7bff8e\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpLoopN.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"./OpCall.sol\\\";\\n\\n/// @title OpLoopN\\n/// @notice Opcode for looping a static number of times. A thin wrapper around\\n/// `OpCall` with the 4 high bits as a number of times to loop. Each iteration\\n/// will use the outputs of the previous iteration as its inputs so the inputs\\n/// to call must be greater or equal to the outputs. If the outputs exceed the\\n/// inputs then each subsequent call will take as many inputs as it needs from\\n/// the top of the intermediate stack. The net outputs to the stack will include\\n/// all the intermediate excess outputs as:\\n/// `outputs + (inputs - outputs) * n`\\nlibrary OpLoopN {\\n    using LibStackPointer for StackPointer;\\n    using LibInterpreterState for InterpreterState;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 n_ = Operand.unwrap(operand_) >> 12;\\n            uint256 inputs_ = Operand.unwrap(operand_) & MASK_4BIT;\\n            uint256 outputs_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\\n            require(inputs_ >= outputs_, \\\"LOOP_N_INPUTS\\\");\\n            Operand callOperand_ = Operand.wrap(\\n                Operand.unwrap(operand_) & MASK_12BIT\\n            );\\n            for (uint256 i_ = 0; i_ < n_; i_++) {\\n                stackTop_ = OpCall.integrity(\\n                    integrityCheckState_,\\n                    callOperand_,\\n                    stackTop_\\n                );\\n            }\\n            return stackTop_;\\n        }\\n    }\\n\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        uint256 n_ = Operand.unwrap(operand_) >> 12;\\n        Operand callOperand_ = Operand.wrap(\\n            Operand.unwrap(operand_) & MASK_12BIT\\n        );\\n        for (uint256 i_ = 0; i_ < n_; i_++) {\\n            stackTop_ = OpCall.run(state_, callOperand_, stackTop_);\\n        }\\n        return stackTop_;\\n    }\\n}\\n\",\"keccak256\":\"0x8a07ef9a4f13fa5f7185647ad03b9b0b19fae4d94dd8adfe1a1cfa98116e26a4\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpReadMemory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"../../../math/Binary.sol\\\";\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// Thrown when a stack read index is outside the current stack top.\\nerror OutOfBoundsStackRead(uint256 stackTopIndex, uint256 stackRead);\\n\\n/// Thrown when a constant read index is outside the constants array.\\nerror OutOfBoundsConstantsRead(uint256 constantsLength, uint256 constantsRead);\\n\\nuint256 constant OPCODE_MEMORY_TYPE_STACK = 0;\\nuint256 constant OPCODE_MEMORY_TYPE_CONSTANT = 1;\\n\\n/// @title OpReadMemory\\n/// @notice Opcode for stacking from the interpreter state in memory. This can\\n/// either be copying values from anywhere in the stack or from the constants\\n/// array by index.\\nlibrary OpReadMemory {\\n    using LibStackPointer for StackPointer;\\n    using LibInterpreterState for InterpreterState;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n    using Math for uint256;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        uint256 type_ = Operand.unwrap(operand_) & MASK_1BIT;\\n        uint256 offset_ = Operand.unwrap(operand_) >> 1;\\n        if (type_ == OPCODE_MEMORY_TYPE_STACK) {\\n            uint256 stackTopIndex_ = integrityCheckState_.stackBottom.toIndex(\\n                stackTop_\\n            );\\n            if (offset_ >= stackTopIndex_) {\\n                revert OutOfBoundsStackRead(stackTopIndex_, offset_);\\n            }\\n\\n            console.log(\\n                \\\"before\\\",\\n                StackPointer.unwrap(integrityCheckState_.stackBottom),\\n                StackPointer.unwrap(integrityCheckState_.stackHighwater)\\n            );\\n            // Ensure that highwater is moved past any stack item that we\\n            // read so that copied values cannot later be consumed.\\n            integrityCheckState_.stackHighwater = StackPointer.wrap(\\n                StackPointer.unwrap(integrityCheckState_.stackHighwater).max(\\n                    StackPointer.unwrap(\\n                        integrityCheckState_.stackBottom.up(offset_)\\n                    )\\n                )\\n            );\\n            console.log(\\n                \\\"after\\\",\\n                StackPointer.unwrap(integrityCheckState_.stackBottom),\\n                StackPointer.unwrap(integrityCheckState_.stackHighwater)\\n            );\\n        } else {\\n            if (offset_ >= integrityCheckState_.constantsLength) {\\n                revert OutOfBoundsConstantsRead(\\n                    integrityCheckState_.constantsLength,\\n                    offset_\\n                );\\n            }\\n        }\\n        return integrityCheckState_.push(stackTop_);\\n    }\\n\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            uint256 type_ = Operand.unwrap(operand_) & MASK_1BIT;\\n            uint256 offset_ = Operand.unwrap(operand_) >> 1;\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(\\n                    stackTop_,\\n                    mload(\\n                        add(\\n                            mload(add(state_, mul(0x20, type_))),\\n                            mul(0x20, offset_)\\n                        )\\n                    )\\n                )\\n            }\\n            return StackPointer.wrap(StackPointer.unwrap(stackTop_) + 0x20);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3dac3c781d76ae3dba79ba53fd8fdf1c36af032071dd44e203f455c31a8a6797\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpSet.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"../../../kv/LibMemoryKV.sol\\\";\\n\\n/// @title OpSet\\n/// @notice Opcode for recording k/v state changes to be set in storage.\\nlibrary OpSet {\\n    using LibStackPointer for StackPointer;\\n    using LibInterpreterState for InterpreterState;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n    using LibMemoryKV for MemoryKV;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            function(uint256, uint256) internal pure fn_;\\n            return integrityCheckState_.applyFn(stackTop_, fn_);\\n        }\\n    }\\n\\n    function run(\\n        InterpreterState memory state_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            uint256 k_;\\n            uint256 v_;\\n            (stackTop_, v_) = stackTop_.pop();\\n            (stackTop_, k_) = stackTop_.pop();\\n            state_.stateKV = state_.stateKV.setVal(\\n                MemoryKVKey.wrap(k_),\\n                MemoryKVVal.wrap(v_)\\n            );\\n            return stackTop_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x973fea5361ad8b959671852f077100b32e565b5ae76d0dcf843ab7d7fe9aa6a9\",\"license\":\"CAL\"},\"contracts/interpreter/ops/crypto/OpHash.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../../type/LibCast.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpHash\\n/// @notice Opcode for hashing a list of values.\\nlibrary OpHash {\\n    using LibStackPointer for StackPointer;\\n    using LibCast for uint256[];\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256[] memory values_) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encodePacked(values_)));\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFn(\\n                stackTop_,\\n                f,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    // Stack the return of `balanceOfBatch`.\\n    // Operand will be the length\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x4d2704ca251d6ee75fa7631c0f917ca8819e4fd93120ac121a7f70b934b291fe\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc1155/OpERC1155BalanceOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC1155Upgradeable as IERC1155} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpERC1155BalanceOf\\n/// @notice Opcode for getting the current erc1155 balance of an account.\\nlibrary OpERC1155BalanceOf {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 token_,\\n        uint256 account_,\\n        uint256 id_\\n    ) internal view returns (uint256) {\\n        return\\n            IERC1155(address(uint160(token_))).balanceOf(\\n                address(uint160(account_)),\\n                id_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0xd19790732530aa7f49b2e9691c15c5bb5889d585d6c96e9156432e12bf6e59dd\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc1155/OpERC1155BalanceOfBatch.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC1155Upgradeable as IERC1155} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../../type/LibCast.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpERC1155BalanceOfBatch\\n/// @notice Opcode for getting the current erc1155 balance of an accounts batch.\\nlibrary OpERC1155BalanceOfBatch {\\n    using LibStackPointer for StackPointer;\\n    using LibCast for uint256[];\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 token_,\\n        uint256[] memory accounts_,\\n        uint256[] memory ids_\\n    ) internal view returns (uint256[] memory) {\\n        return\\n            IERC1155(address(uint160(token_))).balanceOfBatch(\\n                accounts_.asAddresses(),\\n                ids_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFn(\\n                stackTop_,\\n                f,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    // Operand will be the length\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xd038851fe568218d82a65b502bfa977fab09bec74e439d1ac481361d6043dbcd\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc20/OpERC20BalanceOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpERC20BalanceOf\\n/// @notice Opcode for ERC20 `balanceOf`.\\nlibrary OpERC20BalanceOf {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 token_,\\n        uint256 account_\\n    ) internal view returns (uint256) {\\n        return\\n            IERC20(address(uint160(token_))).balanceOf(\\n                address(uint160(account_))\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x51469ce42b26be8ca5662b6cd9fb953f982c2c8b1722ab8e23c8c6263a75631e\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc20/OpERC20TotalSupply.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpERC20TotalSupply\\n/// @notice Opcode for ERC20 `totalSupply`.\\nlibrary OpERC20TotalSupply {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256 token_) internal view returns (uint256) {\\n        return IERC20(address(uint160(token_))).totalSupply();\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x5f4ff6a101657b264dd471fe39ccc1def836d9be50c2288f5222a6a4ebfbc6f9\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc20/snapshot/OpERC20SnapshotBalanceOfAt.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {ERC20SnapshotUpgradeable as ERC20Snapshot} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpERC20SnapshotBalanceOfAt\\n/// @notice Opcode for Open Zeppelin `ERC20Snapshot.balanceOfAt`.\\n/// https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20Snapshot\\nlibrary OpERC20SnapshotBalanceOfAt {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 token_,\\n        uint256 account_,\\n        uint256 snapshotId_\\n    ) internal view returns (uint256) {\\n        return\\n            ERC20Snapshot(address(uint160(token_))).balanceOfAt(\\n                address(uint160(account_)),\\n                snapshotId_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x144afe0ac30c78faf55e1f14c8c9be932cce73b229322126a7053acdaa60a9b6\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc20/snapshot/OpERC20SnapshotTotalSupplyAt.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {ERC20SnapshotUpgradeable as ERC20Snapshot} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpERC20SnapshotTotalSupplyAt\\n/// @notice Opcode for Open Zeppelin `ERC20Snapshot.totalSupplyAt`.\\n/// https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20Snapshot\\nlibrary OpERC20SnapshotTotalSupplyAt {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 token_,\\n        uint256 snapshotId_\\n    ) internal view returns (uint256) {\\n        return\\n            ERC20Snapshot(address(uint160(token_))).totalSupplyAt(snapshotId_);\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x1068e6242be4c76b24d4049fbc69486be77767aad3a65529112615c0eec51788\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc721/OpERC721BalanceOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC721Upgradeable as IERC721} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpERC721BalanceOf\\n/// @notice Opcode for getting the current erc721 balance of an account.\\nlibrary OpERC721BalanceOf {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 token_,\\n        uint256 account_\\n    ) internal view returns (uint256) {\\n        return\\n            IERC721(address(uint160(token_))).balanceOf(\\n                address(uint160(account_))\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x94e8b3b46404d65c81be784e8d76885cd34ae9f6e601d240bcaea07be81ee2ee\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc721/OpERC721OwnerOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC721Upgradeable as IERC721} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpERC721OwnerOf\\n/// @notice Opcode for getting the current erc721 owner of an account.\\nlibrary OpERC721OwnerOf {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 token_,\\n        uint256 id_\\n    ) internal view returns (uint256) {\\n        return uint256(uint160(IERC721(address(uint160(token_))).ownerOf(id_)));\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x457ecb9665391c6a1f0921bc63683e1ba5267280459350fc1d3c157c3b0422ed\",\"license\":\"CAL\"},\"contracts/interpreter/ops/error/OpEnsure.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpEnsure\\n/// @notice Opcode for requiring some truthy values.\\nlibrary OpEnsure {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256 a_) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            if iszero(a_) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                f,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFnN(f, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xd1f1fd8b2b6ec2b3b30cef309d32d0fa6b1b3c5ee4db25a4178e136e0ed2cc21\",\"license\":\"CAL\"},\"contracts/interpreter/ops/evm/OpBlockNumber.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpBlockNumber\\n/// @notice Opcode for getting the current block number.\\nlibrary OpBlockNumber {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        return integrityCheckState_.push(stackTop_);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.push(block.number);\\n    }\\n}\\n\",\"keccak256\":\"0xb85e4f44310c0c1c19a39df2b6effef527d31f643895a5ccffd460432e6a4367\",\"license\":\"CAL\"},\"contracts/interpreter/ops/evm/OpTimestamp.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpTimestamp\\n/// @notice Opcode for getting the current timestamp.\\nlibrary OpTimestamp {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        return integrityCheckState_.push(stackTop_);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.push(block.timestamp);\\n    }\\n}\\n\",\"keccak256\":\"0xc74e68245cd8a07e3fcf7cb8845e00bdea2301b5679065a5fa14c119b9092b6d\",\"license\":\"CAL\"},\"contracts/interpreter/ops/list/OpExplode32.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpExplode\\n/// @notice Opcode for exploding a single value into 8x 32 bit integers.\\nlibrary OpExplode32 {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_), 8);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        (StackPointer location_, uint256 i_) = stackTop_.pop();\\n        uint256 mask_ = uint256(type(uint32).max);\\n        return\\n            location_.push(\\n                i_ & mask_,\\n                (i_ >> 0x20) & mask_,\\n                (i_ >> 0x40) & mask_,\\n                (i_ >> 0x60) & mask_,\\n                (i_ >> 0x80) & mask_,\\n                (i_ >> 0xA0) & mask_,\\n                (i_ >> 0xC0) & mask_,\\n                (i_ >> 0xE0) & mask_\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xb9f4fb1f976aa0cc1aeb506d9f4282a773d0eeef81811d0374b225eb049856f9\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpAdd.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpAdd\\n/// @notice Opcode for adding N numbers with error on overflow.\\nlibrary OpAdd {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    /// Addition with implied overflow checks from the Solidity 0.8.x compiler.\\n    function f(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ + b_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                f,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFnN(f, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xc195e645f999eb46d6b5aa9ddf48db2d0d9333ba2a52b9fad038f1649b93f82b\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpDiv.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpDiv\\n/// @notice Opcode for dividing N numbers.\\nlibrary OpDiv {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _div(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ / b_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                _div,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return stackTop_.applyFnN(_div, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x58aa79b99a9e9a38c1524d7c9581e91e02cb24d27a3c65157932665662311493\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpExp.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpExp\\n/// @notice Opcode to exponentiate N numbers.\\nlibrary OpExp {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _exp(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ ** b_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                _exp,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return stackTop_.applyFnN(_exp, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x8a6c4600f9ae130397e1b3e55f536aa6f1890e46929bb36418ddfd5d389cdb07\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpMax.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpMax\\n/// @notice Opcode to stack the maximum of N numbers.\\nlibrary OpMax {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _max(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ > b_ ? a_ : b_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                _max,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return stackTop_.applyFnN(_max, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xb4db82d68a574987b9aef58e13c0ff03289fa2c335d258df845417be67ce8956\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpMin.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpMin\\n/// @notice Opcode to stack the minimum of N numbers.\\nlibrary OpMin {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _min(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ < b_ ? a_ : b_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                _min,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return stackTop_.applyFnN(_min, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xd7f7f78633f1c429184854be5f5c51f64191b54f3f4e31779004439e5e7bf278\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpMod.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpMod\\n/// @notice Opcode to mod N numbers.\\nlibrary OpMod {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _mod(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ % b_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                _mod,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return stackTop_.applyFnN(_mod, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xb04cbdc74cfe4c3d384d879182bdcfecd0f497a9910a7b4c659d6b859e076b88\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpMul.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpMul\\n/// @notice Opcode for multiplying N numbers.\\nlibrary OpMul {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _mul(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ * b_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                _mul,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return stackTop_.applyFnN(_mul, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xbe40dac40887e6b86c60bf6df1b58da55270db10fe15f01a6ec905fa35555324\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpSub.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpSub\\n/// @notice Opcode for subtracting N numbers.\\nlibrary OpSub {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _sub(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ - b_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                _sub,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return stackTop_.applyFnN(_sub, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x5cb8c344129397f448a9cd4465079c3c357afcf552cc7d567e46e2102b6190f0\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/fixedPoint/OpFixedPointScale18.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpFixedPointScale18\\n/// @notice Opcode for scaling a number to 18 fixed point.\\nlibrary OpFixedPointScale18 {\\n    using FixedPointMath for uint256;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        Operand operand_,\\n        uint256 a_\\n    ) internal pure returns (uint256) {\\n        return a_.scale18(Operand.unwrap(operand_));\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0xba89c22f9ac2881d07cd83b6c20118ef3b727ca2eb35c73b1efed433b2bcf03e\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/fixedPoint/OpFixedPointScale18Div.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpFixedPointScale18Div\\n/// @notice Opcode for performing scale 18 fixed point division.\\nlibrary OpFixedPointScale18Div {\\n    using FixedPointMath for uint256;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        Operand operand_,\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        return a_.scale18(Operand.unwrap(operand_)).fixedPointDiv(b_);\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0x73df3efa5b9f319bef39566d4dce85dc15918d3e220160dc3859cad69ab31902\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/fixedPoint/OpFixedPointScale18Mul.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpFixedPointScale18Mul\\n/// @notice Opcode for performing scale 18 fixed point multiplication.\\nlibrary OpFixedPointScale18Mul {\\n    using FixedPointMath for uint256;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        Operand operand_,\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        return a_.scale18(Operand.unwrap(operand_)).fixedPointMul(b_);\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0x725d9fdd0e23f648d1764f5a72e8806eadda333544f0327bc481e86ed7784c2a\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/fixedPoint/OpFixedPointScaleBy.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpFixedPointScaleBy\\n/// @notice Opcode for scaling a number by some OOMs.\\nlibrary OpFixedPointScaleBy {\\n    using FixedPointMath for uint256;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        Operand operand_,\\n        uint256 a_\\n    ) internal pure returns (uint256) {\\n        return a_.scaleBy(int8(uint8(Operand.unwrap(operand_))));\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0x64de32b7d865115ee71bf969768f34dbee7b25768d4dc57f0399643d79b982ff\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/fixedPoint/OpFixedPointScaleN.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpFixedPointScaleN\\n/// @notice Opcode for scaling a number to N fixed point.\\nlibrary OpFixedPointScaleN {\\n    using FixedPointMath for uint256;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        Operand operand_,\\n        uint256 a_\\n    ) internal pure returns (uint256) {\\n        return a_.scaleN(Operand.unwrap(operand_));\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0x2b8725c09f43c1122631a237625a0cb09c5b13a286e0c5d884252e097f6fbe64\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpAny.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpAny\\n/// @notice Opcode to compare the top N stack values.\\nlibrary OpAny {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        function(uint256[] memory) internal view returns (uint256) fn_;\\n        return\\n            integrityCheckState_.applyFn(\\n                stackTop_,\\n                fn_,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    // ANY\\n    // ANY is the first nonzero item, else 0.\\n    // operand_ id the length of items to check.\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer bottom_ = stackTop_.down(Operand.unwrap(operand_));\\n        for (\\n            StackPointer i_ = bottom_;\\n            StackPointer.unwrap(i_) < StackPointer.unwrap(stackTop_);\\n            i_ = i_.up()\\n        ) {\\n            uint256 item_ = i_.peekUp();\\n            if (item_ > 0) {\\n                return bottom_.push(item_);\\n            }\\n        }\\n        return bottom_.up();\\n    }\\n}\\n\",\"keccak256\":\"0xd75b71897f37cfec7c021592f22248a2102c470583a4f43fd50dca6b562997b6\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpEagerIf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpEagerIf\\n/// @notice Opcode for selecting a value based on a condition.\\nlibrary OpEagerIf {\\n    using LibIntegrityCheck for IntegrityCheckState;\\n    using LibStackPointer for StackPointer;\\n\\n    function _eagerIf(\\n        uint256 a_,\\n        uint256[] memory bs_,\\n        uint256[] memory cs_\\n    ) internal pure returns (uint256[] memory) {\\n        return a_ > 0 ? bs_ : cs_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFn(\\n                stackTop_,\\n                _eagerIf,\\n                Operand.unwrap(operand_) + 1\\n            );\\n    }\\n\\n    /// Eager because BOTH x_ and y_ must be eagerly evaluated\\n    /// before EAGER_IF will select one of them. If both x_ and y_\\n    /// are cheap (e.g. constant values) then this may also be the\\n    /// simplest and cheapest way to select one of them.\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            return stackTop_.applyFn(_eagerIf, Operand.unwrap(operand_) + 1);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x71a60f34c8179fe596e9f2107dd14373a56993d44d32e1e84b5de75732eab3bf\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpEqualTo.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../../type/LibCast.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpEqualTo\\n/// @notice Opcode to compare the top two stack values.\\nlibrary OpEqualTo {\\n    using LibCast for bool;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _equalTo(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256 c_) {\\n        // Perhaps surprisingly it seems to require assembly to efficiently get\\n        // a `uint256` from boolean equality.\\n        assembly (\\\"memory-safe\\\") {\\n            c_ := eq(a_, b_)\\n        }\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, _equalTo);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(_equalTo);\\n    }\\n}\\n\",\"keccak256\":\"0xabadb9889f171c56fbd53fb44bf33e68398d005a50a450b19f569b099dd463c4\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpEvery.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpEvery\\n/// @notice Opcode to compare the top N stack values.\\nlibrary OpEvery {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        function(uint256[] memory) internal view returns (uint256) fn_;\\n        return\\n            integrityCheckState_.applyFn(\\n                stackTop_,\\n                fn_,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    // EVERY\\n    // EVERY is either the first item if every item is nonzero, else 0.\\n    // operand_ is the length of items to check.\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer bottom_ = stackTop_.down(Operand.unwrap(operand_));\\n        for (\\n            StackPointer i_ = bottom_;\\n            StackPointer.unwrap(i_) < StackPointer.unwrap(stackTop_);\\n            i_ = i_.up()\\n        ) {\\n            if (i_.peekUp() == 0) {\\n                return bottom_.push(0);\\n            }\\n        }\\n        return bottom_.up();\\n    }\\n}\\n\",\"keccak256\":\"0x4d49dcd89b27f850a009419f6ee8a055dc86840e456a6c656a11e6fdb1f25bdd\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpGreaterThan.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../../type/LibCast.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpGreaterThan\\n/// @notice Opcode to compare the top two stack values.\\nlibrary OpGreaterThan {\\n    using LibCast for bool;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _greaterThan(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256 c_) {\\n        assembly (\\\"memory-safe\\\") {\\n            c_ := gt(a_, b_)\\n        }\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, _greaterThan);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(_greaterThan);\\n    }\\n}\\n\",\"keccak256\":\"0xcedd845107a0ffd907375d6642b3dd351ce5cca1fcfb8c4a60cb6bc70ae510b1\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpIsZero.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../../type/LibCast.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpIsZero\\n/// @notice Opcode for checking if the stack top is zero.\\nlibrary OpIsZero {\\n    using LibCast for bool;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256 a_) internal pure returns (uint256 b_) {\\n        assembly (\\\"memory-safe\\\") {\\n            b_ := iszero(a_)\\n        }\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x8300675f9c302fd2f68050613f149ad043d6c3c1b59e6028c54c5c69da3084de\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpLessThan.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../../type/LibCast.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpLessThan\\n/// @notice Opcode to compare the top two stack values.\\nlibrary OpLessThan {\\n    using LibStackPointer for StackPointer;\\n    using LibCast for bool;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _lessThan(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256 c_) {\\n        assembly (\\\"memory-safe\\\") {\\n            c_ := lt(a_, b_)\\n        }\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, _lessThan);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(_lessThan);\\n    }\\n}\\n\",\"keccak256\":\"0x21cb5201b62f7dd695cb2eb217df0eb53bca8d0ab705cf07056b2204da7ce009\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/saturating/OpSaturatingAdd.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/SaturatingMath.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpSaturatingAdd\\n/// @notice Opcode for adding N numbers with saturating addition.\\nlibrary OpSaturatingAdd {\\n    using SaturatingMath for uint256;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                SaturatingMath.saturatingAdd,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return\\n            stackTop_.applyFnN(\\n                SaturatingMath.saturatingAdd,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x60e18423c6bc65d7756f97e0f0bc9de3b9a4756397af84981768bcc350b0dbc6\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/saturating/OpSaturatingMul.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/SaturatingMath.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpSaturatingMul\\n/// @notice Opcode for multiplying N numbers with saturating multiplication.\\nlibrary OpSaturatingMul {\\n    using SaturatingMath for uint256;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                SaturatingMath.saturatingMul,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return\\n            stackTop_.applyFnN(\\n                SaturatingMath.saturatingMul,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xca4415a078520559fbecaf721f305f9a4d37778855c4ec768375545ff8bd6e99\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/saturating/OpSaturatingSub.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/SaturatingMath.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpSaturatingSub\\n/// @notice Opcode for subtracting N numbers with saturating subtraction.\\nlibrary OpSaturatingSub {\\n    using SaturatingMath for uint256;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                SaturatingMath.saturatingSub,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return\\n            stackTop_.applyFnN(\\n                SaturatingMath.saturatingSub,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xfdf46384327bc95a8aa0ac7b53f8186887bfc13325dd9ed568e7dfceed6ee764\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/IOrderBookV1/OpIOrderBookV1VaultBalance.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../orderbook/IOrderBookV1.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpIOrderBookV1VaultBalance\\n/// @notice Opcode for IOrderBookV1 `vaultBalance`.\\nlibrary OpIOrderBookV1VaultBalance {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 orderbook_,\\n        uint256 owner_,\\n        uint256 token_,\\n        uint256 id_\\n    ) internal view returns (uint256) {\\n        return\\n            uint256(\\n                uint160(\\n                    IOrderBookV1(address(uint160(orderbook_))).vaultBalance(\\n                        address(uint160(owner_)),\\n                        address(uint160(token_)),\\n                        id_\\n                    )\\n                )\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x4b354dd96e1db51e8159ef05b7ffe82dc31146aae3dfbb3d91e03ddf07751b07\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/ISaleV2/OpISaleV2RemainingTokenInventory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../sale/ISaleV2.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpISaleV2RemainingTokenInventory\\n/// @notice Opcode for ISaleV2 `remainingTokenInventory`.\\nlibrary OpISaleV2RemainingTokenInventory {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256 sale_) internal view returns (uint256) {\\n        return ISaleV2(address(uint160(sale_))).remainingTokenInventory();\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    /// Stack `remainingTokenInventory`.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0xdecae4abbdd2f9e5f4653943d81b5e5893ef094b77a922888227c7444ba693f0\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/ISaleV2/OpISaleV2Reserve.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../sale/ISaleV2.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpISaleV2Reserve\\n/// @notice Opcode for ISaleV2 `reserve`.\\nlibrary OpISaleV2Reserve {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256 sale_) internal view returns (uint256) {\\n        return uint256(uint160(ISaleV2(address(uint160(sale_))).reserve()));\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    /// Stack `reserve`.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0xe2f6fb0b2ecd36bb53f3377e6f6c0b2efe067dcec6974b949003671af154c882\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/ISaleV2/OpISaleV2SaleStatus.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../sale/ISaleV2.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpISaleV2SaleStatus\\n/// @notice Opcode for ISaleV2 `saleStatus`.\\nlibrary OpISaleV2SaleStatus {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256 sale_) internal view returns (uint256) {\\n        return uint(ISaleV2(address(uint160(sale_))).saleStatus());\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    /// Stack `saleStatus`.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x26c3bc24f79e52341342fe6ac69cfc36629df8ad6f1591c9f509241b49f90155\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/ISaleV2/OpISaleV2Token.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../sale/ISaleV2.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpISaleV2Token\\n/// @notice Opcode for ISaleV2 `token`.\\nlibrary OpISaleV2Token {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256 sale_) internal view returns (uint256) {\\n        return uint256(uint160(ISaleV2(address(uint160(sale_))).token()));\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    /// Stack `token`.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x30ff42d3de74de6f90a7e0a664956e08300b0b821e252db02c17f04dfaf1cdee\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/ISaleV2/OpISaleV2TotalReserveReceived.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../sale/ISaleV2.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpISaleV2TotalReserveReceived\\n/// @notice Opcode for ISaleV2 `totalReserveReceived`.\\nlibrary OpISaleV2TotalReserveReceived {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256 sale_) internal view returns (uint256) {\\n        return ISaleV2(address(uint160(sale_))).totalReserveReceived();\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    /// Stack `totalReserveReceived`.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x3a90bc939e393d3c8441e044c997395b7ca60b11cc685caa4018cfc85b20456c\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/IVerifyV1/OpIVerifyV1AccountStatusAtTime.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../verify/IVerifyV1.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpIVerifyV1AccountStatusAtTime\\n/// @notice Opcode for IVerifyV1 `accountStatusAtTime`.\\nlibrary OpIVerifyV1AccountStatusAtTime {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 contract_,\\n        uint256 account_,\\n        uint256 timestamp_\\n    ) internal view returns (uint256) {\\n        return\\n            VerifyStatus.unwrap(\\n                IVerifyV1(address(uint160(contract_))).accountStatusAtTime(\\n                    address(uint160(account_)),\\n                    timestamp_\\n                )\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    /// Stack `token`.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x5517c59f3a991025fab8df860196d248373aa60a356f3d98d9fd2bdc4beffe1f\",\"license\":\"CAL\"},\"contracts/interpreter/ops/tier/OpITierV2Report.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../tier/ITierV2.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpITierV2Report\\n/// @notice Exposes `ITierV2.report` as an opcode.\\nlibrary OpITierV2Report {\\n    using LibStackPointer for StackPointer;\\n    using LibStackPointer for uint256[];\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _report(\\n        uint256 tierContract_,\\n        uint256 account_,\\n        uint256[] memory context_\\n    ) internal view returns (uint256) {\\n        return\\n            ITierV2(address(uint160(tierContract_))).report(\\n                address(uint160(account_)),\\n                context_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFn(\\n                stackTop_,\\n                _report,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    // Stack the `report` returned by an `ITierV2` contract.\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return stackTop_.applyFn(_report, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x42b5660406a8c32743a95e91fc4ad4483429030290f033041d77d940f47542c3\",\"license\":\"CAL\"},\"contracts/interpreter/ops/tier/OpITierV2ReportTimeForTier.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../tier/ITierV2.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpITierV2Report\\n/// @notice Exposes `ITierV2.reportTimeForTier` as an opcode.\\nlibrary OpITierV2ReportTimeForTier {\\n    using LibStackPointer for StackPointer;\\n    using LibStackPointer for uint256[];\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _reportTimeForTier(\\n        uint256 tierContract_,\\n        uint256 account_,\\n        uint256 tier_,\\n        uint256[] memory context_\\n    ) internal view returns (uint256) {\\n        return\\n            ITierV2(address(uint160(tierContract_))).reportTimeForTier(\\n                address(uint160(account_)),\\n                tier_,\\n                context_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFn(\\n                stackTop_,\\n                _reportTimeForTier,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    // Stack the `reportTimeForTier` returned by an `ITierV2` contract.\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(_reportTimeForTier, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x81697da8b4847a557776ec2458ea6c30794887015a3fb353dacbed7cf16b53b5\",\"license\":\"CAL\"},\"contracts/interpreter/ops/tier/OpSaturatingDiff.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../tier/libraries/TierwiseCombine.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\nlibrary OpSaturatingDiff {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFn(\\n                stackTop_,\\n                TierwiseCombine.saturatingSub\\n            );\\n    }\\n\\n    // Stack the tierwise saturating subtraction of two reports.\\n    // If the older report is newer than newer report the result will\\n    // be `0`, else a tierwise diff in blocks will be obtained.\\n    // The older and newer report are taken from the stack.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(TierwiseCombine.saturatingSub);\\n    }\\n}\\n\",\"keccak256\":\"0x62ffc76b1e1d83a633055964f989a9c73d62695f5bf49ed1b72235c27fa3980c\",\"license\":\"CAL\"},\"contracts/interpreter/ops/tier/OpSelectLte.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../tier/libraries/TierwiseCombine.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"../../../math/Binary.sol\\\";\\n\\n/// Zero inputs to select lte is NOT supported.\\nerror ZeroInputs();\\n\\n/// @title OpSelectLte\\n/// @notice Exposes `TierwiseCombine.selectLte` as an opcode.\\nlibrary OpSelectLte {\\n    using LibStackPointer for StackPointer;\\n    using LibStackPointer for uint256[];\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\\n            if (inputs_ == 0) {\\n                revert ZeroInputs();\\n            }\\n\\n            return\\n                integrityCheckState_.push(\\n                    integrityCheckState_.pop(stackTop_, inputs_)\\n                );\\n        }\\n    }\\n\\n    // Stacks the result of a `selectLte` combinator.\\n    // All `selectLte` share the same stack and argument handling.\\n    // Takes the `logic_` and `mode_` from the `operand_` high bits.\\n    // `logic_` is the highest bit.\\n    // `mode_` is the 2 highest bits after `logic_`.\\n    // The other bits specify how many values to take from the stack\\n    // as reports to compare against each other and the block number.\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            uint256 inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\\n            uint256 mode_ = (Operand.unwrap(operand_) >> 8) & MASK_2BIT;\\n            uint256 logic_ = Operand.unwrap(operand_) >> 10;\\n            (uint256 time_, uint256[] memory reports_) = stackTop_.list(\\n                inputs_\\n            );\\n            return\\n                reports_.asStackPointer().push(\\n                    TierwiseCombine.selectLte(logic_, mode_, time_, reports_)\\n                );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1df003c83995c1803252d33d41b5a07254c947d85d4919a2eb676554c00c2b83\",\"license\":\"CAL\"},\"contracts/interpreter/ops/tier/OpUpdateTimesForTierRange.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../tier/libraries/TierReport.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\nlibrary OpUpdateTimesForTierRange {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        Operand operand_,\\n        uint256 report_,\\n        uint256 timestamp_\\n    ) internal pure returns (uint256) {\\n        return\\n            TierReport.updateTimesForTierRange(\\n                report_,\\n                // start tier.\\n                // 4 low bits.\\n                Operand.unwrap(operand_) & 0x0f,\\n                // end tier.\\n                // 4 high bits.\\n                (Operand.unwrap(operand_) >> 4) & 0x0f,\\n                timestamp_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    // Stacks a report with updated times over tier range.\\n    // The start and end tier are taken from the low and high bits of\\n    // the `operand_` respectively.\\n    // The report to update and timestamp to update to are both\\n    // taken from the stack.\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0xdf2214c2c70d79c5d7e23606322ef01d7a5bd0dc1ef362afb63178c0bff7c7d9\",\"license\":\"CAL\"},\"contracts/interpreter/run/IInterpreterV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// @dev The index of a source within a deployed expression that can be evaluated\\n/// by an `IInterpreterV1`. MAY be an entrypoint or the index of a source called\\n/// internally such as by the `call` opcode.\\ntype SourceIndex is uint256;\\n/// @dev Encoded information about a specific evaluation including the expression\\n/// address onchain, entrypoint and expected return values.\\ntype EncodedDispatch is uint256;\\n/// @dev The namespace for state changes as requested by the calling contract.\\n/// The interpreter MUST apply this namespace IN ADDITION to namespacing by\\n/// caller etc.\\ntype StateNamespace is uint256;\\n/// @dev Additional bytes that can be used to configure a single opcode dispatch.\\n/// Commonly used to specify the number of inputs to a variadic function such\\n/// as addition or multiplication.\\ntype Operand is uint256;\\n\\n/// @title IInterpreterV1\\n/// Interface into a standard interpreter that supports:\\n///\\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\\n///   to the evaluated logic\\n/// - handling subsequent state changes in bulk in response to evaluated logic\\n/// - namespacing state changes according to the caller's preferences to avoid\\n///   unwanted key collisions\\n/// - exposing its internal function pointers to support external precompilation\\n///   of logic for more gas efficient runtime evaluation by the interpreter\\n///\\n/// The interface is designed to be stable across many versions and\\n/// implementations of an interpreter, balancing minimalism with features\\n/// required for a general purpose onchain interpreted compute environment.\\n///\\n/// The security model of an interpreter is that it MUST be resilient to\\n/// malicious expressions even if they dispatch arbitrary internal function\\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\\n/// undefined behaviour or error during an eval, _provided that no state changes\\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\\n/// malicious expression can be negatively impacted by the result. In turn, the\\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\\n/// return values from any interpreter that it requests an expression from. And\\n/// so on and so forth up to the externally owned account (EOA) who signs the\\n/// transaction and agrees to a specific combination of contracts, expressions\\n/// and interpreters, who can presumably make an informed decision about which\\n/// ones to trust to get the job done.\\n///\\n/// The state changes for an interpreter are expected to be produces by an `eval`\\n/// and passed back to the interpreter as-is by the caller, after the caller has\\n/// had an opportunity to apply their own intermediate logic such as reentrancy\\n/// defenses against malicious interpreters. The interpreter is free to structure\\n/// the state changes however it wants but MUST guard against the calling\\n/// contract corrupting the changes between `eval` and `stateChanges`. For\\n/// example an interpreter could sandbox storage writes per-caller so that a\\n/// malicious caller can only damage their own state changes, while honest\\n/// callers respect, benefit from and are protected by the interpreter's state\\n/// change handling.\\n///\\n/// The two step eval-state model allows eval to be read-only which provides\\n/// security guarantees for the caller such as no stateful reentrancy, either\\n/// from the interpreter or some contract interface used by some word, while\\n/// still allowing for storage writes. As the storage writes happen on the\\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\\n/// need to trust the interpreter, which allows for permissionless selection of\\n/// interpreters by end users. Delegate call always implies an admin key on the\\n/// caller because the delegatee contract can write arbitrarily to the state of\\n/// the delegator, which severely limits the generality of contract composition.\\ninterface IInterpreterV1 {\\n    /// Exposes the function pointers as `uint16` values packed into a single\\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\\n    ///\\n    /// `IExpressionDeployerV1` contracts use these function pointers to\\n    /// \\\"compile\\\" the expression into something that an interpreter can dispatch\\n    /// directly without paying gas to lookup the same at runtime. As the\\n    /// validity of any integrity check and subsequent dispatch is highly\\n    /// sensitive to both the function pointers and overall bytecode of the\\n    /// interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\\n    /// against accidentally being deployed onchain paired against an unknown\\n    /// interpreter. It is very easy for an apparent compatible pairing to be\\n    /// subtly and critically incompatible due to addition/removal/reordering of\\n    /// opcodes and compiler optimisations on the interpreter bytecode.\\n    ///\\n    /// This MAY return different values during construction vs. all other times\\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\\n    /// on function pointers reported during contract construction.\\n    function functionPointers() external view returns (bytes memory);\\n\\n    /// The raison d'etre for an interpreter. Given some expression and per-call\\n    /// additional contextual data, produce a stack of results and a set of state\\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\\n    /// call to `stateChanges`.\\n    /// @param dispatch All the information required for the interpreter to load\\n    /// an expression, select an entrypoint and return the values expected by the\\n    /// caller. The interpreter MAY encode dispatches differently to\\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\\n    /// calling contracts that hardcode the encoding logic.\\n    /// @param context A 2-dimensional array of data that can be indexed into at\\n    /// runtime by the interpreter. The calling contract is responsible for\\n    /// ensuring the authenticity and completeness of context data. The\\n    /// interpreter MUST revert at runtime if an expression attempts to index\\n    /// into some context value that is not provided by the caller. This implies\\n    /// that context reads cannot be checked for out of bounds reads at deploy\\n    /// time, as the runtime context MAY be provided in a different shape to what\\n    /// the expression is expecting.\\n    function eval(\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    )\\n        external\\n        view\\n        returns (uint256[] memory stack, uint256[] memory stateChanges);\\n\\n    /// Applies state changes from a prior eval to the storage of the\\n    /// interpreter. The interpreter is responsible for ensuring that applying\\n    /// these state changes is safe from key collisions, both with any internal\\n    /// state the interpreter needs for itself and with calls to `stateChanges`\\n    /// from different `msg.sender` callers. I.e. it MUST NOT be possible for\\n    /// a caller to modify the state changes associated with some other caller.\\n    ///\\n    /// The interpreter defines the shape of its own state changes, which is\\n    /// opaque to the calling contract. For example, some interpreter may treat\\n    /// the list of state changes as a pairwise key/value set, and some other\\n    /// interpreter may treat it as a literal list to be stored as-is.\\n    ///\\n    /// The interpreter MUST assume the state changes have been corrupted by the\\n    /// calling contract due to bugs or malicious intent, and enforce state\\n    /// isolation between callers despite arbitrarily invalid state changes. The\\n    /// interpreter MUST revert if it can detect invalid state changes, such\\n    /// as a key/value list having an odd number of items, but this MAY NOT be\\n    /// possible if the corruption is undetectable.\\n    ///\\n    /// @param stateChanges The list of changes to apply to the interpreter's\\n    /// internal state.\\n    function stateChanges(uint256[] calldata stateChanges) external;\\n\\n    /// Same as `eval` but allowing the caller to specify a namespace under which\\n    /// the state changes will be applied. The interpeter MUST ensure that keys\\n    /// will never collide across namespaces, even if, for example:\\n    ///\\n    /// - The calling contract is malicious and attempts to craft a collision\\n    ///   with state changes from another contract\\n    /// - The expression is malicious and attempts to craft a collision with\\n    ///   other expressions evaluated by the same calling contract\\n    ///\\n    /// A malicious entity MAY have access to significant offchain resources to\\n    /// attempt to precompute key collisions through brute force. The collision\\n    /// resistance of namespaces should be comparable or equivalent to the\\n    /// collision resistance of the hashing algorithms employed by the blockchain\\n    /// itself, such as the design of `mapping` in Solidity that hashes each\\n    /// nested key to produce a collision resistant compound key.\\n    ///\\n    /// Calls to `eval` without a namespace are implied to be under namespace `0`\\n    /// so an interpreter MAY implement `eval` in terms of `evalWithNamespace` if\\n    /// this simplifies the implementation.\\n    ///\\n    /// @param namespace The namespace specified by the calling contract.\\n    /// @param dispatch As per `eval`.\\n    /// @param context As per `eval`.\\n    /// @return stack As per `eval`.\\n    /// @return stateChanges As per `eval`.\\n    function evalWithNamespace(\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    )\\n        external\\n        view\\n        returns (uint256[] memory stack, uint256[] memory stateChanges);\\n\\n    /// Same as `stateChanges` but following `evalWithNamespace`. The caller MUST\\n    /// use the same namespace for both `evalWithNamespace` and\\n    /// `stateChangesWithNamespace` for a given expression evaluation.\\n    /// @param namespace As per `evalWithNamespace`.\\n    /// @param stateChanges as per `stateChanges`.\\n    function stateChangesWithNamespace(\\n        StateNamespace namespace,\\n        uint256[] calldata stateChanges\\n    ) external;\\n}\\n\",\"keccak256\":\"0x143cef02a6d24775f36fea669df20262836082fbcfc23282378d07e6b5862062\",\"license\":\"CAL\"},\"contracts/interpreter/run/LibContext.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"../../array/LibUint256Array.sol\\\";\\n\\nimport {SignatureCheckerUpgradeable as SignatureChecker} from \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/SignatureCheckerUpgradeable.sol\\\";\\nimport {ECDSAUpgradeable as ECDSA} from \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\\\";\\n\\n/// Thrown when the ith signature from a list of signed contexts is invalid.\\nerror InvalidSignature(uint256 i);\\n\\n/// Typed embodiment of some context data with associated signer and signature.\\n/// The signature MUST be over the packed encoded bytes of the context array,\\n/// i.e. the context array concatenated as bytes without the length prefix, then\\n/// hashed, then handled as per EIP-191 to produce a final hash to be signed.\\n///\\n/// The calling contract (likely with the help of `LibContext`) is responsible\\n/// for ensuring the authenticity of the signature, but not authorizing _who_ can\\n/// sign. IN ADDITION to authorisation of the signer to known-good entities the\\n/// expression is also responsible for:\\n///\\n/// - Enforcing the context is the expected data (e.g. with a domain separator)\\n/// - Tracking and enforcing nonces if signed contexts are only usable one time\\n/// - Tracking and enforcing uniqueness of signed data if relevant\\n/// - Checking and enforcing expiry times if present and relevant in the context\\n/// - Many other potential constraints that expressions may want to enforce\\n///\\n/// EIP-1271 smart contract signatures are supported in addition to EOA\\n/// signatures via. the Open Zeppelin `SignatureChecker` library, which is\\n/// wrapped by `LibContext.build`. As smart contract signatures are checked\\n/// onchain they CAN BE REVOKED AT ANY MOMENT as the smart contract can simply\\n/// return `false` when it previously returned `true`.\\n///\\n/// @param signer The account that produced the signature for `context`. The\\n/// calling contract MUST authenticate that the signer produced the signature.\\n/// @param signature The cryptographic signature for `context`. The calling\\n/// contract MUST authenticate that the signature is valid for the `signer` and\\n/// `context`.\\n/// @param context The signed data in a format that can be merged into a\\n/// 2-dimensional context matrix as-is.\\nstruct SignedContext {\\n    address signer;\\n    bytes signature;\\n    uint256[] context;\\n}\\n\\n/// @title LibContext\\n/// @notice Conventions for working with context as a calling contract. All of\\n/// this functionality is OPTIONAL but probably useful for the majority of use\\n/// cases. By building and authenticating onchain, caller provided and signed\\n/// contexts all in a standard way the overall usability of context is greatly\\n/// improved for expression authors and readers. Any calling contract that can\\n/// match the context expectations of an existing expression is one large step\\n/// closer to compatibility and portability, inheriting network effects of what\\n/// has already been authored elsewhere.\\nlibrary LibContext {\\n    using LibUint256Array for uint256[];\\n\\n    /// The base context is the `msg.sender` and address of the calling contract.\\n    /// As the interpreter itself is called via an external interface and may be\\n    /// statically calling itself, it MAY NOT have any ability to inspect either\\n    /// of these values. Even if this were not the case the calling contract\\n    /// cannot assume the existence of some opcode(s) in the interpreter that\\n    /// inspect the caller, so providing these two values as context is\\n    /// sufficient to decouple the calling contract from the interpreter. It is\\n    /// STRONGLY RECOMMENDED that even if the calling contract has \\\"no context\\\"\\n    /// that it still provides this base to every `eval`.\\n    ///\\n    /// Calling contracts DO NOT need to call this directly. It is built and\\n    /// merged automatically into the standard context built by `build`.\\n    ///\\n    /// @return The `msg.sender` and address of the calling contract using this\\n    /// library, as a context-compatible array.\\n    function base() internal view returns (uint256[] memory) {\\n        return\\n            LibUint256Array.arrayFrom(\\n                uint(uint160(msg.sender)),\\n                uint(uint160(address(this)))\\n            );\\n    }\\n\\n    /// Standard hashing process over a list of signed contexts. Situationally\\n    /// useful if the calling contract wants to record that it has seen a set of\\n    /// signed data then later compare it against some input (e.g. to ensure that\\n    /// many calls of some function all share the same input values). Note that\\n    /// unlike the internals of `build`, this hashes over the signer and the\\n    /// signature, to ensure that some data cannot be re-signed and used under\\n    /// a different provenance later.\\n    /// @param signedContexts_ The list of signed contexts to hash over.\\n    /// @return The hash of the signed contexts.\\n    function hash(\\n        SignedContext[] memory signedContexts_\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(signedContexts_));\\n    }\\n\\n    /// Builds a standard 2-dimensional context array from base, calling and\\n    /// signed contexts. Note that \\\"columns\\\" of a context array refer to each\\n    /// `uint256[]` and each item within a `uint256[]` is a \\\"row\\\".\\n    ///\\n    /// @param baseContext_ Anything the calling contract can provide without\\n    /// input from the `msg.sender`. More strictly the `msg.sender` MUST NOT be\\n    /// able to directly modify any of these values, although the values MAY be\\n    /// derived from user activity broadly, such as current vault balances after\\n    /// a series of deposits and withdrawals. The default base context from\\n    /// `LibContext.base()` DOES NOT need to be provided by the caller, this\\n    /// matrix MAY be empty and will be simply merged into the final context. The\\n    /// base context matrix MUST contain a consistent number of columns from the\\n    /// calling contract so that the expression can always predict how many\\n    /// columns there will be when it runs.\\n    /// @param callingContext_ Calling context is provided by the `msg.sender`\\n    /// and so should be treated as self-signed data. As an attestation/proof of\\n    /// some external event or state it is highly suspect, but as an indicator\\n    /// of the intent of `msg.sender` it may be treated as gospel. Calling\\n    /// context MAY be empty but a zero length column will still be reserved in\\n    /// the final built context. This ensures that expressions can always\\n    /// predict how many columns there will be when they run.\\n    /// @param signedContexts_ Signed contexts are provided by the `msg.sender`\\n    /// but signed by a third party. The expression (author) defines _who_ may\\n    /// sign and the calling contract authenticates the signature over the\\n    /// signed data. Technically `build` handles all the authentication inline\\n    /// for the calling contract so if some context builds it can be treated as\\n    /// authentic. The builder WILL REVERT if any of the signatures are invalid.\\n    /// Note two things about the structure of the final built context re: signed\\n    /// contexts:\\n    /// - The first column is a list of the signers in order of what they signed\\n    /// - The `msg.sender` can provide an arbitrary number of signed contexts so\\n    ///   expressions DO NOT know exactly how many columns there are.\\n    /// The expression is responsible for defining e.g. a domain separator in a\\n    /// position that would force signed context to be provided in the \\\"correct\\\"\\n    /// order, rather than relying on the `msg.sender` to honestly present data\\n    /// in any particular structure/order.\\n    function build(\\n        uint256[][] memory baseContext_,\\n        uint256[] memory callingContext_,\\n        SignedContext[] memory signedContexts_\\n    ) internal view returns (uint256[][] memory) {\\n        unchecked {\\n            uint256[] memory signers_ = new uint256[](signedContexts_.length);\\n\\n            // - LibContext.base() + whatever we are provided.\\n            // - calling context always even if empty\\n            // - signed contexts + signers if they exist else nothing.\\n            uint256 contextLength_ = 1 +\\n                baseContext_.length +\\n                1 +\\n                (signedContexts_.length > 0 ? signedContexts_.length + 1 : 0);\\n\\n            uint256[][] memory context_ = new uint256[][](contextLength_);\\n            uint256 offset_ = 0;\\n            context_[offset_] = LibContext.base();\\n\\n            for (uint256 i_ = 0; i_ < baseContext_.length; i_++) {\\n                offset_++;\\n                context_[offset_] = baseContext_[i_];\\n            }\\n\\n            // Calling context is added unconditionally so that a 0 length array\\n            // is simply an empty column. We don't want callers to be able to\\n            // manipulate the overall structure of context columns that the\\n            // expression indexes into.\\n            offset_++;\\n            context_[offset_] = callingContext_;\\n\\n            if (signedContexts_.length > 0) {\\n                offset_++;\\n                context_[offset_] = signers_;\\n\\n                for (uint256 i_ = 0; i_ < signedContexts_.length; i_++) {\\n                    if (\\n                        !SignatureChecker.isValidSignatureNow(\\n                            signedContexts_[i_].signer,\\n                            ECDSA.toEthSignedMessageHash(\\n                                // Unlike `LibContext.hash` we can only hash over\\n                                // the context as it's impossible for a signature\\n                                // to sign itself.\\n                                keccak256(\\n                                    abi.encodePacked(\\n                                        signedContexts_[i_].context\\n                                    )\\n                                )\\n                            ),\\n                            signedContexts_[i_].signature\\n                        )\\n                    ) {\\n                        revert InvalidSignature(i_);\\n                    }\\n\\n                    signers_[i_] = uint256(uint160(signedContexts_[i_].signer));\\n                    offset_++;\\n                    context_[offset_] = signedContexts_[i_].context;\\n                }\\n            }\\n\\n            return context_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6461a0131c22f4ca5220eaebe25b3889e16a84962a23e9d8418e40fb3b480111\",\"license\":\"CAL\"},\"contracts/interpreter/run/LibEncodedDispatch.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// @title LibEncodedDispatch\\n/// @notice Establishes and implements a convention for encoding an interpreter\\n/// dispatch. Handles encoding of several things required for efficient dispatch.\\nlibrary LibEncodedDispatch {\\n    /// Builds an `EncodedDispatch` from its constituent parts.\\n    /// @param expression_ The onchain address of the expression to run.\\n    /// @param sourceIndex_ The index of the source to run within the expression\\n    /// as an entrypoint.\\n    /// @param maxOutputs_ The maximum outputs the caller can meaningfully use.\\n    /// If the interpreter returns a larger stack than this it is merely wasting\\n    /// gas across the external call boundary.\\n    /// @return The encoded dispatch.\\n    function encode(\\n        address expression_,\\n        SourceIndex sourceIndex_,\\n        uint256 maxOutputs_\\n    ) internal pure returns (EncodedDispatch) {\\n        return\\n            EncodedDispatch.wrap(\\n                (uint256(uint160(expression_)) << 32) |\\n                    (SourceIndex.unwrap(sourceIndex_) << 16) |\\n                    maxOutputs_\\n            );\\n    }\\n\\n    /// Decodes an `EncodedDispatch` to its constituent parts.\\n    /// @param dispatch_ The `EncodedDispatch` to decode.\\n    /// @return The expression, source index, and max outputs as per `encode`.\\n    function decode(\\n        EncodedDispatch dispatch_\\n    ) internal pure returns (address, SourceIndex, uint256) {\\n        return (\\n            address(uint160(EncodedDispatch.unwrap(dispatch_) >> 32)),\\n            SourceIndex.wrap((EncodedDispatch.unwrap(dispatch_) >> 16) & 0xFF),\\n            EncodedDispatch.unwrap(dispatch_) & 0xFF\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xb3b870af36f1fe88ec0a0cd63f5d6e245a7107aa0fd070d2fb4afb613ca0878b\",\"license\":\"CAL\"},\"contracts/interpreter/run/LibInterpreterState.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../run/IInterpreterV1.sol\\\";\\nimport \\\"../deploy/IExpressionDeployerV1.sol\\\";\\nimport \\\"./LibStackPointer.sol\\\";\\nimport \\\"../../type/LibCast.sol\\\";\\nimport \\\"../../type/LibConvert.sol\\\";\\nimport \\\"../../array/LibUint256Array.sol\\\";\\nimport \\\"../../memory/LibMemorySize.sol\\\";\\nimport {SafeCastUpgradeable as SafeCast} from \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\\\";\\nimport \\\"../../kv/LibMemoryKV.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// Debugging options for a standard console log over the interpreter state.\\n/// - Stack: Log the entire stack, respects the current stack top, i.e. DOES NOT\\n///   log every value of the underlying `uint256[]` unless the stack top points\\n///   to the end of the array.\\n/// - Constant: Log every constant available to the current expression.\\n/// - Context: Log every column/row of context available to the current eval.\\n/// - Source: Log all the raw bytes of the compiled sources being evaluated.\\nenum DebugStyle {\\n    Stack,\\n    Constant,\\n    Context,\\n    Source\\n}\\n\\n/// A fully qualified namespace includes the interpreter's own namespacing logic\\n/// IN ADDITION to the calling contract's requested `StateNamespace`. Typically\\n/// this involves hashing the `msg.sender` into the `StateNamespace` so that each\\n/// caller operates within its own disjoint state universe. Intepreters MUST NOT\\n/// allow either the caller nor any expression/word to modify this directly on\\n/// pain of potential key collisions on writes to the interpreter's own storage.\\ntype FullyQualifiedNamespace is uint256;\\n\\n/// The standard in-memory representation of an interpreter that facilitates\\n/// decoupled coordination between opcodes. Opcodes MAY:\\n///\\n/// - push and pop values to the shared stack\\n/// - read per-expression constants\\n/// - write to the final state changes set within the fully qualified namespace\\n/// - read per-eval context values\\n/// - recursively evaluate any compiled source associated with the expression\\n///\\n/// As the interpreter defines the opcodes it is its responsibility to ensure the\\n/// opcodes are incapable of doing anything to undermine security or correctness.\\n/// For example, a hypothetical opcode could modify the current namespace from\\n/// the stack, but this would be a very bad idea as it would allow expressions\\n/// to hijack storage values associated with other callers, fundamentally\\n/// breaking the state sandbox model.\\n///\\n/// The iterpreter MAY skip any runtime integrity checks that can be reasonably\\n/// assumed to have been performed by a competent expression deployer, such as\\n/// guarding against stack underflow. A competent expression deployer MAY NOT\\n/// have deployed the currently evaluating expression, so the interpreter MUST\\n/// avoid state changes during evaluation, but MAY return garbage data if the\\n/// calling contract fails to leverage an appropriate expression deployer.\\n///\\n/// @param stackBottom Opcodes write to the stack starting at the stack bottom,\\n/// ideally using `LibStackPointer` to normalise push and pop behaviours. A\\n/// competent expression deployer will calculate a memory preallocation that\\n/// pushes and pops above the stack bottom effectively allocate and deallocate\\n/// memory within.\\n/// @param constantsBottom Opcodes read constants starting at the pointer to\\n/// the bottom of the constants array. As the name implies the interpreter MUST\\n/// NOT write to the constants, it is read only.\\n/// @param stateKV The in memory key/value store that tracks reads/writes over\\n/// the underlying interpreter storage for the duration of a single expression\\n/// evaluation.\\n/// @param namespace The fully qualified namespace that all state reads and\\n/// writes MUST be performed under.\\n/// @param context A 2-dimensional array of per-eval data provided by the calling\\n/// contract. Opaque to the interpreter but presumably meaningful to the\\n/// expression.\\n/// @param compiledSources A list of sources that can be directly evaluated by\\n/// the interpreter, either as a top level entrypoint or nested e.g. under a\\n/// dispatch by `call`.\\nstruct InterpreterState {\\n    StackPointer stackBottom;\\n    StackPointer constantsBottom;\\n    MemoryKV stateKV;\\n    FullyQualifiedNamespace namespace;\\n    uint256[][] context;\\n    bytes[] compiledSources;\\n}\\n\\n/// @dev squiggly lines to make the debug output easier to read. Intentionlly\\n/// short to keep compiled code size down.\\nstring constant DEBUG_DELIMETER = \\\"~~~\\\";\\n\\n/// @title LibInterpreterState\\n/// @notice Main workhorse for `InterpeterState` including:\\n///\\n/// - the standard `eval` loop\\n/// - source compilation from opcodes\\n/// - state (de)serialization (more gas efficient than abi encoding)\\n/// - low level debugging utility\\n///\\n/// Interpreters are designed to be highly moddable behind the `IInterpreterV1`\\n/// interface, but pretty much any interpreter that uses `InterpreterState` will\\n/// need these low level facilities verbatim. Further, these facilities\\n/// (with possible exception of debugging logic), while relatively short in terms\\n/// of lines of code, are surprisingly fragile to maintain in a gas efficient way\\n/// so we don't recommend reinventing this wheel.\\nlibrary LibInterpreterState {\\n    using SafeCast for uint256;\\n    using LibMemorySize for uint256;\\n    using LibMemorySize for uint256[];\\n    using LibMemorySize for bytes;\\n    using LibUint256Array for uint256[];\\n    using LibUint256Array for uint256;\\n    using LibInterpreterState for StackPointer;\\n    using LibStackPointer for uint256[];\\n    using LibStackPointer for StackPointer;\\n    using LibStackPointer for bytes;\\n    using LibCast for uint256;\\n    using LibCast for function(\\n        InterpreterState memory,\\n        SourceIndex,\\n        StackPointer\\n    ) view returns (StackPointer);\\n    using LibCast for function(InterpreterState memory, Operand, StackPointer)\\n        view\\n        returns (StackPointer)[];\\n    using LibConvert for uint256[];\\n\\n    /// Thin wrapper around hardhat's `console.log` that loops over any array\\n    /// and logs each value delimited by `DEBUG_DELIMITER`.\\n    /// @param array_ The array to debug.\\n    function debugArray(uint256[] memory array_) internal view {\\n        console.log(DEBUG_DELIMETER);\\n        for (uint256 i_ = 0; i_ < array_.length; i_++) {\\n            console.log(i_, array_[i_]);\\n        }\\n        console.log(DEBUG_DELIMETER);\\n    }\\n\\n    /// Copies the stack to a new array then debugs it. Definitely NOT gas\\n    /// efficient, but affords simple and effective debugging.\\n    /// @param stackBottom_ Pointer to the bottom of the stack.\\n    /// @param stackTop_ Pointer to the top of the stack.\\n    function debugStack(\\n        StackPointer stackBottom_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        uint256 length_ = stackBottom_.toIndex(stackTop_);\\n        debugArray(\\n            StackPointer.unwrap(stackTop_.down(length_)).copyToNewUint256Array(\\n                length_\\n            )\\n        );\\n        return stackTop_;\\n    }\\n\\n    /// Console log various aspects of the Interpreter state. Gas intensive and\\n    /// relies on hardhat console so not intended for production but great for\\n    /// debugging expressions. MAY be exposed as an opcode so expression authors\\n    /// can debug the expressions directly onchain.\\n    /// @param state_ The interpreter state to debug the internals of.\\n    /// @param stackTop_ Pointer to the current stack top.\\n    /// @param debugStyle_ Enum variant defining what should be debugged from the\\n    /// interpreter state.\\n    function debug(\\n        InterpreterState memory state_,\\n        StackPointer stackTop_,\\n        DebugStyle debugStyle_\\n    ) internal view returns (StackPointer) {\\n        if (debugStyle_ == DebugStyle.Source) {\\n            for (uint256 i_ = 0; i_ < state_.compiledSources.length; i_++) {\\n                console.logBytes(state_.compiledSources[i_]);\\n            }\\n        } else {\\n            if (debugStyle_ == DebugStyle.Stack) {\\n                state_.stackBottom.debugStack(stackTop_);\\n            } else if (debugStyle_ == DebugStyle.Constant) {\\n                debugArray(state_.constantsBottom.down().asUint256Array());\\n            } else {\\n                for (uint256 i_ = 0; i_ < state_.context.length; i_++) {\\n                    debugArray(state_.context[i_]);\\n                }\\n            }\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Efficiently serializes some `IInterpreterV1` state config into bytes that\\n    /// can be deserialized to an `InterpreterState` without memory allocation or\\n    /// copying of data on the return trip. This is achieved by mutating data in\\n    /// place for both serialization and deserialization so it is much more gas\\n    /// efficient than abi encode/decode but is NOT SAFE to use the `StateConfig`\\n    /// after it has been serialized. Notably the index based opcodes in the\\n    /// sources in `StateConfig` will be replaced by function pointer based\\n    /// opcodes in place, so are no longer usable in a portable format.\\n    /// @param config_ State config as per `IInterpreterV1`.\\n    /// @param stackLength_ Stack length calculated by `IExpressionDeployerV1`\\n    /// that will be used to allocate memory for the stack upon deserialization.\\n    /// @param opcodeFunctionPointers_ As per `IInterpreterV1.functionPointers`,\\n    /// bytes to be compiled into the final `InterpreterState.compiledSources`.\\n    function serialize(\\n        StateConfig memory config_,\\n        uint256 stackLength_,\\n        bytes memory opcodeFunctionPointers_\\n    ) internal pure returns (bytes memory) {\\n        unchecked {\\n            uint256 size_ = 0;\\n            size_ += stackLength_.size();\\n            size_ += config_.constants.size();\\n            for (uint256 i_ = 0; i_ < config_.sources.length; i_++) {\\n                size_ += config_.sources[i_].size();\\n            }\\n            bytes memory serialized_ = new bytes(size_);\\n            StackPointer cursor_ = serialized_.asStackPointer().up();\\n\\n            // Copy stack length.\\n            cursor_ = cursor_.push(stackLength_);\\n\\n            // Then the constants.\\n            cursor_ = cursor_.pushWithLength(config_.constants);\\n\\n            // Last the sources.\\n            bytes memory source_;\\n            for (uint256 i_ = 0; i_ < config_.sources.length; i_++) {\\n                source_ = config_.sources[i_];\\n                compile(source_, opcodeFunctionPointers_);\\n                cursor_ = cursor_.unalignedPushWithLength(source_);\\n            }\\n            return serialized_;\\n        }\\n    }\\n\\n    /// Return trip from `serialize` but targets an `InterpreterState` NOT a\\n    /// `StateConfig`. Allows serialized bytes to be written directly into\\n    /// contract code on the other side of an expression address, then loaded\\n    /// directly into an eval-able memory layout. The only allocation required\\n    /// is to initialise the stack for eval, there is no copying in memory from\\n    /// the serialized data as the deserialization merely calculates Solidity\\n    /// compatible pointers to positions in the raw serialized data. This is much\\n    /// more gas efficient than an equivalent abi.decode call which would involve\\n    /// more processing, copying and allocating.\\n    ///\\n    /// Note that per-eval data such as namespace and context is NOT initialised\\n    /// by the deserialization process and so will need to be handled by the\\n    /// interpreter as part of `eval`.\\n    ///\\n    /// @param serialized_ Bytes previously serialized by\\n    /// `LibInterpreterState.serialize`.\\n    /// @return An eval-able interpreter state with initialized stack.\\n    function deserialize(\\n        bytes memory serialized_\\n    ) internal pure returns (InterpreterState memory) {\\n        unchecked {\\n            InterpreterState memory state_;\\n\\n            // Context will probably be overridden by the caller according to the\\n            // context scratch that we deserialize so best to just set it empty\\n            // here.\\n            state_.context = new uint256[][](0);\\n\\n            StackPointer cursor_ = serialized_.asStackPointer().up();\\n            // The end of processing is the end of the state bytes.\\n            StackPointer end_ = cursor_.upBytes(cursor_.peek());\\n\\n            // Read the stack length and build a stack.\\n            cursor_ = cursor_.up();\\n            uint256 stackLength_ = cursor_.peek();\\n\\n            // The stack is never stored in stack bytes so we allocate a new\\n            // array for it with length as per the indexes and point the state\\n            // at it.\\n            uint256[] memory stack_ = new uint256[](stackLength_);\\n            state_.stackBottom = stack_.asStackPointerUp();\\n\\n            // Reference the constants array and move cursor past it.\\n            cursor_ = cursor_.up();\\n            state_.constantsBottom = cursor_;\\n            cursor_ = cursor_.up(cursor_.peek());\\n\\n            // Rebuild the sources array.\\n            uint256 i_ = 0;\\n            StackPointer lengthCursor_ = cursor_;\\n            uint256 sourcesLength_ = 0;\\n            while (\\n                StackPointer.unwrap(lengthCursor_) < StackPointer.unwrap(end_)\\n            ) {\\n                lengthCursor_ = lengthCursor_\\n                    .upBytes(lengthCursor_.peekUp())\\n                    .up();\\n                sourcesLength_++;\\n            }\\n            state_.compiledSources = new bytes[](sourcesLength_);\\n            while (StackPointer.unwrap(cursor_) < StackPointer.unwrap(end_)) {\\n                state_.compiledSources[i_] = cursor_.asBytes();\\n                cursor_ = cursor_.upBytes(cursor_.peekUp()).up();\\n                i_++;\\n            }\\n            return state_;\\n        }\\n    }\\n\\n    /// Given a source in opcodes compile to an equivalent source with real\\n    /// function pointers for a given Interpreter contract. The \\\"compilation\\\"\\n    /// involves simply replacing the opcode with the pointer at the index of\\n    /// the opcode. i.e. opcode 4 will be replaced with `pointers_[4]`.\\n    /// Relies heavily on the integrity checks ensuring opcodes used are not OOB\\n    /// and that the pointers provided are valid and in the correct order. As the\\n    /// expression deployer is typically handling compilation during\\n    /// serialization, NOT the interpreter, the interpreter MUST guard against\\n    /// the compilation being garbage or outright hostile during `eval` by\\n    /// pointing to arbitrary internal functions of the interpreter.\\n    /// @param source_ The input source as index based opcodes.\\n    /// @param pointers_ The function pointers ordered by index to replace the\\n    /// index based opcodes with.\\n    function compile(\\n        bytes memory source_,\\n        bytes memory pointers_\\n    ) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n                let replaceMask_ := 0xFFFF\\n                let preserveMask_ := not(replaceMask_)\\n                let sourceLength_ := mload(source_)\\n                let pointersBottom_ := add(pointers_, 2)\\n                let cursor_ := add(source_, 2)\\n                let end_ := add(source_, sourceLength_)\\n            } lt(cursor_, end_) {\\n                cursor_ := add(cursor_, 4)\\n            } {\\n                let data_ := mload(cursor_)\\n                let pointer_ := and(\\n                    replaceMask_,\\n                    mload(\\n                        add(pointersBottom_, mul(2, and(data_, replaceMask_)))\\n                    )\\n                )\\n                mstore(cursor_, or(and(data_, preserveMask_), pointer_))\\n            }\\n        }\\n    }\\n\\n    /// The main eval loop. Does as little as possible as it is an extremely hot\\n    /// performance and critical security path. Loads opcode/operand pairs from\\n    /// a precompiled source in the interpreter state and calls the function\\n    /// that the opcode points to. This function is in turn responsible for\\n    /// actually pushing/popping from the stack, etc. As `eval` receives the\\n    /// source index and stack top alongside its state, it supports recursive\\n    /// calls via. opcodes that can manage scoped substacks, etc. without `eval`\\n    /// needing to house that complexity itself.\\n    /// @param state_ The interpreter state to evaluate a source over.\\n    /// @param sourceIndex_ The index of the source to evaluate. MAY be an\\n    /// entrypoint or a nested call.\\n    /// @param stackTop_ The current stack top, MUST be equal to the stack bottom\\n    /// on the intepreter state if the current eval is for an entrypoint.\\n    function eval(\\n        InterpreterState memory state_,\\n        SourceIndex sourceIndex_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 cursor_;\\n            uint256 end_;\\n            assembly (\\\"memory-safe\\\") {\\n                cursor_ := mload(\\n                    add(\\n                        mload(add(state_, 0xA0)),\\n                        add(0x20, mul(0x20, sourceIndex_))\\n                    )\\n                )\\n                end_ := add(cursor_, mload(cursor_))\\n            }\\n\\n            // Loop until complete.\\n            while (cursor_ < end_) {\\n                function(InterpreterState memory, Operand, StackPointer)\\n                    internal\\n                    view\\n                    returns (StackPointer) fn_;\\n                Operand operand_;\\n                cursor_ += 4;\\n                {\\n                    uint256 op_;\\n                    assembly (\\\"memory-safe\\\") {\\n                        op_ := mload(cursor_)\\n                        operand_ := and(op_, 0xFFFF)\\n                        fn_ := and(shr(16, op_), 0xFFFF)\\n                    }\\n                }\\n                stackTop_ = fn_(state_, operand_, stackTop_);\\n            }\\n            return stackTop_;\\n        }\\n    }\\n\\n    /// Standard way to elevate a caller-provided state namespace to a universal\\n    /// namespace that is disjoint from all other caller-provided namespaces.\\n    /// Essentially just hashes the `msg.sender` into the state namespace as-is.\\n    ///\\n    /// This is deterministic such that the same combination of state namespace\\n    /// and caller will produce the same fully qualified namespace, even across\\n    /// multiple transactions/blocks.\\n    ///\\n    /// @param stateNamespace_ The state namespace as specified by the caller.\\n    /// @return A fully qualified namespace that cannot collide with any other\\n    /// state namespace specified by any other caller.\\n    function qualifyNamespace(\\n        StateNamespace stateNamespace_\\n    ) internal view returns (FullyQualifiedNamespace) {\\n        return\\n            FullyQualifiedNamespace.wrap(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            msg.sender,\\n                            StateNamespace.unwrap(stateNamespace_)\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xd680c532d927ae63ac71369949e3b4c847828350bac9f327a2b6d4783ff6680a\",\"license\":\"CAL\"},\"contracts/interpreter/run/LibStackPointer.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\nimport \\\"../../array/LibUint256Array.sol\\\";\\nimport \\\"../../bytes/LibBytes.sol\\\";\\n\\n/// Thrown when the length of an array as the result of an applied function does\\n/// not match expectations.\\nerror UnexpectedResultLength(uint256 expectedLength, uint256 actualLength);\\n\\n/// Custom type to point to memory ostensibly in a stack.\\ntype StackPointer is uint256;\\n\\n/// @title LibStackPointer\\n/// @notice A `StackPointer` is just a pointer to some memory. Ostensibly it is\\n/// pointing at a stack item in memory used by the `RainInterpreter` so that\\n/// means it can move \\\"up\\\" and \\\"down\\\" (increment and decrement) by `uint256`\\n/// (32 bytes) increments. Structurally a stack is a `uint256[]` but we can save\\n/// a lot of gas vs. default Solidity handling of array indexes by using assembly\\n/// to bypass runtime bounds checks on every read and write. Of course, this\\n/// means we have to introduce some mechanism that gives us equivalent guarantees\\n/// and we do, in the form of the `IExpressionDeployerV1` integrity check.\\n///\\n/// The pointer to the bottom of a stack points at the 0th item, NOT the length\\n/// of the implied `uint256[]` and the top of a stack points AFTER the last item.\\n/// e.g. consider a `uint256[]` in memory with values `3 A B C` and assume this\\n/// starts at position `0` in memory, i.e. `0` points to value `3` for the\\n/// array length. In this case the stack bottom would be\\n/// `StackPointer.wrap(0x20)` (32 bytes above 0, past the length) and the stack\\n/// top would be `StackPointer.wrap(0x80)` (96 bytes above the stack bottom).\\n///\\n/// Most of the functions in this library are equivalent to each other via\\n/// composition, i.e. everything could be achieved with just `up`, `down`,\\n/// `pop`, `push`, `peek`. The reason there is so much overloaded/duplicated\\n/// logic is that the Solidity compiler seems to fail at inlining equivalent\\n/// logic quite a lot. Perhaps once the IR compilation of Solidity is better\\n/// supported by tooling etc. we could remove a lot of this duplication as the\\n/// compiler itself would handle the optimisations.\\nlibrary LibStackPointer {\\n    using LibStackPointer for StackPointer;\\n    using LibStackPointer for uint256[];\\n    using LibStackPointer for bytes;\\n    using LibUint256Array for uint256[];\\n    using LibBytes for uint256;\\n\\n    /// Reads the value above the stack pointer. If the stack pointer is the\\n    /// current stack top this is an out of bounds read! The caller MUST ensure\\n    /// that this is not the case and that the stack pointer being read is within\\n    /// the stack and not after it.\\n    /// @param stackPointer_ Position to read past/above.\\n    function peekUp(\\n        StackPointer stackPointer_\\n    ) internal pure returns (uint256) {\\n        uint256 a_;\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(stackPointer_)\\n        }\\n        return a_;\\n    }\\n\\n    /// Read the value immediately below the given stack pointer. Equivalent to\\n    /// calling `pop` and discarding the `stackPointerAfter_` value, so may be\\n    /// less gas than setting and discarding a value.\\n    /// @param stackPointer_ The stack pointer to read below.\\n    /// @return a_ The value that was read.\\n    function peek(StackPointer stackPointer_) internal pure returns (uint256) {\\n        uint256 a_;\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(sub(stackPointer_, 0x20))\\n        }\\n        return a_;\\n    }\\n\\n    /// Reads 2 values below the given stack pointer.\\n    /// The following statements are equivalent but A may use gas if the\\n    /// compiler fails to inline some function calls.\\n    /// A:\\n    /// ```\\n    /// (uint256 a_, uint256 b_) = stackPointer_.peek2();\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// uint256 b_;\\n    /// (stackPointer_, b_) = stackPointer_.pop();\\n    /// uint256 a_ = stackPointer_.peek();\\n    /// ```\\n    /// @param stackPointer_ The stack top to peek below.\\n    function peek2(\\n        StackPointer stackPointer_\\n    ) internal pure returns (uint256, uint256) {\\n        uint256 a_;\\n        uint256 b_;\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(sub(stackPointer_, 0x40))\\n            b_ := mload(sub(stackPointer_, 0x20))\\n        }\\n        return (a_, b_);\\n    }\\n\\n    /// Read the value immediately below the given stack pointer and return the\\n    /// stack pointer that points to the value that was read alongside the value.\\n    /// The following are equivalent but A may be cheaper if the compiler\\n    /// fails to inline some function calls:\\n    /// A:\\n    /// ```\\n    /// uint256 a_;\\n    /// (stackPointer_, a_) = stackPointer_.pop();\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackPointer_ = stackPointer_.down();\\n    /// uint256 a_ = stackPointer_.peekUp();\\n    /// ```\\n    /// @param stackPointer_ The stack pointer to read below.\\n    /// @return stackPointerAfter_ Points to the value that was read.\\n    /// @return a_ The value that was read.\\n    function pop(\\n        StackPointer stackPointer_\\n    ) internal pure returns (StackPointer, uint256) {\\n        StackPointer stackPointerAfter_;\\n        uint256 a_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointerAfter_ := sub(stackPointer_, 0x20)\\n            a_ := mload(stackPointerAfter_)\\n        }\\n        return (stackPointerAfter_, a_);\\n    }\\n\\n    /// Given two stack pointers that bound a stack build an array of all values\\n    /// above the given sentinel value. The sentinel will be _replaced_ by the\\n    /// length of the array, allowing for efficient construction of a valid\\n    /// `uint256[]` without additional allocation or copying in memory. As the\\n    /// returned value is a `uint256[]` it can be treated as a substack and the\\n    /// same (or different) sentinel can be consumed many times to build many\\n    /// arrays from the main stack.\\n    ///\\n    /// As the sentinel is mutated in place into a length it is NOT safe to call\\n    /// this in a context where the stack is expected to be immutable.\\n    ///\\n    /// The sentinel MUST be chosen to have a negligible chance of colliding with\\n    /// a real value in the array, otherwise an intended array item will be\\n    /// interpreted as a sentinel and the array will be split into two slices.\\n    ///\\n    /// If the sentinel is absent in the stack this WILL REVERT. The intent is\\n    /// to represent dynamic length arrays without forcing expression authors to\\n    /// calculate lengths on the stack. If the expression author wants to model\\n    /// an empty/optional/absent value they MAY provided a sentinel for a zero\\n    /// length array and the calling contract SHOULD handle this.\\n    ///\\n    /// @param stackTop_ Pointer to the top of the stack.\\n    /// @param stackBottom_ Pointer to the bottom of the stack.\\n    /// @param sentinel_ The value to expect as the sentinel. MUST be present in\\n    /// the stack or `consumeSentinel` will revert. MUST NOT collide with valid\\n    /// stack items (or be cryptographically improbable to do so).\\n    /// @param stepSize_ Number of items to move over in the array per loop\\n    /// iteration. If the array has a known multiple of items it can be more\\n    /// efficient to find a sentinel moving in N-item increments rather than\\n    /// reading every item individually.\\n    function consumeSentinel(\\n        StackPointer stackTop_,\\n        StackPointer stackBottom_,\\n        uint256 sentinel_,\\n        uint256 stepSize_\\n    ) internal pure returns (StackPointer, uint256[] memory) {\\n        uint256[] memory array_;\\n        assembly (\\\"memory-safe\\\") {\\n            // Underflow is not allowed and pointing at position 0 in memory is\\n            // corrupt behaviour anyway.\\n            if iszero(stackBottom_) {\\n                revert(0, 0)\\n            }\\n            let sentinelLocation_ := 0\\n            let length_ := 0\\n            let step_ := mul(stepSize_, 0x20)\\n            for {\\n                stackTop_ := sub(stackTop_, 0x20)\\n                let end_ := sub(stackBottom_, 0x20)\\n            } gt(stackTop_, end_) {\\n                stackTop_ := sub(stackTop_, step_)\\n                length_ := add(length_, stepSize_)\\n            } {\\n                if eq(sentinel_, mload(stackTop_)) {\\n                    sentinelLocation_ := stackTop_\\n                    break\\n                }\\n            }\\n            // Sentinel MUST exist in the stack if consumer expects it to there.\\n            if iszero(sentinelLocation_) {\\n                revert(0, 0)\\n            }\\n            mstore(sentinelLocation_, length_)\\n            array_ := sentinelLocation_\\n        }\\n        return (stackTop_, array_);\\n    }\\n\\n    /// Abstraction over `consumeSentinel` to build an array of solidity structs.\\n    /// Solidity won't exactly allow this due to its type system not supporting\\n    /// generics, so instead we return an array of references to struct data that\\n    /// can be assigned/cast to an array of structs easily with assembly. This\\n    /// is NOT intended to be a general purpose workhorse for this task, only\\n    /// structs of pointers to `uint256[]` values are supported.\\n    ///\\n    /// ```\\n    /// struct Foo {\\n    ///   uint256[] a;\\n    ///   uint256[] b;\\n    /// }\\n    ///\\n    /// (StackPointer stackPointer_, uint256[] memory refs_) = consumeStructs(...);\\n    /// Foo[] memory foo_;\\n    /// assembly (\\\"memory-safe\\\") {\\n    ///   mstore(foo_, refs_)\\n    /// }\\n    /// ```\\n    ///\\n    /// @param stackTop_ The top of the stack as per `consumeSentinel`.\\n    /// @param stackBottom_ The bottom of the stack as per `consumeSentinel`.\\n    /// @param sentinel_ The sentinel as per `consumeSentinel`.\\n    /// @param structSize_ The number of `uint256[]` fields on the struct.\\n    function consumeStructs(\\n        StackPointer stackTop_,\\n        StackPointer stackBottom_,\\n        uint256 sentinel_,\\n        uint256 structSize_\\n    ) internal pure returns (StackPointer, uint256[] memory) {\\n        (StackPointer stackTopAfter_, uint256[] memory tempArray_) = stackTop_\\n            .consumeSentinel(stackBottom_, sentinel_, structSize_);\\n        uint256 structsLength_ = tempArray_.length / structSize_;\\n        uint256[] memory refs_ = new uint256[](structsLength_);\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n                let refCursor_ := add(refs_, 0x20)\\n                let refEnd_ := add(refCursor_, mul(structsLength_, 0x20))\\n                let tempCursor_ := add(tempArray_, 0x20)\\n                let tempStepSize_ := mul(structSize_, 0x20)\\n            } lt(refCursor_, refEnd_) {\\n                refCursor_ := add(refCursor_, 0x20)\\n                tempCursor_ := add(tempCursor_, tempStepSize_)\\n            } {\\n                mstore(refCursor_, tempCursor_)\\n            }\\n        }\\n        return (stackTopAfter_, refs_);\\n    }\\n\\n    /// Write a value at the stack pointer. Typically only useful as intermediate\\n    /// logic within some opcode etc. as the value will be treated as an out of\\n    /// bounds for future reads unless the stack top after the opcode logic is\\n    /// above the pointer.\\n    /// @param stackPointer_ The stack top to write the value at.\\n    /// @param a_ The value to write.\\n    function set(StackPointer stackPointer_, uint256 a_) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackPointer_, a_)\\n        }\\n    }\\n\\n    /// Store a `uint256` at the stack pointer and return the stack pointer\\n    /// above the written value. The following statements are equivalent in\\n    /// functionality but A may be less gas if the compiler fails to inline\\n    /// some function calls.\\n    /// A:\\n    /// ```\\n    /// stackPointer_ = stackPointer_.push(a_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackPointer_.set(a_);\\n    /// stackPointer_ = stackPointer_.up();\\n    /// ```\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param a_ The value to write.\\n    /// @return The stack pointer above where `a_` was written to.\\n    function push(\\n        StackPointer stackPointer_,\\n        uint256 a_\\n    ) internal pure returns (StackPointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackPointer_, a_)\\n            stackPointer_ := add(stackPointer_, 0x20)\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Store a `uint256[]` at the stack pointer and return the stack pointer\\n    /// above the written values. The length of the array is NOT written to the\\n    /// stack, ONLY the array values are copied to the stack. The following\\n    /// statements are equivalent in functionality but A may be less gas if the\\n    /// compiler fails to inline some function calls.\\n    /// A:\\n    /// ```\\n    /// stackPointer_ = stackPointer_.push(array_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// unchecked {\\n    ///   for (uint256 i_ = 0; i_ < array_.length; i_++) {\\n    ///     stackPointer_ = stackPointer_.push(array_[i_]);\\n    ///   }\\n    /// }\\n    /// ```\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param array_ The array of values to write.\\n    /// @return The stack pointer above the array.\\n    function push(\\n        StackPointer stackPointer_,\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        array_.unsafeCopyValuesTo(StackPointer.unwrap(stackPointer_));\\n        return stackPointer_.up(array_.length);\\n    }\\n\\n    /// Store a `uint256[]` at the stack pointer and return the stack pointer\\n    /// above the written values. The length of the array IS written to the\\n    /// stack.\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param array_ The array of values and length to write.\\n    /// @return The stack pointer above the array.\\n    function pushWithLength(\\n        StackPointer stackPointer_,\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        return stackPointer_.push(array_.length).push(array_);\\n    }\\n\\n    /// Store `bytes` at the stack pointer and return the stack pointer above\\n    /// the written bytes. The length of the bytes is NOT written to the stack,\\n    /// ONLY the bytes are written. As `bytes` may be of arbitrary length, i.e.\\n    /// it MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\\n    /// ensure that this is safe in context of subsequent reads and writes.\\n    /// @param stackPointer_ The stack top to write at.\\n    /// @param bytes_ The bytes to write at the stack top.\\n    /// @return The stack top above the written bytes.\\n    function unalignedPush(\\n        StackPointer stackPointer_,\\n        bytes memory bytes_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer.unwrap(bytes_.asStackPointer().up()).unsafeCopyBytesTo(\\n            StackPointer.unwrap(stackPointer_),\\n            bytes_.length\\n        );\\n        return stackPointer_.upBytes(bytes_.length);\\n    }\\n\\n    /// Store `bytes` at the stack pointer and return the stack top above the\\n    /// written bytes. The length of the bytes IS written to the stack in\\n    /// addition to the bytes. As `bytes` may be of arbitrary length, i.e. it\\n    /// MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\\n    /// ensure that this is safe in context of subsequent reads and writes.\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param bytes_ The bytes to write with their length at the stack pointer.\\n    /// @return The stack pointer above the written bytes.\\n    function unalignedPushWithLength(\\n        StackPointer stackPointer_,\\n        bytes memory bytes_\\n    ) internal pure returns (StackPointer) {\\n        return stackPointer_.push(bytes_.length).unalignedPush(bytes_);\\n    }\\n\\n    /// Store 8x `uint256` at the stack pointer and return the stack pointer\\n    /// above the written value. The following statements are equivalent in\\n    /// functionality but A may be cheaper if the compiler fails to\\n    /// inline some function calls.\\n    /// A:\\n    /// ```\\n    /// stackPointer_ = stackPointer_.push(a_, b_, c_, d_, e_, f_, g_, h_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackPointer_ = stackPointer_\\n    ///   .push(a_)\\n    ///   .push(b_)\\n    ///   .push(c_)\\n    ///   .push(d_)\\n    ///   .push(e_)\\n    ///   .push(f_)\\n    ///   .push(g_)\\n    ///   .push(h_);\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param a_ The first value to write.\\n    /// @param b_ The second value to write.\\n    /// @param c_ The third value to write.\\n    /// @param d_ The fourth value to write.\\n    /// @param e_ The fifth value to write.\\n    /// @param f_ The sixth value to write.\\n    /// @param g_ The seventh value to write.\\n    /// @param h_ The eighth value to write.\\n    /// @return The stack pointer above where `h_` was written.\\n    function push(\\n        StackPointer stackPointer_,\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_,\\n        uint256 e_,\\n        uint256 f_,\\n        uint256 g_,\\n        uint256 h_\\n    ) internal pure returns (StackPointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackPointer_, a_)\\n            mstore(add(stackPointer_, 0x20), b_)\\n            mstore(add(stackPointer_, 0x40), c_)\\n            mstore(add(stackPointer_, 0x60), d_)\\n            mstore(add(stackPointer_, 0x80), e_)\\n            mstore(add(stackPointer_, 0xA0), f_)\\n            mstore(add(stackPointer_, 0xC0), g_)\\n            mstore(add(stackPointer_, 0xE0), h_)\\n            stackPointer_ := add(stackPointer_, 0x100)\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        a_ = fn_(a_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(Operand, uint256) internal view returns (uint256) fn_,\\n        Operand operand_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        a_ = fn_(operand_, a_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x20)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n        }\\n        a_ = fn_(a_, b_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Reduce a function N times, reading and writing inputs and the accumulated\\n    /// result on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param n_ The number of times to apply fn_ to accumulate a final result.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFnN(\\n        StackPointer stackTop_,\\n        function(uint256, uint256) internal view returns (uint256) fn_,\\n        uint256 n_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 bottom_;\\n            uint256 cursor_;\\n            uint256 a_;\\n            uint256 b_;\\n            StackPointer stackTopAfter_;\\n            assembly (\\\"memory-safe\\\") {\\n                bottom_ := sub(stackTop_, mul(n_, 0x20))\\n                a_ := mload(bottom_)\\n                stackTopAfter_ := add(bottom_, 0x20)\\n                cursor_ := stackTopAfter_\\n            }\\n            while (cursor_ < StackPointer.unwrap(stackTop_)) {\\n                assembly (\\\"memory-safe\\\") {\\n                    b_ := mload(cursor_)\\n                }\\n                a_ = fn_(a_, b_);\\n                cursor_ += 0x20;\\n            }\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(bottom_, a_)\\n            }\\n            return stackTopAfter_;\\n        }\\n    }\\n\\n    /// Reduce a function N times, reading and writing inputs and the accumulated\\n    /// result on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param n_ The number of times to apply fn_ to accumulate a final result.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFnN(\\n        StackPointer stackTop_,\\n        function(uint256) internal view fn_,\\n        uint256 n_\\n    ) internal view returns (StackPointer) {\\n        uint256 cursor_;\\n        uint256 a_;\\n        StackPointer stackTopAfter_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTopAfter_ := sub(stackTop_, mul(n_, 0x20))\\n            cursor_ := stackTopAfter_\\n        }\\n        while (cursor_ < StackPointer.unwrap(stackTop_)) {\\n            assembly (\\\"memory-safe\\\") {\\n                a_ := mload(cursor_)\\n                cursor_ := add(cursor_, 0x20)\\n            }\\n            fn_(a_);\\n        }\\n        return stackTopAfter_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 c_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x40)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n            c_ := mload(add(stackTop_, 0x20))\\n        }\\n        a_ = fn_(a_, b_, c_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256, uint256)\\n            internal\\n            view\\n            returns (uint256) fn_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 c_;\\n        uint256 d_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x60)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n            c_ := mload(add(stackTop_, 0x20))\\n            d_ := mload(add(stackTop_, 0x40))\\n        }\\n        a_ = fn_(a_, b_, c_, d_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param operand_ Operand is passed from the source instead of the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(Operand, uint256, uint256) internal view returns (uint256) fn_,\\n        Operand operand_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x20)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n        }\\n        a_ = fn_(operand_, a_, b_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the array to pass to fn_ from the stack.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256[] memory) internal view returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        (uint256 a_, uint256[] memory tail_) = stackTop_.list(length_);\\n        uint256 b_ = fn_(tail_);\\n        return tail_.asStackPointer().push(a_).push(b_);\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the array to pass to fn_ from the stack.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        (uint256 b_, uint256[] memory tail_) = stackTop_.list(length_);\\n        StackPointer stackTopAfter_ = tail_.asStackPointer();\\n        (StackPointer location_, uint256 a_) = stackTopAfter_.pop();\\n        location_.set(fn_(a_, b_, tail_));\\n        return stackTopAfter_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the array to pass to fn_ from the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        (uint256 c_, uint256[] memory tail_) = stackTop_.list(length_);\\n        (StackPointer stackTopAfter_, uint256 b_) = tail_\\n            .asStackPointer()\\n            .pop();\\n        uint256 a_ = stackTopAfter_.peek();\\n        stackTopAfter_.down().set(fn_(a_, b_, c_, tail_));\\n        return stackTopAfter_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the arrays to pass to fn_ from the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256[] memory, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256[] memory) fn_,\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        StackPointer csStart_ = stackTop_.down(length_);\\n        uint256[] memory cs_ = LibUint256Array.copyToNewUint256Array(\\n            StackPointer.unwrap(csStart_),\\n            length_\\n        );\\n        (uint256 a_, uint256[] memory bs_) = csStart_.list(length_);\\n\\n        uint256[] memory results_ = fn_(a_, bs_, cs_);\\n        if (results_.length != length_) {\\n            revert UnexpectedResultLength(length_, results_.length);\\n        }\\n\\n        StackPointer bottom_ = bs_.asStackPointer();\\n        LibUint256Array.unsafeCopyValuesTo(\\n            results_,\\n            StackPointer.unwrap(bottom_)\\n        );\\n        return bottom_.up(length_);\\n    }\\n\\n    /// Returns `length_` values from the stack as an array without allocating\\n    /// new memory. As arrays always start with their length, this requires\\n    /// writing the length value to the stack below the array values. The value\\n    /// that is overwritten in the process is also returned so that data is not\\n    /// lost. For example, imagine a stack `[ A B C D ]` and we list 2 values.\\n    /// This will write the stack to look like `[ A 2 C D ]` and return both `B`\\n    /// and a pointer to `2` represented as a `uint256[]`.\\n    /// The returned array is ONLY valid for as long as the stack DOES NOT move\\n    /// back into its memory. As soon as the stack moves up again and writes into\\n    /// the array it will be corrupt. The caller MUST ensure that it does not\\n    /// read from the returned array after it has been corrupted by subsequent\\n    /// stack writes.\\n    /// @param stackPointer_ The stack pointer to read the values below into an\\n    /// array.\\n    /// @param length_ The number of values to include in the returned array.\\n    /// @return head_ The value that was overwritten with the length.\\n    /// @return tail_ The array constructed from the stack memory.\\n    function list(\\n        StackPointer stackPointer_,\\n        uint256 length_\\n    ) internal pure returns (uint256, uint256[] memory) {\\n        uint256 head_;\\n        uint256[] memory tail_;\\n        assembly (\\\"memory-safe\\\") {\\n            tail_ := sub(stackPointer_, add(0x20, mul(length_, 0x20)))\\n            head_ := mload(tail_)\\n            mstore(tail_, length_)\\n        }\\n        return (head_, tail_);\\n    }\\n\\n    /// Cast a `uint256[]` array to a stack pointer. The stack pointer will\\n    /// point to the length of the array, NOT its first value.\\n    /// @param array_ The array to cast to a stack pointer.\\n    /// @return stackPointer_ The stack pointer that points to the length of the\\n    /// array.\\n    function asStackPointer(\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer stackPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointer_ := array_\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Cast a stack pointer to an array. The value immediately above the stack\\n    /// pointer will be treated as the length of the array, so the proceeding\\n    /// length values will be the items of the array. The caller MUST ensure the\\n    /// values above the stack position constitute a valid array. The returned\\n    /// array will be corrupt if/when the stack subsequently moves into it and\\n    /// writes to those memory locations. The caller MUST ensure that it does\\n    /// NOT read from the returned array after the stack writes over it.\\n    /// @param stackPointer_ The stack pointer that will be cast to an array.\\n    /// @return array_ The array above the stack pointer.\\n    function asUint256Array(\\n        StackPointer stackPointer_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_;\\n        assembly (\\\"memory-safe\\\") {\\n            array_ := stackPointer_\\n        }\\n        return array_;\\n    }\\n\\n    /// Cast a stack position to bytes. The value immediately above the stack\\n    /// position will be treated as the length of the `bytes`, so the proceeding\\n    /// length bytes will be the data of the `bytes`. The caller MUST ensure the\\n    /// length and bytes above the stack top constitute valid `bytes` data. The\\n    /// returned `bytes` will be corrupt if/when the stack subsequently moves\\n    /// into it and writes to those memory locations. The caller MUST ensure\\n    // that it does NOT read from the returned bytes after the stack writes over\\n    /// it.\\n    /// @param stackPointer_ The stack pointer that will be cast to bytes.\\n    /// @return bytes_ The bytes above the stack top.\\n    function asBytes(\\n        StackPointer stackPointer_\\n    ) internal pure returns (bytes memory) {\\n        bytes memory bytes_;\\n        assembly (\\\"memory-safe\\\") {\\n            bytes_ := stackPointer_\\n        }\\n        return bytes_;\\n    }\\n\\n    /// Cast a `uint256[]` array to a stack pointer after its length. The stack\\n    /// pointer will point to the first item of the array, NOT its length.\\n    /// @param array_ The array to cast to a stack pointer.\\n    /// @return stackPointer_ The stack pointer that points to the first item of\\n    /// the array.\\n    function asStackPointerUp(\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer stackPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointer_ := add(array_, 0x20)\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Cast a `uint256[]` array to a stack pointer after its items. The stack\\n    /// pointer will point after the last item of the array. It is out of bounds\\n    /// to read above the returned pointer. This can be interpreted as the stack\\n    /// top assuming the entire given array is a valid stack.\\n    /// @param array_ The array to cast to a stack pointer.\\n    /// @return stackPointer_ The stack pointer that points after the last item\\n    /// of the array.\\n    function asStackPointerAfter(\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer stackPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointer_ := add(array_, add(0x20, mul(mload(array_), 0x20)))\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Cast `bytes` to a stack pointer. The stack pointer will point to the\\n    /// length of the `bytes`, NOT the first byte.\\n    /// @param bytes_ The `bytes` to cast to a stack pointer.\\n    /// @return stackPointer_ The stack top that points to the length of the\\n    /// bytes.\\n    function asStackPointer(\\n        bytes memory bytes_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer stackPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointer_ := bytes_\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Returns the stack pointer 32 bytes above/past the given stack pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @return The stack pointer 32 bytes above the input stack pointer.\\n    function up(\\n        StackPointer stackPointer_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return StackPointer.wrap(StackPointer.unwrap(stackPointer_) + 0x20);\\n        }\\n    }\\n\\n    /// Returns the stack pointer `n_ * 32` bytes above/past the given stack\\n    /// pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @param n_ The multiplier on the stack movement. MAY be zero.\\n    /// @return The stack pointer `n_ * 32` bytes above/past the input stack\\n    /// pointer.\\n    function up(\\n        StackPointer stackPointer_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return\\n                StackPointer.wrap(\\n                    StackPointer.unwrap(stackPointer_) + 0x20 * n_\\n                );\\n        }\\n    }\\n\\n    /// Returns the stack pointer `n_` bytes above/past the given stack pointer.\\n    /// The returned stack pointer MAY NOT be aligned with the given stack\\n    /// pointer for subsequent 32 byte reads and writes. The caller MUST ensure\\n    /// that it is safe to read and write data relative to the returned stack\\n    /// pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @param n_ The number of bytes to move.\\n    /// @return The stack pointer `n_` bytes above/past the given stack pointer.\\n    function upBytes(\\n        StackPointer stackPointer_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return StackPointer.wrap(StackPointer.unwrap(stackPointer_) + n_);\\n        }\\n    }\\n\\n    /// Returns the stack pointer 32 bytes below/before the given stack pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @return The stack pointer 32 bytes below/before the given stack pointer.\\n    function down(\\n        StackPointer stackPointer_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return StackPointer.wrap(StackPointer.unwrap(stackPointer_) - 0x20);\\n        }\\n    }\\n\\n    /// Returns the stack pointer `n_ * 32` bytes below/before the given stack\\n    /// pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @param n_ The multiplier on the movement.\\n    /// @return The stack pointer `n_ * 32` bytes below/before the given stack\\n    /// pointer.\\n    function down(\\n        StackPointer stackPointer_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return\\n                StackPointer.wrap(\\n                    StackPointer.unwrap(stackPointer_) - 0x20 * n_\\n                );\\n        }\\n    }\\n\\n    /// Convert two stack pointer values to a single stack index. A stack index\\n    /// is the distance in 32 byte increments between two stack pointers. The\\n    /// calculations assumes the two stack pointers are aligned. The caller MUST\\n    /// ensure the alignment of both values. The calculation is unchecked and MAY\\n    /// underflow. The caller MUST ensure that the stack top is always above the\\n    /// stack bottom.\\n    /// @param stackBottom_ The lower of the two values.\\n    /// @param stackTop_ The higher of the two values.\\n    /// @return The stack index as 32 byte distance between the top and bottom.\\n    function toIndex(\\n        StackPointer stackBottom_,\\n        StackPointer stackTop_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            return\\n                (StackPointer.unwrap(stackTop_) -\\n                    StackPointer.unwrap(stackBottom_)) / 0x20;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe9c7ce66b490126433ff8e1cf52c92ea78eb2a4e93c88e20c2f6fd8a716b1e96\",\"license\":\"CAL\"},\"contracts/kv/LibMemoryKV.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../math/Binary.sol\\\";\\n\\n/// Thrown when attempting to read a value from the other side of a zero pointer.\\nerror InvalidPtr(MemoryKVPtr ptr);\\n\\n/// Entrypoint into the key/value store. Is a mutable pointer to the head of the\\n/// linked list. Initially points to `0` for an empty list. The total length of\\n/// the linked list is also encoded alongside the pointer to allow efficient O(1)\\n/// memory allocation for a `uint256[]` in the case of a final snapshot/export.\\ntype MemoryKV is uint256;\\n/// The key associated with the value for each item in the linked list.\\ntype MemoryKVKey is uint256;\\n/// The pointer to the next item in the list. `0` signifies the end of the list.\\ntype MemoryKVPtr is uint256;\\n/// The value associated with the key for each item in the linked list.\\ntype MemoryKVVal is uint256;\\n\\n/// @title LibMemoryKV\\n/// @notice Implements an in-memory key/value store in terms of a linked list\\n/// that can be snapshotted/exported to a `uint256[]` of pairwise keys/values as\\n/// its items. Ostensibly supports reading/writing to storage within a read only\\n/// context in an interpreter `eval` by tracking changes requested by an\\n/// expression in memory as a cache-like structure over the underlying storage.\\n///\\n/// A linked list is required because unlike stack movements we do NOT have any\\n/// way to precalculate how many items will be included in the final set at\\n/// deploy time. Any two writes may share the same key known only at runtime, so\\n/// any two writes may result in either 2 or 1 insertions (and 0 or 1 updates).\\n/// We could attempt to solve this by allowing duplicate keys and simply append\\n/// values for each write, so two writes will always insert 2 values, but then\\n/// looping constructs such as `OpDoWhile` and `OpFoldContext` with net 0 stack\\n/// movements (i.e. predictably deallocateable memory) can still cause\\n/// unbounded/unknown inserts for our state changes. The linked list allows us\\n/// to both dedupe same-key writes and also safely handle an unknown\\n/// (at deploy time) number of upserts. New items are inserted at the head of\\n/// the list and a pointer to `0` is the sentinel that defines the end of the\\n/// list. It is an error to dereference the `0` pointer.\\n///\\n/// Currently implemented as O(n) where n is likely relatively small, in future\\n/// could be reimplemented as 8 linked lists over a single `MemoryKV` by packing\\n/// many `MemoryKVPtr` and using `%` to distribute keys between lists. The\\n/// extremely high gas cost of writing to storage itself should be a natural\\n/// disincentive for n getting large enough to cause the linked list traversal\\n/// to be a significant gas cost itself.\\n///\\n/// Currently implemented in terms of raw `uint256` custom types that represent\\n/// keys, values and pointers. Could be reimplemented in terms of an equivalent\\n/// struct with key, value and pointer fields.\\nlibrary LibMemoryKV {\\n    /// Reads the `MemoryKVVal` that some `MemoryKVPtr` is pointing to. It is an\\n    /// error to call this if `ptr_` is `0`.\\n    /// @param ptr_ The pointer to read the value\\n    function readPtrVal(\\n        MemoryKVPtr ptr_\\n    ) internal pure returns (MemoryKVVal v_) {\\n        // This is ALWAYS a bug. It means the caller did not check if the ptr is\\n        // nonzero before trying to read from it.\\n        if (MemoryKVPtr.unwrap(ptr_) == 0) {\\n            revert InvalidPtr(ptr_);\\n        }\\n\\n        assembly (\\\"memory-safe\\\") {\\n            v_ := mload(add(ptr_, 0x20))\\n        }\\n    }\\n\\n    /// Finds the pointer to the item that holds the value associated with the\\n    /// given key. Walks the linked list from the entrypoint into the key/value\\n    /// store until it finds the specified key. As the last pointer in the list\\n    /// is always `0`, `0` is what will be returned if the key is not found. Any\\n    /// non-zero pointer implies the value it points to is for the provided key.\\n    /// @param kv_ The entrypoint to the key/value store.\\n    /// @param k_ The key to lookup a pointer for.\\n    /// @return ptr_ The _pointer_ to the value for the key, if it exists, else\\n    /// a pointer to `0`. If the pointer is non-zero the associated value can be\\n    /// read to a `MemoryKVVal` with `LibMemoryKV.readPtrVal`.\\n    function getPtr(\\n        MemoryKV kv_,\\n        MemoryKVKey k_\\n    ) internal pure returns (MemoryKVPtr ptr_) {\\n        uint256 mask_ = MASK_16BIT;\\n        assembly (\\\"memory-safe\\\") {\\n            // loop until k found or give up if ptr is zero\\n            for {\\n                ptr_ := and(kv_, mask_)\\n            } iszero(iszero(ptr_)) {\\n                ptr_ := mload(add(ptr_, 0x40))\\n            } {\\n                if eq(k_, mload(ptr_)) {\\n                    break\\n                }\\n            }\\n        }\\n    }\\n\\n    /// Upserts a value in the set by its key. I.e. if the key exists then the\\n    /// associated value will be mutated in place, else a new key/value pair will\\n    /// be inserted. The key/value store pointer will be mutated and returned as\\n    /// it MAY point to a new list item in memory.\\n    /// @param kv_ The key/value store pointer to modify.\\n    /// @param k_ The key to upsert against.\\n    /// @param v_ The value to associate with the upserted key.\\n    /// @return The final value of `kv_` as it MAY be modified if the upsert\\n    /// resulted in an insert operation.\\n    function setVal(\\n        MemoryKV kv_,\\n        MemoryKVKey k_,\\n        MemoryKVVal v_\\n    ) internal pure returns (MemoryKV) {\\n        MemoryKVPtr ptr_ = getPtr(kv_, k_);\\n        uint256 mask_ = MASK_16BIT;\\n        // update\\n        if (MemoryKVPtr.unwrap(ptr_) > 0) {\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(add(ptr_, 0x20), v_)\\n            }\\n        }\\n        // insert\\n        else {\\n            assembly (\\\"memory-safe\\\") {\\n                // allocate new memory\\n                ptr_ := mload(0x40)\\n                mstore(0x40, add(ptr_, 0x60))\\n                // set k/v/ptr\\n                mstore(ptr_, k_)\\n                mstore(add(ptr_, 0x20), v_)\\n                mstore(add(ptr_, 0x40), and(kv_, mask_))\\n                // kv must point to new insertion and update array len\\n                kv_ := or(\\n                    // inc len by 2\\n                    shl(16, add(shr(16, kv_), 2)),\\n                    // set ptr\\n                    ptr_\\n                )\\n            }\\n        }\\n        return kv_;\\n    }\\n\\n    /// Export/snapshot the underlying linked list of the key/value store into\\n    /// a standard `uint256[]`. Reads the total length to preallocate the\\n    /// `uint256[]` then walks the entire linked list, copying every key and\\n    /// value into the array, until it reaches a pointer to `0`. Note this is a\\n    /// one time export, if the key/value store is subsequently mutated the built\\n    /// array will not reflect these mutations.\\n    /// @param kv_ The entrypoint into the key/value store.\\n    /// @return All the keys and values copied pairwise into a `uint256[]`.\\n    function toUint256Array(\\n        MemoryKV kv_\\n    ) internal pure returns (uint256[] memory) {\\n        unchecked {\\n            uint256 ptr_ = MemoryKV.unwrap(kv_) & MASK_16BIT;\\n            uint256 length_ = MemoryKV.unwrap(kv_) >> 16;\\n            uint256[] memory arr_ = new uint256[](length_);\\n            assembly (\\\"memory-safe\\\") {\\n                for {\\n                    let cursor_ := add(arr_, 0x20)\\n                    let end_ := add(cursor_, mul(mload(arr_), 0x20))\\n                } lt(cursor_, end_) {\\n                    cursor_ := add(cursor_, 0x20)\\n                    ptr_ := mload(add(ptr_, 0x40))\\n                } {\\n                    // key\\n                    mstore(cursor_, mload(ptr_))\\n                    cursor_ := add(cursor_, 0x20)\\n                    // value\\n                    mstore(cursor_, mload(add(ptr_, 0x20)))\\n                }\\n            }\\n            return arr_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbf745ef2a8e5918ff93548a431296811dded10b727bfadbfcc35c6f742cba91a\",\"license\":\"CAL\"},\"contracts/math/Binary.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// @dev Binary 1.\\nuint256 constant B_1 = 2 ** 1 - 1;\\n/// @dev Binary 11.\\nuint256 constant B_11 = 2 ** 2 - 1;\\n/// @dev Binary 111.\\nuint256 constant B_111 = 2 ** 3 - 1;\\n/// @dev Binary 1111.\\nuint256 constant B_1111 = 2 ** 4 - 1;\\n/// @dev Binary 11111.\\nuint256 constant B_11111 = 2 ** 5 - 1;\\n/// @dev Binary 111111.\\nuint256 constant B_111111 = 2 ** 6 - 1;\\n/// @dev Binary 1111111.\\nuint256 constant B_1111111 = 2 ** 7 - 1;\\n/// @dev Binary 11111111.\\nuint256 constant B_11111111 = 2 ** 8 - 1;\\n/// @dev Binary 111111111.\\nuint256 constant B_111111111 = 2 ** 9 - 1;\\n/// @dev Binary 1111111111.\\nuint256 constant B_1111111111 = 2 ** 10 - 1;\\n/// @dev Binary 11111111111.\\nuint256 constant B_11111111111 = 2 ** 11 - 1;\\n/// @dev Binary 111111111111.\\nuint256 constant B_111111111111 = 2 ** 12 - 1;\\n/// @dev Binary 1111111111111.\\nuint256 constant B_1111111111111 = 2 ** 13 - 1;\\n/// @dev Binary 11111111111111.\\nuint256 constant B_11111111111111 = 2 ** 14 - 1;\\n/// @dev Binary 111111111111111.\\nuint256 constant B_111111111111111 = 2 ** 15 - 1;\\n/// @dev Binary 1111111111111111.\\nuint256 constant B_1111111111111111 = 2 ** 16 - 1;\\n\\n/// @dev Bitmask for 1 bit.\\nuint256 constant MASK_1BIT = B_1;\\n/// @dev Bitmask for 2 bits.\\nuint256 constant MASK_2BIT = B_11;\\n/// @dev Bitmask for 3 bits.\\nuint256 constant MASK_3BIT = B_111;\\n/// @dev Bitmask for 4 bits.\\nuint256 constant MASK_4BIT = B_1111;\\n/// @dev Bitmask for 5 bits.\\nuint256 constant MASK_5BIT = B_11111;\\n/// @dev Bitmask for 6 bits.\\nuint256 constant MASK_6BIT = B_111111;\\n/// @dev Bitmask for 7 bits.\\nuint256 constant MASK_7BIT = B_1111111;\\n/// @dev Bitmask for 8 bits.\\nuint256 constant MASK_8BIT = B_11111111;\\n/// @dev Bitmask for 9 bits.\\nuint256 constant MASK_9BIT = B_111111111;\\n/// @dev Bitmask for 10 bits.\\nuint256 constant MASK_10BIT = B_1111111111;\\n/// @dev Bitmask for 11 bits.\\nuint256 constant MASK_11BIT = B_11111111111;\\n/// @dev Bitmask for 12 bits.\\nuint256 constant MASK_12BIT = B_111111111111;\\n/// @dev Bitmask for 13 bits.\\nuint256 constant MASK_13BIT = B_1111111111111;\\n/// @dev Bitmask for 14 bits.\\nuint256 constant MASK_14BIT = B_11111111111111;\\n/// @dev Bitmask for 15 bits.\\nuint256 constant MASK_15BIT = B_111111111111111;\\n/// @dev Bitmask for 16 bits.\\nuint256 constant MASK_16BIT = B_1111111111111111;\\n\",\"keccak256\":\"0x63a0b41ebb7c6b78d7e8a9f8b33900421c5d641276a36a6258e97fab4310cdf2\",\"license\":\"CAL\"},\"contracts/math/FixedPointMath.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\nimport {SafeCastUpgradeable as SafeCast} from \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\\\";\\nimport \\\"../math/SaturatingMath.sol\\\";\\n\\n/// @dev The scale of all fixed point math. This is adopting the conventions of\\n/// both ETH (wei) and most ERC20 tokens, so is hopefully uncontroversial.\\nuint256 constant FP_DECIMALS = 18;\\n/// @dev The number `1` in the standard fixed point math scaling. Most of the\\n/// differences between fixed point math and regular math is multiplying or\\n/// dividing by `ONE` after the appropriate scaling has been applied.\\nuint256 constant FP_ONE = 1e18;\\n\\n/// @title FixedPointMath\\n/// @notice Sometimes we want to do math with decimal values but all we have\\n/// are integers, typically uint256 integers. Floats are very complex so we\\n/// don't attempt to simulate them. Instead we provide a standard definition of\\n/// \\\"one\\\" as 10 ** 18 and scale everything up/down to this as fixed point math.\\n///\\n/// Overflows SATURATE rather than error, e.g. scaling max uint256 up will result\\n/// in max uint256. The max uint256 as decimal is roughly 1e77 so scaling values\\n/// comparable to 1e18 is unlikely to ever saturate in practise. For a typical\\n/// use case involving tokens, the entire supply of a token rescaled up a full\\n/// 18 decimals would still put it \\\"only\\\" in the region of ~1e40 which has a full\\n/// 30 orders of magnitude buffer before running into saturation issues. However,\\n/// there's no theoretical reason that a token or any other use case couldn't use\\n/// large numbers or extremely precise decimals that would push this library to\\n/// saturation point, so it MUST be treated with caution around the edge cases.\\n///\\n/// One case where values could come near the saturation/overflow point is phantom\\n/// overflow. This is where an overflow happens during the internal logic of some\\n/// operation like \\\"fixed point multiplication\\\" even though the final result fits\\n/// within uint256. The fixed point multiplication and division functions are\\n/// thin wrappers around Open Zeppelin's `mulDiv` function, that handles phantom\\n/// overflow, reducing the problems of rescaling overflow/saturation to the input\\n/// and output range rather than to the internal implementation details. For this\\n/// library that gives an additional full 18 orders of magnitude for safe fixed\\n/// point multiplication operations.\\n///\\n/// Note that scaling down ANY fixed point decimal also reduces the precision\\n/// which lead to dust or in the worst case trapped funds if subsequent\\n/// subtraction overflows a rounded-down number. Consider using saturating\\n/// subtraction for safety against previously downscaled values, and whether\\n/// trapped dust is a significant issue. If you need to retain full/arbitrary\\n/// precision in the case of downscaling DO NOT use this library.\\nlibrary FixedPointMath {\\n    using Math for uint256;\\n    using SafeCast for int256;\\n    using SaturatingMath for uint256;\\n\\n    /// Scale a fixed point decimal of some scale factor to match `DECIMALS`.\\n    /// @param a_ Some fixed point decimal value.\\n    /// @param aDecimals_ The number of fixed decimals of `a_`.\\n    /// @return `a_` scaled to match `DECIMALS`.\\n    function scale18(\\n        uint256 a_,\\n        uint256 aDecimals_\\n    ) internal pure returns (uint256) {\\n        uint256 decimals_;\\n        if (FP_DECIMALS == aDecimals_) {\\n            return a_;\\n        } else if (FP_DECIMALS > aDecimals_) {\\n            unchecked {\\n                decimals_ = FP_DECIMALS - aDecimals_;\\n            }\\n            return a_.saturatingMul(10 ** decimals_);\\n        } else {\\n            unchecked {\\n                decimals_ = aDecimals_ - FP_DECIMALS;\\n            }\\n            return a_ / 10 ** decimals_;\\n        }\\n    }\\n\\n    /// Scale a fixed point decimals of `DECIMALS` to some other scale.\\n    /// @param a_ A `DECIMALS` fixed point decimals.\\n    /// @param targetDecimals_ The new scale of `a_`.\\n    /// @return `a_` rescaled from `DECIMALS` to `targetDecimals_`.\\n    function scaleN(\\n        uint256 a_,\\n        uint256 targetDecimals_\\n    ) internal pure returns (uint256) {\\n        uint256 decimals_;\\n        if (targetDecimals_ == FP_DECIMALS) {\\n            return a_;\\n        } else if (FP_DECIMALS > targetDecimals_) {\\n            unchecked {\\n                decimals_ = FP_DECIMALS - targetDecimals_;\\n            }\\n            return a_ / 10 ** decimals_;\\n        } else {\\n            unchecked {\\n                decimals_ = targetDecimals_ - FP_DECIMALS;\\n            }\\n            return a_.saturatingMul(10 ** decimals_);\\n        }\\n    }\\n\\n    /// Scale a fixed point decimals of `DECIMALS` that represents a ratio of\\n    /// a_:b_ according to the decimals of a and b that MAY NOT be `DECIMALS`.\\n    /// i.e. a subsequent call to `a_.fixedPointMul(ratio_)` would yield the value\\n    /// that it would have as though `a_` and `b_` were both `DECIMALS` and we\\n    /// hadn't rescaled the ratio.\\n    function scaleRatio(\\n        uint256 ratio_,\\n        uint8 aDecimals_,\\n        uint8 bDecimals_\\n    ) internal pure returns (uint256) {\\n        return\\n            scaleBy(\\n                ratio_,\\n                (int256(uint(bDecimals_)) - int256(uint256(aDecimals_)))\\n                    .toInt8()\\n            );\\n    }\\n\\n    /// Scale a fixed point up or down by `scaleBy_` orders of magnitude.\\n    /// The caller MUST ensure the end result matches `DECIMALS` if other\\n    /// functions in this library are to work correctly.\\n    /// Notably `scaleBy` is a SIGNED integer so scaling down by negative OOMS\\n    /// is supported.\\n    /// @param a_ Some integer of any scale.\\n    /// @param scaleBy_ OOMs to scale `a_` up or down by.\\n    /// @return `a_` rescaled according to `scaleBy_`.\\n    function scaleBy(\\n        uint256 a_,\\n        int8 scaleBy_\\n    ) internal pure returns (uint256) {\\n        if (scaleBy_ == 0) {\\n            return a_;\\n        } else if (scaleBy_ > 0) {\\n            return a_.saturatingMul(10 ** uint8(scaleBy_));\\n        } else {\\n            uint256 posScaleDownBy_;\\n            unchecked {\\n                posScaleDownBy_ = uint8(-1 * scaleBy_);\\n            }\\n            return a_ / 10 ** posScaleDownBy_;\\n        }\\n    }\\n\\n    /// Fixed point multiplication in native scale decimals.\\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return `a_` multiplied by `b_` to `DECIMALS` fixed point decimals.\\n    function fixedPointMul(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        return a_.mulDiv(b_, FP_ONE);\\n    }\\n\\n    /// Overloaded `fixedPointMul` that exposes underlying `mulDiv` rounding.\\n    function fixedPointMul(\\n        uint256 a_,\\n        uint256 b_,\\n        Math.Rounding rounding_\\n    ) internal pure returns (uint256) {\\n        return a_.mulDiv(b_, FP_ONE, rounding_);\\n    }\\n\\n    /// Fixed point division in native scale decimals.\\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return `a_` divided by `b_` to `DECIMALS` fixed point decimals.\\n    function fixedPointDiv(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        return a_.mulDiv(FP_ONE, b_);\\n    }\\n\\n    /// Overloaded `fixedPointDiv` that exposes underlying `mulDiv` rounding.\\n    function fixedPointDiv(\\n        uint256 a_,\\n        uint256 b_,\\n        Math.Rounding rounding_\\n    ) internal pure returns (uint256) {\\n        return a_.mulDiv(FP_ONE, b_, rounding_);\\n    }\\n}\\n\",\"keccak256\":\"0xb0a3915f29d110fa420c189ca343399c2325646215e20d9c164c5b424a58c8a3\",\"license\":\"CAL\"},\"contracts/math/SaturatingMath.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// @title SaturatingMath\\n/// @notice Sometimes we neither want math operations to error nor wrap around\\n/// on an overflow or underflow. In the case of transferring assets an error\\n/// may cause assets to be locked in an irretrievable state within the erroring\\n/// contract, e.g. due to a tiny rounding/calculation error. We also can't have\\n/// assets underflowing and attempting to approve/transfer \\\"infinity\\\" when we\\n/// wanted \\\"almost or exactly zero\\\" but some calculation bug underflowed zero.\\n/// Ideally there are no calculation mistakes, but in guarding against bugs it\\n/// may be safer pragmatically to saturate arithmatic at the numeric bounds.\\n/// Note that saturating div is not supported because 0/0 is undefined.\\nlibrary SaturatingMath {\\n    /// Saturating addition.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return Minimum of a_ + b_ and max uint256.\\n    function saturatingAdd(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 c_ = a_ + b_;\\n            return c_ < a_ ? type(uint256).max : c_;\\n        }\\n    }\\n\\n    /// Saturating subtraction.\\n    /// @param a_ Minuend.\\n    /// @param b_ Subtrahend.\\n    /// @return Maximum of a_ - b_ and 0.\\n    function saturatingSub(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            return a_ > b_ ? a_ - b_ : 0;\\n        }\\n    }\\n\\n    /// Saturating multiplication.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return Minimum of a_ * b_ and max uint256.\\n    function saturatingMul(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being\\n            // zero, but the benefit is lost if 'b' is also tested.\\n            // https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a_ == 0) return 0;\\n            uint256 c_ = a_ * b_;\\n            return c_ / a_ != b_ ? type(uint256).max : c_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5ffcfd7be86bf2a4e28bc55aceeae041b1c014e0a0d7394107238d607ace352a\",\"license\":\"CAL\"},\"contracts/memory/LibMemorySize.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.10;\\n\\n/// @title LibMemorySize\\n/// @notice Reports the size in bytes of type data that represents contigious\\n/// regions of memory. Pointers to regions of memory that may not be congigious\\n/// are not supported, e.g. fields on structs may point to dynamic data that is\\n/// separate to the struct. Length slots for dynamic data are included in the\\n/// size and the size is always measured in bytes.\\nlibrary LibMemorySize {\\n    /// Reports the size of a `uint256` in bytes. Is always 32.\\n    /// @return 32.\\n    function size(uint256) internal pure returns (uint256) {\\n        return 0x20;\\n    }\\n\\n    /// Reports the size of a `uint256[]` in bytes. Is the size of the length\\n    /// slot (32 bytes) plus the length of the array multiplied by 32 bytes per\\n    /// item.\\n    /// @return The size of the array data including its length slot size.\\n    function size(uint256[] memory array_) internal pure returns (uint256) {\\n        unchecked {\\n            return 0x20 + (array_.length * 0x20);\\n        }\\n    }\\n\\n    /// Reports the size of `bytes` data. Is the size of the length slot\\n    /// (32 bytes) plus the number of bytes as per its length.\\n    /// @return The size of the `bytes` data including its length slot size.\\n    function size(bytes memory bytes_) internal pure returns (uint256) {\\n        unchecked {\\n            return 0x20 + bytes_.length;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8d83afcdf42bce8f16b93f7c00f7059e02d86234e78f97ed9d2e19651da616d5\",\"license\":\"CAL\"},\"contracts/orderbook/IOrderBookV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../interpreter/deploy/IExpressionDeployerV1.sol\\\";\\nimport \\\"../interpreter/run/IInterpreterV1.sol\\\";\\n\\nstruct DepositConfig {\\n    address token;\\n    uint256 vaultId;\\n    uint256 amount;\\n}\\n\\nstruct WithdrawConfig {\\n    address token;\\n    uint256 vaultId;\\n    uint256 amount;\\n}\\n\\nstruct IO {\\n    address token;\\n    uint8 decimals;\\n    uint256 vaultId;\\n}\\n\\nstruct OrderConfig {\\n    address expressionDeployer;\\n    address interpreter;\\n    StateConfig interpreterStateConfig;\\n    IO[] validInputs;\\n    IO[] validOutputs;\\n    bytes data;\\n}\\n\\nstruct Order {\\n    address owner;\\n    address interpreter;\\n    EncodedDispatch dispatch;\\n    EncodedDispatch handleIODispatch;\\n    IO[] validInputs;\\n    IO[] validOutputs;\\n    bytes data;\\n}\\n\\nstruct TakeOrdersConfig {\\n    /// Output token from the perspective of the order taker.\\n    address output;\\n    /// Input token from the perspective of the order taker.\\n    address input;\\n    /// Minimum input from the perspective of the order taker.\\n    uint256 minimumInput;\\n    /// Maximum input from the perspective of the order taker.\\n    uint256 maximumInput;\\n    /// Maximum IO ratio as calculated by the order being taken. The input is\\n    /// from the perspective of the order so higher ratio means worse deal for\\n    /// the order taker.\\n    uint256 maximumIORatio;\\n    /// Ordered list of orders that will be taken until the limit is hit. Takers\\n    /// are expected to prioritise orders that appear to be offering better\\n    /// deals i.e. lower IO ratios. This prioritisation and sorting MUST happen\\n    /// offchain, e.g. via. some simulator.\\n    TakeOrderConfig[] orders;\\n}\\n\\nstruct TakeOrderConfig {\\n    Order order;\\n    uint256 inputIOIndex;\\n    uint256 outputIOIndex;\\n}\\n\\nstruct ClearConfig {\\n    uint256 aInputIOIndex;\\n    uint256 aOutputIOIndex;\\n    uint256 bInputIOIndex;\\n    uint256 bOutputIOIndex;\\n    uint256 aBountyVaultId;\\n    uint256 bBountyVaultId;\\n}\\n\\ninterface IOrderBookV1 {\\n    /// depositor => token => vault id => token amount.\\n    function vaultBalance(\\n        address owner,\\n        address token,\\n        uint256 id\\n    ) external view returns (uint256 balance);\\n\\n    function deposit(DepositConfig calldata config) external;\\n\\n    function withdraw(WithdrawConfig calldata config) external;\\n\\n    function addOrder(OrderConfig calldata config) external;\\n\\n    function removeOrder(Order calldata order) external;\\n\\n    function takeOrders(\\n        TakeOrdersConfig calldata takeOrders\\n    ) external returns (uint256 totalInput, uint256 totalOutput);\\n\\n    function clear(\\n        Order memory a,\\n        Order memory b,\\n        ClearConfig calldata clearConfig\\n    ) external;\\n}\\n\",\"keccak256\":\"0x9ddec3a21a2615b952d076b7fbd8c422cf72fd0c27d4dfae8d327033cb25252b\",\"license\":\"CAL\"},\"contracts/sale/ISaleV2.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// An `ISale` can be in one of 4 possible states and a linear progression is\\n/// expected from an \\\"in flight\\\" status to an immutable definitive outcome.\\n/// - Pending: The sale is deployed onchain but cannot be interacted with yet.\\n/// - Active: The sale can now be bought into and otherwise interacted with.\\n/// - Success: The sale has ended AND reached its minimum raise target.\\n/// - Fail: The sale has ended BUT NOT reached its minimum raise target.\\n/// Once an `ISale` reaches `Active` it MUST NOT return `Pending` ever again.\\n/// Once an `ISale` reaches `Success` or `Fail` it MUST NOT return any other\\n/// status ever again.\\nenum SaleStatus {\\n    Pending,\\n    Active,\\n    Success,\\n    Fail\\n}\\n\\ninterface ISaleV2 {\\n    /// Returns the address of the token being sold in the sale.\\n    /// MUST NOT change during the lifecycle of the sale contract.\\n    function token() external view returns (address);\\n\\n    function remainingTokenInventory() external view returns (uint256);\\n\\n    /// Returns the address of the token that sale prices are denominated in.\\n    /// MUST NOT change during the lifecycle of the sale contract.\\n    function reserve() external view returns (address);\\n\\n    /// total reserve taken in to the sale contract via. buys. Does NOT\\n    /// include any reserve sent directly to the sale contract outside the\\n    /// standard buy/refund loop, e.g. due to a dusting attack.\\n    function totalReserveReceived() external view returns (uint256);\\n\\n    /// Returns the current `SaleStatus` of the sale.\\n    /// Represents a linear progression of the sale through its major lifecycle\\n    /// events.\\n    function saleStatus() external view returns (SaleStatus);\\n}\\n\",\"keccak256\":\"0x4c55a0e1679ee3d00d3d80a76dad6d6eb149a959ed77e6af5b8e914830f7aa87\",\"license\":\"CAL\"},\"contracts/sentinel/LibSentinel.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nbytes32 constant SENTINEL_HIGH_BITS = bytes32(\\n    0xF000000000000000000000000000000000000000000000000000000000000000\\n);\\n\",\"keccak256\":\"0xd25db816643a702af32a6e0b14bc4ec4ed1acc7cb81c2e7c99f5bec324761c52\",\"license\":\"CAL\"},\"contracts/tier/ITierV2.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// @title ITierV2\\n/// @notice `ITierV2` is a simple interface that contracts can implement to\\n/// provide membership lists for other contracts.\\n///\\n/// There are many use-cases for a time-preserving conditional membership list.\\n///\\n/// Some examples include:\\n///\\n/// - Self-serve whitelist to participate in fundraising\\n/// - Lists of users who can claim airdrops and perks\\n/// - Pooling resources with implied governance/reward tiers\\n/// - POAP style attendance proofs allowing access to future exclusive events\\n///\\n/// @dev Standard interface to a tiered membership.\\n///\\n/// A \\\"membership\\\" can represent many things:\\n/// - Exclusive access.\\n/// - Participation in some event or process.\\n/// - KYC completion.\\n/// - Combination of sub-memberships.\\n/// - Etc.\\n///\\n/// The high level requirements for a contract implementing `ITierV2`:\\n/// - MUST represent held tiers as a `uint`.\\n/// - MUST implement `report`.\\n///   - The report is a `uint256` that SHOULD represent the time each tier has\\n///     been continuously held since encoded as `uint32`.\\n///   - The encoded tiers start at `1`; Tier `0` is implied if no tier has ever\\n///     been held.\\n///   - Tier `0` is NOT encoded in the report, it is simply the fallback value.\\n///   - If a tier is lost the time data is erased for that tier and will be\\n///     set if/when the tier is regained to the new time.\\n///   - If a tier is held but the historical time information is not available\\n///     the report MAY return `0x00000000` for all held tiers.\\n///   - Tiers that are lost or have never been held MUST return `0xFFFFFFFF`.\\n///   - Context can be a list of numbers that MAY pairwise define tiers such as\\n///     minimum thresholds, or MAY simply provide global context such as a\\n///     relevant NFT ID for example.\\n/// - MUST implement `reportTimeForTier`\\n///   - Functions exactly as `report` but only returns a single time for a\\n///     single tier\\n///   - MUST return the same time value `report` would for any given tier and\\n///     context combination.\\n///\\n/// So the four possible states and report values are:\\n/// - Tier is held and time is known: Timestamp is in the report\\n/// - Tier is held but time is NOT known: `0` is in the report\\n/// - Tier is NOT held: `0xFF..` is in the report\\n/// - Tier is unknown: `0xFF..` is in the report\\n///\\n/// The reason `context` is specified as a list of values rather than arbitrary\\n/// bytes is to allow clear and efficient compatibility with interpreter stacks.\\n/// Some N values can be taken from an interpreter stack and used directly as a\\n/// context, which would be difficult or impossible to ensure is safe for\\n/// arbitrary bytes.\\ninterface ITierV2 {\\n    /// Same as report but only returns the time for a single tier.\\n    /// Often the implementing contract can calculate a single tier more\\n    /// efficiently than all 8 tiers. If the consumer only needs one or a few\\n    /// tiers it MAY be much cheaper to request only those tiers individually.\\n    /// This DOES NOT apply to all contracts, an obvious example is token\\n    /// balance based tiers which always return `ALWAYS` or `NEVER` for all\\n    /// tiers so no efficiency is gained.\\n    /// The return value is a `uint256` for gas efficiency but the values will\\n    /// be bounded by `type(uint32).max` as no single tier can report a value\\n    /// higher than this.\\n    function reportTimeForTier(\\n        address account,\\n        uint256 tier,\\n        uint256[] calldata context\\n    ) external view returns (uint256 time);\\n\\n    /// Returns an 8 tier encoded report of 32 bit timestamps for the given\\n    /// account.\\n    ///\\n    /// Same as `ITier` (legacy interface) but with a list of values for\\n    /// `context` which allows a single underlying state to present many\\n    /// different reports dynamically.\\n    ///\\n    /// For example:\\n    /// - Staking ledgers can calculate different tier thresholds\\n    /// - NFTs can give different tiers based on different IDs\\n    /// - Snapshot ERC20s can give different reports based on snapshot ID\\n    ///\\n    /// `context` supercedes `setTier` function and `TierChange` event from\\n    /// `ITier` at the interface level.\\n    function report(\\n        address account,\\n        uint256[] calldata context\\n    ) external view returns (uint256 report);\\n}\\n\",\"keccak256\":\"0xbaa924c1ae43bb50718e2f9f19ae2dffc97eec916b58c544121c50c2ced211d7\",\"license\":\"CAL\"},\"contracts/tier/libraries/TierConstants.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// @title TierConstants\\n/// @notice Constants for use with tier logic.\\nlibrary TierConstants {\\n    /// NEVER is 0xFF.. as it is infinitely in the future.\\n    /// NEVER for an entire report.\\n    uint256 internal constant NEVER_REPORT = type(uint256).max;\\n    /// NEVER for a single tier time.\\n    uint32 internal constant NEVER_TIME = type(uint32).max;\\n\\n    /// Always is 0 as negative timestamps are not possible/supported onchain.\\n    /// Tiers can't predate the chain but they can predate an `ITierV2`\\n    /// contract.\\n    uint256 internal constant ALWAYS = 0;\\n\\n    /// Account has never held a tier.\\n    uint256 internal constant TIER_ZERO = 0;\\n\\n    /// Magic number for tier one.\\n    uint256 internal constant TIER_ONE = 1;\\n    /// Magic number for tier two.\\n    uint256 internal constant TIER_TWO = 2;\\n    /// Magic number for tier three.\\n    uint256 internal constant TIER_THREE = 3;\\n    /// Magic number for tier four.\\n    uint256 internal constant TIER_FOUR = 4;\\n    /// Magic number for tier five.\\n    uint256 internal constant TIER_FIVE = 5;\\n    /// Magic number for tier six.\\n    uint256 internal constant TIER_SIX = 6;\\n    /// Magic number for tier seven.\\n    uint256 internal constant TIER_SEVEN = 7;\\n    /// Magic number for tier eight.\\n    uint256 internal constant TIER_EIGHT = 8;\\n    /// Maximum tier is `TIER_EIGHT`.\\n    uint256 internal constant MAX_TIER = TIER_EIGHT;\\n}\\n\",\"keccak256\":\"0x8b28d4e524cdc6e728bd1c133e5e5bb14c80ddc4f75a04a1351d9f470c98fc0c\",\"license\":\"CAL\"},\"contracts/tier/libraries/TierReport.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\nimport {ITierV2} from \\\"../ITierV2.sol\\\";\\nimport \\\"./TierConstants.sol\\\";\\n\\n/// @title TierReport\\n/// @notice `TierReport` implements several pure functions that can be\\n/// used to interface with reports.\\n/// - `tierAtTimeFromReport`: Returns the highest status achieved relative to\\n/// a block timestamp and report. Statuses gained after that block are ignored.\\n/// - `tierTime`: Returns the timestamp that a given tier has been held\\n/// since according to a report.\\n/// - `truncateTiersAbove`: Resets all the tiers above the reference tier.\\n/// - `updateTimesForTierRange`: Updates a report with a timestamp for every\\n///    tier in a range.\\n/// - `updateReportWithTierAtTime`: Updates a report to a new tier.\\n/// @dev Utilities to consistently read, write and manipulate tiers in reports.\\n/// The low-level bit shifting can be difficult to get right so this\\n/// factors that out.\\nlibrary TierReport {\\n    /// Enforce upper limit on tiers so we can do unchecked math.\\n    /// @param tier_ The tier to enforce bounds on.\\n    modifier maxTier(uint256 tier_) {\\n        require(tier_ <= TierConstants.MAX_TIER, \\\"MAX_TIER\\\");\\n        _;\\n    }\\n\\n    /// Returns the highest tier achieved relative to a block timestamp\\n    /// and report.\\n    ///\\n    /// Note that typically the report will be from the _current_ contract\\n    /// state, i.e. `block.timestamp` but not always. Tiers gained after the\\n    /// reference time are ignored.\\n    ///\\n    /// When the `report` comes from a later block than the `timestamp_` this\\n    /// means the user must have held the tier continuously from `timestamp_`\\n    /// _through_ to the report time.\\n    /// I.e. NOT a snapshot.\\n    ///\\n    /// @param report_ A report as per `ITierV2`.\\n    /// @param timestamp_ The timestamp to check the tiers against.\\n    /// @return tier_ The highest tier held since `timestamp_` as per `report`.\\n    function tierAtTimeFromReport(\\n        uint256 report_,\\n        uint256 timestamp_\\n    ) internal pure returns (uint256 tier_) {\\n        unchecked {\\n            for (tier_ = 0; tier_ < 8; tier_++) {\\n                if (uint32(uint256(report_ >> (tier_ * 32))) > timestamp_) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// Returns the timestamp that a given tier has been held since from a\\n    /// report.\\n    ///\\n    /// The report MUST encode \\\"never\\\" as 0xFFFFFFFF. This ensures\\n    /// compatibility with `tierAtTimeFromReport`.\\n    ///\\n    /// @param report_ The report to read a timestamp from.\\n    /// @param tier_ The Tier to read the timestamp for.\\n    /// @return The timestamp the tier has been held since.\\n    function reportTimeForTier(\\n        uint256 report_,\\n        uint256 tier_\\n    ) internal pure maxTier(tier_) returns (uint256) {\\n        unchecked {\\n            // ZERO is a special case. Everyone has always been at least ZERO,\\n            // since block 0.\\n            if (tier_ == 0) {\\n                return 0;\\n            }\\n\\n            uint256 offset_ = (tier_ - 1) * 32;\\n            return uint256(uint32(uint256(report_ >> offset_)));\\n        }\\n    }\\n\\n    /// Resets all the tiers above the reference tier to 0xFFFFFFFF.\\n    ///\\n    /// @param report_ Report to truncate with high bit 1s.\\n    /// @param tier_ Tier to truncate above (exclusive).\\n    /// @return Truncated report.\\n    function truncateTiersAbove(\\n        uint256 report_,\\n        uint256 tier_\\n    ) internal pure maxTier(tier_) returns (uint256) {\\n        unchecked {\\n            uint256 offset_ = tier_ * 32;\\n            uint256 mask_ = (TierConstants.NEVER_REPORT >> offset_) << offset_;\\n            return report_ | mask_;\\n        }\\n    }\\n\\n    /// Updates a report with a timestamp for a given tier.\\n    /// More gas efficient than `updateTimesForTierRange` if only a single\\n    /// tier is being modified.\\n    /// The tier at/above the given tier is updated. E.g. tier `0` will update\\n    /// the time for tier `1`.\\n    /// @param report_ Report to use as the baseline for the updated report.\\n    /// @param tier_ The tier level to update.\\n    /// @param timestamp_ The new block number for `tier_`.\\n    /// @return The newly updated `report_`.\\n    function updateTimeAtTier(\\n        uint256 report_,\\n        uint256 tier_,\\n        uint256 timestamp_\\n    ) internal pure maxTier(tier_) returns (uint256) {\\n        unchecked {\\n            uint256 offset_ = tier_ * 32;\\n            return\\n                (report_ &\\n                    ~uint256(uint256(TierConstants.NEVER_TIME) << offset_)) |\\n                uint256(timestamp_ << offset_);\\n        }\\n    }\\n\\n    /// Updates a report with a block number for every tier in a range.\\n    ///\\n    /// Does nothing if the end status is equal or less than the start tier.\\n    /// @param report_ The report to update.\\n    /// @param startTier_ The tier at the start of the range (exclusive).\\n    /// @param endTier_ The tier at the end of the range (inclusive).\\n    /// @param timestamp_ The timestamp to set for every tier in the range.\\n    /// @return The updated report.\\n    function updateTimesForTierRange(\\n        uint256 report_,\\n        uint256 startTier_,\\n        uint256 endTier_,\\n        uint256 timestamp_\\n    ) internal pure maxTier(endTier_) returns (uint256) {\\n        unchecked {\\n            uint256 offset_;\\n            for (uint256 i_ = startTier_; i_ < endTier_; i_++) {\\n                offset_ = i_ * 32;\\n                report_ =\\n                    (report_ &\\n                        ~uint256(\\n                            uint256(TierConstants.NEVER_TIME) << offset_\\n                        )) |\\n                    uint256(timestamp_ << offset_);\\n            }\\n            return report_;\\n        }\\n    }\\n\\n    /// Updates a report to a new status.\\n    ///\\n    /// Internally dispatches to `truncateTiersAbove` and\\n    /// `updateBlocksForTierRange`.\\n    /// The dispatch is based on whether the new tier is above or below the\\n    /// current tier.\\n    /// The `startTier_` MUST match the result of `tierAtBlockFromReport`.\\n    /// It is expected the caller will know the current tier when\\n    /// calling this function and need to do other things in the calling scope\\n    /// with it.\\n    ///\\n    /// @param report_ The report to update.\\n    /// @param startTier_ The tier to start updating relative to. Data above\\n    /// this tier WILL BE LOST so probably should be the current tier.\\n    /// @param endTier_ The new highest tier held, at the given timestamp_.\\n    /// @param timestamp_ The timestamp_ to update the highest tier to, and\\n    /// intermediate tiers from `startTier_`.\\n    /// @return The updated report.\\n    function updateReportWithTierAtTime(\\n        uint256 report_,\\n        uint256 startTier_,\\n        uint256 endTier_,\\n        uint256 timestamp_\\n    ) internal pure returns (uint256) {\\n        return\\n            endTier_ < startTier_\\n                ? truncateTiersAbove(report_, endTier_)\\n                : updateTimesForTierRange(\\n                    report_,\\n                    startTier_,\\n                    endTier_,\\n                    timestamp_\\n                );\\n    }\\n}\\n\",\"keccak256\":\"0x05fb1319c05c5e40468fe07dc0b322598b721222a8c09cc3a3d0e64b17d1729e\",\"license\":\"CAL\"},\"contracts/tier/libraries/TierwiseCombine.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\nimport \\\"./TierReport.sol\\\";\\nimport \\\"../../math/SaturatingMath.sol\\\";\\n\\nlibrary TierwiseCombine {\\n    using Math for uint256;\\n    using SaturatingMath for uint256;\\n\\n    /// Every lte check in `selectLte` must pass.\\n    uint256 internal constant LOGIC_EVERY = 0;\\n    /// Only one lte check in `selectLte` must pass.\\n    uint256 internal constant LOGIC_ANY = 1;\\n\\n    /// Select the minimum block number from passing blocks in `selectLte`.\\n    uint256 internal constant MODE_MIN = 0;\\n    /// Select the maximum block number from passing blocks in `selectLte`.\\n    uint256 internal constant MODE_MAX = 1;\\n    /// Select the first block number that passes in `selectLte`.\\n    uint256 internal constant MODE_FIRST = 2;\\n\\n    /// Performs a tierwise saturating subtraction of two reports.\\n    /// Intepret as \\\"# of blocks older report was held before newer report\\\".\\n    /// If older report is in fact newer then `0` will be returned.\\n    /// i.e. the diff cannot be negative, older report as simply spent 0 blocks\\n    /// existing before newer report, if it is in truth the newer report.\\n    /// @param newerReport_ Block to subtract from.\\n    /// @param olderReport_ Block to subtract.\\n    function saturatingSub(\\n        uint256 newerReport_,\\n        uint256 olderReport_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 ret_;\\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\\n                uint256 newerBlock_ = TierReport.reportTimeForTier(\\n                    newerReport_,\\n                    tier_\\n                );\\n                uint256 olderBlock_ = TierReport.reportTimeForTier(\\n                    olderReport_,\\n                    tier_\\n                );\\n                uint256 diff_ = newerBlock_.saturatingSub(olderBlock_);\\n                ret_ = TierReport.updateTimeAtTier(ret_, tier_ - 1, diff_);\\n            }\\n            return ret_;\\n        }\\n    }\\n\\n    /// Given a list of reports, selects the best tier in a tierwise fashion.\\n    /// The \\\"best\\\" criteria can be configured by `logic_` and `mode_`.\\n    /// Logic can be \\\"every\\\" or \\\"any\\\", which means that the reports for a given\\n    /// tier must either all or any be less than or equal to the reference\\n    /// `blockNumber_`.\\n    /// Mode can be \\\"min\\\", \\\"max\\\", \\\"first\\\" which selects between all the block\\n    /// numbers for a given tier that meet the lte criteria.\\n    /// IMPORTANT: If the output of `selectLte` is used to write to storage\\n    /// care must be taken to ensure that \\\"upcoming\\\" tiers relative to the\\n    /// `blockNumber_` are not overwritten inappropriately. Typically this\\n    /// function should be used as a filter over reads only from an upstream\\n    /// source of truth.\\n    /// @param reports_ The list of reports to select over.\\n    /// @param blockNumber_ The block number that tier blocks must be lte.\\n    /// @param logic_ `LOGIC_EVERY` or `LOGIC_ANY`.\\n    /// @param mode_ `MODE_MIN`, `MODE_MAX` or `MODE_FIRST`.\\n    function selectLte(\\n        uint256 logic_,\\n        uint256 mode_,\\n        uint256 blockNumber_,\\n        uint256[] memory reports_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 ret_;\\n            uint256 block_;\\n            bool anyLte_;\\n            uint256 length_ = reports_.length;\\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\\n                uint256 accumulator_;\\n                // Nothing lte the reference block for this tier yet.\\n                anyLte_ = false;\\n\\n                // Initialize the accumulator for this tier.\\n                if (mode_ == MODE_MIN) {\\n                    accumulator_ = TierConstants.NEVER_REPORT;\\n                } else {\\n                    accumulator_ = 0;\\n                }\\n\\n                // Filter all the blocks at the current tier from all the\\n                // reports against the reference tier and each other.\\n                for (uint256 i_ = 0; i_ < length_; i_++) {\\n                    block_ = TierReport.reportTimeForTier(reports_[i_], tier_);\\n\\n                    if (block_ <= blockNumber_) {\\n                        // Min and max need to compare current value against\\n                        // the accumulator.\\n                        if (mode_ == MODE_MIN) {\\n                            accumulator_ = block_.min(accumulator_);\\n                        } else if (mode_ == MODE_MAX) {\\n                            accumulator_ = block_.max(accumulator_);\\n                        } else if (mode_ == MODE_FIRST && !anyLte_) {\\n                            accumulator_ = block_;\\n                        }\\n                        anyLte_ = true;\\n                    } else if (logic_ == LOGIC_EVERY) {\\n                        // Can short circuit for an \\\"every\\\" check.\\n                        accumulator_ = TierConstants.NEVER_REPORT;\\n                        break;\\n                    }\\n                }\\n                if (!anyLte_) {\\n                    accumulator_ = TierConstants.NEVER_REPORT;\\n                }\\n                ret_ = TierReport.updateTimeAtTier(\\n                    ret_,\\n                    tier_ - 1,\\n                    accumulator_\\n                );\\n            }\\n            return ret_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa795019166092c4663c1a6f441651a4866c9298ffa310f6f5105439cce8d2554\",\"license\":\"CAL\"},\"contracts/type/LibCast.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../interpreter/run/LibStackPointer.sol\\\";\\nimport \\\"../interpreter/run/LibInterpreterState.sol\\\";\\nimport \\\"../interpreter/deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title LibCast\\n/// @notice Additional type casting logic that the Solidity compiler doesn't\\n/// give us by default. A type cast (vs. conversion) is considered one where the\\n/// structure is unchanged by the cast. The cast does NOT (can't) check that the\\n/// input is a valid output, for example any integer MAY be cast to a function\\n/// pointer but almost all integers are NOT valid function pointers. It is the\\n/// calling context that MUST ensure the validity of the data, the cast will\\n/// merely retype the data in place, generally without additional checks.\\n/// As most structures in solidity have the same memory structure as a `uint256`\\n/// or fixed/dynamic array of `uint256` there are many conversions that can be\\n/// done with near zero or minimal overhead.\\nlibrary LibCast {\\n    /// Retype an integer to an opcode function pointer.\\n    /// @param u_ The integer to cast to an opcode function pointer.\\n    /// @return fn_ The opcode function pointer.\\n    function asOpFunctionPointer(\\n        uint256 u_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(InterpreterState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer) fn_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fn_ := u_\\n        }\\n    }\\n\\n    /// Retype an array of integers to an array of opcode function pointers.\\n    /// @param us_ The array of integers to cast to an array of opcode fuction\\n    /// pointers.\\n    /// @return fns_ The array of opcode function pointers.\\n    function asOpcodeFunctionPointers(\\n        uint256[] memory us_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(InterpreterState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer)[]\\n                memory fns_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fns_ := us_\\n        }\\n    }\\n\\n    /// Retype an integer to an integrity function pointer.\\n    /// @param u_ The integer to cast to an integrity function pointer.\\n    /// @return fn_ The integrity function pointer.\\n    function asIntegrityFunctionPointer(\\n        uint256 u_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(IntegrityCheckState memory, Operand, StackPointer)\\n                internal\\n                view\\n                returns (StackPointer) fn_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fn_ := u_\\n        }\\n    }\\n\\n    /// Retype a list of integrity check function pointers to a `uint256[]`.\\n    /// @param fns_ The list of function pointers.\\n    /// @return us_ The list of pointers as `uint256[]`.\\n    function asUint256Array(\\n        function(IntegrityCheckState memory, Operand, StackPointer)\\n            internal\\n            view\\n            returns (StackPointer)[]\\n            memory fns_\\n    ) internal pure returns (uint256[] memory us_) {\\n        assembly (\\\"memory-safe\\\") {\\n            us_ := fns_\\n        }\\n    }\\n\\n    /// Retype a list of interpreter opcode function pointers to a `uint256[]`.\\n    /// @param fns_ The list of function pointers.\\n    /// @return us_ The list of pointers as `uint256[]`.\\n    function asUint256Array(\\n        function(InterpreterState memory, Operand, StackPointer)\\n            view\\n            returns (StackPointer)[]\\n            memory fns_\\n    ) internal pure returns (uint256[] memory us_) {\\n        assembly (\\\"memory-safe\\\") {\\n            us_ := fns_\\n        }\\n    }\\n\\n    /// Retype a list of `uint256[]` to `address[]`.\\n    /// @param us_ The list of integers to cast to addresses.\\n    /// @return addresses_ The list of addresses cast from each integer.\\n    function asAddresses(\\n        uint256[] memory us_\\n    ) internal pure returns (address[] memory addresses_) {\\n        assembly (\\\"memory-safe\\\") {\\n            addresses_ := us_\\n        }\\n    }\\n\\n    /// Retype a list of integers to integrity check function pointers.\\n    /// @param us_ The list of integers to use as function pointers.\\n    /// @return fns_ The list of integrity check function pointers.\\n    function asIntegrityPointers(\\n        uint256[] memory us_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(IntegrityCheckState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer)[]\\n                memory fns_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fns_ := us_\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9650d8d1876bd61c5a326f1fb5c04dc0f6407e65abcc92fdc29b8f050f5e02d3\",\"license\":\"CAL\"},\"contracts/type/LibConvert.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// @title LibConvert\\n/// @notice Type conversions that require additional structural changes to\\n/// complete safely. These are NOT mere type casts and involve additional\\n/// reads and writes to complete, such as recalculating the length of an array.\\n/// The convention \\\"toX\\\" is adopted from Rust to imply the additional costs and\\n/// consumption of the source to produce the target.\\nlibrary LibConvert {\\n    /// Convert an array of integers to `bytes` data. This requires modifying\\n    /// the length in situ as the integer array length is measured in 32 byte\\n    /// increments while the length of `bytes` is the literal number of bytes.\\n    /// @return bytes_ The integer array converted to `bytes` data.\\n    function toBytes(\\n        uint256[] memory us_\\n    ) internal pure returns (bytes memory bytes_) {\\n        assembly (\\\"memory-safe\\\") {\\n            bytes_ := us_\\n            // Length in bytes is 32x the length in uint256\\n            mstore(bytes_, mul(0x20, mload(bytes_)))\\n        }\\n    }\\n\\n    /// Truncate `uint256[]` values down to `uint16[]` then pack this to `bytes`\\n    /// without padding or length prefix. Unsafe because the starting `uint256`\\n    /// values are not checked for overflow due to the truncation. The caller\\n    /// MUST ensure that all values fit in `type(uint16).max` or that silent\\n    /// overflow is safe.\\n    /// @param us_ The `uint256[]` to truncate and concatenate to 16 bit `bytes`.\\n    /// @return The concatenated 2-byte chunks.\\n    function unsafeTo16BitBytes(\\n        uint256[] memory us_\\n    ) internal pure returns (bytes memory) {\\n        unchecked {\\n            // We will keep 2 bytes (16 bits) from each integer.\\n            bytes memory bytes_ = new bytes(us_.length * 2);\\n            assembly (\\\"memory-safe\\\") {\\n                let replaceMask_ := 0xFFFF\\n                let preserveMask_ := not(replaceMask_)\\n                for {\\n                    let cursor_ := add(us_, 0x20)\\n                    let end_ := add(cursor_, mul(mload(us_), 0x20))\\n                    let bytesCursor_ := add(bytes_, 0x02)\\n                } lt(cursor_, end_) {\\n                    cursor_ := add(cursor_, 0x20)\\n                    bytesCursor_ := add(bytesCursor_, 0x02)\\n                } {\\n                    let data_ := mload(bytesCursor_)\\n                    mstore(\\n                        bytesCursor_,\\n                        or(and(preserveMask_, data_), mload(cursor_))\\n                    )\\n                }\\n            }\\n            return bytes_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd9e2df8b8ad347ec018df890eb4461df536de485407026f3761545753e9191de\",\"license\":\"CAL\"},\"contracts/verify/IVerifyV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\ntype VerifyStatus is uint256;\\n\\ninterface IVerifyV1 {\\n    function accountStatusAtTime(\\n        address account,\\n        uint256 timestamp\\n    ) external view returns (VerifyStatus);\\n}\\n\",\"keccak256\":\"0xb04c15c0c71544132752b8589ae590ff4bad61c027990c550bf3ba09659c0e98\",\"license\":\"CAL\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x60b0215121bf25612a6739fb2f1ec35f31ee82e4a8216c032c8243d904ab3aa9\",\"license\":\"MIT\"}},\"version\":1}",
  "devdoc": {
    "events": {
      "Initialize(address,(string,string,(bytes[],uint256[]),(address,address,(bytes[],uint256[])[])))": {
        "params": {
          "config": "All initialized config.",
          "sender": "`msg.sender` initializing the contract (factory)."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "approve(address,uint256)": {
        "details": "See {IERC721-approve}."
      },
      "balanceOf(address)": {
        "details": "See {IERC721-balanceOf}."
      },
      "getApproved(uint256)": {
        "details": "See {IERC721-getApproved}."
      },
      "initialize((string,string,(bytes[],uint256[]),(address,address,(bytes[],uint256[])[])))": {
        "params": {
          "config_": "source and token config. Also controls delegated claims."
        }
      },
      "isApprovedForAll(address,address)": {
        "details": "See {IERC721-isApprovedForAll}."
      },
      "multicall(bytes[])": {
        "details": "Receives and executes a batch of function calls on this contract."
      },
      "name()": {
        "details": "See {IERC721Metadata-name}."
      },
      "onERC721Received(address,address,uint256,bytes)": {
        "details": "See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`."
      },
      "ownerOf(uint256)": {
        "details": "See {IERC721-ownerOf}."
      },
      "safeTransferFrom(address,address,uint256)": {
        "details": "See {IERC721-safeTransferFrom}."
      },
      "safeTransferFrom(address,address,uint256,bytes)": {
        "details": "See {IERC721-safeTransferFrom}."
      },
      "setApprovalForAll(address,bool)": {
        "details": "See {IERC721-setApprovalForAll}."
      },
      "symbol()": {
        "details": "See {IERC721Metadata-symbol}."
      },
      "tokenURI(uint256)": {
        "details": "See {IERC721Metadata-tokenURI}."
      },
      "transferFrom(address,address,uint256)": {
        "details": "See {IERC721-transferFrom}."
      }
    },
    "title": "FlowERC721",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "InvalidSignature(uint256)": [
        {
          "notice": "Thrown when the ith signature from a list of signed contexts is invalid."
        }
      ]
    },
    "events": {
      "Initialize(address,(string,string,(bytes[],uint256[]),(address,address,(bytes[],uint256[])[])))": {
        "notice": "Contract has initialized."
      }
    },
    "kind": "user",
    "methods": {
      "supportsInterface(bytes4)": {
        "notice": "Needed here to fix Open Zeppelin implementing `supportsInterface` on multiple base contracts."
      }
    },
    "version": 1
  }
}