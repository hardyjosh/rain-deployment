{
  "address": "0xA9a5943fe662a463148B1e966739c4C03B35cEb0",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "interpreter_",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "dynamicLength",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "standardOpsLength",
          "type": "uint256"
        }
      ],
      "name": "BadDynamicLength",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "inputs",
          "type": "uint256"
        }
      ],
      "name": "DoWhileMaxInputs",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "minStackOutputs",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "actualStackOutputs",
          "type": "uint256"
        }
      ],
      "name": "MinFinalStack",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MinStackBottom",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "expectedEntrypoints",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "actualEntrypoints",
          "type": "uint256"
        }
      ],
      "name": "MissingEntrypoint",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "price",
          "type": "int256"
        }
      ],
      "name": "NotPosIntPrice",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "constantsLength",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "constantsRead",
          "type": "uint256"
        }
      ],
      "name": "OutOfBoundsConstantsRead",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "stackTopIndex",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "stackRead",
          "type": "uint256"
        }
      ],
      "name": "OutOfBoundsStackRead",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "stackHighwaterIndex",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "stackTopIndex",
          "type": "uint256"
        }
      ],
      "name": "StackPopUnderflow",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "updatedAt",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "staleAfter",
          "type": "uint256"
        }
      ],
      "name": "StalePrice",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "actualBytecodeHash",
          "type": "bytes32"
        }
      ],
      "name": "UnexpectedInterpreterBytecodeHash",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "actualPointers",
          "type": "bytes"
        }
      ],
      "name": "UnexpectedPointers",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "WriteError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroInputs",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "bytes[]",
              "name": "sources",
              "type": "bytes[]"
            },
            {
              "internalType": "uint256[]",
              "name": "constants",
              "type": "uint256[]"
            }
          ],
          "indexed": false,
          "internalType": "struct StateConfig",
          "name": "config",
          "type": "tuple"
        }
      ],
      "name": "ExpressionConfig",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "expression",
          "type": "address"
        }
      ],
      "name": "ExpressionDeployed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "interpreter",
          "type": "address"
        }
      ],
      "name": "ValidInterpreter",
      "type": "event"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes[]",
              "name": "sources",
              "type": "bytes[]"
            },
            {
              "internalType": "uint256[]",
              "name": "constants",
              "type": "uint256[]"
            }
          ],
          "internalType": "struct StateConfig",
          "name": "config_",
          "type": "tuple"
        },
        {
          "internalType": "uint256[]",
          "name": "minStackOutputs_",
          "type": "uint256[]"
        }
      ],
      "name": "deployExpression",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x673ce04565642d7ad8995bd662647a388a5221406a3c107dde8603a096d881ee",
  "receipt": {
    "to": null,
    "from": "0xbF334f8BD1420a1CbFE15407f73919424934B1B3",
    "contractAddress": "0xA9a5943fe662a463148B1e966739c4C03B35cEb0",
    "transactionIndex": 3,
    "gasUsed": "2732401",
    "logsBloom": "0x00000000000000000100000000000000000000000400002000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000040000800000000000000000000100000000004000000000000200000000000000000000000000000000000080000000010000000000000000000001000000000000000001000000000080000000000000000000200000000000000000000000000000000000000000001000000000000000004000000000000000000001000000000000000000000000000000100040000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x913511e233cfce756a6f456e44c2f5954464ed64af2cd089502087f32ff087cd",
    "transactionHash": "0x673ce04565642d7ad8995bd662647a388a5221406a3c107dde8603a096d881ee",
    "logs": [
      {
        "transactionIndex": 3,
        "blockNumber": 30456777,
        "transactionHash": "0x673ce04565642d7ad8995bd662647a388a5221406a3c107dde8603a096d881ee",
        "address": "0xA9a5943fe662a463148B1e966739c4C03B35cEb0",
        "topics": [
          "0xf37e8ef81084fa6f55ef06a1fee409bc7e4dc04c063ecb589e146bafcbd9cbcf"
        ],
        "data": "0x000000000000000000000000bf334f8bd1420a1cbfe15407f73919424934b1b30000000000000000000000005cfbf7d001a1095115657c6c08e87a9039c3343b",
        "logIndex": 4,
        "blockHash": "0x913511e233cfce756a6f456e44c2f5954464ed64af2cd089502087f32ff087cd"
      },
      {
        "transactionIndex": 3,
        "blockNumber": 30456777,
        "transactionHash": "0x673ce04565642d7ad8995bd662647a388a5221406a3c107dde8603a096d881ee",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000bf334f8bd1420a1cbfe15407f73919424934b1b3",
          "0x000000000000000000000000be188d6641e8b680743a4815dfa0f6208038960f"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000035339d1ed72c02000000000000000000000000000000000000000000000000a615ef78996b9b370000000000000000000000000000000000000000000028ab0be3df388c083852000000000000000000000000000000000000000000000000a5e0bbdb7a946f350000000000000000000000000000000000000000000028ab0c1912d5aadf6454",
        "logIndex": 5,
        "blockHash": "0x913511e233cfce756a6f456e44c2f5954464ed64af2cd089502087f32ff087cd"
      }
    ],
    "blockNumber": 30456777,
    "cumulativeGasUsed": "4803964",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x5CFbf7d001A1095115657c6C08e87a9039C3343b"
  ],
  "numDeployments": 1,
  "solcInputHash": "0a2c1cfb658e0cd1c4b0edc075963ea3",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"interpreter_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dynamicLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"standardOpsLength\",\"type\":\"uint256\"}],\"name\":\"BadDynamicLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputs\",\"type\":\"uint256\"}],\"name\":\"DoWhileMaxInputs\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minStackOutputs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actualStackOutputs\",\"type\":\"uint256\"}],\"name\":\"MinFinalStack\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinStackBottom\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expectedEntrypoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actualEntrypoints\",\"type\":\"uint256\"}],\"name\":\"MissingEntrypoint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"price\",\"type\":\"int256\"}],\"name\":\"NotPosIntPrice\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"constantsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"constantsRead\",\"type\":\"uint256\"}],\"name\":\"OutOfBoundsConstantsRead\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stackTopIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stackRead\",\"type\":\"uint256\"}],\"name\":\"OutOfBoundsStackRead\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stackHighwaterIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stackTopIndex\",\"type\":\"uint256\"}],\"name\":\"StackPopUnderflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"staleAfter\",\"type\":\"uint256\"}],\"name\":\"StalePrice\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"actualBytecodeHash\",\"type\":\"bytes32\"}],\"name\":\"UnexpectedInterpreterBytecodeHash\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"actualPointers\",\"type\":\"bytes\"}],\"name\":\"UnexpectedPointers\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WriteError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroInputs\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes[]\",\"name\":\"sources\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"indexed\":false,\"internalType\":\"struct StateConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"ExpressionConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"name\":\"ExpressionDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"}],\"name\":\"ValidInterpreter\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes[]\",\"name\":\"sources\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"internalType\":\"struct StateConfig\",\"name\":\"config_\",\"type\":\"tuple\"},{\"internalType\":\"uint256[]\",\"name\":\"minStackOutputs_\",\"type\":\"uint256[]\"}],\"name\":\"deployExpression\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"MinFinalStack(uint256,uint256)\":[{\"params\":{\"actualStackOutputs\":\"The final stack height after evaluating a source. Will be less than the min stack outputs if this error is thrown.\",\"minStackOutputs\":\"The required minimum stack height.\"}}],\"MissingEntrypoint(uint256,uint256)\":[{\"details\":\"There are more entrypoints defined by the minimum stack outputs than there are provided sources. This means the calling contract WILL attempt to eval a dangling reference to a non-existent source at some point, so this MUST REVERT.\"}],\"NotPosIntPrice(int256)\":[{\"params\":{\"price\":\"The price that is not a positive integer.\"}}],\"StackPopUnderflow(uint256,uint256)\":[{\"params\":{\"stackHighwaterIndex\":\"Index of the stack highwater at the moment of underflow.\",\"stackTopIndex\":\"Index of the stack top at the moment of underflow.\"}}],\"StalePrice(uint256,uint256)\":[{\"params\":{\"staleAfter\":\"The maximum number of seconds the caller allows between the block timestamp and the updated time.\",\"updatedAt\":\"The latest time the oracle was updated according to the oracle.\"}}],\"UnexpectedInterpreterBytecodeHash(bytes32)\":[{\"details\":\"Thrown when the bytecode hash known to the expression deployer DOES NOT match the interpreter it is constructed for. This WILL cause undefined expression behaviour so MUST REVERT.\"}],\"UnexpectedPointers(bytes)\":[{\"details\":\"Thrown when the pointers known to the expression deployer DO NOT match the interpreter it is constructed for. This WILL cause undefined expression behaviour so MUST REVERT.\"}]},\"events\":{\"ExpressionConfig(address,(bytes[],uint256[]))\":{\"params\":{\"config\":\"The config for the deployed expression.\",\"sender\":\"The caller of `deployExpression`.\"}},\"ExpressionDeployed(address,address)\":{\"params\":{\"expression\":\"The address of the deployed expression.\",\"sender\":\"The caller of `deployExpression`.\"}},\"ValidInterpreter(address,address)\":{\"params\":{\"interpreter\":\"The address of the interpreter that the expression deployer agrees to perform integrity checks for. Note that the pairing between interpreter and expression deployer needs to be checked and enforced elsewhere offchain and/or onchain.\",\"sender\":\"The account that constructed the expression deployer.\"}}},\"kind\":\"dev\",\"methods\":{\"deployExpression((bytes[],uint256[]),uint256[])\":{\"params\":{\"config\":\"All the state config associated with an expression.\",\"minOutputs\":\"The first N sources on the state config are entrypoints to the expression where N is the length of the `minOutputs` array. Each item in the `minOutputs` array specifies the number of outputs that MUST be present on the final stack for an evaluation of each entrypoint. The minimum output for some entrypoint MAY be zero if the expectation is that the expression only applies checks and error logic. Non-entrypoint sources MUST NOT have a minimum outputs length specified.\"},\"returns\":{\"_0\":\"The onchain address of the deployed expression.\"}}},\"title\":\"RainterpreterExpressionDeployer\",\"version\":1},\"userdoc\":{\"errors\":{\"BadDynamicLength(uint256,uint256)\":[{\"notice\":\"Thrown when a dynamic length array is NOT 1 more than a fixed length array. Should never happen outside a major breaking change to memory layouts.\"}],\"DoWhileMaxInputs(uint256)\":[{\"notice\":\"More inputs were encoded in the operand than can be dispatched internally by a do-while loop.\"}],\"MinFinalStack(uint256,uint256)\":[{\"notice\":\"The final stack produced by some source did not hit the minimum required for its calling context.\"}],\"MinStackBottom()\":[{\"notice\":\"It is a misconfiguration to set the initial stack bottom to zero or some small value as this trivially exposes the integrity check to potential underflow issues that are gas intensive to repeatedly guard against on every pop. The initial stack bottom for an `IntegrityCheckState` should be `INITIAL_STACK_BOTTOM` to safely avoid the need for underflow checks due to pops and pushes.\"}],\"NotPosIntPrice(int256)\":[{\"notice\":\"Thrown if a price is zero or negative as this is probably not anticipated or useful for most users of a price feed. Of course there are use cases where zero or negative _oracle values_ in general are useful, such as negative temperatures from a thermometer, but these are unlikely to be useful _prices_ for assets. Zero value prices are likely to result in division by zero downstream or giving away assets for free, negative price values could result in even weirder behaviour due to token amounts being `uint256` and the subtleties of signed vs. unsigned integer conversions.\"}],\"OutOfBoundsConstantsRead(uint256,uint256)\":[{\"notice\":\"Thrown when a constant read index is outside the constants array.\"}],\"OutOfBoundsStackRead(uint256,uint256)\":[{\"notice\":\"Thrown when a stack read index is outside the current stack top.\"}],\"StackPopUnderflow(uint256,uint256)\":[{\"notice\":\"The virtual stack top has underflowed the stack highwater (or zero) during an integrity check. The highwater will initially be the stack bottom but MAY move higher due to certain operations such as placing multiple outputs on the stack or copying from a stack position. The highwater prevents subsequent popping of values that are considered immutable.\"}],\"StalePrice(uint256,uint256)\":[{\"notice\":\"Thrown when the updatedAt time from the Chainlink oracle is more than staleAfter seconds prior to the current block timestamp. Prevents stale prices from being used within the constraints set by the caller.\"}],\"ZeroInputs()\":[{\"notice\":\"Zero inputs to select lte is NOT supported.\"}]},\"events\":{\"ExpressionConfig(address,(bytes[],uint256[]))\":{\"notice\":\"The config of the deployed expression including uncompiled sources. Will only be emitted after the config passes the integrity check.\"},\"ExpressionDeployed(address,address)\":{\"notice\":\"The address of the deployed expression. Will only be emitted once the expression can be loaded and deserialized into an evaluable interpreter state.\"},\"ValidInterpreter(address,address)\":{\"notice\":\"The interpreter passed in construction is valid. The only valid interpreter has the exact bytecode hash known to the expression deployer.\"}},\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"THIS IS NOT A SECURITY CHECK. IT IS AN INTEGRITY CHECK TO PREVENT HONEST MISTAKES. IT CANNOT PREVENT EITHER A MALICIOUS INTERPRETER OR DEPLOYER FROM BEING EXECUTED.\"},\"deployExpression((bytes[],uint256[]),uint256[])\":{\"notice\":\"Expressions are expected to be deployed onchain as immutable contract code with a first class address like any other contract or account. Technically this is optional in the sense that all the tools required to eval some expression and define all its opcodes are available as libraries. In practise there are enough advantages to deploying the sources directly onchain as contract data and loading them from the interpreter at eval time: - Loading and storing binary data is gas efficient as immutable contract data - Expressions need to be immutable between their deploy time integrity check   and runtime evaluation - Passing the address of an expression through calldata to an interpreter is   cheaper than passing an entire expression through calldata - Conceptually a very simple approach, even if implementations like SSTORE2   are subtle under the hood The expression deployer MUST perform an integrity check of the source code before it puts the expression onchain at a known address. The integrity check MUST at a minimum (it is free to do additional static analysis) calculate the memory required to be allocated for the stack in total, and that no out of bounds memory reads/writes occur within this stack. A simple example of an invalid source would be one that pushes one value to the stack then attempts to pops two values, clearly we cannot remove more values than we added. The `IExpressionDeployerV1` MUST revert in the case of any integrity failure, all integrity checks MUST pass in order for the deployment to complete. Once the integrity check is complete the `IExpressionDeployerV1` MUST do any additional processing required by its paired interpreter. For example, the `IExpressionDeployerV1` MAY NEED to replace the indexed opcodes in the `StateConfig` sources with real function pointers from the corresponding interpreter.\"}},\"notice\":\"Minimal binding of the `IExpressionDeployerV1` interface to the `LibIntegrityCheck.ensureIntegrity` loop and `AllStandardOps`.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/interpreter/shared/RainterpreterExpressionDeployer.sol\":\"RainterpreterExpressionDeployer\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000000},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\",\"keccak256\":\"0x6e6e4b0835904509406b070ee173b5bc8f677c19421b76be38aea3b1b3d30846\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0xe798cadb41e2da274913e4b3183a80f50fb057a42238fe8467e077268100ec27\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x091a49ef99a2be002680781a10cc9dd74c0f348301ede5482c4ea625f79a8ffe\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\",\"keccak256\":\"0xb1d9e69cf8073efa574b31b1f840e20709139c19bfb27e60b16393d6073f3d42\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4e733d3164f73f461eaf9d8087a7ad1ea180bdc8ba0d3d61b0e1ae16d8e63dff\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/extensions/ERC20Snapshot.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/ArraysUpgradeable.sol\\\";\\nimport \\\"../../../utils/CountersUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\\n * total supply at the time are recorded for later access.\\n *\\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\\n * In naive implementations it's possible to perform a \\\"double spend\\\" attack by reusing the same balance from different\\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\\n * used to create an efficient ERC20 forking mechanism.\\n *\\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\\n * and the account address.\\n *\\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\\n * return `block.number` will trigger the creation of snapshot at the beginning of each new block. When overriding this\\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\\n *\\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\\n * alternative consider {ERC20Votes}.\\n *\\n * ==== Gas Costs\\n *\\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\\n *\\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\\n * transfers will have normal cost until the next snapshot, and so on.\\n */\\n\\nabstract contract ERC20SnapshotUpgradeable is Initializable, ERC20Upgradeable {\\n    function __ERC20Snapshot_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC20Snapshot_init_unchained() internal onlyInitializing {\\n    }\\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\\n    // https://github.com/Giveth/minime/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\\n\\n    using ArraysUpgradeable for uint256[];\\n    using CountersUpgradeable for CountersUpgradeable.Counter;\\n\\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\\n    // Snapshot struct, but that would impede usage of functions that work on an array.\\n    struct Snapshots {\\n        uint256[] ids;\\n        uint256[] values;\\n    }\\n\\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\\n    Snapshots private _totalSupplySnapshots;\\n\\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\\n    CountersUpgradeable.Counter private _currentSnapshotId;\\n\\n    /**\\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\\n     */\\n    event Snapshot(uint256 id);\\n\\n    /**\\n     * @dev Creates a new snapshot and returns its snapshot id.\\n     *\\n     * Emits a {Snapshot} event that contains the same id.\\n     *\\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\\n     *\\n     * [WARNING]\\n     * ====\\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\\n     * you must consider that it can potentially be used by attackers in two ways.\\n     *\\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\\n     * section above.\\n     *\\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\\n     * ====\\n     */\\n    function _snapshot() internal virtual returns (uint256) {\\n        _currentSnapshotId.increment();\\n\\n        uint256 currentId = _getCurrentSnapshotId();\\n        emit Snapshot(currentId);\\n        return currentId;\\n    }\\n\\n    /**\\n     * @dev Get the current snapshotId\\n     */\\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\\n        return _currentSnapshotId.current();\\n    }\\n\\n    /**\\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\\n     */\\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\\n\\n        return snapshotted ? value : balanceOf(account);\\n    }\\n\\n    /**\\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\\n     */\\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\\n\\n        return snapshotted ? value : totalSupply();\\n    }\\n\\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        if (from == address(0)) {\\n            // mint\\n            _updateAccountSnapshot(to);\\n            _updateTotalSupplySnapshot();\\n        } else if (to == address(0)) {\\n            // burn\\n            _updateAccountSnapshot(from);\\n            _updateTotalSupplySnapshot();\\n        } else {\\n            // transfer\\n            _updateAccountSnapshot(from);\\n            _updateAccountSnapshot(to);\\n        }\\n    }\\n\\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\\n        require(snapshotId > 0, \\\"ERC20Snapshot: id is 0\\\");\\n        require(snapshotId <= _getCurrentSnapshotId(), \\\"ERC20Snapshot: nonexistent id\\\");\\n\\n        // When a valid snapshot is queried, there are three possibilities:\\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\\n        //  to this id is the current one.\\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\\n        //  requested id, and its value is the one to return.\\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\\n        //  larger than the requested one.\\n        //\\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\\n        // exactly this.\\n\\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\\n\\n        if (index == snapshots.ids.length) {\\n            return (false, 0);\\n        } else {\\n            return (true, snapshots.values[index]);\\n        }\\n    }\\n\\n    function _updateAccountSnapshot(address account) private {\\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\\n    }\\n\\n    function _updateTotalSupplySnapshot() private {\\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\\n    }\\n\\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\\n        uint256 currentId = _getCurrentSnapshotId();\\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\\n            snapshots.ids.push(currentId);\\n            snapshots.values.push(currentValue);\\n        }\\n    }\\n\\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\\n        if (ids.length == 0) {\\n            return 0;\\n        } else {\\n            return ids[ids.length - 1];\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[46] private __gap;\\n}\\n\",\"keccak256\":\"0x42da8099f59958af496f6c8f0d9c1ce0a929151e02f877e4be23aca4cc440cbe\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x605434219ebbe4653f703640f06969faa5a1d78f0bfef878e5ddbb1ca369ceeb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x2c0b89cef83f353c6f9488c013d8a5968587ffdd6dfc26aad53774214b97e229\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2edcb41c121abc510932e8d83ff8b82cf9cdde35e7c297622f5c29ef0af25183\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ArraysUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Arrays.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./StorageSlotUpgradeable.sol\\\";\\nimport \\\"./math/MathUpgradeable.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to array types.\\n */\\nlibrary ArraysUpgradeable {\\n    using StorageSlotUpgradeable for bytes32;\\n\\n    /**\\n     * @dev Searches a sorted `array` and returns the first index that contains\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\n     * values in the array are strictly less than `element`), the array length is\\n     * returned. Time complexity O(log n).\\n     *\\n     * `array` is expected to be sorted in ascending order, and to contain no\\n     * repeated elements.\\n     */\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        if (array.length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        while (low < high) {\\n            uint256 mid = MathUpgradeable.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds down (it does integer division with truncation).\\n            if (unsafeAccess(array, mid).value > element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlotUpgradeable.AddressSlot storage) {\\n        bytes32 slot;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0, arr.slot)\\n            slot := add(keccak256(0, 0x20), pos)\\n        }\\n        return slot.getAddressSlot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlotUpgradeable.Bytes32Slot storage) {\\n        bytes32 slot;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0, arr.slot)\\n            slot := add(keccak256(0, 0x20), pos)\\n        }\\n        return slot.getBytes32Slot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlotUpgradeable.Uint256Slot storage) {\\n        bytes32 slot;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0, arr.slot)\\n            slot := add(keccak256(0, 0x20), pos)\\n        }\\n        return slot.getUint256Slot();\\n    }\\n}\\n\",\"keccak256\":\"0xc3821e9d41b2b19b612238b308dcc8f4ab46afcd0f6b3bd174e89789bbf59e26\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary CountersUpgradeable {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\",\"keccak256\":\"0x798741e231b22b81e2dd2eddaaf8832dee4baf5cd8e2dbaa5c1dd12a1c053c4d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x09864aea84f01e39313375b5610c73a3c1c68abbdc51e5ccdd25ff977fdadf9a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc6cef87559d0aeffdf0a99803de655938a7779ec0a3cd5d4383483ad85565a09\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc1bd5b53319c68f84e3becd75694d941e8f4be94049903232cd8bc7c535aaa5a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCastUpgradeable {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0xcef50f95b43b038aa40aed25b62fc45906c681a5c1d504a4fdcf3bc6330a8d4b\",\"license\":\"MIT\"},\"contracts/array/LibUint256Array.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// Thrown if a truncated length is longer than the array being truncated. It is\\n/// not possible to truncate something and increase its length as the memory\\n/// region after the array MAY be allocated for something else already.\\nerror OutOfBoundsTruncate(uint256 arrayLength, uint256 truncatedLength);\\n\\n/// @title Uint256Array\\n/// @notice Things we want to do carefully and efficiently with uint256 arrays\\n/// that Solidity doesn't give us native tools for.\\nlibrary LibUint256Array {\\n    using LibUint256Array for uint256[];\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ a single integer to build an array around.\\n    /// @return the newly allocated array including a_ as a single item.\\n    function arrayFrom(uint256 a_) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](1);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ the first integer to build an array around.\\n    /// @param b_ the second integer to build an array around.\\n    /// @return the newly allocated array including a_ and b_ as the only items.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](2);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ the first integer to build an array around.\\n    /// @param b_ the second integer to build an array around.\\n    /// @param c_ the third integer to build an array around.\\n    /// @return the newly allocated array including a_, b_ and c_ as the only\\n    /// items.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](3);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ the first integer to build an array around.\\n    /// @param b_ the second integer to build an array around.\\n    /// @param c_ the third integer to build an array around.\\n    /// @param d_ the fourth integer to build an array around.\\n    /// @return the newly allocated array including a_, b_, c_ and d_ as the only\\n    /// items.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](4);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n            mstore(add(array_, 0x80), d_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ the first integer to build an array around.\\n    /// @param b_ the second integer to build an array around.\\n    /// @param c_ the third integer to build an array around.\\n    /// @param d_ the fourth integer to build an array around.\\n    /// @param e_ the fifth integer to build an array around.\\n    /// @return the newly allocated array including a_, b_, c_, d_ and e_ as the\\n    /// only items.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_,\\n        uint256 e_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](5);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n            mstore(add(array_, 0x80), d_)\\n            mstore(add(array_, 0xA0), e_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ the first integer to build an array around.\\n    /// @param b_ the second integer to build an array around.\\n    /// @param c_ the third integer to build an array around.\\n    /// @param d_ the fourth integer to build an array around.\\n    /// @param e_ the fifth integer to build an array around.\\n    /// @param f_ the sixth integer to build an array around.\\n    /// @return the newly allocated array including a_, b_, c_, d_, e_ and f_ as\\n    /// the only items.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_,\\n        uint256 e_,\\n        uint256 f_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](6);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n            mstore(add(array_, 0x80), d_)\\n            mstore(add(array_, 0xA0), e_)\\n            mstore(add(array_, 0xC0), f_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ The head of the new array.\\n    /// @param tail_ The tail of the new array.\\n    /// @return The new array.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256[] memory tail_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](1);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n        }\\n        array_.extend(tail_);\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ The first item of the new array.\\n    /// @param b_ The second item of the new array.\\n    /// @param tail_ The tail of the new array.\\n    /// @return The new array.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256[] memory tail_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](2);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n        }\\n        array_.extend(tail_);\\n        return array_;\\n    }\\n\\n    /// 2-dimensional analogue of `arrayFrom`. Takes a 1-dimensional array and\\n    /// coerces it to a 2-dimensional matrix where the first and only item in the\\n    /// matrix is the 1-dimensional array.\\n    /// @param a_ The 1-dimensional array to coerce.\\n    /// @return The 2-dimensional matrix containing `a_`.\\n    function matrixFrom(\\n        uint256[] memory a_\\n    ) internal pure returns (uint256[][] memory) {\\n        uint256[][] memory matrix_ = new uint256[][](1);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(matrix_, 0x20), a_)\\n        }\\n        return matrix_;\\n    }\\n\\n    /// Solidity provides no way to change the length of in-memory arrays but\\n    /// it also does not deallocate memory ever. It is always safe to shrink an\\n    /// array that has already been allocated, with the caveat that the\\n    /// truncated items will effectively become inaccessible regions of memory.\\n    /// That is to say, we deliberately \\\"leak\\\" the truncated items, but that is\\n    /// no worse than Solidity's native behaviour of leaking everything always.\\n    /// The array is MUTATED in place so there is no return value and there is\\n    /// no new allocation or copying of data either.\\n    /// @param array_ The array to truncate.\\n    /// @param newLength_ The new length of the array after truncation.\\n    function truncate(\\n        uint256[] memory array_,\\n        uint256 newLength_\\n    ) internal pure {\\n        if (newLength_ > array_.length) {\\n            revert OutOfBoundsTruncate(array_.length, newLength_);\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(array_, newLength_)\\n        }\\n    }\\n\\n    /// Extends `base_` with `extend_` by allocating additional `extend_.length`\\n    /// uints onto `base_`. Reverts if some other memory has been allocated\\n    /// after `base_` already, in which case it is NOT safe to copy inline.\\n    /// If `base_` is large this MAY be significantly more efficient than\\n    /// allocating `base_.length + extend_.length` for an entirely new array and\\n    /// copying both `base_` and `extend_` into the new array one item at a\\n    /// time in Solidity.\\n    /// The Solidity compiler MAY rearrange sibling statements in a code block\\n    /// EVEN IF THE OPTIMIZER IS DISABLED such that it becomes unsafe to use\\n    /// `extend` for memory allocated in different code blocks. It is ONLY safe\\n    /// to `extend` arrays that were allocated in the same lexical scope and you\\n    /// WILL see subtle errors that revert transactions otherwise.\\n    /// i.e. the `new` keyword MUST appear in the same code block as `extend`.\\n    /// @param base_ The base integer array that will be extended by `extend_`.\\n    /// @param extend_ The integer array that extends `base_`.\\n    function extend(\\n        uint256[] memory base_,\\n        uint256[] memory extend_\\n    ) internal pure {\\n        uint256 freeMemoryPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            // Solidity stores free memory pointer at 0x40\\n            freeMemoryPointer_ := mload(0x40)\\n            let baseLength_ := mload(base_)\\n            let extendLength_ := mload(extend_)\\n\\n            // The freeMemoryPointer_ does NOT point to the end of `base_` so\\n            // it is NOT safe to copy `extend_` over the top of already\\n            // allocated memory. This happens whenever some memory is allocated\\n            // after `base_` is allocated but before `extend` is called.\\n            if gt(\\n                freeMemoryPointer_,\\n                add(base_, add(0x20, mul(0x20, baseLength_)))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            // Move the free memory pointer by the length of extend_, excluding\\n            // the length slot of extend as that will NOT be copied to `base_`.\\n            mstore(0x40, add(freeMemoryPointer_, mul(0x20, extendLength_)))\\n\\n            // Update the length of base to be the length of base+extend.\\n            mstore(base_, add(baseLength_, extendLength_))\\n        }\\n\\n        unsafeCopyValuesTo(extend_, freeMemoryPointer_);\\n    }\\n\\n    /// Copies `inputs_` to `outputCursor_` with NO attempt to check that this\\n    /// is safe to do so. The caller MUST ensure that there exists allocated\\n    /// memory at `outputCursor_` in which it is safe and appropriate to copy\\n    /// ALL `inputs_` to. Anything that was already written to memory at\\n    /// `[outputCursor_:outputCursor_+(inputs_.length * 32 bytes)]` will be\\n    /// overwritten. The length of `inputs_` is NOT copied to the output\\n    /// location, ONLY the `uint256` values of the `inputs_` array are copied.\\n    /// There is no return value as memory is modified directly.\\n    /// @param inputs_ The input array that will be copied from EXCLUDING the\\n    /// length at the start of the array in memory.\\n    /// @param outputCursor_ Location in memory that the values will be copied\\n    /// to linearly.\\n    function unsafeCopyValuesTo(\\n        uint256[] memory inputs_,\\n        uint256 outputCursor_\\n    ) internal pure {\\n        uint256 inputCursor_;\\n        assembly (\\\"memory-safe\\\") {\\n            inputCursor_ := add(inputs_, 0x20)\\n        }\\n        unsafeCopyValuesTo(inputCursor_, outputCursor_, inputs_.length);\\n    }\\n\\n    /// Copies `length_` 32 byte words from `inputCursor_` to a newly allocated\\n    /// uint256[] array with NO attempt to check that the inputs are sane.\\n    /// This function is safe in that the outputs are guaranteed to be copied\\n    /// to newly allocated memory so no existing data will be overwritten.\\n    /// This function is subtle in that the `inputCursor_` is NOT validated in\\n    /// any way so the caller MUST ensure it points to a sensible memory\\n    /// location to read (e.g. to exclude the length from input arrays etc.).\\n    /// @param inputCursor_ The start of the memory that will be copied to the\\n    /// newly allocated array.\\n    /// @param length_ Number of 32 byte words to copy starting at\\n    /// `inputCursor_` to the items of the newly allocated array.\\n    /// @return The newly allocated `uint256[]` array.\\n    function copyToNewUint256Array(\\n        uint256 inputCursor_,\\n        uint256 length_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory outputs_ = new uint256[](length_);\\n        uint256 outputCursor_;\\n        assembly (\\\"memory-safe\\\") {\\n            outputCursor_ := add(outputs_, 0x20)\\n        }\\n        unsafeCopyValuesTo(inputCursor_, outputCursor_, length_);\\n        return outputs_;\\n    }\\n\\n    /// Copies `length_` uint256 values starting from `inputsCursor_` to\\n    /// `outputCursor_` with NO attempt to check that this is safe to do so.\\n    /// The caller MUST ensure that there exists allocated memory at\\n    /// `outputCursor_` in which it is safe and appropriate to copy\\n    /// `length_ * 32` bytes to. Anything that was already written to memory at\\n    /// `[outputCursor_:outputCursor_+(length_ * 32 bytes)]` will be\\n    /// overwritten.\\n    /// There is no return value as memory is modified directly.\\n    /// @param inputCursor_ The starting position in memory that data will be\\n    /// copied from.\\n    /// @param outputCursor_ The starting position in memory that data will be\\n    /// copied to.\\n    /// @param length_ The number of 32 byte (i.e. `uint256`) values that will\\n    /// be copied.\\n    function unsafeCopyValuesTo(\\n        uint256 inputCursor_,\\n        uint256 outputCursor_,\\n        uint256 length_\\n    ) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n                let end_ := add(inputCursor_, mul(0x20, length_))\\n            } lt(inputCursor_, end_) {\\n                inputCursor_ := add(inputCursor_, 0x20)\\n                outputCursor_ := add(outputCursor_, 0x20)\\n            } {\\n                mstore(outputCursor_, mload(inputCursor_))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x118cb5bba9671ac311c8e196984e6213390334712f53dea901284fa4ba208b84\",\"license\":\"CAL\"},\"contracts/bytes/LibBytes.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// @title LibBytes\\n/// @notice Things we want to do carefully and efficiently with `bytes` in memory\\n/// that Solidity doesn't give us native tools for.\\nlibrary LibBytes {\\n    /// Copy an arbitrary number of bytes from one location in memory to another.\\n    /// As we can only read/write bytes in 32 byte chunks we first have to loop\\n    /// over 32 byte values to copy then handle any unaligned remaining data. The\\n    /// remaining data will be appropriately masked with the existing data in the\\n    /// final chunk so as to not write past the desired length. Note that the\\n    /// final unaligned write will be more gas intensive than the prior aligned\\n    /// writes. The writes are completely unsafe, the caller MUST ensure that\\n    /// sufficient memory is allocated and reading/writing the requested number\\n    /// of bytes from/to the requested locations WILL NOT corrupt memory in the\\n    /// opinion of solidity or other subsequent read/write operations.\\n    /// @param inputCursor_ The starting location in memory to read from.\\n    /// @param outputCursor_ The starting location in memory to write to.\\n    /// @param remaining_ The number of bytes to read/write.\\n    function unsafeCopyBytesTo(\\n        uint256 inputCursor_,\\n        uint256 outputCursor_,\\n        uint256 remaining_\\n    ) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n\\n            } iszero(lt(remaining_, 0x20)) {\\n                remaining_ := sub(remaining_, 0x20)\\n                inputCursor_ := add(inputCursor_, 0x20)\\n                outputCursor_ := add(outputCursor_, 0x20)\\n            } {\\n                mstore(outputCursor_, mload(inputCursor_))\\n            }\\n\\n            if gt(remaining_, 0) {\\n                let mask_ := shr(\\n                    mul(remaining_, 8),\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n                // preserve existing bytes\\n                mstore(\\n                    outputCursor_,\\n                    or(\\n                        // input\\n                        and(mload(inputCursor_), not(mask_)),\\n                        and(mload(outputCursor_), mask_)\\n                    )\\n                )\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x613125e88688bca7d52cc48447a70fd2a17b3a120ef41c7c61092b3b523aa121\",\"license\":\"CAL\"},\"contracts/chainlink/LibChainlink.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../math/FixedPointMath.sol\\\";\\n\\n/// Thrown if a price is zero or negative as this is probably not anticipated or\\n/// useful for most users of a price feed. Of course there are use cases where\\n/// zero or negative _oracle values_ in general are useful, such as negative\\n/// temperatures from a thermometer, but these are unlikely to be useful _prices_\\n/// for assets. Zero value prices are likely to result in division by zero\\n/// downstream or giving away assets for free, negative price values could result\\n/// in even weirder behaviour due to token amounts being `uint256` and the\\n/// subtleties of signed vs. unsigned integer conversions.\\n/// @param price The price that is not a positive integer.\\nerror NotPosIntPrice(int256 price);\\n\\n/// Thrown when the updatedAt time from the Chainlink oracle is more than\\n/// staleAfter seconds prior to the current block timestamp. Prevents stale\\n/// prices from being used within the constraints set by the caller.\\n/// @param updatedAt The latest time the oracle was updated according to the\\n/// oracle.\\n/// @param staleAfter The maximum number of seconds the caller allows between\\n/// the block timestamp and the updated time.\\nerror StalePrice(uint256 updatedAt, uint256 staleAfter);\\n\\nlibrary LibChainlink {\\n    using SafeCast for int256;\\n    using FixedPointMath for uint256;\\n\\n    function price(\\n        address feed_,\\n        uint256 staleAfter_\\n    ) internal view returns (uint256) {\\n        (, int256 answer_, , uint256 updatedAt_, ) = AggregatorV3Interface(\\n            feed_\\n        ).latestRoundData();\\n\\n        if (answer_ <= 0) {\\n            revert NotPosIntPrice(answer_);\\n        }\\n\\n        // Checked time comparison ensures no updates from the future as that\\n        // would overflow, and no stale prices.\\n        // solhint-disable-next-line not-rely-on-time\\n        if (block.timestamp - updatedAt_ > staleAfter_) {\\n            revert StalePrice(updatedAt_, staleAfter_);\\n        }\\n\\n        // Safely cast the answer to uint256 and scale it to 18 decimal FP.\\n        return\\n            answer_.toUint256().scale18(\\n                AggregatorV3Interface(feed_).decimals()\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x3ff6ddc5c8209e59dce4be84215c8b0421c60e338f87b778b6fde234870594a5\",\"license\":\"CAL\"},\"contracts/interpreter/deploy/IExpressionDeployerV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\n/// Config required to build a new `State`.\\n/// @param sources Sources verbatim. These sources MUST be provided in their\\n/// sequential/index opcode form as the deployment process will need to index\\n/// into BOTH the integrity check and the final runtime function pointers.\\n/// This will be emitted in an event for offchain processing to use the indexed\\n/// opcode sources. The first N sources are considered entrypoints and will be\\n/// integrity checked by the expression deployer against a starting stack height\\n/// of 0. Non-entrypoint sources MAY be provided for internal use such as the\\n/// `call` opcode but will NOT be integrity checked UNLESS entered by an opcode\\n/// in an entrypoint.\\n/// @param constants Constants verbatim. Constants are provided alongside sources\\n/// rather than inline as it allows us to avoid variable length opcodes and can\\n/// be more memory efficient if the same constant is referenced several times\\n/// from the sources.\\nstruct StateConfig {\\n    bytes[] sources;\\n    uint256[] constants;\\n}\\n\\n/// @title IExpressionDeployerV1\\n/// @notice Companion to `IInterpreterV1` responsible for onchain static code\\n/// analysis and deploying expressions. Each `IExpressionDeployerV1` is tightly\\n/// coupled at the bytecode level to some interpreter that it knows how to\\n/// analyse and deploy expressions for. The expression deployer can perform an\\n/// integrity check \\\"dry run\\\" of candidate source code for the intepreter. The\\n/// critical analysis/transformation includes:\\n///\\n/// - Enforcement of no out of bounds memory reads/writes\\n/// - Calculation of memory required to eval the stack with a single allocation\\n/// - Replacing index based opcodes with absolute interpreter function pointers\\n/// - Enforcement that all opcodes and operands used exist and are valid\\n///\\n/// This analysis is highly sensitive to the specific implementation and position\\n/// of all opcodes and function pointers as compiled into the interpreter. This\\n/// is what makes the coupling between an interpreter and expression deployer\\n/// so tight. Ideally all responsibilities would be handled by a single contract\\n/// but this introduces code size issues quickly by roughly doubling the compiled\\n/// logic of each opcode (half for the integrity check and half for evaluation).\\n///\\n/// Interpreters MUST assume that expression deployers are malicious and fail\\n/// gracefully if the integrity check is corrupt/bypassed and/or function\\n/// pointers are incorrect, etc. i.e. the interpreter MUST always return a stack\\n/// from `eval` in a read only way or error. I.e. it is the expression deployer's\\n/// responsibility to do everything it can to prevent undefined behaviour in the\\n/// interpreter, and the interpreter's responsibility to handle the expression\\n/// deployer completely failing to do so.\\ninterface IExpressionDeployerV1 {\\n    /// Expressions are expected to be deployed onchain as immutable contract\\n    /// code with a first class address like any other contract or account.\\n    /// Technically this is optional in the sense that all the tools required to\\n    /// eval some expression and define all its opcodes are available as libraries.\\n    ///\\n    /// In practise there are enough advantages to deploying the sources directly\\n    /// onchain as contract data and loading them from the interpreter at eval time:\\n    ///\\n    /// - Loading and storing binary data is gas efficient as immutable contract data\\n    /// - Expressions need to be immutable between their deploy time integrity check\\n    ///   and runtime evaluation\\n    /// - Passing the address of an expression through calldata to an interpreter is\\n    ///   cheaper than passing an entire expression through calldata\\n    /// - Conceptually a very simple approach, even if implementations like SSTORE2\\n    ///   are subtle under the hood\\n    ///\\n    /// The expression deployer MUST perform an integrity check of the source code\\n    /// before it puts the expression onchain at a known address. The integrity check\\n    /// MUST at a minimum (it is free to do additional static analysis) calculate the\\n    /// memory required to be allocated for the stack in total, and that no out of\\n    /// bounds memory reads/writes occur within this stack. A simple example of an\\n    /// invalid source would be one that pushes one value to the stack then attempts\\n    /// to pops two values, clearly we cannot remove more values than we added. The\\n    /// `IExpressionDeployerV1` MUST revert in the case of any integrity failure, all\\n    /// integrity checks MUST pass in order for the deployment to complete.\\n    ///\\n    /// Once the integrity check is complete the `IExpressionDeployerV1` MUST do any\\n    /// additional processing required by its paired interpreter. For example, the\\n    /// `IExpressionDeployerV1` MAY NEED to replace the indexed opcodes in the\\n    /// `StateConfig` sources with real function pointers from the corresponding\\n    /// interpreter.\\n    ///\\n    /// @param config All the state config associated with an expression.\\n    /// @param minOutputs The first N sources on the state config are entrypoints to\\n    /// the expression where N is the length of the `minOutputs` array. Each item in\\n    /// the `minOutputs` array specifies the number of outputs that MUST be present\\n    /// on the final stack for an evaluation of each entrypoint. The minimum output\\n    /// for some entrypoint MAY be zero if the expectation is that the expression\\n    /// only applies checks and error logic. Non-entrypoint sources MUST NOT have a\\n    /// minimum outputs length specified.\\n    /// @return expression The onchain address of the deployed expression.\\n    function deployExpression(\\n        StateConfig memory config,\\n        uint256[] memory minOutputs\\n    ) external returns (address expression);\\n}\\n\",\"keccak256\":\"0x90685338765adf8780a7ccc6990a2b2e312d595b37858e18319bf80e2e559f40\",\"license\":\"CAL\"},\"contracts/interpreter/deploy/LibIntegrityCheck.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../run/LibStackPointer.sol\\\";\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\n\\nimport \\\"./IExpressionDeployerV1.sol\\\";\\nimport \\\"../run/IInterpreterV1.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @dev The virtual stack pointers are never read or written so don't need to\\n/// point to a real location in memory. We only care that the stack never moves\\n/// below its starting point at the stack bottom. For the virtual stack used by\\n/// the integrity check we can start it in the middle of the `uint256` range and\\n/// achieve something analogous to signed integers with unsigned integer types.\\nStackPointer constant INITIAL_STACK_BOTTOM = StackPointer.wrap(\\n    type(uint256).max / 2\\n);\\n\\n/// It is a misconfiguration to set the initial stack bottom to zero or some\\n/// small value as this trivially exposes the integrity check to potential\\n/// underflow issues that are gas intensive to repeatedly guard against on every\\n/// pop. The initial stack bottom for an `IntegrityCheckState` should be\\n/// `INITIAL_STACK_BOTTOM` to safely avoid the need for underflow checks due to\\n/// pops and pushes.\\nerror MinStackBottom();\\n\\n/// The virtual stack top has underflowed the stack highwater (or zero) during an\\n/// integrity check. The highwater will initially be the stack bottom but MAY\\n/// move higher due to certain operations such as placing multiple outputs on the\\n/// stack or copying from a stack position. The highwater prevents subsequent\\n/// popping of values that are considered immutable.\\n/// @param stackHighwaterIndex Index of the stack highwater at the moment of\\n/// underflow.\\n/// @param stackTopIndex Index of the stack top at the moment of underflow.\\nerror StackPopUnderflow(uint256 stackHighwaterIndex, uint256 stackTopIndex);\\n\\n/// The final stack produced by some source did not hit the minimum required for\\n/// its calling context.\\n/// @param minStackOutputs The required minimum stack height.\\n/// @param actualStackOutputs The final stack height after evaluating a source.\\n/// Will be less than the min stack outputs if this error is thrown.\\nerror MinFinalStack(uint256 minStackOutputs, uint256 actualStackOutputs);\\n\\n/// Running an integrity check is a stateful operation. As well as the basic\\n/// configuration of what is being checked such as the sources and size of the\\n/// constants, the current and maximum stack height is being recomputed on every\\n/// checked opcode. The stack is virtual during the integrity check so whatever\\n/// the `StackPointer` values are during the check, it's always undefined\\n/// behaviour to actually try to read/write to them.\\n///\\n/// @param sources All the sources of the expression are provided to the\\n/// integrity check as any entrypoint and non-entrypoint can `call` into some\\n/// other source at any time, provided the overall inputs and outputs to the\\n/// stack are valid.\\n/// @param constantsLength The integrity check assumes the existence of some\\n/// opcode that will read from a predefined list of constants. Technically this\\n/// opcode MAY NOT exist in some interpreter but it seems highly likely to be\\n/// included in most setups. The integrity check only needs the length of the\\n/// constants array to check for out of bounds reads, which allows runtime\\n/// behaviour to read without additional gas for OOB index checks.\\n/// @param stackBottom Pointer to the bottom of the virtual stack that the\\n/// integrity check uses to simulate a real eval.\\n/// @param stackMaxTop Pointer to the maximum height the virtual stack has\\n/// reached during the integrity check. The current virtual stack height will\\n/// be handled separately to the state during the check.\\n/// @param integrityFunctionPointers We pass an array of all the function\\n/// pointers to per-opcode integrity checks around with the state to facilitate\\n/// simple recursive integrity checking.\\nstruct IntegrityCheckState {\\n    // Sources in zeroth position as we read from it in assembly without paying\\n    // gas to calculate offsets.\\n    bytes[] sources;\\n    uint256 constantsLength;\\n    StackPointer stackBottom;\\n    StackPointer stackHighwater;\\n    StackPointer stackMaxTop;\\n    function(IntegrityCheckState memory, Operand, StackPointer)\\n        view\\n        returns (StackPointer)[] integrityFunctionPointers;\\n}\\n\\n/// @title LibIntegrityCheck\\n/// @notice \\\"Dry run\\\" versions of the key logic from `LibStackPointer` that\\n/// allows us to simulate a virtual stack based on the Solidity type system\\n/// itself. The core loop of an integrity check is to dispatch an integrity-only\\n/// version of a runtime opcode that then uses `LibIntegrityCheck` to apply a\\n/// function that simulates a stack movement. The simulated stack movement will\\n/// move a pointer to memory in the same way as a real pop/push would at runtime\\n/// but without any associated logic or even allocating and writing data in\\n/// memory on the other side of the pointer. Every pop is checked for out of\\n/// bounds reads, even if it is an intermediate pop within the logic of a single\\n/// opcode. The _gross_ stack movement is just as important as the net movement.\\n/// For example, consider a simple ERC20 total supply read. The _net_ movement\\n/// of a total supply read is 0, it pops the token address then pushes the total\\n/// supply. However the _gross_ movement is first -1 then +1, so we have to guard\\n/// against the -1 underflowing while reading the token address _during_ the\\n/// simulated opcode dispatch. In general this can be subtle, complex and error\\n/// prone, which is why `LibIntegrityCheck` and `LibStackPointer` take function\\n/// signatures as arguments, so that the overloading mechanism in Solidity itself\\n/// enforces correct pop/push calculations for every opcode.\\nlibrary LibIntegrityCheck {\\n    using LibIntegrityCheck for IntegrityCheckState;\\n    using LibStackPointer for StackPointer;\\n    using Math for uint256;\\n\\n    function newState(\\n        StateConfig memory config_,\\n        function(IntegrityCheckState memory, Operand, StackPointer)\\n            view\\n            returns (StackPointer)[]\\n            memory integrityFns_\\n    ) internal pure returns (IntegrityCheckState memory) {\\n        return\\n            IntegrityCheckState(\\n                config_.sources,\\n                config_.constants.length,\\n                INITIAL_STACK_BOTTOM,\\n                // Highwater starts underneath stack bottom as it errors on an\\n                // greater than _or equal to_ check.\\n                INITIAL_STACK_BOTTOM.down(),\\n                INITIAL_STACK_BOTTOM,\\n                integrityFns_\\n            );\\n    }\\n\\n    /// If the given stack pointer is above the current state of the max stack\\n    /// top, the max stack top will be moved to the stack pointer.\\n    /// i.e. this works like `stackMaxTop = stackMaxTop.max(stackPointer_)` but\\n    /// with the type unwrapping boilerplate included for convenience.\\n    /// @param integrityCheckState_ The state of the current integrity check\\n    /// including the current max stack top.\\n    /// @param stackPointer_ The stack pointer to compare and potentially swap\\n    /// the max stack top for.\\n    function syncStackMaxTop(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackPointer_\\n    ) internal pure {\\n        if (\\n            StackPointer.unwrap(stackPointer_) >\\n            StackPointer.unwrap(integrityCheckState_.stackMaxTop)\\n        ) {\\n            integrityCheckState_.stackMaxTop = stackPointer_;\\n        }\\n    }\\n\\n    /// The main integrity check loop. Designed so that it can be called\\n    /// recursively by the dispatched integrity opcodes to support arbitrary\\n    /// nesting of sources and substacks, loops, etc.\\n    /// If ANY of the integrity checks for ANY opcode fails the entire integrity\\n    /// check will revert.\\n    /// @param integrityCheckState_ Current state of the integrity check passed\\n    /// by reference to allow for recursive/nested integrity checking.\\n    /// @param sourceIndex_ The source to check the integrity of which can be\\n    /// either an entrypoint or a non-entrypoint source if this is a recursive\\n    /// call to `ensureIntegrity`.\\n    /// @param stackTop_ The current top of the virtual stack as a pointer. This\\n    /// can be manipulated to create effective substacks/scoped/immutable\\n    /// runtime values by restricting how the `stackTop_` can move at deploy\\n    /// time.\\n    /// @param minStackOutputs_ The minimum stack height required by the end of\\n    /// this integrity check. The caller MUST ensure that it sets this value high\\n    /// enough so that it can safely read enough values from the final stack\\n    /// without out of bounds reads. The external interface to the expression\\n    /// deployer accepts an array of minimum stack heights against entrypoints,\\n    /// but the internal checks can be recursive against non-entrypoints and each\\n    /// opcode such as `call` can build scoped stacks, etc. so here we just put\\n    /// defining the requirements back on the caller.\\n    function ensureIntegrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        SourceIndex sourceIndex_,\\n        StackPointer stackTop_,\\n        uint256 minStackOutputs_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            // It's generally more efficient to ensure the stack bottom has\\n            // plenty of headroom to make underflows from pops impossible rather\\n            // than guard every single pop against underflow.\\n            if (\\n                StackPointer.unwrap(integrityCheckState_.stackBottom) <\\n                StackPointer.unwrap(INITIAL_STACK_BOTTOM)\\n            ) {\\n                revert MinStackBottom();\\n            }\\n            uint256 cursor_;\\n            uint256 end_;\\n            assembly (\\\"memory-safe\\\") {\\n                cursor_ := mload(\\n                    add(\\n                        mload(integrityCheckState_),\\n                        add(0x20, mul(0x20, sourceIndex_))\\n                    )\\n                )\\n                end_ := add(cursor_, mload(cursor_))\\n            }\\n\\n            // Loop until complete.\\n            while (cursor_ < end_) {\\n                uint256 opcode_;\\n                Operand operand_;\\n                cursor_ += 4;\\n                assembly (\\\"memory-safe\\\") {\\n                    let op_ := mload(cursor_)\\n                    operand_ := and(op_, 0xFFFF)\\n                    opcode_ := and(shr(16, op_), 0xFFFF)\\n                }\\n                // We index into the function pointers here to ensure that any\\n                // opcodes that we don't have a pointer for will error.\\n                stackTop_ = integrityCheckState_.integrityFunctionPointers[\\n                    opcode_\\n                ](integrityCheckState_, operand_, stackTop_);\\n            }\\n            uint256 finalStackOutputs_ = integrityCheckState_\\n                .stackBottom\\n                .toIndex(stackTop_);\\n            if (minStackOutputs_ > finalStackOutputs_) {\\n                revert MinFinalStack(minStackOutputs_, finalStackOutputs_);\\n            }\\n            return stackTop_;\\n        }\\n    }\\n\\n    /// Push a single virtual item onto the virtual stack.\\n    /// Simply moves the stack top up one and syncs the interpreter max stack\\n    /// height with it if needed.\\n    /// @param integrityCheckState_ The state of the current integrity check.\\n    /// @param stackTop_ The pointer to the virtual stack top for the current\\n    /// integrity check.\\n    /// @return The stack top after it has pushed an item.\\n    function push(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        stackTop_ = stackTop_.up();\\n        integrityCheckState_.syncStackMaxTop(stackTop_);\\n        return stackTop_;\\n    }\\n\\n    /// Overloaded `push` to support `n_` pushes in a single movement.\\n    /// `n_` MAY be 0 and this is a virtual noop stack movement.\\n    /// @param integrityCheckState_ as per `push`.\\n    /// @param stackTop_ as per `push`.\\n    /// @param n_ The number of items to push to the virtual stack.\\n    function push(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        stackTop_ = stackTop_.up(n_);\\n        // Any time we push more than 1 item to the stack we move the highwater\\n        // _past_ it as nested multioutput is disallowed.\\n        if (\\n            n_ > 1 &&\\n            StackPointer.unwrap(stackTop_) >\\n            StackPointer.unwrap(integrityCheckState_.stackHighwater)\\n        ) {\\n            integrityCheckState_.stackHighwater = stackTop_;\\n        }\\n        integrityCheckState_.syncStackMaxTop(stackTop_);\\n        return stackTop_;\\n    }\\n\\n    /// As push for 0+ values. Does NOT move the highwater. This may be useful if\\n    /// the highwater is already calculated somehow by the caller.\\n    function pushIgnoreHighwater(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        stackTop_ = stackTop_.up(n_);\\n        integrityCheckState_.syncStackMaxTop(stackTop_);\\n        return stackTop_;\\n    }\\n\\n    /// Move the stock top down one item then check that it hasn't underflowed\\n    /// the stack bottom. If all virtual stack movements are defined in terms\\n    /// of pops and pushes this will enforce that the gross stack movements do\\n    /// not underflow, which would lead to out of bounds stack reads at runtime.\\n    /// @param integrityCheckState_ The state of the current integrity check.\\n    /// @param stackTop_ The virtual stack top before an item is popped.\\n    /// @return The virtual stack top after the pop.\\n    function pop(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        stackTop_ = stackTop_.down();\\n        integrityCheckState_.popUnderflowCheck(stackTop_);\\n        return stackTop_;\\n    }\\n\\n    /// Overloaded `pop` to support `n_` pops in a single movement.\\n    /// `n_` MAY be 0 and this is a virtual noop stack movement.\\n    /// @param integrityCheckState_ as per `pop`.\\n    /// @param stackTop_ as per `pop`.\\n    /// @param n_ The number of items to pop off the virtual stack.\\n    function pop(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        uint256 n_\\n    ) internal view returns (StackPointer) {\\n        console.log(\\\"pop\\\", n_, StackPointer.unwrap(stackTop_));\\n        if (n_ > 0) {\\n            stackTop_ = stackTop_.down(n_);\\n            integrityCheckState_.popUnderflowCheck(stackTop_);\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Ensures that pops have not underflowed the stack, i.e. that the stack\\n    /// top is not below the stack bottom. We set a large stack bottom that is\\n    /// impossible to underflow within gas limits with realistic pops so that\\n    /// we don't have to deal with a numeric underflow of the stack top.\\n    /// @param integrityCheckState_ As per `pop`.\\n    /// @param stackTop_ as per `pop`.\\n    function popUnderflowCheck(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_\\n    ) internal view {\\n        console.log(\\\"puc\\\", StackPointer.unwrap(stackTop_), StackPointer.unwrap(integrityCheckState_.stackHighwater));\\n        if (\\n            StackPointer.unwrap(stackTop_) <=\\n            StackPointer.unwrap(integrityCheckState_.stackHighwater)\\n        ) {\\n            revert StackPopUnderflow(\\n                integrityCheckState_.stackBottom.toIndex(\\n                    integrityCheckState_.stackHighwater\\n                ),\\n                integrityCheckState_.stackBottom.toIndex(stackTop_)\\n            );\\n        }\\n    }\\n\\n    /// Maps `function(uint256, uint256) internal view returns (uint256)` to pops\\n    /// and pushes repeatedly N times. The function itself is irrelevant we only\\n    /// care about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param n_ The number of times the function is applied to the stack.\\n    /// @return The stack top after the function has been applied n times.\\n    function applyFnN(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256) internal view returns (uint256),\\n        uint256 n_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, n_));\\n    }\\n\\n    /// Maps `function(uint256) internal view` to pops and pushes repeatedly N\\n    /// times. The function itself is irrelevant we only care about the\\n    /// signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param n_ The number of times the function is applied to the stack.\\n    /// @return The stack top after the function has been applied n times.\\n    function applyFnN(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256) internal view,\\n        uint256 n_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.pop(stackTop_, n_);\\n    }\\n\\n    /// Maps `function(uint256) internal view returns (uint256)` to pops and\\n    /// pushes once. The function itself is irrelevant we only care about the\\n    /// signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256) internal view returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.push(integrityCheckState_.pop(stackTop_));\\n    }\\n\\n    /// Maps `function(uint256, uint256) internal view` to pops and pushes once.\\n    /// The function itself is irrelevant we only care about the signature to\\n    /// know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256) internal view\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.pop(stackTop_, 2);\\n    }\\n\\n    /// Maps `function(uint256, uint256) internal view returns (uint256)` to\\n    /// pops and pushes once. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256) internal view returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, 2));\\n    }\\n\\n    /// Maps\\n    /// `function(uint256, uint256, uint256) internal view returns (uint256)` to\\n    /// pops and pushes once. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256) internal view returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, 3));\\n    }\\n\\n    /// Maps\\n    /// ```\\n    /// function(uint256, uint256, uint256, uint256)\\n    ///     internal\\n    ///     view\\n    ///     returns (uint256)\\n    /// ```\\n    /// to pops and pushes once. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256, uint256)\\n            internal\\n            view\\n            returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, 4));\\n    }\\n\\n    /// Maps `function(uint256[] memory) internal view returns (uint256)` to\\n    /// pops and pushes once given that we know the length of the dynamic array\\n    /// at deploy time. The function itself is irrelevant we only care about the\\n    /// signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param length_ The length of the dynamic input array.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256[] memory) internal view returns (uint256),\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(\\n                integrityCheckState_.pop(stackTop_, length_)\\n            );\\n    }\\n\\n    /// Maps\\n    /// ```\\n    /// function(uint256, uint256, uint256[] memory)\\n    ///     internal\\n    ///     view\\n    ///     returns (uint256)\\n    /// ```\\n    /// to pops and pushes once given that we know the length of the dynamic\\n    /// array at deploy time. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param length_ The length of the dynamic input array.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256),\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            return\\n                integrityCheckState_.push(\\n                    integrityCheckState_.pop(stackTop_, length_ + 2)\\n                );\\n        }\\n    }\\n\\n    /// Maps\\n    /// ```\\n    /// function(uint256, uint256, uint256, uint256[] memory)\\n    ///     internal\\n    ///     view\\n    ///     returns (uint256)\\n    /// ```\\n    /// to pops and pushes once given that we know the length of the dynamic\\n    /// array at deploy time. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param length_ The length of the dynamic input array.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256),\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            return\\n                integrityCheckState_.push(\\n                    integrityCheckState_.pop(stackTop_, length_ + 3)\\n                );\\n        }\\n    }\\n\\n    /// Maps\\n    /// ```\\n    /// function(uint256, uint256[] memory, uint256[] memory)\\n    ///     internal\\n    ///     view\\n    ///     returns (uint256[] memory)\\n    /// ```\\n    /// to pops and pushes once given that we know the length of the dynamic\\n    /// array at deploy time. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param length_ The length of the dynamic input array.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256[] memory, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256[] memory),\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            return\\n                integrityCheckState_.push(\\n                    integrityCheckState_.pop(stackTop_, length_ * 2 + 1),\\n                    length_\\n                );\\n        }\\n    }\\n\\n    /// Maps `function(Operand, uint256) internal view returns (uint256)` to\\n    /// pops and pushes once. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    ///\\n    /// The operand MUST NOT influence the stack movements if this application\\n    /// is to be valid.\\n    ///\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(Operand, uint256) internal view returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.push(integrityCheckState_.pop(stackTop_));\\n    }\\n\\n    /// Maps\\n    /// `function(Operand, uint256, uint256) internal view returns (uint256)` to\\n    /// pops and pushes once. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    ///\\n    /// The operand MUST NOT influence the stack movements if this application\\n    /// is to be valid.\\n    ///\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(Operand, uint256, uint256) internal view returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, 2));\\n    }\\n}\\n\",\"keccak256\":\"0x8f15d85e24237a4905e2a96def5b31d508950440f3da8bf18c8f4cc7c002f8b5\",\"license\":\"CAL\"},\"contracts/interpreter/ops/AllStandardOps.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"../../type/LibCast.sol\\\";\\nimport \\\"../../type/LibConvert.sol\\\";\\nimport \\\"../../array/LibUint256Array.sol\\\";\\nimport \\\"./chainlink/OpChainlinkOraclePrice.sol\\\";\\nimport \\\"./core/OpCall.sol\\\";\\nimport \\\"./core/OpSet.sol\\\";\\nimport \\\"./core/OpContext.sol\\\";\\nimport \\\"./core/OpContextRow.sol\\\";\\nimport \\\"./core/OpDebug.sol\\\";\\nimport \\\"./core/OpDoWhile.sol\\\";\\nimport \\\"./core/OpFoldContext.sol\\\";\\nimport \\\"./core/OpLoopN.sol\\\";\\nimport \\\"./core/OpReadMemory.sol\\\";\\nimport \\\"./crypto/OpHash.sol\\\";\\nimport \\\"./erc20/OpERC20BalanceOf.sol\\\";\\nimport \\\"./erc20/OpERC20TotalSupply.sol\\\";\\nimport \\\"./erc20/snapshot/OpERC20SnapshotBalanceOfAt.sol\\\";\\nimport \\\"./erc20/snapshot/OpERC20SnapshotTotalSupplyAt.sol\\\";\\nimport \\\"./erc721/OpERC721BalanceOf.sol\\\";\\nimport \\\"./erc721/OpERC721OwnerOf.sol\\\";\\nimport \\\"./erc1155/OpERC1155BalanceOf.sol\\\";\\nimport \\\"./erc1155/OpERC1155BalanceOfBatch.sol\\\";\\nimport \\\"./error/OpEnsure.sol\\\";\\nimport \\\"./evm/OpBlockNumber.sol\\\";\\nimport \\\"./evm/OpTimestamp.sol\\\";\\nimport \\\"./list/OpExplode32.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScale18.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScale18Div.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScale18Mul.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScaleBy.sol\\\";\\nimport \\\"./math/fixedPoint/OpFixedPointScaleN.sol\\\";\\nimport \\\"./math/logic/OpAny.sol\\\";\\nimport \\\"./math/logic/OpEagerIf.sol\\\";\\nimport \\\"./math/logic/OpEqualTo.sol\\\";\\nimport \\\"./math/logic/OpEvery.sol\\\";\\nimport \\\"./math/logic/OpGreaterThan.sol\\\";\\nimport \\\"./math/logic/OpIsZero.sol\\\";\\nimport \\\"./math/logic/OpLessThan.sol\\\";\\nimport \\\"./math/saturating/OpSaturatingAdd.sol\\\";\\nimport \\\"./math/saturating/OpSaturatingMul.sol\\\";\\nimport \\\"./math/saturating/OpSaturatingSub.sol\\\";\\nimport \\\"./math/OpAdd.sol\\\";\\nimport \\\"./math/OpDiv.sol\\\";\\nimport \\\"./math/OpExp.sol\\\";\\nimport \\\"./math/OpMax.sol\\\";\\nimport \\\"./math/OpMin.sol\\\";\\nimport \\\"./math/OpMod.sol\\\";\\nimport \\\"./math/OpMul.sol\\\";\\nimport \\\"./math/OpSub.sol\\\";\\nimport \\\"./rain/IOrderBookV1/OpIOrderBookV1VaultBalance.sol\\\";\\nimport \\\"./rain/ISaleV2/OpISaleV2RemainingTokenInventory.sol\\\";\\nimport \\\"./rain/ISaleV2/OpISaleV2Reserve.sol\\\";\\nimport \\\"./rain/ISaleV2/OpISaleV2SaleStatus.sol\\\";\\nimport \\\"./rain/ISaleV2/OpISaleV2Token.sol\\\";\\nimport \\\"./rain/ISaleV2/OpISaleV2TotalReserveReceived.sol\\\";\\nimport \\\"./rain/IVerifyV1/OpIVerifyV1AccountStatusAtTime.sol\\\";\\nimport \\\"./tier/OpITierV2Report.sol\\\";\\nimport \\\"./tier/OpITierV2ReportTimeForTier.sol\\\";\\nimport \\\"./tier/OpSaturatingDiff.sol\\\";\\nimport \\\"./tier/OpSelectLte.sol\\\";\\nimport \\\"./tier/OpUpdateTimesForTierRange.sol\\\";\\n\\n/// Thrown when a dynamic length array is NOT 1 more than a fixed length array.\\n/// Should never happen outside a major breaking change to memory layouts.\\nerror BadDynamicLength(uint256 dynamicLength, uint256 standardOpsLength);\\n\\n/// @dev Number of ops currently provided by `AllStandardOps`.\\nuint256 constant ALL_STANDARD_OPS_LENGTH = 58;\\n\\n/// @title AllStandardOps\\n/// @notice Every opcode available from the core repository laid out as a single\\n/// array to easily build function pointers for `IInterpreterV1`.\\nlibrary AllStandardOps {\\n    using LibCast for uint256;\\n    using LibCast for function(uint256) pure returns (uint256);\\n    using LibCast for function(InterpreterState memory, uint256, StackPointer)\\n        view\\n        returns (StackPointer);\\n    using LibCast for function(InterpreterState memory, uint256, StackPointer)\\n        pure\\n        returns (StackPointer);\\n    using LibCast for function(InterpreterState memory, uint256, StackPointer)\\n        view\\n        returns (StackPointer)[];\\n\\n    using AllStandardOps for function(\\n        IntegrityCheckState memory,\\n        Operand,\\n        StackPointer\\n    ) view returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1];\\n    using AllStandardOps for function(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer\\n    ) view returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1];\\n\\n    using AllStandardOps for uint256[ALL_STANDARD_OPS_LENGTH + 1];\\n\\n    using LibUint256Array for uint256[];\\n    using LibConvert for uint256[];\\n    using LibCast for uint256[];\\n    using LibCast for function(\\n        IntegrityCheckState memory,\\n        Operand,\\n        StackPointer\\n    ) view returns (StackPointer);\\n    using LibCast for function(\\n        IntegrityCheckState memory,\\n        Operand,\\n        StackPointer\\n    ) pure returns (StackPointer);\\n    using LibCast for function(\\n        IntegrityCheckState memory,\\n        Operand,\\n        StackPointer\\n    ) view returns (StackPointer)[];\\n    using LibCast for function(InterpreterState memory, Operand, StackPointer)\\n        view\\n        returns (StackPointer)[];\\n\\n    /// An oddly specific length conversion between a fixed and dynamic `uint256`\\n    /// array. This is useful for the purpose of building metadata for bounds\\n    /// checks and dispatch of all the standard ops provided by `Rainterpreter`.\\n    /// The cast will fail if the length of the dynamic array doesn't match the\\n    /// first item of the fixed array; it relies on differences in memory\\n    /// layout in Solidity that MAY change in the future. The rollback guards\\n    /// against changes in Solidity memory layout silently breaking this cast.\\n    /// @param fixed_ The fixed size `uint256` array to cast to a dynamic\\n    /// `uint256` array. Specifically the size is fixed to match the number of\\n    /// standard ops.\\n    /// @param dynamic_ The dynamic `uint256` array with length of the standard\\n    /// ops.\\n    function asUint256Array(\\n        function(IntegrityCheckState memory, Operand, StackPointer)\\n            view\\n            returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1]\\n            memory fixed_\\n    ) internal pure returns (uint256[] memory dynamic_) {\\n        assembly (\\\"memory-safe\\\") {\\n            dynamic_ := fixed_\\n        }\\n        if (dynamic_.length != ALL_STANDARD_OPS_LENGTH) {\\n            revert BadDynamicLength(dynamic_.length, ALL_STANDARD_OPS_LENGTH);\\n        }\\n    }\\n\\n    /// An oddly specific conversion between a fixed and dynamic `uint256` array.\\n    /// This is useful for the purpose of building function pointers for the\\n    /// runtime dispatch of all the standard ops provided by `Rainterpreter`.\\n    /// The cast will fail if the length of the dynamic array doesn't match the\\n    /// first item of the fixed array; it relies on differences in memory\\n    /// layout in Solidity that MAY change in the future. The rollback guards\\n    /// against changes in Solidity memory layout silently breaking this cast.\\n    /// @param fixed_ The fixed size `uint256` array to cast to a dynamic\\n    /// `uint256` array. Specifically the size is fixed to match the number of\\n    /// standard ops.\\n    /// @param dynamic_ The dynamic `uint256` array with length of the standard\\n    /// ops.\\n    function asUint256Array(\\n        function(InterpreterState memory, Operand, StackPointer)\\n            view\\n            returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1]\\n            memory fixed_\\n    ) internal pure returns (uint256[] memory dynamic_) {\\n        assembly (\\\"memory-safe\\\") {\\n            dynamic_ := fixed_\\n        }\\n        if (dynamic_.length != ALL_STANDARD_OPS_LENGTH) {\\n            revert BadDynamicLength(dynamic_.length, ALL_STANDARD_OPS_LENGTH);\\n        }\\n    }\\n\\n    function integrityFunctionPointers(\\n        function(IntegrityCheckState memory, Operand, StackPointer)\\n            view\\n            returns (StackPointer)[]\\n            memory locals_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(IntegrityCheckState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer)[]\\n                memory\\n        )\\n    {\\n        unchecked {\\n            function(IntegrityCheckState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1]\\n                memory pointersFixed_ = [\\n                    ALL_STANDARD_OPS_LENGTH.asIntegrityFunctionPointer(),\\n                    OpChainlinkOraclePrice.integrity,\\n                    OpCall.integrity,\\n                    OpContext.integrity,\\n                    OpContextRow.integrity,\\n                    OpDebug.integrity,\\n                    OpDoWhile.integrity,\\n                    OpFoldContext.integrity,\\n                    OpLoopN.integrity,\\n                    OpReadMemory.integrity,\\n                    OpSet.integrity,\\n                    OpHash.integrity,\\n                    OpERC20BalanceOf.integrity,\\n                    OpERC20TotalSupply.integrity,\\n                    OpERC20SnapshotBalanceOfAt.integrity,\\n                    OpERC20SnapshotTotalSupplyAt.integrity,\\n                    OpERC721BalanceOf.integrity,\\n                    OpERC721OwnerOf.integrity,\\n                    OpERC1155BalanceOf.integrity,\\n                    OpERC1155BalanceOfBatch.integrity,\\n                    OpEnsure.integrity,\\n                    OpBlockNumber.integrity,\\n                    OpTimestamp.integrity,\\n                    OpExplode32.integrity,\\n                    OpFixedPointScale18.integrity,\\n                    OpFixedPointScale18Div.integrity,\\n                    OpFixedPointScale18Mul.integrity,\\n                    OpFixedPointScaleBy.integrity,\\n                    OpFixedPointScaleN.integrity,\\n                    OpAny.integrity,\\n                    OpEagerIf.integrity,\\n                    OpEqualTo.integrity,\\n                    OpEvery.integrity,\\n                    OpGreaterThan.integrity,\\n                    OpIsZero.integrity,\\n                    OpLessThan.integrity,\\n                    OpSaturatingAdd.integrity,\\n                    OpSaturatingMul.integrity,\\n                    OpSaturatingSub.integrity,\\n                    OpAdd.integrity,\\n                    OpDiv.integrity,\\n                    OpExp.integrity,\\n                    OpMax.integrity,\\n                    OpMin.integrity,\\n                    OpMod.integrity,\\n                    OpMul.integrity,\\n                    OpSub.integrity,\\n                    OpIOrderBookV1VaultBalance.integrity,\\n                    OpISaleV2RemainingTokenInventory.integrity,\\n                    OpISaleV2Reserve.integrity,\\n                    OpISaleV2SaleStatus.integrity,\\n                    OpISaleV2Token.integrity,\\n                    OpISaleV2TotalReserveReceived.integrity,\\n                    OpIVerifyV1AccountStatusAtTime.integrity,\\n                    OpITierV2Report.integrity,\\n                    OpITierV2ReportTimeForTier.integrity,\\n                    OpSaturatingDiff.integrity,\\n                    OpSelectLte.integrity,\\n                    OpUpdateTimesForTierRange.integrity\\n                ];\\n            uint256[] memory pointers_ = pointersFixed_.asUint256Array();\\n            pointers_.extend(locals_.asUint256Array());\\n            return pointers_.asIntegrityPointers();\\n        }\\n    }\\n\\n    function opcodeFunctionPointers(\\n        function(InterpreterState memory, Operand, StackPointer)\\n            view\\n            returns (StackPointer)[]\\n            memory locals_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(InterpreterState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer)[]\\n                memory opcodeFunctionPointers_\\n        )\\n    {\\n        unchecked {\\n            function(InterpreterState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1]\\n                memory pointersFixed_ = [\\n                    ALL_STANDARD_OPS_LENGTH.asOpFunctionPointer(),\\n                    OpChainlinkOraclePrice.run,\\n                    OpCall.run,\\n                    OpContext.run,\\n                    OpContextRow.run,\\n                    OpDebug.run,\\n                    OpDoWhile.run,\\n                    OpFoldContext.run,\\n                    OpLoopN.run,\\n                    OpReadMemory.run,\\n                    OpSet.run,\\n                    OpHash.run,\\n                    OpERC20BalanceOf.run,\\n                    OpERC20TotalSupply.run,\\n                    OpERC20SnapshotBalanceOfAt.run,\\n                    OpERC20SnapshotTotalSupplyAt.run,\\n                    OpERC721BalanceOf.run,\\n                    OpERC721OwnerOf.run,\\n                    OpERC1155BalanceOf.run,\\n                    OpERC1155BalanceOfBatch.run,\\n                    OpEnsure.run,\\n                    OpBlockNumber.run,\\n                    OpTimestamp.run,\\n                    OpExplode32.run,\\n                    OpFixedPointScale18.run,\\n                    OpFixedPointScale18Div.run,\\n                    OpFixedPointScale18Mul.run,\\n                    OpFixedPointScaleBy.run,\\n                    OpFixedPointScaleN.run,\\n                    OpAny.run,\\n                    OpEagerIf.run,\\n                    OpEqualTo.run,\\n                    OpEvery.run,\\n                    OpGreaterThan.run,\\n                    OpIsZero.run,\\n                    OpLessThan.run,\\n                    OpSaturatingAdd.run,\\n                    OpSaturatingMul.run,\\n                    OpSaturatingSub.run,\\n                    OpAdd.run,\\n                    OpDiv.run,\\n                    OpExp.run,\\n                    OpMax.run,\\n                    OpMin.run,\\n                    OpMod.run,\\n                    OpMul.run,\\n                    OpSub.run,\\n                    OpIOrderBookV1VaultBalance.run,\\n                    OpISaleV2RemainingTokenInventory.run,\\n                    OpISaleV2Reserve.run,\\n                    OpISaleV2SaleStatus.run,\\n                    OpISaleV2Token.run,\\n                    OpISaleV2TotalReserveReceived.run,\\n                    OpIVerifyV1AccountStatusAtTime.run,\\n                    OpITierV2Report.run,\\n                    OpITierV2ReportTimeForTier.run,\\n                    OpSaturatingDiff.run,\\n                    OpSelectLte.run,\\n                    OpUpdateTimesForTierRange.run\\n                ];\\n            uint256[] memory pointers_ = pointersFixed_.asUint256Array();\\n            pointers_.extend(locals_.asUint256Array());\\n            opcodeFunctionPointers_ = pointers_.asOpcodeFunctionPointers();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x909d817a745759b57877e191e7d8fa8184a5372b75c71e762e9f70aeb18c73c3\",\"license\":\"CAL\"},\"contracts/interpreter/ops/chainlink/OpChainlinkOraclePrice.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {LibChainlink} from \\\"../../../chainlink/LibChainlink.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpChainlinkOraclePrice\\n/// @notice Opcode for chainlink oracle prices.\\nlibrary OpChainlinkOraclePrice {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 feed_,\\n        uint256 staleAfter_\\n    ) internal view returns (uint256) {\\n        return LibChainlink.price(address(uint160(feed_)), staleAfter_);\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x5ca6f91bcf9eaddcc75fe5d44f90ae4189452dc6ca685a119bfd46a08c257e31\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpCall.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"../../../math/Binary.sol\\\";\\n\\n/// @title OpCall\\n/// @notice Opcode for calling eval with a new scope. The construction of this\\n/// scope is split across integrity and runtime responsibilities. When the\\n/// integrity checks are done the expression being called has all its integrity\\n/// logic run, recursively if needed. The integrity checks are run against the\\n/// integrity state as it is but with the stack bottom set below the inputs to\\n/// the called source. This ensures that the sub-integrity checks do not\\n/// underflow what they perceive as a fresh stack, and it ensures that we set the\\n/// stack length long enough to cover all sub-executions as a single array in\\n/// memory. At runtime we trust the integrity checks have allocated enough runway\\n/// in the stack for all our recursive sub-calls so we simply move the stack\\n/// bottom in the state below the inputs during the call and move it back to\\n/// where it was after the call. Notably this means that reading from the stack\\n/// in the called source will 0 index from the first input, NOT the bottom of\\n/// the calling stack.\\nlibrary OpCall {\\n    using LibIntegrityCheck for IntegrityCheckState;\\n    using LibStackPointer for StackPointer;\\n    using LibInterpreterState for InterpreterState;\\n    using LibUint256Array for uint256;\\n\\n    /// Interpreter integrity logic.\\n    /// The basic movements on the outer stack are to pop the inputs and push the\\n    /// outputs, but the called source doesn't have access to a separately\\n    /// allocated region of memory. There's only a single shared memory\\n    /// allocation for all executions and sub-executions, so we recursively run\\n    /// integrity checks on the called source relative to the current stack\\n    /// position.\\n    /// @param integrityCheckState_ The state of the current integrity check.\\n    /// @param operand_ The operand associated with this call.\\n    /// @param stackTop_ The current stack top within the integrity check.\\n    /// @return stackTopAfter_ The stack top after the call movements are applied.\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        // Unpack the operand to get IO and the source to be called.\\n        uint256 inputs_ = Operand.unwrap(operand_) & MASK_4BIT;\\n        uint256 outputs_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\\n        SourceIndex callSourceIndex_ = SourceIndex.wrap(\\n            Operand.unwrap(operand_) >> 8\\n        );\\n\\n        // Remember the outer stack bottom and highwater.\\n        StackPointer stackBottom_ = integrityCheckState_.stackBottom;\\n        StackPointer stackHighwater_ = integrityCheckState_.stackHighwater;\\n\\n        // Set the inner stack bottom to below the inputs and highwater to\\n        // protect the inputs from being popped internally.\\n        integrityCheckState_.stackBottom = integrityCheckState_.pop(\\n            stackTop_,\\n            inputs_\\n        );\\n        integrityCheckState_.stackHighwater = stackTop_.down();\\n\\n        // Ensure the integrity of the inner source on the current state using\\n        // the stack top above the inputs as the starting stack top.\\n        // Contraints namespace is irrelevant here.\\n        integrityCheckState_.ensureIntegrity(\\n            callSourceIndex_,\\n            stackTop_,\\n            outputs_\\n        );\\n\\n        // Reinstate the original highwater before handling outputs as single\\n        // outputs can be nested but multioutput will move the highwater.\\n        integrityCheckState_.stackHighwater = stackHighwater_;\\n\\n        // The outer stack top will move above the outputs relative to the inner\\n        // stack bottom. At runtime any values that are not outputs will be\\n        // removed so they do not need to be accounted for here.\\n        stackTopAfter_ = integrityCheckState_.push(\\n            integrityCheckState_.stackBottom,\\n            outputs_\\n        );\\n\\n        // Reinstate the outer stack bottom.\\n        integrityCheckState_.stackBottom = stackBottom_;\\n    }\\n\\n    /// Call eval with a new scope.\\n    /// @param state_ The state of the current evaluation.\\n    /// @param operand_ The operand associated with this call.\\n    /// @param stackTop_ The current stack top within the evaluation.\\n    /// @return stackTopAfter_ The stack top after the call is evaluated.\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        // Unpack the operand to get IO and the source to be called.\\n        uint256 inputs_ = Operand.unwrap(operand_) & MASK_4BIT;\\n        uint256 outputs_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\\n        SourceIndex callSourceIndex_ = SourceIndex.wrap(\\n            Operand.unwrap(operand_) >> 8\\n        );\\n\\n        // Remember the outer stack bottom.\\n        StackPointer stackBottom_ = state_.stackBottom;\\n\\n        // Set the inner stack bottom to below the inputs.\\n        state_.stackBottom = stackTop_.down(inputs_);\\n\\n        // Eval the source from the operand on the current state using the stack\\n        // top above the inputs as the starting stack top. The final stack top\\n        // is where we will read outputs from below.\\n        StackPointer stackTopEval_ = state_.eval(callSourceIndex_, stackTop_);\\n        // Normalize the inner final stack so that it contains only the outputs\\n        // starting from the inner stack bottom.\\n        LibUint256Array.unsafeCopyValuesTo(\\n            StackPointer.unwrap(stackTopEval_.down(outputs_)),\\n            StackPointer.unwrap(state_.stackBottom),\\n            outputs_\\n        );\\n\\n        // The outer stack top should now point above the outputs.\\n        stackTopAfter_ = state_.stackBottom.up(outputs_);\\n\\n        // The outer stack bottom needs to be reinstated as it was before eval.\\n        state_.stackBottom = stackBottom_;\\n    }\\n}\\n\",\"keccak256\":\"0x4f1036707ef6cb3932d5809f1a915fec781bffb3fc1a8e400b9c88e4255fe65d\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpContext.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"../../../math/Binary.sol\\\";\\n\\n/// @title OpContext\\n/// @notice Opcode for stacking from the context. Context requires slightly\\n/// different handling to other memory reads as it is working with data that\\n/// is provided at runtime from the calling contract on a per-eval basis so\\n/// cannot be predicted at deploy time.\\nlibrary OpContext {\\n    using LibStackPointer for StackPointer;\\n    using LibInterpreterState for InterpreterState;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    /// Interpreter integrity logic.\\n    /// Context pushes a single value to the stack from the context array.\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        // Note that a expression with context can error at runtime due to OOB\\n        // reads that we don't know about here.\\n        return integrityCheckState_.push(stackTop_);\\n    }\\n\\n    /// Stack a value from the context WITH OOB checks from solidity.\\n    /// The bounds checks are done at runtime because context MAY be provided\\n    /// by the end user with arbitrary length.\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        // The indexing syntax here enforces OOB checks at runtime.\\n        return\\n            stackTop_.push(\\n                state_.context[Operand.unwrap(operand_) >> 8][\\n                    Operand.unwrap(operand_) & MASK_8BIT\\n                ]\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x3b3d94b3b6c60e0f20e415a57ac114974751c411b820f53e18780a8c1989a8d5\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpContextRow.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"../../../math/Binary.sol\\\";\\n\\n/// @title OpContextRow\\n/// @notice Opcode for stacking a dynamic row from the context. Context requires\\n/// slightly different handling to other memory reads as it is working with data\\n/// that is provided at runtime. `OpContextRow` works exactly like `OpContext`\\n/// but the row is provided from the stack instead of the operand. We rely on\\n/// Solidity OOB checks at runtime to enforce that the index from the stack is\\n/// within bounds at runtime. As we do NOT know statically which row will be read\\n/// the context reads is set to the entire column.\\nlibrary OpContextRow {\\n    using LibStackPointer for StackPointer;\\n    using LibInterpreterState for InterpreterState;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    /// Interpreter integrity logic.\\n    /// Context pushes a single value to the stack from memory.\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        // Note that a expression with context can error at runtime due to OOB\\n        // reads that we don't know about here.\\n        function(uint256) internal pure returns (uint256) fn_;\\n        return integrityCheckState_.applyFn(stackTop_, fn_);\\n    }\\n\\n    /// Stack a value from the context WITH OOB checks from solidity.\\n    /// The bounds checks are done at runtime because context MAY be provided\\n    /// by the end user with arbitrary length.\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        // The indexing syntax here enforces OOB checks at runtime.\\n        (StackPointer location_, uint256 row_) = stackTop_.pop();\\n        location_.set(state_.context[Operand.unwrap(operand_)][row_]);\\n        return stackTop_;\\n    }\\n}\\n\",\"keccak256\":\"0xb21eb981a50d7cce88e6c0a5baa82b934935697323f4ddd3ec444df029425418\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpDebug.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpDebug\\n/// @notice Opcode for debugging state. Uses the standard debugging logic from\\n/// InterpreterState.debug.\\nlibrary OpDebug {\\n    using LibStackPointer for StackPointer;\\n    using LibInterpreterState for InterpreterState;\\n\\n    /// Interpreter integrity for debug.\\n    /// Debug doesn't modify the stack.\\n    function integrity(\\n        IntegrityCheckState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        // Try to build a debug style from the operand to ensure we can enumerate\\n        // it.\\n        DebugStyle(Operand.unwrap(operand_));\\n        return stackTop_;\\n    }\\n\\n    /// Debug the current state.\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        DebugStyle debugStyle_ = DebugStyle(Operand.unwrap(operand_));\\n\\n        state_.debug(stackTop_, debugStyle_);\\n\\n        return stackTop_;\\n    }\\n}\\n\",\"keccak256\":\"0x98bf9ef4a0d7c83a6a9fbcc22adc3b18833df761a3c5af22ac786df19546f872\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpDoWhile.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"./OpCall.sol\\\";\\n\\n/// More inputs were encoded in the operand than can be dispatched internally by\\n/// a do-while loop.\\nerror DoWhileMaxInputs(uint256 inputs);\\n\\n/// @title OpDoWhile\\n/// @notice Opcode for looping while the stack top is nonzero. As we pre-allocate\\n/// all the memory for execution during integrity checks we have an apparent\\n/// contradiction here. If we do not know how many times the loop will run then\\n/// we cannot calculate the final stack height or intermediate pops and pushes.\\n/// To solve this we simply wrap `OpCall` which already has fixed inputs and\\n/// outputs and enforce that the outputs of each iteration is 1 more than the\\n/// inputs. We then consume the extra output as the condition for the decision\\n/// to loop again, thus the outputs = inputs for every iteration. If the stack\\n/// height does not change between iterations we do not care how many times we\\n/// loop (although the user paying gas might).\\nlibrary OpDoWhile {\\n    using LibIntegrityCheck for IntegrityCheckState;\\n    using LibStackPointer for StackPointer;\\n    using LibInterpreterState for InterpreterState;\\n\\n    /// Interpreter integrity for do while.\\n    /// The loop itself pops a single value from the stack to determine whether\\n    /// it should run another iteration of the loop. The source called by the\\n    /// loop must then put a value back on the stack in the same position to\\n    /// either continue or break the loop.\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\\n            /// We need outputs to be _larger than_ inputs so inputs must be\\n            /// _strictly less than_ the max value possible in 4 bits or outputs\\n            /// will overflow.\\n            if (inputs_ >= MASK_4BIT) {\\n                revert DoWhileMaxInputs(inputs_);\\n            }\\n            uint256 outputs_ = inputs_ + 1;\\n            Operand callOperand_ = Operand.wrap(\\n                Operand.unwrap(operand_) | (outputs_ << 4)\\n            );\\n            // Stack height changes are deterministic so if we call once we've\\n            // called a thousand times. Also we pop one output off the result of\\n            // the call to check the while condition.\\n            return\\n                integrityCheckState_.pop(\\n                    OpCall.integrity(\\n                        integrityCheckState_,\\n                        callOperand_,\\n                        stackTop_\\n                    )\\n                );\\n        }\\n    }\\n\\n    /// Loop the stack while the stack top is true.\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\\n            uint256 outputs_ = inputs_ + 1;\\n            Operand callOperand_ = Operand.wrap(\\n                Operand.unwrap(operand_) | (outputs_ << 4)\\n            );\\n            uint256 do_;\\n            (stackTop_, do_) = stackTop_.pop();\\n            while (do_ > 0) {\\n                stackTop_ = OpCall.run(state_, callOperand_, stackTop_);\\n                (stackTop_, do_) = stackTop_.pop();\\n            }\\n            return stackTop_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1b782373c5c8243cd083dd6fd6aa38d19658680dceaafe9750fcf7d59ec99eb3\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpFoldContext.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"./OpCall.sol\\\";\\n\\n/// @title OpFoldContext\\n/// Folds over columns of context from their start to end. Expressions do not\\n/// have a good way of handling dynamic lengths of things, and that is\\n/// intentional to avoid end users having to write out looping constructs of the\\n/// form `i = 0; i < length; i++` is is so tedious and error prone in software\\n/// development generally. It is very easy to implement \\\"off by one\\\" errors in\\n/// this form, and requires sourcing a length from somewhere. This opcode exposes\\n/// a pretty typical fold as found elsewhere in functional programming. A start\\n/// column and width of columns can be specified, the rows will be iterated and\\n/// pushed to the stack on top of any additional inputs specified by the\\n/// expression. The additional inputs are the accumulators and so the number of\\n/// outputs in the called source needs to match the number of accumulator inputs.\\nlibrary OpFoldContext {\\n    using LibIntegrityCheck for IntegrityCheckState;\\n    using LibStackPointer for StackPointer;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 sourceIndex_ = Operand.unwrap(operand_) & MASK_4BIT;\\n            // We don't use the column for anything in the integrity check.\\n            // uint256 column_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\\n            uint256 width_ = (Operand.unwrap(operand_) >> 8) & MASK_4BIT;\\n            uint256 inputs_ = Operand.unwrap(operand_) >> 12;\\n            uint256 callInputs_ = width_ + inputs_;\\n\\n            // Outputs for call is the same as the inputs.\\n            Operand callOperand_ = Operand.wrap(\\n                (sourceIndex_ << 8) | (inputs_ << 4) | callInputs_\\n            );\\n\\n            // First the width of the context columns being folded is pushed to\\n            // the stack. Ignore the highwater here as `OpCall.integrity` has its\\n            // own internal highwater handling over all its inputs and outputs.\\n            stackTop_ = integrityCheckState_.pushIgnoreHighwater(\\n                stackTop_,\\n                width_\\n            );\\n            // Then we loop over call taking the width and extra inputs, then\\n            // returning the same number of outputs as non-width inputs.\\n            return\\n                OpCall.integrity(integrityCheckState_, callOperand_, stackTop_);\\n        }\\n    }\\n\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 sourceIndex_ = Operand.unwrap(operand_) & MASK_4BIT;\\n            uint256 column_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\\n            uint256 width_ = (Operand.unwrap(operand_) >> 8) & MASK_4BIT;\\n            uint256 inputs_ = Operand.unwrap(operand_) >> 12;\\n            // Call will take the width of the context rows being copied and the\\n            // base inputs that will be the accumulators of the fold.\\n            uint256 callInputs_ = width_ + inputs_;\\n\\n            // Fold over the entire context. This will error with an OOB index\\n            // if the context columns are not of the same length.\\n            for (uint256 i_ = 0; i_ < state_.context[column_].length; i_++) {\\n                // Push the width of the context columns onto the stack as rows.\\n                for (uint256 j_ = 0; j_ < width_; j_++) {\\n                    stackTop_ = stackTop_.push(\\n                        state_.context[column_ + j_][i_]\\n                    );\\n                }\\n                // The outputs of call are the same as the base inputs, this is\\n                // similar to `OpDoWhile` so that we don't have to care how many\\n                // iterations there are in order to calculate the stack.\\n                Operand callOperand_ = Operand.wrap(\\n                    (sourceIndex_ << 8) | (inputs_ << 4) | callInputs_\\n                );\\n                stackTop_ = OpCall.run(state_, callOperand_, stackTop_);\\n            }\\n\\n            return stackTop_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x64f3040161d7cbee8b17325af7d40efc23392f413c3fd152be3b416d5d7bff8e\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpGet.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpGet\\n/// @notice Opcode for reading from storage.\\nlibrary OpGet {\\n    using LibStackPointer for StackPointer;\\n    using LibInterpreterState for InterpreterState;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            // Pop key\\n            // Stack value\\n            function(uint256) internal pure returns (uint256) fn_;\\n            return integrityCheckState_.applyFn(stackTop_, fn_);\\n        }\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer\\n    ) internal pure returns (StackPointer) {\\n        // This must be implemented on the interpreter itself so that storage\\n        // reads can happen.\\n        revert(\\\"UNIMPLEMENTED\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x603a89979fe8a391dddd00568e2233189028a37b573198266c79228a791cb3ff\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpLoopN.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"./OpCall.sol\\\";\\n\\n/// @title OpLoopN\\n/// @notice Opcode for looping a static number of times. A thin wrapper around\\n/// `OpCall` with the 4 high bits as a number of times to loop. Each iteration\\n/// will use the outputs of the previous iteration as its inputs so the inputs\\n/// to call must be greater or equal to the outputs. If the outputs exceed the\\n/// inputs then each subsequent call will take as many inputs as it needs from\\n/// the top of the intermediate stack. The net outputs to the stack will include\\n/// all the intermediate excess outputs as:\\n/// `outputs + (inputs - outputs) * n`\\nlibrary OpLoopN {\\n    using LibStackPointer for StackPointer;\\n    using LibInterpreterState for InterpreterState;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 n_ = Operand.unwrap(operand_) >> 12;\\n            uint256 inputs_ = Operand.unwrap(operand_) & MASK_4BIT;\\n            uint256 outputs_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\\n            require(inputs_ >= outputs_, \\\"LOOP_N_INPUTS\\\");\\n            Operand callOperand_ = Operand.wrap(\\n                Operand.unwrap(operand_) & MASK_12BIT\\n            );\\n            for (uint256 i_ = 0; i_ < n_; i_++) {\\n                stackTop_ = OpCall.integrity(\\n                    integrityCheckState_,\\n                    callOperand_,\\n                    stackTop_\\n                );\\n            }\\n            return stackTop_;\\n        }\\n    }\\n\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        uint256 n_ = Operand.unwrap(operand_) >> 12;\\n        Operand callOperand_ = Operand.wrap(\\n            Operand.unwrap(operand_) & MASK_12BIT\\n        );\\n        for (uint256 i_ = 0; i_ < n_; i_++) {\\n            stackTop_ = OpCall.run(state_, callOperand_, stackTop_);\\n        }\\n        return stackTop_;\\n    }\\n}\\n\",\"keccak256\":\"0x8a07ef9a4f13fa5f7185647ad03b9b0b19fae4d94dd8adfe1a1cfa98116e26a4\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpReadMemory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"../../../math/Binary.sol\\\";\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// Thrown when a stack read index is outside the current stack top.\\nerror OutOfBoundsStackRead(uint256 stackTopIndex, uint256 stackRead);\\n\\n/// Thrown when a constant read index is outside the constants array.\\nerror OutOfBoundsConstantsRead(uint256 constantsLength, uint256 constantsRead);\\n\\nuint256 constant OPCODE_MEMORY_TYPE_STACK = 0;\\nuint256 constant OPCODE_MEMORY_TYPE_CONSTANT = 1;\\n\\n/// @title OpReadMemory\\n/// @notice Opcode for stacking from the interpreter state in memory. This can\\n/// either be copying values from anywhere in the stack or from the constants\\n/// array by index.\\nlibrary OpReadMemory {\\n    using LibStackPointer for StackPointer;\\n    using LibInterpreterState for InterpreterState;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n    using Math for uint256;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        uint256 type_ = Operand.unwrap(operand_) & MASK_1BIT;\\n        uint256 offset_ = Operand.unwrap(operand_) >> 1;\\n        if (type_ == OPCODE_MEMORY_TYPE_STACK) {\\n            uint256 stackTopIndex_ = integrityCheckState_.stackBottom.toIndex(\\n                stackTop_\\n            );\\n            if (offset_ >= stackTopIndex_) {\\n                revert OutOfBoundsStackRead(stackTopIndex_, offset_);\\n            }\\n\\n            console.log(\\n                \\\"before\\\",\\n                StackPointer.unwrap(integrityCheckState_.stackBottom),\\n                StackPointer.unwrap(integrityCheckState_.stackHighwater)\\n            );\\n            // Ensure that highwater is moved past any stack item that we\\n            // read so that copied values cannot later be consumed.\\n            integrityCheckState_.stackHighwater = StackPointer.wrap(\\n                StackPointer.unwrap(integrityCheckState_.stackHighwater).max(\\n                    StackPointer.unwrap(\\n                        integrityCheckState_.stackBottom.up(offset_)\\n                    )\\n                )\\n            );\\n            console.log(\\n                \\\"after\\\",\\n                StackPointer.unwrap(integrityCheckState_.stackBottom),\\n                StackPointer.unwrap(integrityCheckState_.stackHighwater)\\n            );\\n        } else {\\n            if (offset_ >= integrityCheckState_.constantsLength) {\\n                revert OutOfBoundsConstantsRead(\\n                    integrityCheckState_.constantsLength,\\n                    offset_\\n                );\\n            }\\n        }\\n        return integrityCheckState_.push(stackTop_);\\n    }\\n\\n    function run(\\n        InterpreterState memory state_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            uint256 type_ = Operand.unwrap(operand_) & MASK_1BIT;\\n            uint256 offset_ = Operand.unwrap(operand_) >> 1;\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(\\n                    stackTop_,\\n                    mload(\\n                        add(\\n                            mload(add(state_, mul(0x20, type_))),\\n                            mul(0x20, offset_)\\n                        )\\n                    )\\n                )\\n            }\\n            return StackPointer.wrap(StackPointer.unwrap(stackTop_) + 0x20);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3dac3c781d76ae3dba79ba53fd8fdf1c36af032071dd44e203f455c31a8a6797\",\"license\":\"CAL\"},\"contracts/interpreter/ops/core/OpSet.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"../../../kv/LibMemoryKV.sol\\\";\\n\\n/// @title OpSet\\n/// @notice Opcode for recording k/v state changes to be set in storage.\\nlibrary OpSet {\\n    using LibStackPointer for StackPointer;\\n    using LibInterpreterState for InterpreterState;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n    using LibMemoryKV for MemoryKV;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            function(uint256, uint256) internal pure fn_;\\n            return integrityCheckState_.applyFn(stackTop_, fn_);\\n        }\\n    }\\n\\n    function run(\\n        InterpreterState memory state_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            uint256 k_;\\n            uint256 v_;\\n            (stackTop_, v_) = stackTop_.pop();\\n            (stackTop_, k_) = stackTop_.pop();\\n            state_.stateKV = state_.stateKV.setVal(\\n                MemoryKVKey.wrap(k_),\\n                MemoryKVVal.wrap(v_)\\n            );\\n            return stackTop_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x973fea5361ad8b959671852f077100b32e565b5ae76d0dcf843ab7d7fe9aa6a9\",\"license\":\"CAL\"},\"contracts/interpreter/ops/crypto/OpHash.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../../type/LibCast.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpHash\\n/// @notice Opcode for hashing a list of values.\\nlibrary OpHash {\\n    using LibStackPointer for StackPointer;\\n    using LibCast for uint256[];\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256[] memory values_) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encodePacked(values_)));\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFn(\\n                stackTop_,\\n                f,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    // Stack the return of `balanceOfBatch`.\\n    // Operand will be the length\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x4d2704ca251d6ee75fa7631c0f917ca8819e4fd93120ac121a7f70b934b291fe\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc1155/OpERC1155BalanceOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC1155Upgradeable as IERC1155} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpERC1155BalanceOf\\n/// @notice Opcode for getting the current erc1155 balance of an account.\\nlibrary OpERC1155BalanceOf {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 token_,\\n        uint256 account_,\\n        uint256 id_\\n    ) internal view returns (uint256) {\\n        return\\n            IERC1155(address(uint160(token_))).balanceOf(\\n                address(uint160(account_)),\\n                id_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0xd19790732530aa7f49b2e9691c15c5bb5889d585d6c96e9156432e12bf6e59dd\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc1155/OpERC1155BalanceOfBatch.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC1155Upgradeable as IERC1155} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../../type/LibCast.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpERC1155BalanceOfBatch\\n/// @notice Opcode for getting the current erc1155 balance of an accounts batch.\\nlibrary OpERC1155BalanceOfBatch {\\n    using LibStackPointer for StackPointer;\\n    using LibCast for uint256[];\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 token_,\\n        uint256[] memory accounts_,\\n        uint256[] memory ids_\\n    ) internal view returns (uint256[] memory) {\\n        return\\n            IERC1155(address(uint160(token_))).balanceOfBatch(\\n                accounts_.asAddresses(),\\n                ids_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFn(\\n                stackTop_,\\n                f,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    // Operand will be the length\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xd038851fe568218d82a65b502bfa977fab09bec74e439d1ac481361d6043dbcd\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc20/OpERC20BalanceOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpERC20BalanceOf\\n/// @notice Opcode for ERC20 `balanceOf`.\\nlibrary OpERC20BalanceOf {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 token_,\\n        uint256 account_\\n    ) internal view returns (uint256) {\\n        return\\n            IERC20(address(uint160(token_))).balanceOf(\\n                address(uint160(account_))\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x51469ce42b26be8ca5662b6cd9fb953f982c2c8b1722ab8e23c8c6263a75631e\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc20/OpERC20TotalSupply.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpERC20TotalSupply\\n/// @notice Opcode for ERC20 `totalSupply`.\\nlibrary OpERC20TotalSupply {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256 token_) internal view returns (uint256) {\\n        return IERC20(address(uint160(token_))).totalSupply();\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x5f4ff6a101657b264dd471fe39ccc1def836d9be50c2288f5222a6a4ebfbc6f9\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc20/snapshot/OpERC20SnapshotBalanceOfAt.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {ERC20SnapshotUpgradeable as ERC20Snapshot} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpERC20SnapshotBalanceOfAt\\n/// @notice Opcode for Open Zeppelin `ERC20Snapshot.balanceOfAt`.\\n/// https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20Snapshot\\nlibrary OpERC20SnapshotBalanceOfAt {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 token_,\\n        uint256 account_,\\n        uint256 snapshotId_\\n    ) internal view returns (uint256) {\\n        return\\n            ERC20Snapshot(address(uint160(token_))).balanceOfAt(\\n                address(uint160(account_)),\\n                snapshotId_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x144afe0ac30c78faf55e1f14c8c9be932cce73b229322126a7053acdaa60a9b6\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc20/snapshot/OpERC20SnapshotTotalSupplyAt.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {ERC20SnapshotUpgradeable as ERC20Snapshot} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpERC20SnapshotTotalSupplyAt\\n/// @notice Opcode for Open Zeppelin `ERC20Snapshot.totalSupplyAt`.\\n/// https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20Snapshot\\nlibrary OpERC20SnapshotTotalSupplyAt {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 token_,\\n        uint256 snapshotId_\\n    ) internal view returns (uint256) {\\n        return\\n            ERC20Snapshot(address(uint160(token_))).totalSupplyAt(snapshotId_);\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x1068e6242be4c76b24d4049fbc69486be77767aad3a65529112615c0eec51788\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc721/OpERC721BalanceOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC721Upgradeable as IERC721} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpERC721BalanceOf\\n/// @notice Opcode for getting the current erc721 balance of an account.\\nlibrary OpERC721BalanceOf {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 token_,\\n        uint256 account_\\n    ) internal view returns (uint256) {\\n        return\\n            IERC721(address(uint160(token_))).balanceOf(\\n                address(uint160(account_))\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x94e8b3b46404d65c81be784e8d76885cd34ae9f6e601d240bcaea07be81ee2ee\",\"license\":\"CAL\"},\"contracts/interpreter/ops/erc721/OpERC721OwnerOf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport {IERC721Upgradeable as IERC721} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpERC721OwnerOf\\n/// @notice Opcode for getting the current erc721 owner of an account.\\nlibrary OpERC721OwnerOf {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 token_,\\n        uint256 id_\\n    ) internal view returns (uint256) {\\n        return uint256(uint160(IERC721(address(uint160(token_))).ownerOf(id_)));\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x457ecb9665391c6a1f0921bc63683e1ba5267280459350fc1d3c157c3b0422ed\",\"license\":\"CAL\"},\"contracts/interpreter/ops/error/OpEnsure.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpEnsure\\n/// @notice Opcode for requiring some truthy values.\\nlibrary OpEnsure {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256 a_) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            if iszero(a_) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                f,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFnN(f, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xd1f1fd8b2b6ec2b3b30cef309d32d0fa6b1b3c5ee4db25a4178e136e0ed2cc21\",\"license\":\"CAL\"},\"contracts/interpreter/ops/evm/OpBlockNumber.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpBlockNumber\\n/// @notice Opcode for getting the current block number.\\nlibrary OpBlockNumber {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        return integrityCheckState_.push(stackTop_);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.push(block.number);\\n    }\\n}\\n\",\"keccak256\":\"0xb85e4f44310c0c1c19a39df2b6effef527d31f643895a5ccffd460432e6a4367\",\"license\":\"CAL\"},\"contracts/interpreter/ops/evm/OpTimestamp.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpTimestamp\\n/// @notice Opcode for getting the current timestamp.\\nlibrary OpTimestamp {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        return integrityCheckState_.push(stackTop_);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.push(block.timestamp);\\n    }\\n}\\n\",\"keccak256\":\"0xc74e68245cd8a07e3fcf7cb8845e00bdea2301b5679065a5fa14c119b9092b6d\",\"license\":\"CAL\"},\"contracts/interpreter/ops/list/OpExplode32.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpExplode\\n/// @notice Opcode for exploding a single value into 8x 32 bit integers.\\nlibrary OpExplode32 {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_), 8);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        (StackPointer location_, uint256 i_) = stackTop_.pop();\\n        uint256 mask_ = uint256(type(uint32).max);\\n        return\\n            location_.push(\\n                i_ & mask_,\\n                (i_ >> 0x20) & mask_,\\n                (i_ >> 0x40) & mask_,\\n                (i_ >> 0x60) & mask_,\\n                (i_ >> 0x80) & mask_,\\n                (i_ >> 0xA0) & mask_,\\n                (i_ >> 0xC0) & mask_,\\n                (i_ >> 0xE0) & mask_\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xb9f4fb1f976aa0cc1aeb506d9f4282a773d0eeef81811d0374b225eb049856f9\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpAdd.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../array/LibUint256Array.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpAdd\\n/// @notice Opcode for adding N numbers with error on overflow.\\nlibrary OpAdd {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    /// Addition with implied overflow checks from the Solidity 0.8.x compiler.\\n    function f(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ + b_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                f,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFnN(f, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xc195e645f999eb46d6b5aa9ddf48db2d0d9333ba2a52b9fad038f1649b93f82b\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpDiv.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpDiv\\n/// @notice Opcode for dividing N numbers.\\nlibrary OpDiv {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _div(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ / b_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                _div,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return stackTop_.applyFnN(_div, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x58aa79b99a9e9a38c1524d7c9581e91e02cb24d27a3c65157932665662311493\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpExp.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpExp\\n/// @notice Opcode to exponentiate N numbers.\\nlibrary OpExp {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _exp(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ ** b_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                _exp,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return stackTop_.applyFnN(_exp, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x8a6c4600f9ae130397e1b3e55f536aa6f1890e46929bb36418ddfd5d389cdb07\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpMax.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpMax\\n/// @notice Opcode to stack the maximum of N numbers.\\nlibrary OpMax {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _max(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ > b_ ? a_ : b_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                _max,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return stackTop_.applyFnN(_max, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xb4db82d68a574987b9aef58e13c0ff03289fa2c335d258df845417be67ce8956\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpMin.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpMin\\n/// @notice Opcode to stack the minimum of N numbers.\\nlibrary OpMin {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _min(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ < b_ ? a_ : b_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                _min,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return stackTop_.applyFnN(_min, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xd7f7f78633f1c429184854be5f5c51f64191b54f3f4e31779004439e5e7bf278\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpMod.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpMod\\n/// @notice Opcode to mod N numbers.\\nlibrary OpMod {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _mod(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ % b_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                _mod,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return stackTop_.applyFnN(_mod, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xb04cbdc74cfe4c3d384d879182bdcfecd0f497a9910a7b4c659d6b859e076b88\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpMul.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpMul\\n/// @notice Opcode for multiplying N numbers.\\nlibrary OpMul {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _mul(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ * b_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                _mul,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return stackTop_.applyFnN(_mul, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0xbe40dac40887e6b86c60bf6df1b58da55270db10fe15f01a6ec905fa35555324\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/OpSub.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpSub\\n/// @notice Opcode for subtracting N numbers.\\nlibrary OpSub {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _sub(uint256 a_, uint256 b_) internal pure returns (uint256) {\\n        return a_ - b_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                _sub,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return stackTop_.applyFnN(_sub, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x5cb8c344129397f448a9cd4465079c3c357afcf552cc7d567e46e2102b6190f0\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/fixedPoint/OpFixedPointScale18.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpFixedPointScale18\\n/// @notice Opcode for scaling a number to 18 fixed point.\\nlibrary OpFixedPointScale18 {\\n    using FixedPointMath for uint256;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        Operand operand_,\\n        uint256 a_\\n    ) internal pure returns (uint256) {\\n        return a_.scale18(Operand.unwrap(operand_));\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0xba89c22f9ac2881d07cd83b6c20118ef3b727ca2eb35c73b1efed433b2bcf03e\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/fixedPoint/OpFixedPointScale18Div.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpFixedPointScale18Div\\n/// @notice Opcode for performing scale 18 fixed point division.\\nlibrary OpFixedPointScale18Div {\\n    using FixedPointMath for uint256;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        Operand operand_,\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        return a_.scale18(Operand.unwrap(operand_)).fixedPointDiv(b_);\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0x73df3efa5b9f319bef39566d4dce85dc15918d3e220160dc3859cad69ab31902\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/fixedPoint/OpFixedPointScale18Mul.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpFixedPointScale18Mul\\n/// @notice Opcode for performing scale 18 fixed point multiplication.\\nlibrary OpFixedPointScale18Mul {\\n    using FixedPointMath for uint256;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        Operand operand_,\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        return a_.scale18(Operand.unwrap(operand_)).fixedPointMul(b_);\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0x725d9fdd0e23f648d1764f5a72e8806eadda333544f0327bc481e86ed7784c2a\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/fixedPoint/OpFixedPointScaleBy.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpFixedPointScaleBy\\n/// @notice Opcode for scaling a number by some OOMs.\\nlibrary OpFixedPointScaleBy {\\n    using FixedPointMath for uint256;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        Operand operand_,\\n        uint256 a_\\n    ) internal pure returns (uint256) {\\n        return a_.scaleBy(int8(uint8(Operand.unwrap(operand_))));\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0x64de32b7d865115ee71bf969768f34dbee7b25768d4dc57f0399643d79b982ff\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/fixedPoint/OpFixedPointScaleN.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/FixedPointMath.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpFixedPointScaleN\\n/// @notice Opcode for scaling a number to N fixed point.\\nlibrary OpFixedPointScaleN {\\n    using FixedPointMath for uint256;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        Operand operand_,\\n        uint256 a_\\n    ) internal pure returns (uint256) {\\n        return a_.scaleN(Operand.unwrap(operand_));\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0x2b8725c09f43c1122631a237625a0cb09c5b13a286e0c5d884252e097f6fbe64\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpAny.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpAny\\n/// @notice Opcode to compare the top N stack values.\\nlibrary OpAny {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        function(uint256[] memory) internal view returns (uint256) fn_;\\n        return\\n            integrityCheckState_.applyFn(\\n                stackTop_,\\n                fn_,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    // ANY\\n    // ANY is the first nonzero item, else 0.\\n    // operand_ id the length of items to check.\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer bottom_ = stackTop_.down(Operand.unwrap(operand_));\\n        for (\\n            StackPointer i_ = bottom_;\\n            StackPointer.unwrap(i_) < StackPointer.unwrap(stackTop_);\\n            i_ = i_.up()\\n        ) {\\n            uint256 item_ = i_.peekUp();\\n            if (item_ > 0) {\\n                return bottom_.push(item_);\\n            }\\n        }\\n        return bottom_.up();\\n    }\\n}\\n\",\"keccak256\":\"0xd75b71897f37cfec7c021592f22248a2102c470583a4f43fd50dca6b562997b6\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpEagerIf.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpEagerIf\\n/// @notice Opcode for selecting a value based on a condition.\\nlibrary OpEagerIf {\\n    using LibIntegrityCheck for IntegrityCheckState;\\n    using LibStackPointer for StackPointer;\\n\\n    function _eagerIf(\\n        uint256 a_,\\n        uint256[] memory bs_,\\n        uint256[] memory cs_\\n    ) internal pure returns (uint256[] memory) {\\n        return a_ > 0 ? bs_ : cs_;\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFn(\\n                stackTop_,\\n                _eagerIf,\\n                Operand.unwrap(operand_) + 1\\n            );\\n    }\\n\\n    /// Eager because BOTH x_ and y_ must be eagerly evaluated\\n    /// before EAGER_IF will select one of them. If both x_ and y_\\n    /// are cheap (e.g. constant values) then this may also be the\\n    /// simplest and cheapest way to select one of them.\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            return stackTop_.applyFn(_eagerIf, Operand.unwrap(operand_) + 1);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x71a60f34c8179fe596e9f2107dd14373a56993d44d32e1e84b5de75732eab3bf\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpEqualTo.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../../type/LibCast.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpEqualTo\\n/// @notice Opcode to compare the top two stack values.\\nlibrary OpEqualTo {\\n    using LibCast for bool;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _equalTo(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256 c_) {\\n        // Perhaps surprisingly it seems to require assembly to efficiently get\\n        // a `uint256` from boolean equality.\\n        assembly (\\\"memory-safe\\\") {\\n            c_ := eq(a_, b_)\\n        }\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, _equalTo);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(_equalTo);\\n    }\\n}\\n\",\"keccak256\":\"0xabadb9889f171c56fbd53fb44bf33e68398d005a50a450b19f569b099dd463c4\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpEvery.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpEvery\\n/// @notice Opcode to compare the top N stack values.\\nlibrary OpEvery {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        function(uint256[] memory) internal view returns (uint256) fn_;\\n        return\\n            integrityCheckState_.applyFn(\\n                stackTop_,\\n                fn_,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    // EVERY\\n    // EVERY is either the first item if every item is nonzero, else 0.\\n    // operand_ is the length of items to check.\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer bottom_ = stackTop_.down(Operand.unwrap(operand_));\\n        for (\\n            StackPointer i_ = bottom_;\\n            StackPointer.unwrap(i_) < StackPointer.unwrap(stackTop_);\\n            i_ = i_.up()\\n        ) {\\n            if (i_.peekUp() == 0) {\\n                return bottom_.push(0);\\n            }\\n        }\\n        return bottom_.up();\\n    }\\n}\\n\",\"keccak256\":\"0x4d49dcd89b27f850a009419f6ee8a055dc86840e456a6c656a11e6fdb1f25bdd\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpGreaterThan.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../../type/LibCast.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpGreaterThan\\n/// @notice Opcode to compare the top two stack values.\\nlibrary OpGreaterThan {\\n    using LibCast for bool;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _greaterThan(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256 c_) {\\n        assembly (\\\"memory-safe\\\") {\\n            c_ := gt(a_, b_)\\n        }\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, _greaterThan);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(_greaterThan);\\n    }\\n}\\n\",\"keccak256\":\"0xcedd845107a0ffd907375d6642b3dd351ce5cca1fcfb8c4a60cb6bc70ae510b1\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpIsZero.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../../type/LibCast.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpIsZero\\n/// @notice Opcode for checking if the stack top is zero.\\nlibrary OpIsZero {\\n    using LibCast for bool;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256 a_) internal pure returns (uint256 b_) {\\n        assembly (\\\"memory-safe\\\") {\\n            b_ := iszero(a_)\\n        }\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x8300675f9c302fd2f68050613f149ad043d6c3c1b59e6028c54c5c69da3084de\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/logic/OpLessThan.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../../type/LibCast.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpLessThan\\n/// @notice Opcode to compare the top two stack values.\\nlibrary OpLessThan {\\n    using LibStackPointer for StackPointer;\\n    using LibCast for bool;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _lessThan(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256 c_) {\\n        assembly (\\\"memory-safe\\\") {\\n            c_ := lt(a_, b_)\\n        }\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, _lessThan);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(_lessThan);\\n    }\\n}\\n\",\"keccak256\":\"0x21cb5201b62f7dd695cb2eb217df0eb53bca8d0ab705cf07056b2204da7ce009\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/saturating/OpSaturatingAdd.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/SaturatingMath.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpSaturatingAdd\\n/// @notice Opcode for adding N numbers with saturating addition.\\nlibrary OpSaturatingAdd {\\n    using SaturatingMath for uint256;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                SaturatingMath.saturatingAdd,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return\\n            stackTop_.applyFnN(\\n                SaturatingMath.saturatingAdd,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x60e18423c6bc65d7756f97e0f0bc9de3b9a4756397af84981768bcc350b0dbc6\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/saturating/OpSaturatingMul.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/SaturatingMath.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpSaturatingMul\\n/// @notice Opcode for multiplying N numbers with saturating multiplication.\\nlibrary OpSaturatingMul {\\n    using SaturatingMath for uint256;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                SaturatingMath.saturatingMul,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return\\n            stackTop_.applyFnN(\\n                SaturatingMath.saturatingMul,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xca4415a078520559fbecaf721f305f9a4d37778855c4ec768375545ff8bd6e99\",\"license\":\"CAL\"},\"contracts/interpreter/ops/math/saturating/OpSaturatingSub.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../math/SaturatingMath.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpSaturatingSub\\n/// @notice Opcode for subtracting N numbers with saturating subtraction.\\nlibrary OpSaturatingSub {\\n    using SaturatingMath for uint256;\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFnN(\\n                stackTop_,\\n                SaturatingMath.saturatingSub,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return\\n            stackTop_.applyFnN(\\n                SaturatingMath.saturatingSub,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xfdf46384327bc95a8aa0ac7b53f8186887bfc13325dd9ed568e7dfceed6ee764\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/IOrderBookV1/OpIOrderBookV1VaultBalance.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../orderbook/IOrderBookV1.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpIOrderBookV1VaultBalance\\n/// @notice Opcode for IOrderBookV1 `vaultBalance`.\\nlibrary OpIOrderBookV1VaultBalance {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 orderbook_,\\n        uint256 owner_,\\n        uint256 token_,\\n        uint256 id_\\n    ) internal view returns (uint256) {\\n        return\\n            uint256(\\n                uint160(\\n                    IOrderBookV1(address(uint160(orderbook_))).vaultBalance(\\n                        address(uint160(owner_)),\\n                        address(uint160(token_)),\\n                        id_\\n                    )\\n                )\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x4b354dd96e1db51e8159ef05b7ffe82dc31146aae3dfbb3d91e03ddf07751b07\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/ISaleV2/OpISaleV2RemainingTokenInventory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../sale/ISaleV2.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpISaleV2RemainingTokenInventory\\n/// @notice Opcode for ISaleV2 `remainingTokenInventory`.\\nlibrary OpISaleV2RemainingTokenInventory {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256 sale_) internal view returns (uint256) {\\n        return ISaleV2(address(uint160(sale_))).remainingTokenInventory();\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    /// Stack `remainingTokenInventory`.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0xdecae4abbdd2f9e5f4653943d81b5e5893ef094b77a922888227c7444ba693f0\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/ISaleV2/OpISaleV2Reserve.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../sale/ISaleV2.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpISaleV2Reserve\\n/// @notice Opcode for ISaleV2 `reserve`.\\nlibrary OpISaleV2Reserve {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256 sale_) internal view returns (uint256) {\\n        return uint256(uint160(ISaleV2(address(uint160(sale_))).reserve()));\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    /// Stack `reserve`.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0xe2f6fb0b2ecd36bb53f3377e6f6c0b2efe067dcec6974b949003671af154c882\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/ISaleV2/OpISaleV2SaleStatus.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../sale/ISaleV2.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpISaleV2SaleStatus\\n/// @notice Opcode for ISaleV2 `saleStatus`.\\nlibrary OpISaleV2SaleStatus {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256 sale_) internal view returns (uint256) {\\n        return uint(ISaleV2(address(uint160(sale_))).saleStatus());\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    /// Stack `saleStatus`.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x26c3bc24f79e52341342fe6ac69cfc36629df8ad6f1591c9f509241b49f90155\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/ISaleV2/OpISaleV2Token.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../sale/ISaleV2.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpISaleV2Token\\n/// @notice Opcode for ISaleV2 `token`.\\nlibrary OpISaleV2Token {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256 sale_) internal view returns (uint256) {\\n        return uint256(uint160(ISaleV2(address(uint160(sale_))).token()));\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    /// Stack `token`.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x30ff42d3de74de6f90a7e0a664956e08300b0b821e252db02c17f04dfaf1cdee\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/ISaleV2/OpISaleV2TotalReserveReceived.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../sale/ISaleV2.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpISaleV2TotalReserveReceived\\n/// @notice Opcode for ISaleV2 `totalReserveReceived`.\\nlibrary OpISaleV2TotalReserveReceived {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(uint256 sale_) internal view returns (uint256) {\\n        return ISaleV2(address(uint160(sale_))).totalReserveReceived();\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    /// Stack `totalReserveReceived`.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x3a90bc939e393d3c8441e044c997395b7ca60b11cc685caa4018cfc85b20456c\",\"license\":\"CAL\"},\"contracts/interpreter/ops/rain/IVerifyV1/OpIVerifyV1AccountStatusAtTime.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../../verify/IVerifyV1.sol\\\";\\nimport \\\"../../../run/LibStackPointer.sol\\\";\\nimport \\\"../../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpIVerifyV1AccountStatusAtTime\\n/// @notice Opcode for IVerifyV1 `accountStatusAtTime`.\\nlibrary OpIVerifyV1AccountStatusAtTime {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        uint256 contract_,\\n        uint256 account_,\\n        uint256 timestamp_\\n    ) internal view returns (uint256) {\\n        return\\n            VerifyStatus.unwrap(\\n                IVerifyV1(address(uint160(contract_))).accountStatusAtTime(\\n                    address(uint160(account_)),\\n                    timestamp_\\n                )\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    /// Stack `token`.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f);\\n    }\\n}\\n\",\"keccak256\":\"0x5517c59f3a991025fab8df860196d248373aa60a356f3d98d9fd2bdc4beffe1f\",\"license\":\"CAL\"},\"contracts/interpreter/ops/tier/OpITierV2Report.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../tier/ITierV2.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpITierV2Report\\n/// @notice Exposes `ITierV2.report` as an opcode.\\nlibrary OpITierV2Report {\\n    using LibStackPointer for StackPointer;\\n    using LibStackPointer for uint256[];\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _report(\\n        uint256 tierContract_,\\n        uint256 account_,\\n        uint256[] memory context_\\n    ) internal view returns (uint256) {\\n        return\\n            ITierV2(address(uint160(tierContract_))).report(\\n                address(uint160(account_)),\\n                context_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFn(\\n                stackTop_,\\n                _report,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    // Stack the `report` returned by an `ITierV2` contract.\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer stackTopAfter_) {\\n        return stackTop_.applyFn(_report, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x42b5660406a8c32743a95e91fc4ad4483429030290f033041d77d940f47542c3\",\"license\":\"CAL\"},\"contracts/interpreter/ops/tier/OpITierV2ReportTimeForTier.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../tier/ITierV2.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title OpITierV2Report\\n/// @notice Exposes `ITierV2.reportTimeForTier` as an opcode.\\nlibrary OpITierV2ReportTimeForTier {\\n    using LibStackPointer for StackPointer;\\n    using LibStackPointer for uint256[];\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function _reportTimeForTier(\\n        uint256 tierContract_,\\n        uint256 account_,\\n        uint256 tier_,\\n        uint256[] memory context_\\n    ) internal view returns (uint256) {\\n        return\\n            ITierV2(address(uint160(tierContract_))).reportTimeForTier(\\n                address(uint160(account_)),\\n                tier_,\\n                context_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFn(\\n                stackTop_,\\n                _reportTimeForTier,\\n                Operand.unwrap(operand_)\\n            );\\n    }\\n\\n    // Stack the `reportTimeForTier` returned by an `ITierV2` contract.\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(_reportTimeForTier, Operand.unwrap(operand_));\\n    }\\n}\\n\",\"keccak256\":\"0x81697da8b4847a557776ec2458ea6c30794887015a3fb353dacbed7cf16b53b5\",\"license\":\"CAL\"},\"contracts/interpreter/ops/tier/OpSaturatingDiff.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../tier/libraries/TierwiseCombine.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\nlibrary OpSaturatingDiff {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFn(\\n                stackTop_,\\n                TierwiseCombine.saturatingSub\\n            );\\n    }\\n\\n    // Stack the tierwise saturating subtraction of two reports.\\n    // If the older report is newer than newer report the result will\\n    // be `0`, else a tierwise diff in blocks will be obtained.\\n    // The older and newer report are taken from the stack.\\n    function run(\\n        InterpreterState memory,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(TierwiseCombine.saturatingSub);\\n    }\\n}\\n\",\"keccak256\":\"0x62ffc76b1e1d83a633055964f989a9c73d62695f5bf49ed1b72235c27fa3980c\",\"license\":\"CAL\"},\"contracts/interpreter/ops/tier/OpSelectLte.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../tier/libraries/TierwiseCombine.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\nimport \\\"../../../math/Binary.sol\\\";\\n\\n/// Zero inputs to select lte is NOT supported.\\nerror ZeroInputs();\\n\\n/// @title OpSelectLte\\n/// @notice Exposes `TierwiseCombine.selectLte` as an opcode.\\nlibrary OpSelectLte {\\n    using LibStackPointer for StackPointer;\\n    using LibStackPointer for uint256[];\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\\n            if (inputs_ == 0) {\\n                revert ZeroInputs();\\n            }\\n\\n            return\\n                integrityCheckState_.push(\\n                    integrityCheckState_.pop(stackTop_, inputs_)\\n                );\\n        }\\n    }\\n\\n    // Stacks the result of a `selectLte` combinator.\\n    // All `selectLte` share the same stack and argument handling.\\n    // Takes the `logic_` and `mode_` from the `operand_` high bits.\\n    // `logic_` is the highest bit.\\n    // `mode_` is the 2 highest bits after `logic_`.\\n    // The other bits specify how many values to take from the stack\\n    // as reports to compare against each other and the block number.\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            uint256 inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\\n            uint256 mode_ = (Operand.unwrap(operand_) >> 8) & MASK_2BIT;\\n            uint256 logic_ = Operand.unwrap(operand_) >> 10;\\n            (uint256 time_, uint256[] memory reports_) = stackTop_.list(\\n                inputs_\\n            );\\n            return\\n                reports_.asStackPointer().push(\\n                    TierwiseCombine.selectLte(logic_, mode_, time_, reports_)\\n                );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1df003c83995c1803252d33d41b5a07254c947d85d4919a2eb676554c00c2b83\",\"license\":\"CAL\"},\"contracts/interpreter/ops/tier/OpUpdateTimesForTierRange.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../../tier/libraries/TierReport.sol\\\";\\nimport \\\"../../run/LibStackPointer.sol\\\";\\nimport \\\"../../run/LibInterpreterState.sol\\\";\\nimport \\\"../../deploy/LibIntegrityCheck.sol\\\";\\n\\nlibrary OpUpdateTimesForTierRange {\\n    using LibStackPointer for StackPointer;\\n    using LibIntegrityCheck for IntegrityCheckState;\\n\\n    function f(\\n        Operand operand_,\\n        uint256 report_,\\n        uint256 timestamp_\\n    ) internal pure returns (uint256) {\\n        return\\n            TierReport.updateTimesForTierRange(\\n                report_,\\n                // start tier.\\n                // 4 low bits.\\n                Operand.unwrap(operand_) & 0x0f,\\n                // end tier.\\n                // 4 high bits.\\n                (Operand.unwrap(operand_) >> 4) & 0x0f,\\n                timestamp_\\n            );\\n    }\\n\\n    function integrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        Operand,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.applyFn(stackTop_, f);\\n    }\\n\\n    // Stacks a report with updated times over tier range.\\n    // The start and end tier are taken from the low and high bits of\\n    // the `operand_` respectively.\\n    // The report to update and timestamp to update to are both\\n    // taken from the stack.\\n    function run(\\n        InterpreterState memory,\\n        Operand operand_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        return stackTop_.applyFn(f, operand_);\\n    }\\n}\\n\",\"keccak256\":\"0xdf2214c2c70d79c5d7e23606322ef01d7a5bd0dc1ef362afb63178c0bff7c7d9\",\"license\":\"CAL\"},\"contracts/interpreter/run/IInterpreterV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// @dev The index of a source within a deployed expression that can be evaluated\\n/// by an `IInterpreterV1`. MAY be an entrypoint or the index of a source called\\n/// internally such as by the `call` opcode.\\ntype SourceIndex is uint256;\\n/// @dev Encoded information about a specific evaluation including the expression\\n/// address onchain, entrypoint and expected return values.\\ntype EncodedDispatch is uint256;\\n/// @dev The namespace for state changes as requested by the calling contract.\\n/// The interpreter MUST apply this namespace IN ADDITION to namespacing by\\n/// caller etc.\\ntype StateNamespace is uint256;\\n/// @dev Additional bytes that can be used to configure a single opcode dispatch.\\n/// Commonly used to specify the number of inputs to a variadic function such\\n/// as addition or multiplication.\\ntype Operand is uint256;\\n\\n/// @title IInterpreterV1\\n/// Interface into a standard interpreter that supports:\\n///\\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\\n///   to the evaluated logic\\n/// - handling subsequent state changes in bulk in response to evaluated logic\\n/// - namespacing state changes according to the caller's preferences to avoid\\n///   unwanted key collisions\\n/// - exposing its internal function pointers to support external precompilation\\n///   of logic for more gas efficient runtime evaluation by the interpreter\\n///\\n/// The interface is designed to be stable across many versions and\\n/// implementations of an interpreter, balancing minimalism with features\\n/// required for a general purpose onchain interpreted compute environment.\\n///\\n/// The security model of an interpreter is that it MUST be resilient to\\n/// malicious expressions even if they dispatch arbitrary internal function\\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\\n/// undefined behaviour or error during an eval, _provided that no state changes\\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\\n/// malicious expression can be negatively impacted by the result. In turn, the\\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\\n/// return values from any interpreter that it requests an expression from. And\\n/// so on and so forth up to the externally owned account (EOA) who signs the\\n/// transaction and agrees to a specific combination of contracts, expressions\\n/// and interpreters, who can presumably make an informed decision about which\\n/// ones to trust to get the job done.\\n///\\n/// The state changes for an interpreter are expected to be produces by an `eval`\\n/// and passed back to the interpreter as-is by the caller, after the caller has\\n/// had an opportunity to apply their own intermediate logic such as reentrancy\\n/// defenses against malicious interpreters. The interpreter is free to structure\\n/// the state changes however it wants but MUST guard against the calling\\n/// contract corrupting the changes between `eval` and `stateChanges`. For\\n/// example an interpreter could sandbox storage writes per-caller so that a\\n/// malicious caller can only damage their own state changes, while honest\\n/// callers respect, benefit from and are protected by the interpreter's state\\n/// change handling.\\n///\\n/// The two step eval-state model allows eval to be read-only which provides\\n/// security guarantees for the caller such as no stateful reentrancy, either\\n/// from the interpreter or some contract interface used by some word, while\\n/// still allowing for storage writes. As the storage writes happen on the\\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\\n/// need to trust the interpreter, which allows for permissionless selection of\\n/// interpreters by end users. Delegate call always implies an admin key on the\\n/// caller because the delegatee contract can write arbitrarily to the state of\\n/// the delegator, which severely limits the generality of contract composition.\\ninterface IInterpreterV1 {\\n    /// Exposes the function pointers as `uint16` values packed into a single\\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\\n    ///\\n    /// `IExpressionDeployerV1` contracts use these function pointers to\\n    /// \\\"compile\\\" the expression into something that an interpreter can dispatch\\n    /// directly without paying gas to lookup the same at runtime. As the\\n    /// validity of any integrity check and subsequent dispatch is highly\\n    /// sensitive to both the function pointers and overall bytecode of the\\n    /// interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\\n    /// against accidentally being deployed onchain paired against an unknown\\n    /// interpreter. It is very easy for an apparent compatible pairing to be\\n    /// subtly and critically incompatible due to addition/removal/reordering of\\n    /// opcodes and compiler optimisations on the interpreter bytecode.\\n    ///\\n    /// This MAY return different values during construction vs. all other times\\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\\n    /// on function pointers reported during contract construction.\\n    function functionPointers() external view returns (bytes memory);\\n\\n    /// The raison d'etre for an interpreter. Given some expression and per-call\\n    /// additional contextual data, produce a stack of results and a set of state\\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\\n    /// call to `stateChanges`.\\n    /// @param dispatch All the information required for the interpreter to load\\n    /// an expression, select an entrypoint and return the values expected by the\\n    /// caller. The interpreter MAY encode dispatches differently to\\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\\n    /// calling contracts that hardcode the encoding logic.\\n    /// @param context A 2-dimensional array of data that can be indexed into at\\n    /// runtime by the interpreter. The calling contract is responsible for\\n    /// ensuring the authenticity and completeness of context data. The\\n    /// interpreter MUST revert at runtime if an expression attempts to index\\n    /// into some context value that is not provided by the caller. This implies\\n    /// that context reads cannot be checked for out of bounds reads at deploy\\n    /// time, as the runtime context MAY be provided in a different shape to what\\n    /// the expression is expecting.\\n    function eval(\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    )\\n        external\\n        view\\n        returns (uint256[] memory stack, uint256[] memory stateChanges);\\n\\n    /// Applies state changes from a prior eval to the storage of the\\n    /// interpreter. The interpreter is responsible for ensuring that applying\\n    /// these state changes is safe from key collisions, both with any internal\\n    /// state the interpreter needs for itself and with calls to `stateChanges`\\n    /// from different `msg.sender` callers. I.e. it MUST NOT be possible for\\n    /// a caller to modify the state changes associated with some other caller.\\n    ///\\n    /// The interpreter defines the shape of its own state changes, which is\\n    /// opaque to the calling contract. For example, some interpreter may treat\\n    /// the list of state changes as a pairwise key/value set, and some other\\n    /// interpreter may treat it as a literal list to be stored as-is.\\n    ///\\n    /// The interpreter MUST assume the state changes have been corrupted by the\\n    /// calling contract due to bugs or malicious intent, and enforce state\\n    /// isolation between callers despite arbitrarily invalid state changes. The\\n    /// interpreter MUST revert if it can detect invalid state changes, such\\n    /// as a key/value list having an odd number of items, but this MAY NOT be\\n    /// possible if the corruption is undetectable.\\n    ///\\n    /// @param stateChanges The list of changes to apply to the interpreter's\\n    /// internal state.\\n    function stateChanges(uint256[] calldata stateChanges) external;\\n\\n    /// Same as `eval` but allowing the caller to specify a namespace under which\\n    /// the state changes will be applied. The interpeter MUST ensure that keys\\n    /// will never collide across namespaces, even if, for example:\\n    ///\\n    /// - The calling contract is malicious and attempts to craft a collision\\n    ///   with state changes from another contract\\n    /// - The expression is malicious and attempts to craft a collision with\\n    ///   other expressions evaluated by the same calling contract\\n    ///\\n    /// A malicious entity MAY have access to significant offchain resources to\\n    /// attempt to precompute key collisions through brute force. The collision\\n    /// resistance of namespaces should be comparable or equivalent to the\\n    /// collision resistance of the hashing algorithms employed by the blockchain\\n    /// itself, such as the design of `mapping` in Solidity that hashes each\\n    /// nested key to produce a collision resistant compound key.\\n    ///\\n    /// Calls to `eval` without a namespace are implied to be under namespace `0`\\n    /// so an interpreter MAY implement `eval` in terms of `evalWithNamespace` if\\n    /// this simplifies the implementation.\\n    ///\\n    /// @param namespace The namespace specified by the calling contract.\\n    /// @param dispatch As per `eval`.\\n    /// @param context As per `eval`.\\n    /// @return stack As per `eval`.\\n    /// @return stateChanges As per `eval`.\\n    function evalWithNamespace(\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    )\\n        external\\n        view\\n        returns (uint256[] memory stack, uint256[] memory stateChanges);\\n\\n    /// Same as `stateChanges` but following `evalWithNamespace`. The caller MUST\\n    /// use the same namespace for both `evalWithNamespace` and\\n    /// `stateChangesWithNamespace` for a given expression evaluation.\\n    /// @param namespace As per `evalWithNamespace`.\\n    /// @param stateChanges as per `stateChanges`.\\n    function stateChangesWithNamespace(\\n        StateNamespace namespace,\\n        uint256[] calldata stateChanges\\n    ) external;\\n}\\n\",\"keccak256\":\"0x143cef02a6d24775f36fea669df20262836082fbcfc23282378d07e6b5862062\",\"license\":\"CAL\"},\"contracts/interpreter/run/LibInterpreterState.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../run/IInterpreterV1.sol\\\";\\nimport \\\"../deploy/IExpressionDeployerV1.sol\\\";\\nimport \\\"./LibStackPointer.sol\\\";\\nimport \\\"../../type/LibCast.sol\\\";\\nimport \\\"../../type/LibConvert.sol\\\";\\nimport \\\"../../array/LibUint256Array.sol\\\";\\nimport \\\"../../memory/LibMemorySize.sol\\\";\\nimport {SafeCastUpgradeable as SafeCast} from \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\\\";\\nimport \\\"../../kv/LibMemoryKV.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// Debugging options for a standard console log over the interpreter state.\\n/// - Stack: Log the entire stack, respects the current stack top, i.e. DOES NOT\\n///   log every value of the underlying `uint256[]` unless the stack top points\\n///   to the end of the array.\\n/// - Constant: Log every constant available to the current expression.\\n/// - Context: Log every column/row of context available to the current eval.\\n/// - Source: Log all the raw bytes of the compiled sources being evaluated.\\nenum DebugStyle {\\n    Stack,\\n    Constant,\\n    Context,\\n    Source\\n}\\n\\n/// A fully qualified namespace includes the interpreter's own namespacing logic\\n/// IN ADDITION to the calling contract's requested `StateNamespace`. Typically\\n/// this involves hashing the `msg.sender` into the `StateNamespace` so that each\\n/// caller operates within its own disjoint state universe. Intepreters MUST NOT\\n/// allow either the caller nor any expression/word to modify this directly on\\n/// pain of potential key collisions on writes to the interpreter's own storage.\\ntype FullyQualifiedNamespace is uint256;\\n\\n/// The standard in-memory representation of an interpreter that facilitates\\n/// decoupled coordination between opcodes. Opcodes MAY:\\n///\\n/// - push and pop values to the shared stack\\n/// - read per-expression constants\\n/// - write to the final state changes set within the fully qualified namespace\\n/// - read per-eval context values\\n/// - recursively evaluate any compiled source associated with the expression\\n///\\n/// As the interpreter defines the opcodes it is its responsibility to ensure the\\n/// opcodes are incapable of doing anything to undermine security or correctness.\\n/// For example, a hypothetical opcode could modify the current namespace from\\n/// the stack, but this would be a very bad idea as it would allow expressions\\n/// to hijack storage values associated with other callers, fundamentally\\n/// breaking the state sandbox model.\\n///\\n/// The iterpreter MAY skip any runtime integrity checks that can be reasonably\\n/// assumed to have been performed by a competent expression deployer, such as\\n/// guarding against stack underflow. A competent expression deployer MAY NOT\\n/// have deployed the currently evaluating expression, so the interpreter MUST\\n/// avoid state changes during evaluation, but MAY return garbage data if the\\n/// calling contract fails to leverage an appropriate expression deployer.\\n///\\n/// @param stackBottom Opcodes write to the stack starting at the stack bottom,\\n/// ideally using `LibStackPointer` to normalise push and pop behaviours. A\\n/// competent expression deployer will calculate a memory preallocation that\\n/// pushes and pops above the stack bottom effectively allocate and deallocate\\n/// memory within.\\n/// @param constantsBottom Opcodes read constants starting at the pointer to\\n/// the bottom of the constants array. As the name implies the interpreter MUST\\n/// NOT write to the constants, it is read only.\\n/// @param stateKV The in memory key/value store that tracks reads/writes over\\n/// the underlying interpreter storage for the duration of a single expression\\n/// evaluation.\\n/// @param namespace The fully qualified namespace that all state reads and\\n/// writes MUST be performed under.\\n/// @param context A 2-dimensional array of per-eval data provided by the calling\\n/// contract. Opaque to the interpreter but presumably meaningful to the\\n/// expression.\\n/// @param compiledSources A list of sources that can be directly evaluated by\\n/// the interpreter, either as a top level entrypoint or nested e.g. under a\\n/// dispatch by `call`.\\nstruct InterpreterState {\\n    StackPointer stackBottom;\\n    StackPointer constantsBottom;\\n    MemoryKV stateKV;\\n    FullyQualifiedNamespace namespace;\\n    uint256[][] context;\\n    bytes[] compiledSources;\\n}\\n\\n/// @dev squiggly lines to make the debug output easier to read. Intentionlly\\n/// short to keep compiled code size down.\\nstring constant DEBUG_DELIMETER = \\\"~~~\\\";\\n\\n/// @title LibInterpreterState\\n/// @notice Main workhorse for `InterpeterState` including:\\n///\\n/// - the standard `eval` loop\\n/// - source compilation from opcodes\\n/// - state (de)serialization (more gas efficient than abi encoding)\\n/// - low level debugging utility\\n///\\n/// Interpreters are designed to be highly moddable behind the `IInterpreterV1`\\n/// interface, but pretty much any interpreter that uses `InterpreterState` will\\n/// need these low level facilities verbatim. Further, these facilities\\n/// (with possible exception of debugging logic), while relatively short in terms\\n/// of lines of code, are surprisingly fragile to maintain in a gas efficient way\\n/// so we don't recommend reinventing this wheel.\\nlibrary LibInterpreterState {\\n    using SafeCast for uint256;\\n    using LibMemorySize for uint256;\\n    using LibMemorySize for uint256[];\\n    using LibMemorySize for bytes;\\n    using LibUint256Array for uint256[];\\n    using LibUint256Array for uint256;\\n    using LibInterpreterState for StackPointer;\\n    using LibStackPointer for uint256[];\\n    using LibStackPointer for StackPointer;\\n    using LibStackPointer for bytes;\\n    using LibCast for uint256;\\n    using LibCast for function(\\n        InterpreterState memory,\\n        SourceIndex,\\n        StackPointer\\n    ) view returns (StackPointer);\\n    using LibCast for function(InterpreterState memory, Operand, StackPointer)\\n        view\\n        returns (StackPointer)[];\\n    using LibConvert for uint256[];\\n\\n    /// Thin wrapper around hardhat's `console.log` that loops over any array\\n    /// and logs each value delimited by `DEBUG_DELIMITER`.\\n    /// @param array_ The array to debug.\\n    function debugArray(uint256[] memory array_) internal view {\\n        console.log(DEBUG_DELIMETER);\\n        for (uint256 i_ = 0; i_ < array_.length; i_++) {\\n            console.log(i_, array_[i_]);\\n        }\\n        console.log(DEBUG_DELIMETER);\\n    }\\n\\n    /// Copies the stack to a new array then debugs it. Definitely NOT gas\\n    /// efficient, but affords simple and effective debugging.\\n    /// @param stackBottom_ Pointer to the bottom of the stack.\\n    /// @param stackTop_ Pointer to the top of the stack.\\n    function debugStack(\\n        StackPointer stackBottom_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        uint256 length_ = stackBottom_.toIndex(stackTop_);\\n        debugArray(\\n            StackPointer.unwrap(stackTop_.down(length_)).copyToNewUint256Array(\\n                length_\\n            )\\n        );\\n        return stackTop_;\\n    }\\n\\n    /// Console log various aspects of the Interpreter state. Gas intensive and\\n    /// relies on hardhat console so not intended for production but great for\\n    /// debugging expressions. MAY be exposed as an opcode so expression authors\\n    /// can debug the expressions directly onchain.\\n    /// @param state_ The interpreter state to debug the internals of.\\n    /// @param stackTop_ Pointer to the current stack top.\\n    /// @param debugStyle_ Enum variant defining what should be debugged from the\\n    /// interpreter state.\\n    function debug(\\n        InterpreterState memory state_,\\n        StackPointer stackTop_,\\n        DebugStyle debugStyle_\\n    ) internal view returns (StackPointer) {\\n        if (debugStyle_ == DebugStyle.Source) {\\n            for (uint256 i_ = 0; i_ < state_.compiledSources.length; i_++) {\\n                console.logBytes(state_.compiledSources[i_]);\\n            }\\n        } else {\\n            if (debugStyle_ == DebugStyle.Stack) {\\n                state_.stackBottom.debugStack(stackTop_);\\n            } else if (debugStyle_ == DebugStyle.Constant) {\\n                debugArray(state_.constantsBottom.down().asUint256Array());\\n            } else {\\n                for (uint256 i_ = 0; i_ < state_.context.length; i_++) {\\n                    debugArray(state_.context[i_]);\\n                }\\n            }\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Efficiently serializes some `IInterpreterV1` state config into bytes that\\n    /// can be deserialized to an `InterpreterState` without memory allocation or\\n    /// copying of data on the return trip. This is achieved by mutating data in\\n    /// place for both serialization and deserialization so it is much more gas\\n    /// efficient than abi encode/decode but is NOT SAFE to use the `StateConfig`\\n    /// after it has been serialized. Notably the index based opcodes in the\\n    /// sources in `StateConfig` will be replaced by function pointer based\\n    /// opcodes in place, so are no longer usable in a portable format.\\n    /// @param config_ State config as per `IInterpreterV1`.\\n    /// @param stackLength_ Stack length calculated by `IExpressionDeployerV1`\\n    /// that will be used to allocate memory for the stack upon deserialization.\\n    /// @param opcodeFunctionPointers_ As per `IInterpreterV1.functionPointers`,\\n    /// bytes to be compiled into the final `InterpreterState.compiledSources`.\\n    function serialize(\\n        StateConfig memory config_,\\n        uint256 stackLength_,\\n        bytes memory opcodeFunctionPointers_\\n    ) internal pure returns (bytes memory) {\\n        unchecked {\\n            uint256 size_ = 0;\\n            size_ += stackLength_.size();\\n            size_ += config_.constants.size();\\n            for (uint256 i_ = 0; i_ < config_.sources.length; i_++) {\\n                size_ += config_.sources[i_].size();\\n            }\\n            bytes memory serialized_ = new bytes(size_);\\n            StackPointer cursor_ = serialized_.asStackPointer().up();\\n\\n            // Copy stack length.\\n            cursor_ = cursor_.push(stackLength_);\\n\\n            // Then the constants.\\n            cursor_ = cursor_.pushWithLength(config_.constants);\\n\\n            // Last the sources.\\n            bytes memory source_;\\n            for (uint256 i_ = 0; i_ < config_.sources.length; i_++) {\\n                source_ = config_.sources[i_];\\n                compile(source_, opcodeFunctionPointers_);\\n                cursor_ = cursor_.unalignedPushWithLength(source_);\\n            }\\n            return serialized_;\\n        }\\n    }\\n\\n    /// Return trip from `serialize` but targets an `InterpreterState` NOT a\\n    /// `StateConfig`. Allows serialized bytes to be written directly into\\n    /// contract code on the other side of an expression address, then loaded\\n    /// directly into an eval-able memory layout. The only allocation required\\n    /// is to initialise the stack for eval, there is no copying in memory from\\n    /// the serialized data as the deserialization merely calculates Solidity\\n    /// compatible pointers to positions in the raw serialized data. This is much\\n    /// more gas efficient than an equivalent abi.decode call which would involve\\n    /// more processing, copying and allocating.\\n    ///\\n    /// Note that per-eval data such as namespace and context is NOT initialised\\n    /// by the deserialization process and so will need to be handled by the\\n    /// interpreter as part of `eval`.\\n    ///\\n    /// @param serialized_ Bytes previously serialized by\\n    /// `LibInterpreterState.serialize`.\\n    /// @return An eval-able interpreter state with initialized stack.\\n    function deserialize(\\n        bytes memory serialized_\\n    ) internal pure returns (InterpreterState memory) {\\n        unchecked {\\n            InterpreterState memory state_;\\n\\n            // Context will probably be overridden by the caller according to the\\n            // context scratch that we deserialize so best to just set it empty\\n            // here.\\n            state_.context = new uint256[][](0);\\n\\n            StackPointer cursor_ = serialized_.asStackPointer().up();\\n            // The end of processing is the end of the state bytes.\\n            StackPointer end_ = cursor_.upBytes(cursor_.peek());\\n\\n            // Read the stack length and build a stack.\\n            cursor_ = cursor_.up();\\n            uint256 stackLength_ = cursor_.peek();\\n\\n            // The stack is never stored in stack bytes so we allocate a new\\n            // array for it with length as per the indexes and point the state\\n            // at it.\\n            uint256[] memory stack_ = new uint256[](stackLength_);\\n            state_.stackBottom = stack_.asStackPointerUp();\\n\\n            // Reference the constants array and move cursor past it.\\n            cursor_ = cursor_.up();\\n            state_.constantsBottom = cursor_;\\n            cursor_ = cursor_.up(cursor_.peek());\\n\\n            // Rebuild the sources array.\\n            uint256 i_ = 0;\\n            StackPointer lengthCursor_ = cursor_;\\n            uint256 sourcesLength_ = 0;\\n            while (\\n                StackPointer.unwrap(lengthCursor_) < StackPointer.unwrap(end_)\\n            ) {\\n                lengthCursor_ = lengthCursor_\\n                    .upBytes(lengthCursor_.peekUp())\\n                    .up();\\n                sourcesLength_++;\\n            }\\n            state_.compiledSources = new bytes[](sourcesLength_);\\n            while (StackPointer.unwrap(cursor_) < StackPointer.unwrap(end_)) {\\n                state_.compiledSources[i_] = cursor_.asBytes();\\n                cursor_ = cursor_.upBytes(cursor_.peekUp()).up();\\n                i_++;\\n            }\\n            return state_;\\n        }\\n    }\\n\\n    /// Given a source in opcodes compile to an equivalent source with real\\n    /// function pointers for a given Interpreter contract. The \\\"compilation\\\"\\n    /// involves simply replacing the opcode with the pointer at the index of\\n    /// the opcode. i.e. opcode 4 will be replaced with `pointers_[4]`.\\n    /// Relies heavily on the integrity checks ensuring opcodes used are not OOB\\n    /// and that the pointers provided are valid and in the correct order. As the\\n    /// expression deployer is typically handling compilation during\\n    /// serialization, NOT the interpreter, the interpreter MUST guard against\\n    /// the compilation being garbage or outright hostile during `eval` by\\n    /// pointing to arbitrary internal functions of the interpreter.\\n    /// @param source_ The input source as index based opcodes.\\n    /// @param pointers_ The function pointers ordered by index to replace the\\n    /// index based opcodes with.\\n    function compile(\\n        bytes memory source_,\\n        bytes memory pointers_\\n    ) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n                let replaceMask_ := 0xFFFF\\n                let preserveMask_ := not(replaceMask_)\\n                let sourceLength_ := mload(source_)\\n                let pointersBottom_ := add(pointers_, 2)\\n                let cursor_ := add(source_, 2)\\n                let end_ := add(source_, sourceLength_)\\n            } lt(cursor_, end_) {\\n                cursor_ := add(cursor_, 4)\\n            } {\\n                let data_ := mload(cursor_)\\n                let pointer_ := and(\\n                    replaceMask_,\\n                    mload(\\n                        add(pointersBottom_, mul(2, and(data_, replaceMask_)))\\n                    )\\n                )\\n                mstore(cursor_, or(and(data_, preserveMask_), pointer_))\\n            }\\n        }\\n    }\\n\\n    /// The main eval loop. Does as little as possible as it is an extremely hot\\n    /// performance and critical security path. Loads opcode/operand pairs from\\n    /// a precompiled source in the interpreter state and calls the function\\n    /// that the opcode points to. This function is in turn responsible for\\n    /// actually pushing/popping from the stack, etc. As `eval` receives the\\n    /// source index and stack top alongside its state, it supports recursive\\n    /// calls via. opcodes that can manage scoped substacks, etc. without `eval`\\n    /// needing to house that complexity itself.\\n    /// @param state_ The interpreter state to evaluate a source over.\\n    /// @param sourceIndex_ The index of the source to evaluate. MAY be an\\n    /// entrypoint or a nested call.\\n    /// @param stackTop_ The current stack top, MUST be equal to the stack bottom\\n    /// on the intepreter state if the current eval is for an entrypoint.\\n    function eval(\\n        InterpreterState memory state_,\\n        SourceIndex sourceIndex_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 cursor_;\\n            uint256 end_;\\n            assembly (\\\"memory-safe\\\") {\\n                cursor_ := mload(\\n                    add(\\n                        mload(add(state_, 0xA0)),\\n                        add(0x20, mul(0x20, sourceIndex_))\\n                    )\\n                )\\n                end_ := add(cursor_, mload(cursor_))\\n            }\\n\\n            // Loop until complete.\\n            while (cursor_ < end_) {\\n                function(InterpreterState memory, Operand, StackPointer)\\n                    internal\\n                    view\\n                    returns (StackPointer) fn_;\\n                Operand operand_;\\n                cursor_ += 4;\\n                {\\n                    uint256 op_;\\n                    assembly (\\\"memory-safe\\\") {\\n                        op_ := mload(cursor_)\\n                        operand_ := and(op_, 0xFFFF)\\n                        fn_ := and(shr(16, op_), 0xFFFF)\\n                    }\\n                }\\n                stackTop_ = fn_(state_, operand_, stackTop_);\\n            }\\n            return stackTop_;\\n        }\\n    }\\n\\n    /// Standard way to elevate a caller-provided state namespace to a universal\\n    /// namespace that is disjoint from all other caller-provided namespaces.\\n    /// Essentially just hashes the `msg.sender` into the state namespace as-is.\\n    ///\\n    /// This is deterministic such that the same combination of state namespace\\n    /// and caller will produce the same fully qualified namespace, even across\\n    /// multiple transactions/blocks.\\n    ///\\n    /// @param stateNamespace_ The state namespace as specified by the caller.\\n    /// @return A fully qualified namespace that cannot collide with any other\\n    /// state namespace specified by any other caller.\\n    function qualifyNamespace(\\n        StateNamespace stateNamespace_\\n    ) internal view returns (FullyQualifiedNamespace) {\\n        return\\n            FullyQualifiedNamespace.wrap(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            msg.sender,\\n                            StateNamespace.unwrap(stateNamespace_)\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xd680c532d927ae63ac71369949e3b4c847828350bac9f327a2b6d4783ff6680a\",\"license\":\"CAL\"},\"contracts/interpreter/run/LibStackPointer.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\nimport \\\"../../array/LibUint256Array.sol\\\";\\nimport \\\"../../bytes/LibBytes.sol\\\";\\n\\n/// Thrown when the length of an array as the result of an applied function does\\n/// not match expectations.\\nerror UnexpectedResultLength(uint256 expectedLength, uint256 actualLength);\\n\\n/// Custom type to point to memory ostensibly in a stack.\\ntype StackPointer is uint256;\\n\\n/// @title LibStackPointer\\n/// @notice A `StackPointer` is just a pointer to some memory. Ostensibly it is\\n/// pointing at a stack item in memory used by the `RainInterpreter` so that\\n/// means it can move \\\"up\\\" and \\\"down\\\" (increment and decrement) by `uint256`\\n/// (32 bytes) increments. Structurally a stack is a `uint256[]` but we can save\\n/// a lot of gas vs. default Solidity handling of array indexes by using assembly\\n/// to bypass runtime bounds checks on every read and write. Of course, this\\n/// means we have to introduce some mechanism that gives us equivalent guarantees\\n/// and we do, in the form of the `IExpressionDeployerV1` integrity check.\\n///\\n/// The pointer to the bottom of a stack points at the 0th item, NOT the length\\n/// of the implied `uint256[]` and the top of a stack points AFTER the last item.\\n/// e.g. consider a `uint256[]` in memory with values `3 A B C` and assume this\\n/// starts at position `0` in memory, i.e. `0` points to value `3` for the\\n/// array length. In this case the stack bottom would be\\n/// `StackPointer.wrap(0x20)` (32 bytes above 0, past the length) and the stack\\n/// top would be `StackPointer.wrap(0x80)` (96 bytes above the stack bottom).\\n///\\n/// Most of the functions in this library are equivalent to each other via\\n/// composition, i.e. everything could be achieved with just `up`, `down`,\\n/// `pop`, `push`, `peek`. The reason there is so much overloaded/duplicated\\n/// logic is that the Solidity compiler seems to fail at inlining equivalent\\n/// logic quite a lot. Perhaps once the IR compilation of Solidity is better\\n/// supported by tooling etc. we could remove a lot of this duplication as the\\n/// compiler itself would handle the optimisations.\\nlibrary LibStackPointer {\\n    using LibStackPointer for StackPointer;\\n    using LibStackPointer for uint256[];\\n    using LibStackPointer for bytes;\\n    using LibUint256Array for uint256[];\\n    using LibBytes for uint256;\\n\\n    /// Reads the value above the stack pointer. If the stack pointer is the\\n    /// current stack top this is an out of bounds read! The caller MUST ensure\\n    /// that this is not the case and that the stack pointer being read is within\\n    /// the stack and not after it.\\n    /// @param stackPointer_ Position to read past/above.\\n    function peekUp(\\n        StackPointer stackPointer_\\n    ) internal pure returns (uint256) {\\n        uint256 a_;\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(stackPointer_)\\n        }\\n        return a_;\\n    }\\n\\n    /// Read the value immediately below the given stack pointer. Equivalent to\\n    /// calling `pop` and discarding the `stackPointerAfter_` value, so may be\\n    /// less gas than setting and discarding a value.\\n    /// @param stackPointer_ The stack pointer to read below.\\n    /// @return a_ The value that was read.\\n    function peek(StackPointer stackPointer_) internal pure returns (uint256) {\\n        uint256 a_;\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(sub(stackPointer_, 0x20))\\n        }\\n        return a_;\\n    }\\n\\n    /// Reads 2 values below the given stack pointer.\\n    /// The following statements are equivalent but A may use gas if the\\n    /// compiler fails to inline some function calls.\\n    /// A:\\n    /// ```\\n    /// (uint256 a_, uint256 b_) = stackPointer_.peek2();\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// uint256 b_;\\n    /// (stackPointer_, b_) = stackPointer_.pop();\\n    /// uint256 a_ = stackPointer_.peek();\\n    /// ```\\n    /// @param stackPointer_ The stack top to peek below.\\n    function peek2(\\n        StackPointer stackPointer_\\n    ) internal pure returns (uint256, uint256) {\\n        uint256 a_;\\n        uint256 b_;\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(sub(stackPointer_, 0x40))\\n            b_ := mload(sub(stackPointer_, 0x20))\\n        }\\n        return (a_, b_);\\n    }\\n\\n    /// Read the value immediately below the given stack pointer and return the\\n    /// stack pointer that points to the value that was read alongside the value.\\n    /// The following are equivalent but A may be cheaper if the compiler\\n    /// fails to inline some function calls:\\n    /// A:\\n    /// ```\\n    /// uint256 a_;\\n    /// (stackPointer_, a_) = stackPointer_.pop();\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackPointer_ = stackPointer_.down();\\n    /// uint256 a_ = stackPointer_.peekUp();\\n    /// ```\\n    /// @param stackPointer_ The stack pointer to read below.\\n    /// @return stackPointerAfter_ Points to the value that was read.\\n    /// @return a_ The value that was read.\\n    function pop(\\n        StackPointer stackPointer_\\n    ) internal pure returns (StackPointer, uint256) {\\n        StackPointer stackPointerAfter_;\\n        uint256 a_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointerAfter_ := sub(stackPointer_, 0x20)\\n            a_ := mload(stackPointerAfter_)\\n        }\\n        return (stackPointerAfter_, a_);\\n    }\\n\\n    /// Given two stack pointers that bound a stack build an array of all values\\n    /// above the given sentinel value. The sentinel will be _replaced_ by the\\n    /// length of the array, allowing for efficient construction of a valid\\n    /// `uint256[]` without additional allocation or copying in memory. As the\\n    /// returned value is a `uint256[]` it can be treated as a substack and the\\n    /// same (or different) sentinel can be consumed many times to build many\\n    /// arrays from the main stack.\\n    ///\\n    /// As the sentinel is mutated in place into a length it is NOT safe to call\\n    /// this in a context where the stack is expected to be immutable.\\n    ///\\n    /// The sentinel MUST be chosen to have a negligible chance of colliding with\\n    /// a real value in the array, otherwise an intended array item will be\\n    /// interpreted as a sentinel and the array will be split into two slices.\\n    ///\\n    /// If the sentinel is absent in the stack this WILL REVERT. The intent is\\n    /// to represent dynamic length arrays without forcing expression authors to\\n    /// calculate lengths on the stack. If the expression author wants to model\\n    /// an empty/optional/absent value they MAY provided a sentinel for a zero\\n    /// length array and the calling contract SHOULD handle this.\\n    ///\\n    /// @param stackTop_ Pointer to the top of the stack.\\n    /// @param stackBottom_ Pointer to the bottom of the stack.\\n    /// @param sentinel_ The value to expect as the sentinel. MUST be present in\\n    /// the stack or `consumeSentinel` will revert. MUST NOT collide with valid\\n    /// stack items (or be cryptographically improbable to do so).\\n    /// @param stepSize_ Number of items to move over in the array per loop\\n    /// iteration. If the array has a known multiple of items it can be more\\n    /// efficient to find a sentinel moving in N-item increments rather than\\n    /// reading every item individually.\\n    function consumeSentinel(\\n        StackPointer stackTop_,\\n        StackPointer stackBottom_,\\n        uint256 sentinel_,\\n        uint256 stepSize_\\n    ) internal pure returns (StackPointer, uint256[] memory) {\\n        uint256[] memory array_;\\n        assembly (\\\"memory-safe\\\") {\\n            // Underflow is not allowed and pointing at position 0 in memory is\\n            // corrupt behaviour anyway.\\n            if iszero(stackBottom_) {\\n                revert(0, 0)\\n            }\\n            let sentinelLocation_ := 0\\n            let length_ := 0\\n            let step_ := mul(stepSize_, 0x20)\\n            for {\\n                stackTop_ := sub(stackTop_, 0x20)\\n                let end_ := sub(stackBottom_, 0x20)\\n            } gt(stackTop_, end_) {\\n                stackTop_ := sub(stackTop_, step_)\\n                length_ := add(length_, stepSize_)\\n            } {\\n                if eq(sentinel_, mload(stackTop_)) {\\n                    sentinelLocation_ := stackTop_\\n                    break\\n                }\\n            }\\n            // Sentinel MUST exist in the stack if consumer expects it to there.\\n            if iszero(sentinelLocation_) {\\n                revert(0, 0)\\n            }\\n            mstore(sentinelLocation_, length_)\\n            array_ := sentinelLocation_\\n        }\\n        return (stackTop_, array_);\\n    }\\n\\n    /// Abstraction over `consumeSentinel` to build an array of solidity structs.\\n    /// Solidity won't exactly allow this due to its type system not supporting\\n    /// generics, so instead we return an array of references to struct data that\\n    /// can be assigned/cast to an array of structs easily with assembly. This\\n    /// is NOT intended to be a general purpose workhorse for this task, only\\n    /// structs of pointers to `uint256[]` values are supported.\\n    ///\\n    /// ```\\n    /// struct Foo {\\n    ///   uint256[] a;\\n    ///   uint256[] b;\\n    /// }\\n    ///\\n    /// (StackPointer stackPointer_, uint256[] memory refs_) = consumeStructs(...);\\n    /// Foo[] memory foo_;\\n    /// assembly (\\\"memory-safe\\\") {\\n    ///   mstore(foo_, refs_)\\n    /// }\\n    /// ```\\n    ///\\n    /// @param stackTop_ The top of the stack as per `consumeSentinel`.\\n    /// @param stackBottom_ The bottom of the stack as per `consumeSentinel`.\\n    /// @param sentinel_ The sentinel as per `consumeSentinel`.\\n    /// @param structSize_ The number of `uint256[]` fields on the struct.\\n    function consumeStructs(\\n        StackPointer stackTop_,\\n        StackPointer stackBottom_,\\n        uint256 sentinel_,\\n        uint256 structSize_\\n    ) internal pure returns (StackPointer, uint256[] memory) {\\n        (StackPointer stackTopAfter_, uint256[] memory tempArray_) = stackTop_\\n            .consumeSentinel(stackBottom_, sentinel_, structSize_);\\n        uint256 structsLength_ = tempArray_.length / structSize_;\\n        uint256[] memory refs_ = new uint256[](structsLength_);\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n                let refCursor_ := add(refs_, 0x20)\\n                let refEnd_ := add(refCursor_, mul(structsLength_, 0x20))\\n                let tempCursor_ := add(tempArray_, 0x20)\\n                let tempStepSize_ := mul(structSize_, 0x20)\\n            } lt(refCursor_, refEnd_) {\\n                refCursor_ := add(refCursor_, 0x20)\\n                tempCursor_ := add(tempCursor_, tempStepSize_)\\n            } {\\n                mstore(refCursor_, tempCursor_)\\n            }\\n        }\\n        return (stackTopAfter_, refs_);\\n    }\\n\\n    /// Write a value at the stack pointer. Typically only useful as intermediate\\n    /// logic within some opcode etc. as the value will be treated as an out of\\n    /// bounds for future reads unless the stack top after the opcode logic is\\n    /// above the pointer.\\n    /// @param stackPointer_ The stack top to write the value at.\\n    /// @param a_ The value to write.\\n    function set(StackPointer stackPointer_, uint256 a_) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackPointer_, a_)\\n        }\\n    }\\n\\n    /// Store a `uint256` at the stack pointer and return the stack pointer\\n    /// above the written value. The following statements are equivalent in\\n    /// functionality but A may be less gas if the compiler fails to inline\\n    /// some function calls.\\n    /// A:\\n    /// ```\\n    /// stackPointer_ = stackPointer_.push(a_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackPointer_.set(a_);\\n    /// stackPointer_ = stackPointer_.up();\\n    /// ```\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param a_ The value to write.\\n    /// @return The stack pointer above where `a_` was written to.\\n    function push(\\n        StackPointer stackPointer_,\\n        uint256 a_\\n    ) internal pure returns (StackPointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackPointer_, a_)\\n            stackPointer_ := add(stackPointer_, 0x20)\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Store a `uint256[]` at the stack pointer and return the stack pointer\\n    /// above the written values. The length of the array is NOT written to the\\n    /// stack, ONLY the array values are copied to the stack. The following\\n    /// statements are equivalent in functionality but A may be less gas if the\\n    /// compiler fails to inline some function calls.\\n    /// A:\\n    /// ```\\n    /// stackPointer_ = stackPointer_.push(array_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// unchecked {\\n    ///   for (uint256 i_ = 0; i_ < array_.length; i_++) {\\n    ///     stackPointer_ = stackPointer_.push(array_[i_]);\\n    ///   }\\n    /// }\\n    /// ```\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param array_ The array of values to write.\\n    /// @return The stack pointer above the array.\\n    function push(\\n        StackPointer stackPointer_,\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        array_.unsafeCopyValuesTo(StackPointer.unwrap(stackPointer_));\\n        return stackPointer_.up(array_.length);\\n    }\\n\\n    /// Store a `uint256[]` at the stack pointer and return the stack pointer\\n    /// above the written values. The length of the array IS written to the\\n    /// stack.\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param array_ The array of values and length to write.\\n    /// @return The stack pointer above the array.\\n    function pushWithLength(\\n        StackPointer stackPointer_,\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        return stackPointer_.push(array_.length).push(array_);\\n    }\\n\\n    /// Store `bytes` at the stack pointer and return the stack pointer above\\n    /// the written bytes. The length of the bytes is NOT written to the stack,\\n    /// ONLY the bytes are written. As `bytes` may be of arbitrary length, i.e.\\n    /// it MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\\n    /// ensure that this is safe in context of subsequent reads and writes.\\n    /// @param stackPointer_ The stack top to write at.\\n    /// @param bytes_ The bytes to write at the stack top.\\n    /// @return The stack top above the written bytes.\\n    function unalignedPush(\\n        StackPointer stackPointer_,\\n        bytes memory bytes_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer.unwrap(bytes_.asStackPointer().up()).unsafeCopyBytesTo(\\n            StackPointer.unwrap(stackPointer_),\\n            bytes_.length\\n        );\\n        return stackPointer_.upBytes(bytes_.length);\\n    }\\n\\n    /// Store `bytes` at the stack pointer and return the stack top above the\\n    /// written bytes. The length of the bytes IS written to the stack in\\n    /// addition to the bytes. As `bytes` may be of arbitrary length, i.e. it\\n    /// MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\\n    /// ensure that this is safe in context of subsequent reads and writes.\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param bytes_ The bytes to write with their length at the stack pointer.\\n    /// @return The stack pointer above the written bytes.\\n    function unalignedPushWithLength(\\n        StackPointer stackPointer_,\\n        bytes memory bytes_\\n    ) internal pure returns (StackPointer) {\\n        return stackPointer_.push(bytes_.length).unalignedPush(bytes_);\\n    }\\n\\n    /// Store 8x `uint256` at the stack pointer and return the stack pointer\\n    /// above the written value. The following statements are equivalent in\\n    /// functionality but A may be cheaper if the compiler fails to\\n    /// inline some function calls.\\n    /// A:\\n    /// ```\\n    /// stackPointer_ = stackPointer_.push(a_, b_, c_, d_, e_, f_, g_, h_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackPointer_ = stackPointer_\\n    ///   .push(a_)\\n    ///   .push(b_)\\n    ///   .push(c_)\\n    ///   .push(d_)\\n    ///   .push(e_)\\n    ///   .push(f_)\\n    ///   .push(g_)\\n    ///   .push(h_);\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param a_ The first value to write.\\n    /// @param b_ The second value to write.\\n    /// @param c_ The third value to write.\\n    /// @param d_ The fourth value to write.\\n    /// @param e_ The fifth value to write.\\n    /// @param f_ The sixth value to write.\\n    /// @param g_ The seventh value to write.\\n    /// @param h_ The eighth value to write.\\n    /// @return The stack pointer above where `h_` was written.\\n    function push(\\n        StackPointer stackPointer_,\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_,\\n        uint256 e_,\\n        uint256 f_,\\n        uint256 g_,\\n        uint256 h_\\n    ) internal pure returns (StackPointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackPointer_, a_)\\n            mstore(add(stackPointer_, 0x20), b_)\\n            mstore(add(stackPointer_, 0x40), c_)\\n            mstore(add(stackPointer_, 0x60), d_)\\n            mstore(add(stackPointer_, 0x80), e_)\\n            mstore(add(stackPointer_, 0xA0), f_)\\n            mstore(add(stackPointer_, 0xC0), g_)\\n            mstore(add(stackPointer_, 0xE0), h_)\\n            stackPointer_ := add(stackPointer_, 0x100)\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        a_ = fn_(a_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(Operand, uint256) internal view returns (uint256) fn_,\\n        Operand operand_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        a_ = fn_(operand_, a_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x20)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n        }\\n        a_ = fn_(a_, b_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Reduce a function N times, reading and writing inputs and the accumulated\\n    /// result on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param n_ The number of times to apply fn_ to accumulate a final result.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFnN(\\n        StackPointer stackTop_,\\n        function(uint256, uint256) internal view returns (uint256) fn_,\\n        uint256 n_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 bottom_;\\n            uint256 cursor_;\\n            uint256 a_;\\n            uint256 b_;\\n            StackPointer stackTopAfter_;\\n            assembly (\\\"memory-safe\\\") {\\n                bottom_ := sub(stackTop_, mul(n_, 0x20))\\n                a_ := mload(bottom_)\\n                stackTopAfter_ := add(bottom_, 0x20)\\n                cursor_ := stackTopAfter_\\n            }\\n            while (cursor_ < StackPointer.unwrap(stackTop_)) {\\n                assembly (\\\"memory-safe\\\") {\\n                    b_ := mload(cursor_)\\n                }\\n                a_ = fn_(a_, b_);\\n                cursor_ += 0x20;\\n            }\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(bottom_, a_)\\n            }\\n            return stackTopAfter_;\\n        }\\n    }\\n\\n    /// Reduce a function N times, reading and writing inputs and the accumulated\\n    /// result on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param n_ The number of times to apply fn_ to accumulate a final result.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFnN(\\n        StackPointer stackTop_,\\n        function(uint256) internal view fn_,\\n        uint256 n_\\n    ) internal view returns (StackPointer) {\\n        uint256 cursor_;\\n        uint256 a_;\\n        StackPointer stackTopAfter_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTopAfter_ := sub(stackTop_, mul(n_, 0x20))\\n            cursor_ := stackTopAfter_\\n        }\\n        while (cursor_ < StackPointer.unwrap(stackTop_)) {\\n            assembly (\\\"memory-safe\\\") {\\n                a_ := mload(cursor_)\\n                cursor_ := add(cursor_, 0x20)\\n            }\\n            fn_(a_);\\n        }\\n        return stackTopAfter_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 c_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x40)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n            c_ := mload(add(stackTop_, 0x20))\\n        }\\n        a_ = fn_(a_, b_, c_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256, uint256)\\n            internal\\n            view\\n            returns (uint256) fn_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 c_;\\n        uint256 d_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x60)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n            c_ := mload(add(stackTop_, 0x20))\\n            d_ := mload(add(stackTop_, 0x40))\\n        }\\n        a_ = fn_(a_, b_, c_, d_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param operand_ Operand is passed from the source instead of the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(Operand, uint256, uint256) internal view returns (uint256) fn_,\\n        Operand operand_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x20)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n        }\\n        a_ = fn_(operand_, a_, b_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the array to pass to fn_ from the stack.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256[] memory) internal view returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        (uint256 a_, uint256[] memory tail_) = stackTop_.list(length_);\\n        uint256 b_ = fn_(tail_);\\n        return tail_.asStackPointer().push(a_).push(b_);\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the array to pass to fn_ from the stack.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        (uint256 b_, uint256[] memory tail_) = stackTop_.list(length_);\\n        StackPointer stackTopAfter_ = tail_.asStackPointer();\\n        (StackPointer location_, uint256 a_) = stackTopAfter_.pop();\\n        location_.set(fn_(a_, b_, tail_));\\n        return stackTopAfter_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the array to pass to fn_ from the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        (uint256 c_, uint256[] memory tail_) = stackTop_.list(length_);\\n        (StackPointer stackTopAfter_, uint256 b_) = tail_\\n            .asStackPointer()\\n            .pop();\\n        uint256 a_ = stackTopAfter_.peek();\\n        stackTopAfter_.down().set(fn_(a_, b_, c_, tail_));\\n        return stackTopAfter_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the arrays to pass to fn_ from the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256[] memory, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256[] memory) fn_,\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        StackPointer csStart_ = stackTop_.down(length_);\\n        uint256[] memory cs_ = LibUint256Array.copyToNewUint256Array(\\n            StackPointer.unwrap(csStart_),\\n            length_\\n        );\\n        (uint256 a_, uint256[] memory bs_) = csStart_.list(length_);\\n\\n        uint256[] memory results_ = fn_(a_, bs_, cs_);\\n        if (results_.length != length_) {\\n            revert UnexpectedResultLength(length_, results_.length);\\n        }\\n\\n        StackPointer bottom_ = bs_.asStackPointer();\\n        LibUint256Array.unsafeCopyValuesTo(\\n            results_,\\n            StackPointer.unwrap(bottom_)\\n        );\\n        return bottom_.up(length_);\\n    }\\n\\n    /// Returns `length_` values from the stack as an array without allocating\\n    /// new memory. As arrays always start with their length, this requires\\n    /// writing the length value to the stack below the array values. The value\\n    /// that is overwritten in the process is also returned so that data is not\\n    /// lost. For example, imagine a stack `[ A B C D ]` and we list 2 values.\\n    /// This will write the stack to look like `[ A 2 C D ]` and return both `B`\\n    /// and a pointer to `2` represented as a `uint256[]`.\\n    /// The returned array is ONLY valid for as long as the stack DOES NOT move\\n    /// back into its memory. As soon as the stack moves up again and writes into\\n    /// the array it will be corrupt. The caller MUST ensure that it does not\\n    /// read from the returned array after it has been corrupted by subsequent\\n    /// stack writes.\\n    /// @param stackPointer_ The stack pointer to read the values below into an\\n    /// array.\\n    /// @param length_ The number of values to include in the returned array.\\n    /// @return head_ The value that was overwritten with the length.\\n    /// @return tail_ The array constructed from the stack memory.\\n    function list(\\n        StackPointer stackPointer_,\\n        uint256 length_\\n    ) internal pure returns (uint256, uint256[] memory) {\\n        uint256 head_;\\n        uint256[] memory tail_;\\n        assembly (\\\"memory-safe\\\") {\\n            tail_ := sub(stackPointer_, add(0x20, mul(length_, 0x20)))\\n            head_ := mload(tail_)\\n            mstore(tail_, length_)\\n        }\\n        return (head_, tail_);\\n    }\\n\\n    /// Cast a `uint256[]` array to a stack pointer. The stack pointer will\\n    /// point to the length of the array, NOT its first value.\\n    /// @param array_ The array to cast to a stack pointer.\\n    /// @return stackPointer_ The stack pointer that points to the length of the\\n    /// array.\\n    function asStackPointer(\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer stackPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointer_ := array_\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Cast a stack pointer to an array. The value immediately above the stack\\n    /// pointer will be treated as the length of the array, so the proceeding\\n    /// length values will be the items of the array. The caller MUST ensure the\\n    /// values above the stack position constitute a valid array. The returned\\n    /// array will be corrupt if/when the stack subsequently moves into it and\\n    /// writes to those memory locations. The caller MUST ensure that it does\\n    /// NOT read from the returned array after the stack writes over it.\\n    /// @param stackPointer_ The stack pointer that will be cast to an array.\\n    /// @return array_ The array above the stack pointer.\\n    function asUint256Array(\\n        StackPointer stackPointer_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_;\\n        assembly (\\\"memory-safe\\\") {\\n            array_ := stackPointer_\\n        }\\n        return array_;\\n    }\\n\\n    /// Cast a stack position to bytes. The value immediately above the stack\\n    /// position will be treated as the length of the `bytes`, so the proceeding\\n    /// length bytes will be the data of the `bytes`. The caller MUST ensure the\\n    /// length and bytes above the stack top constitute valid `bytes` data. The\\n    /// returned `bytes` will be corrupt if/when the stack subsequently moves\\n    /// into it and writes to those memory locations. The caller MUST ensure\\n    // that it does NOT read from the returned bytes after the stack writes over\\n    /// it.\\n    /// @param stackPointer_ The stack pointer that will be cast to bytes.\\n    /// @return bytes_ The bytes above the stack top.\\n    function asBytes(\\n        StackPointer stackPointer_\\n    ) internal pure returns (bytes memory) {\\n        bytes memory bytes_;\\n        assembly (\\\"memory-safe\\\") {\\n            bytes_ := stackPointer_\\n        }\\n        return bytes_;\\n    }\\n\\n    /// Cast a `uint256[]` array to a stack pointer after its length. The stack\\n    /// pointer will point to the first item of the array, NOT its length.\\n    /// @param array_ The array to cast to a stack pointer.\\n    /// @return stackPointer_ The stack pointer that points to the first item of\\n    /// the array.\\n    function asStackPointerUp(\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer stackPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointer_ := add(array_, 0x20)\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Cast a `uint256[]` array to a stack pointer after its items. The stack\\n    /// pointer will point after the last item of the array. It is out of bounds\\n    /// to read above the returned pointer. This can be interpreted as the stack\\n    /// top assuming the entire given array is a valid stack.\\n    /// @param array_ The array to cast to a stack pointer.\\n    /// @return stackPointer_ The stack pointer that points after the last item\\n    /// of the array.\\n    function asStackPointerAfter(\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer stackPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointer_ := add(array_, add(0x20, mul(mload(array_), 0x20)))\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Cast `bytes` to a stack pointer. The stack pointer will point to the\\n    /// length of the `bytes`, NOT the first byte.\\n    /// @param bytes_ The `bytes` to cast to a stack pointer.\\n    /// @return stackPointer_ The stack top that points to the length of the\\n    /// bytes.\\n    function asStackPointer(\\n        bytes memory bytes_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer stackPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointer_ := bytes_\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Returns the stack pointer 32 bytes above/past the given stack pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @return The stack pointer 32 bytes above the input stack pointer.\\n    function up(\\n        StackPointer stackPointer_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return StackPointer.wrap(StackPointer.unwrap(stackPointer_) + 0x20);\\n        }\\n    }\\n\\n    /// Returns the stack pointer `n_ * 32` bytes above/past the given stack\\n    /// pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @param n_ The multiplier on the stack movement. MAY be zero.\\n    /// @return The stack pointer `n_ * 32` bytes above/past the input stack\\n    /// pointer.\\n    function up(\\n        StackPointer stackPointer_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return\\n                StackPointer.wrap(\\n                    StackPointer.unwrap(stackPointer_) + 0x20 * n_\\n                );\\n        }\\n    }\\n\\n    /// Returns the stack pointer `n_` bytes above/past the given stack pointer.\\n    /// The returned stack pointer MAY NOT be aligned with the given stack\\n    /// pointer for subsequent 32 byte reads and writes. The caller MUST ensure\\n    /// that it is safe to read and write data relative to the returned stack\\n    /// pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @param n_ The number of bytes to move.\\n    /// @return The stack pointer `n_` bytes above/past the given stack pointer.\\n    function upBytes(\\n        StackPointer stackPointer_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return StackPointer.wrap(StackPointer.unwrap(stackPointer_) + n_);\\n        }\\n    }\\n\\n    /// Returns the stack pointer 32 bytes below/before the given stack pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @return The stack pointer 32 bytes below/before the given stack pointer.\\n    function down(\\n        StackPointer stackPointer_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return StackPointer.wrap(StackPointer.unwrap(stackPointer_) - 0x20);\\n        }\\n    }\\n\\n    /// Returns the stack pointer `n_ * 32` bytes below/before the given stack\\n    /// pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @param n_ The multiplier on the movement.\\n    /// @return The stack pointer `n_ * 32` bytes below/before the given stack\\n    /// pointer.\\n    function down(\\n        StackPointer stackPointer_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return\\n                StackPointer.wrap(\\n                    StackPointer.unwrap(stackPointer_) - 0x20 * n_\\n                );\\n        }\\n    }\\n\\n    /// Convert two stack pointer values to a single stack index. A stack index\\n    /// is the distance in 32 byte increments between two stack pointers. The\\n    /// calculations assumes the two stack pointers are aligned. The caller MUST\\n    /// ensure the alignment of both values. The calculation is unchecked and MAY\\n    /// underflow. The caller MUST ensure that the stack top is always above the\\n    /// stack bottom.\\n    /// @param stackBottom_ The lower of the two values.\\n    /// @param stackTop_ The higher of the two values.\\n    /// @return The stack index as 32 byte distance between the top and bottom.\\n    function toIndex(\\n        StackPointer stackBottom_,\\n        StackPointer stackTop_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            return\\n                (StackPointer.unwrap(stackTop_) -\\n                    StackPointer.unwrap(stackBottom_)) / 0x20;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe9c7ce66b490126433ff8e1cf52c92ea78eb2a4e93c88e20c2f6fd8a716b1e96\",\"license\":\"CAL\"},\"contracts/interpreter/shared/RainterpreterExpressionDeployer.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../deploy/IExpressionDeployerV1.sol\\\";\\nimport \\\"../ops/AllStandardOps.sol\\\";\\nimport \\\"../ops/core/OpGet.sol\\\";\\nimport \\\"../../sstore2/SSTORE2.sol\\\";\\n\\n/// @dev Thrown when the pointers known to the expression deployer DO NOT match\\n/// the interpreter it is constructed for. This WILL cause undefined expression\\n/// behaviour so MUST REVERT.\\nerror UnexpectedPointers(bytes actualPointers);\\n\\n/// @dev Thrown when the bytecode hash known to the expression deployer DOES NOT\\n/// match the interpreter it is constructed for. This WILL cause undefined\\n/// expression behaviour so MUST REVERT.\\nerror UnexpectedInterpreterBytecodeHash(bytes32 actualBytecodeHash);\\n\\n/// @dev There are more entrypoints defined by the minimum stack outputs than\\n/// there are provided sources. This means the calling contract WILL attempt to\\n/// eval a dangling reference to a non-existent source at some point, so this\\n/// MUST REVERT.\\nerror MissingEntrypoint(uint256 expectedEntrypoints, uint256 actualEntrypoints);\\n\\n/// @dev The function pointers known to the expression deployer. These are\\n/// immutable for any given interpreter so once the expression deployer is\\n/// constructed and has verified that this matches what the interpreter reports,\\n/// it can use this constant value to compile and serialize expressions.\\nbytes constant OPCODE_FUNCTION_POINTERS = hex\\\"0cb50cc30d190d6b0de90e150eae0f780fad0fcb105310621070107e108c1062109a10a810b610c510d410e210f0116811771186119511a411b311fc120e121c124e125c126a12781287129612a512b412c312d212e112f012ff130e131d132b13391347135513631371137f138e139d13ab13f507e5\\\";\\n\\n/// @dev The interpreter bytecode hash known to the expression deployer. Checking\\n/// this guarantees that the code on the other side of the function pointers is\\n/// what the expression deployer expects it to be, giving significantly higher\\n/// confidence that the integrity checks are valid.\\nbytes32 constant INTERPRETER_BYTECODE_HASH = bytes32(\\n    0xda914e60d06a83d8099b6562ac80dd60acbac7c35f0fcee9bffa8e160b377f63\\n);\\n\\n/// @title RainterpreterExpressionDeployer\\n/// @notice Minimal binding of the `IExpressionDeployerV1` interface to the\\n/// `LibIntegrityCheck.ensureIntegrity` loop and `AllStandardOps`.\\ncontract RainterpreterExpressionDeployer is IExpressionDeployerV1 {\\n    using LibInterpreterState for StateConfig;\\n    using LibStackPointer for StackPointer;\\n\\n    /// The interpreter passed in construction is valid. The only valid\\n    /// interpreter has the exact bytecode hash known to the expression deployer.\\n    /// @param sender The account that constructed the expression deployer.\\n    /// @param interpreter The address of the interpreter that the expression\\n    /// deployer agrees to perform integrity checks for. Note that the pairing\\n    /// between interpreter and expression deployer needs to be checked and\\n    /// enforced elsewhere offchain and/or onchain.\\n    event ValidInterpreter(address sender, address interpreter);\\n\\n    /// The config of the deployed expression including uncompiled sources. Will\\n    /// only be emitted after the config passes the integrity check.\\n    /// @param sender The caller of `deployExpression`.\\n    /// @param config The config for the deployed expression.\\n    event ExpressionConfig(address sender, StateConfig config);\\n\\n    /// The address of the deployed expression. Will only be emitted once the\\n    /// expression can be loaded and deserialized into an evaluable interpreter\\n    /// state.\\n    /// @param sender The caller of `deployExpression`.\\n    /// @param expression The address of the deployed expression.\\n    event ExpressionDeployed(address sender, address expression);\\n\\n    /// THIS IS NOT A SECURITY CHECK. IT IS AN INTEGRITY CHECK TO PREVENT HONEST\\n    /// MISTAKES. IT CANNOT PREVENT EITHER A MALICIOUS INTERPRETER OR DEPLOYER\\n    /// FROM BEING EXECUTED.\\n    constructor(address interpreter_) {\\n        // Guard against serializing incorrect function pointers, which would\\n        // cause undefined runtime behaviour for corrupted opcodes.\\n        bytes memory functionPointers_ = IInterpreterV1(interpreter_)\\n            .functionPointers();\\n        if (\\n            keccak256(functionPointers_) != keccak256(OPCODE_FUNCTION_POINTERS)\\n        ) {\\n            revert UnexpectedPointers(functionPointers_);\\n        }\\n\\n        // Guard against an interpreter with unknown/untrusted bytecode that\\n        // could run arbitrary logic even if the function pointers are identical\\n        // to the known/trusted interpreter.\\n        bytes32 interpreterHash_;\\n        assembly (\\\"memory-safe\\\") {\\n            interpreterHash_ := extcodehash(interpreter_)\\n        }\\n        if (interpreterHash_ != INTERPRETER_BYTECODE_HASH) {\\n            revert UnexpectedInterpreterBytecodeHash(interpreterHash_);\\n        }\\n\\n        emit ValidInterpreter(msg.sender, interpreter_);\\n    }\\n\\n    /// Defines all the function pointers to integrity checks. This is the\\n    /// expression deployer's equivalent of the opcode function pointers and\\n    /// follows a near identical dispatch process. These are never compiled into\\n    /// source and are instead indexed into directly by the integrity check. The\\n    /// indexing into integrity pointers (which has an out of bounds check) is a\\n    /// proxy for enforcing that all opcode pointers exist at runtime, so the\\n    /// length of the integrity pointers MUST match the length of opcode function\\n    /// pointers. This function is `virtual` so that it can be overridden\\n    /// pairwise with overrides to `functionPointers` on `Rainterpreter`.\\n    /// @return The list of integrity function pointers.\\n    function integrityFunctionPointers()\\n        internal\\n        view\\n        virtual\\n        returns (\\n            function(IntegrityCheckState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer)[]\\n                memory\\n        )\\n    {\\n        function(IntegrityCheckState memory, Operand, StackPointer)\\n            view\\n            returns (StackPointer)[]\\n            memory localFnPtrs_ = new function(\\n                IntegrityCheckState memory,\\n                Operand,\\n                StackPointer\\n            ) view returns (StackPointer)[](1);\\n        localFnPtrs_[0] = OpGet.integrity;\\n        return AllStandardOps.integrityFunctionPointers(localFnPtrs_);\\n    }\\n\\n    /// @inheritdoc IExpressionDeployerV1\\n    function deployExpression(\\n        StateConfig memory config_,\\n        uint256[] memory minStackOutputs_\\n    ) external returns (address) {\\n        // Ensure that we are not missing any entrypoints expected by the calling\\n        // contract.\\n        if (minStackOutputs_.length > config_.sources.length) {\\n            revert MissingEntrypoint(\\n                minStackOutputs_.length,\\n                config_.sources.length\\n            );\\n        }\\n\\n        // Build the initial state of the integrity check.\\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\\n            .newState(config_, integrityFunctionPointers());\\n        // Loop over each possible entrypoint as defined by the calling contract\\n        // and check the integrity of each. At the least we need to be sure that\\n        // there are no out of bounds stack reads/writes and to know the total\\n        // memory to allocate when later deserializing an associated interpreter\\n        // state for evaluation.\\n        StackPointer initialStackBottom_ = integrityCheckState_.stackBottom;\\n        StackPointer initialStackHighwater_ = integrityCheckState_.stackHighwater;\\n        for (uint256 i_ = 0; i_ < minStackOutputs_.length; i_++) {\\n            // Reset the top, bottom and highwater between each entrypoint as\\n            // every external eval MUST have a fresh stack, but retain the max\\n            // stack height as the latter is used for unconditional memory\\n            // allocation so MUST be the max height across all possible\\n            // entrypoints.\\n            integrityCheckState_.stackBottom = initialStackBottom_;\\n            integrityCheckState_.stackHighwater = initialStackHighwater_;\\n            LibIntegrityCheck.ensureIntegrity(\\n                integrityCheckState_,\\n                SourceIndex.wrap(i_),\\n                INITIAL_STACK_BOTTOM,\\n                minStackOutputs_[i_]\\n            );\\n        }\\n        uint256 stackLength_ = integrityCheckState_.stackBottom.toIndex(\\n            integrityCheckState_.stackMaxTop\\n        );\\n\\n        // Emit the config of the expression _before_ we serialize it, as the\\n        // serialization process itself is destructive of the config in memory.\\n        emit ExpressionConfig(msg.sender, config_);\\n\\n        // Serialize the state config into bytes that can be deserialized later\\n        // by the interpreter. This will compile the sources according to the\\n        // provided function pointers.\\n        bytes memory stateBytes_ = config_.serialize(\\n            stackLength_,\\n            OPCODE_FUNCTION_POINTERS\\n        );\\n\\n        // Deploy the serialized expression onchain.\\n        address expression_ = SSTORE2.write(stateBytes_);\\n\\n        // Emit and return the address of the deployed expression.\\n        emit ExpressionDeployed(msg.sender, expression_);\\n\\n        return expression_;\\n    }\\n}\\n\",\"keccak256\":\"0xfcaa12dcbb94edaa883f939422f04cca8dc325d3d0d2ede6167685273d3182b0\",\"license\":\"CAL\"},\"contracts/kv/LibMemoryKV.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../math/Binary.sol\\\";\\n\\n/// Thrown when attempting to read a value from the other side of a zero pointer.\\nerror InvalidPtr(MemoryKVPtr ptr);\\n\\n/// Entrypoint into the key/value store. Is a mutable pointer to the head of the\\n/// linked list. Initially points to `0` for an empty list. The total length of\\n/// the linked list is also encoded alongside the pointer to allow efficient O(1)\\n/// memory allocation for a `uint256[]` in the case of a final snapshot/export.\\ntype MemoryKV is uint256;\\n/// The key associated with the value for each item in the linked list.\\ntype MemoryKVKey is uint256;\\n/// The pointer to the next item in the list. `0` signifies the end of the list.\\ntype MemoryKVPtr is uint256;\\n/// The value associated with the key for each item in the linked list.\\ntype MemoryKVVal is uint256;\\n\\n/// @title LibMemoryKV\\n/// @notice Implements an in-memory key/value store in terms of a linked list\\n/// that can be snapshotted/exported to a `uint256[]` of pairwise keys/values as\\n/// its items. Ostensibly supports reading/writing to storage within a read only\\n/// context in an interpreter `eval` by tracking changes requested by an\\n/// expression in memory as a cache-like structure over the underlying storage.\\n///\\n/// A linked list is required because unlike stack movements we do NOT have any\\n/// way to precalculate how many items will be included in the final set at\\n/// deploy time. Any two writes may share the same key known only at runtime, so\\n/// any two writes may result in either 2 or 1 insertions (and 0 or 1 updates).\\n/// We could attempt to solve this by allowing duplicate keys and simply append\\n/// values for each write, so two writes will always insert 2 values, but then\\n/// looping constructs such as `OpDoWhile` and `OpFoldContext` with net 0 stack\\n/// movements (i.e. predictably deallocateable memory) can still cause\\n/// unbounded/unknown inserts for our state changes. The linked list allows us\\n/// to both dedupe same-key writes and also safely handle an unknown\\n/// (at deploy time) number of upserts. New items are inserted at the head of\\n/// the list and a pointer to `0` is the sentinel that defines the end of the\\n/// list. It is an error to dereference the `0` pointer.\\n///\\n/// Currently implemented as O(n) where n is likely relatively small, in future\\n/// could be reimplemented as 8 linked lists over a single `MemoryKV` by packing\\n/// many `MemoryKVPtr` and using `%` to distribute keys between lists. The\\n/// extremely high gas cost of writing to storage itself should be a natural\\n/// disincentive for n getting large enough to cause the linked list traversal\\n/// to be a significant gas cost itself.\\n///\\n/// Currently implemented in terms of raw `uint256` custom types that represent\\n/// keys, values and pointers. Could be reimplemented in terms of an equivalent\\n/// struct with key, value and pointer fields.\\nlibrary LibMemoryKV {\\n    /// Reads the `MemoryKVVal` that some `MemoryKVPtr` is pointing to. It is an\\n    /// error to call this if `ptr_` is `0`.\\n    /// @param ptr_ The pointer to read the value\\n    function readPtrVal(\\n        MemoryKVPtr ptr_\\n    ) internal pure returns (MemoryKVVal v_) {\\n        // This is ALWAYS a bug. It means the caller did not check if the ptr is\\n        // nonzero before trying to read from it.\\n        if (MemoryKVPtr.unwrap(ptr_) == 0) {\\n            revert InvalidPtr(ptr_);\\n        }\\n\\n        assembly (\\\"memory-safe\\\") {\\n            v_ := mload(add(ptr_, 0x20))\\n        }\\n    }\\n\\n    /// Finds the pointer to the item that holds the value associated with the\\n    /// given key. Walks the linked list from the entrypoint into the key/value\\n    /// store until it finds the specified key. As the last pointer in the list\\n    /// is always `0`, `0` is what will be returned if the key is not found. Any\\n    /// non-zero pointer implies the value it points to is for the provided key.\\n    /// @param kv_ The entrypoint to the key/value store.\\n    /// @param k_ The key to lookup a pointer for.\\n    /// @return ptr_ The _pointer_ to the value for the key, if it exists, else\\n    /// a pointer to `0`. If the pointer is non-zero the associated value can be\\n    /// read to a `MemoryKVVal` with `LibMemoryKV.readPtrVal`.\\n    function getPtr(\\n        MemoryKV kv_,\\n        MemoryKVKey k_\\n    ) internal pure returns (MemoryKVPtr ptr_) {\\n        uint256 mask_ = MASK_16BIT;\\n        assembly (\\\"memory-safe\\\") {\\n            // loop until k found or give up if ptr is zero\\n            for {\\n                ptr_ := and(kv_, mask_)\\n            } iszero(iszero(ptr_)) {\\n                ptr_ := mload(add(ptr_, 0x40))\\n            } {\\n                if eq(k_, mload(ptr_)) {\\n                    break\\n                }\\n            }\\n        }\\n    }\\n\\n    /// Upserts a value in the set by its key. I.e. if the key exists then the\\n    /// associated value will be mutated in place, else a new key/value pair will\\n    /// be inserted. The key/value store pointer will be mutated and returned as\\n    /// it MAY point to a new list item in memory.\\n    /// @param kv_ The key/value store pointer to modify.\\n    /// @param k_ The key to upsert against.\\n    /// @param v_ The value to associate with the upserted key.\\n    /// @return The final value of `kv_` as it MAY be modified if the upsert\\n    /// resulted in an insert operation.\\n    function setVal(\\n        MemoryKV kv_,\\n        MemoryKVKey k_,\\n        MemoryKVVal v_\\n    ) internal pure returns (MemoryKV) {\\n        MemoryKVPtr ptr_ = getPtr(kv_, k_);\\n        uint256 mask_ = MASK_16BIT;\\n        // update\\n        if (MemoryKVPtr.unwrap(ptr_) > 0) {\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(add(ptr_, 0x20), v_)\\n            }\\n        }\\n        // insert\\n        else {\\n            assembly (\\\"memory-safe\\\") {\\n                // allocate new memory\\n                ptr_ := mload(0x40)\\n                mstore(0x40, add(ptr_, 0x60))\\n                // set k/v/ptr\\n                mstore(ptr_, k_)\\n                mstore(add(ptr_, 0x20), v_)\\n                mstore(add(ptr_, 0x40), and(kv_, mask_))\\n                // kv must point to new insertion and update array len\\n                kv_ := or(\\n                    // inc len by 2\\n                    shl(16, add(shr(16, kv_), 2)),\\n                    // set ptr\\n                    ptr_\\n                )\\n            }\\n        }\\n        return kv_;\\n    }\\n\\n    /// Export/snapshot the underlying linked list of the key/value store into\\n    /// a standard `uint256[]`. Reads the total length to preallocate the\\n    /// `uint256[]` then walks the entire linked list, copying every key and\\n    /// value into the array, until it reaches a pointer to `0`. Note this is a\\n    /// one time export, if the key/value store is subsequently mutated the built\\n    /// array will not reflect these mutations.\\n    /// @param kv_ The entrypoint into the key/value store.\\n    /// @return All the keys and values copied pairwise into a `uint256[]`.\\n    function toUint256Array(\\n        MemoryKV kv_\\n    ) internal pure returns (uint256[] memory) {\\n        unchecked {\\n            uint256 ptr_ = MemoryKV.unwrap(kv_) & MASK_16BIT;\\n            uint256 length_ = MemoryKV.unwrap(kv_) >> 16;\\n            uint256[] memory arr_ = new uint256[](length_);\\n            assembly (\\\"memory-safe\\\") {\\n                for {\\n                    let cursor_ := add(arr_, 0x20)\\n                    let end_ := add(cursor_, mul(mload(arr_), 0x20))\\n                } lt(cursor_, end_) {\\n                    cursor_ := add(cursor_, 0x20)\\n                    ptr_ := mload(add(ptr_, 0x40))\\n                } {\\n                    // key\\n                    mstore(cursor_, mload(ptr_))\\n                    cursor_ := add(cursor_, 0x20)\\n                    // value\\n                    mstore(cursor_, mload(add(ptr_, 0x20)))\\n                }\\n            }\\n            return arr_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbf745ef2a8e5918ff93548a431296811dded10b727bfadbfcc35c6f742cba91a\",\"license\":\"CAL\"},\"contracts/math/Binary.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// @dev Binary 1.\\nuint256 constant B_1 = 2 ** 1 - 1;\\n/// @dev Binary 11.\\nuint256 constant B_11 = 2 ** 2 - 1;\\n/// @dev Binary 111.\\nuint256 constant B_111 = 2 ** 3 - 1;\\n/// @dev Binary 1111.\\nuint256 constant B_1111 = 2 ** 4 - 1;\\n/// @dev Binary 11111.\\nuint256 constant B_11111 = 2 ** 5 - 1;\\n/// @dev Binary 111111.\\nuint256 constant B_111111 = 2 ** 6 - 1;\\n/// @dev Binary 1111111.\\nuint256 constant B_1111111 = 2 ** 7 - 1;\\n/// @dev Binary 11111111.\\nuint256 constant B_11111111 = 2 ** 8 - 1;\\n/// @dev Binary 111111111.\\nuint256 constant B_111111111 = 2 ** 9 - 1;\\n/// @dev Binary 1111111111.\\nuint256 constant B_1111111111 = 2 ** 10 - 1;\\n/// @dev Binary 11111111111.\\nuint256 constant B_11111111111 = 2 ** 11 - 1;\\n/// @dev Binary 111111111111.\\nuint256 constant B_111111111111 = 2 ** 12 - 1;\\n/// @dev Binary 1111111111111.\\nuint256 constant B_1111111111111 = 2 ** 13 - 1;\\n/// @dev Binary 11111111111111.\\nuint256 constant B_11111111111111 = 2 ** 14 - 1;\\n/// @dev Binary 111111111111111.\\nuint256 constant B_111111111111111 = 2 ** 15 - 1;\\n/// @dev Binary 1111111111111111.\\nuint256 constant B_1111111111111111 = 2 ** 16 - 1;\\n\\n/// @dev Bitmask for 1 bit.\\nuint256 constant MASK_1BIT = B_1;\\n/// @dev Bitmask for 2 bits.\\nuint256 constant MASK_2BIT = B_11;\\n/// @dev Bitmask for 3 bits.\\nuint256 constant MASK_3BIT = B_111;\\n/// @dev Bitmask for 4 bits.\\nuint256 constant MASK_4BIT = B_1111;\\n/// @dev Bitmask for 5 bits.\\nuint256 constant MASK_5BIT = B_11111;\\n/// @dev Bitmask for 6 bits.\\nuint256 constant MASK_6BIT = B_111111;\\n/// @dev Bitmask for 7 bits.\\nuint256 constant MASK_7BIT = B_1111111;\\n/// @dev Bitmask for 8 bits.\\nuint256 constant MASK_8BIT = B_11111111;\\n/// @dev Bitmask for 9 bits.\\nuint256 constant MASK_9BIT = B_111111111;\\n/// @dev Bitmask for 10 bits.\\nuint256 constant MASK_10BIT = B_1111111111;\\n/// @dev Bitmask for 11 bits.\\nuint256 constant MASK_11BIT = B_11111111111;\\n/// @dev Bitmask for 12 bits.\\nuint256 constant MASK_12BIT = B_111111111111;\\n/// @dev Bitmask for 13 bits.\\nuint256 constant MASK_13BIT = B_1111111111111;\\n/// @dev Bitmask for 14 bits.\\nuint256 constant MASK_14BIT = B_11111111111111;\\n/// @dev Bitmask for 15 bits.\\nuint256 constant MASK_15BIT = B_111111111111111;\\n/// @dev Bitmask for 16 bits.\\nuint256 constant MASK_16BIT = B_1111111111111111;\\n\",\"keccak256\":\"0x63a0b41ebb7c6b78d7e8a9f8b33900421c5d641276a36a6258e97fab4310cdf2\",\"license\":\"CAL\"},\"contracts/math/FixedPointMath.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\nimport {SafeCastUpgradeable as SafeCast} from \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\\\";\\nimport \\\"../math/SaturatingMath.sol\\\";\\n\\n/// @dev The scale of all fixed point math. This is adopting the conventions of\\n/// both ETH (wei) and most ERC20 tokens, so is hopefully uncontroversial.\\nuint256 constant FP_DECIMALS = 18;\\n/// @dev The number `1` in the standard fixed point math scaling. Most of the\\n/// differences between fixed point math and regular math is multiplying or\\n/// dividing by `ONE` after the appropriate scaling has been applied.\\nuint256 constant FP_ONE = 1e18;\\n\\n/// @title FixedPointMath\\n/// @notice Sometimes we want to do math with decimal values but all we have\\n/// are integers, typically uint256 integers. Floats are very complex so we\\n/// don't attempt to simulate them. Instead we provide a standard definition of\\n/// \\\"one\\\" as 10 ** 18 and scale everything up/down to this as fixed point math.\\n///\\n/// Overflows SATURATE rather than error, e.g. scaling max uint256 up will result\\n/// in max uint256. The max uint256 as decimal is roughly 1e77 so scaling values\\n/// comparable to 1e18 is unlikely to ever saturate in practise. For a typical\\n/// use case involving tokens, the entire supply of a token rescaled up a full\\n/// 18 decimals would still put it \\\"only\\\" in the region of ~1e40 which has a full\\n/// 30 orders of magnitude buffer before running into saturation issues. However,\\n/// there's no theoretical reason that a token or any other use case couldn't use\\n/// large numbers or extremely precise decimals that would push this library to\\n/// saturation point, so it MUST be treated with caution around the edge cases.\\n///\\n/// One case where values could come near the saturation/overflow point is phantom\\n/// overflow. This is where an overflow happens during the internal logic of some\\n/// operation like \\\"fixed point multiplication\\\" even though the final result fits\\n/// within uint256. The fixed point multiplication and division functions are\\n/// thin wrappers around Open Zeppelin's `mulDiv` function, that handles phantom\\n/// overflow, reducing the problems of rescaling overflow/saturation to the input\\n/// and output range rather than to the internal implementation details. For this\\n/// library that gives an additional full 18 orders of magnitude for safe fixed\\n/// point multiplication operations.\\n///\\n/// Note that scaling down ANY fixed point decimal also reduces the precision\\n/// which lead to dust or in the worst case trapped funds if subsequent\\n/// subtraction overflows a rounded-down number. Consider using saturating\\n/// subtraction for safety against previously downscaled values, and whether\\n/// trapped dust is a significant issue. If you need to retain full/arbitrary\\n/// precision in the case of downscaling DO NOT use this library.\\nlibrary FixedPointMath {\\n    using Math for uint256;\\n    using SafeCast for int256;\\n    using SaturatingMath for uint256;\\n\\n    /// Scale a fixed point decimal of some scale factor to match `DECIMALS`.\\n    /// @param a_ Some fixed point decimal value.\\n    /// @param aDecimals_ The number of fixed decimals of `a_`.\\n    /// @return `a_` scaled to match `DECIMALS`.\\n    function scale18(\\n        uint256 a_,\\n        uint256 aDecimals_\\n    ) internal pure returns (uint256) {\\n        uint256 decimals_;\\n        if (FP_DECIMALS == aDecimals_) {\\n            return a_;\\n        } else if (FP_DECIMALS > aDecimals_) {\\n            unchecked {\\n                decimals_ = FP_DECIMALS - aDecimals_;\\n            }\\n            return a_.saturatingMul(10 ** decimals_);\\n        } else {\\n            unchecked {\\n                decimals_ = aDecimals_ - FP_DECIMALS;\\n            }\\n            return a_ / 10 ** decimals_;\\n        }\\n    }\\n\\n    /// Scale a fixed point decimals of `DECIMALS` to some other scale.\\n    /// @param a_ A `DECIMALS` fixed point decimals.\\n    /// @param targetDecimals_ The new scale of `a_`.\\n    /// @return `a_` rescaled from `DECIMALS` to `targetDecimals_`.\\n    function scaleN(\\n        uint256 a_,\\n        uint256 targetDecimals_\\n    ) internal pure returns (uint256) {\\n        uint256 decimals_;\\n        if (targetDecimals_ == FP_DECIMALS) {\\n            return a_;\\n        } else if (FP_DECIMALS > targetDecimals_) {\\n            unchecked {\\n                decimals_ = FP_DECIMALS - targetDecimals_;\\n            }\\n            return a_ / 10 ** decimals_;\\n        } else {\\n            unchecked {\\n                decimals_ = targetDecimals_ - FP_DECIMALS;\\n            }\\n            return a_.saturatingMul(10 ** decimals_);\\n        }\\n    }\\n\\n    /// Scale a fixed point decimals of `DECIMALS` that represents a ratio of\\n    /// a_:b_ according to the decimals of a and b that MAY NOT be `DECIMALS`.\\n    /// i.e. a subsequent call to `a_.fixedPointMul(ratio_)` would yield the value\\n    /// that it would have as though `a_` and `b_` were both `DECIMALS` and we\\n    /// hadn't rescaled the ratio.\\n    function scaleRatio(\\n        uint256 ratio_,\\n        uint8 aDecimals_,\\n        uint8 bDecimals_\\n    ) internal pure returns (uint256) {\\n        return\\n            scaleBy(\\n                ratio_,\\n                (int256(uint(bDecimals_)) - int256(uint256(aDecimals_)))\\n                    .toInt8()\\n            );\\n    }\\n\\n    /// Scale a fixed point up or down by `scaleBy_` orders of magnitude.\\n    /// The caller MUST ensure the end result matches `DECIMALS` if other\\n    /// functions in this library are to work correctly.\\n    /// Notably `scaleBy` is a SIGNED integer so scaling down by negative OOMS\\n    /// is supported.\\n    /// @param a_ Some integer of any scale.\\n    /// @param scaleBy_ OOMs to scale `a_` up or down by.\\n    /// @return `a_` rescaled according to `scaleBy_`.\\n    function scaleBy(\\n        uint256 a_,\\n        int8 scaleBy_\\n    ) internal pure returns (uint256) {\\n        if (scaleBy_ == 0) {\\n            return a_;\\n        } else if (scaleBy_ > 0) {\\n            return a_.saturatingMul(10 ** uint8(scaleBy_));\\n        } else {\\n            uint256 posScaleDownBy_;\\n            unchecked {\\n                posScaleDownBy_ = uint8(-1 * scaleBy_);\\n            }\\n            return a_ / 10 ** posScaleDownBy_;\\n        }\\n    }\\n\\n    /// Fixed point multiplication in native scale decimals.\\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return `a_` multiplied by `b_` to `DECIMALS` fixed point decimals.\\n    function fixedPointMul(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        return a_.mulDiv(b_, FP_ONE);\\n    }\\n\\n    /// Overloaded `fixedPointMul` that exposes underlying `mulDiv` rounding.\\n    function fixedPointMul(\\n        uint256 a_,\\n        uint256 b_,\\n        Math.Rounding rounding_\\n    ) internal pure returns (uint256) {\\n        return a_.mulDiv(b_, FP_ONE, rounding_);\\n    }\\n\\n    /// Fixed point division in native scale decimals.\\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return `a_` divided by `b_` to `DECIMALS` fixed point decimals.\\n    function fixedPointDiv(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        return a_.mulDiv(FP_ONE, b_);\\n    }\\n\\n    /// Overloaded `fixedPointDiv` that exposes underlying `mulDiv` rounding.\\n    function fixedPointDiv(\\n        uint256 a_,\\n        uint256 b_,\\n        Math.Rounding rounding_\\n    ) internal pure returns (uint256) {\\n        return a_.mulDiv(FP_ONE, b_, rounding_);\\n    }\\n}\\n\",\"keccak256\":\"0xb0a3915f29d110fa420c189ca343399c2325646215e20d9c164c5b424a58c8a3\",\"license\":\"CAL\"},\"contracts/math/SaturatingMath.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// @title SaturatingMath\\n/// @notice Sometimes we neither want math operations to error nor wrap around\\n/// on an overflow or underflow. In the case of transferring assets an error\\n/// may cause assets to be locked in an irretrievable state within the erroring\\n/// contract, e.g. due to a tiny rounding/calculation error. We also can't have\\n/// assets underflowing and attempting to approve/transfer \\\"infinity\\\" when we\\n/// wanted \\\"almost or exactly zero\\\" but some calculation bug underflowed zero.\\n/// Ideally there are no calculation mistakes, but in guarding against bugs it\\n/// may be safer pragmatically to saturate arithmatic at the numeric bounds.\\n/// Note that saturating div is not supported because 0/0 is undefined.\\nlibrary SaturatingMath {\\n    /// Saturating addition.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return Minimum of a_ + b_ and max uint256.\\n    function saturatingAdd(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 c_ = a_ + b_;\\n            return c_ < a_ ? type(uint256).max : c_;\\n        }\\n    }\\n\\n    /// Saturating subtraction.\\n    /// @param a_ Minuend.\\n    /// @param b_ Subtrahend.\\n    /// @return Maximum of a_ - b_ and 0.\\n    function saturatingSub(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            return a_ > b_ ? a_ - b_ : 0;\\n        }\\n    }\\n\\n    /// Saturating multiplication.\\n    /// @param a_ First term.\\n    /// @param b_ Second term.\\n    /// @return Minimum of a_ * b_ and max uint256.\\n    function saturatingMul(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being\\n            // zero, but the benefit is lost if 'b' is also tested.\\n            // https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a_ == 0) return 0;\\n            uint256 c_ = a_ * b_;\\n            return c_ / a_ != b_ ? type(uint256).max : c_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5ffcfd7be86bf2a4e28bc55aceeae041b1c014e0a0d7394107238d607ace352a\",\"license\":\"CAL\"},\"contracts/memory/LibMemorySize.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.10;\\n\\n/// @title LibMemorySize\\n/// @notice Reports the size in bytes of type data that represents contigious\\n/// regions of memory. Pointers to regions of memory that may not be congigious\\n/// are not supported, e.g. fields on structs may point to dynamic data that is\\n/// separate to the struct. Length slots for dynamic data are included in the\\n/// size and the size is always measured in bytes.\\nlibrary LibMemorySize {\\n    /// Reports the size of a `uint256` in bytes. Is always 32.\\n    /// @return 32.\\n    function size(uint256) internal pure returns (uint256) {\\n        return 0x20;\\n    }\\n\\n    /// Reports the size of a `uint256[]` in bytes. Is the size of the length\\n    /// slot (32 bytes) plus the length of the array multiplied by 32 bytes per\\n    /// item.\\n    /// @return The size of the array data including its length slot size.\\n    function size(uint256[] memory array_) internal pure returns (uint256) {\\n        unchecked {\\n            return 0x20 + (array_.length * 0x20);\\n        }\\n    }\\n\\n    /// Reports the size of `bytes` data. Is the size of the length slot\\n    /// (32 bytes) plus the number of bytes as per its length.\\n    /// @return The size of the `bytes` data including its length slot size.\\n    function size(bytes memory bytes_) internal pure returns (uint256) {\\n        unchecked {\\n            return 0x20 + bytes_.length;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8d83afcdf42bce8f16b93f7c00f7059e02d86234e78f97ed9d2e19651da616d5\",\"license\":\"CAL\"},\"contracts/orderbook/IOrderBookV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../interpreter/deploy/IExpressionDeployerV1.sol\\\";\\nimport \\\"../interpreter/run/IInterpreterV1.sol\\\";\\n\\nstruct DepositConfig {\\n    address token;\\n    uint256 vaultId;\\n    uint256 amount;\\n}\\n\\nstruct WithdrawConfig {\\n    address token;\\n    uint256 vaultId;\\n    uint256 amount;\\n}\\n\\nstruct IO {\\n    address token;\\n    uint8 decimals;\\n    uint256 vaultId;\\n}\\n\\nstruct OrderConfig {\\n    address expressionDeployer;\\n    address interpreter;\\n    StateConfig interpreterStateConfig;\\n    IO[] validInputs;\\n    IO[] validOutputs;\\n    bytes data;\\n}\\n\\nstruct Order {\\n    address owner;\\n    address interpreter;\\n    EncodedDispatch dispatch;\\n    EncodedDispatch handleIODispatch;\\n    IO[] validInputs;\\n    IO[] validOutputs;\\n    bytes data;\\n}\\n\\nstruct TakeOrdersConfig {\\n    /// Output token from the perspective of the order taker.\\n    address output;\\n    /// Input token from the perspective of the order taker.\\n    address input;\\n    /// Minimum input from the perspective of the order taker.\\n    uint256 minimumInput;\\n    /// Maximum input from the perspective of the order taker.\\n    uint256 maximumInput;\\n    /// Maximum IO ratio as calculated by the order being taken. The input is\\n    /// from the perspective of the order so higher ratio means worse deal for\\n    /// the order taker.\\n    uint256 maximumIORatio;\\n    /// Ordered list of orders that will be taken until the limit is hit. Takers\\n    /// are expected to prioritise orders that appear to be offering better\\n    /// deals i.e. lower IO ratios. This prioritisation and sorting MUST happen\\n    /// offchain, e.g. via. some simulator.\\n    TakeOrderConfig[] orders;\\n}\\n\\nstruct TakeOrderConfig {\\n    Order order;\\n    uint256 inputIOIndex;\\n    uint256 outputIOIndex;\\n}\\n\\nstruct ClearConfig {\\n    uint256 aInputIOIndex;\\n    uint256 aOutputIOIndex;\\n    uint256 bInputIOIndex;\\n    uint256 bOutputIOIndex;\\n    uint256 aBountyVaultId;\\n    uint256 bBountyVaultId;\\n}\\n\\ninterface IOrderBookV1 {\\n    /// depositor => token => vault id => token amount.\\n    function vaultBalance(\\n        address owner,\\n        address token,\\n        uint256 id\\n    ) external view returns (uint256 balance);\\n\\n    function deposit(DepositConfig calldata config) external;\\n\\n    function withdraw(WithdrawConfig calldata config) external;\\n\\n    function addOrder(OrderConfig calldata config) external;\\n\\n    function removeOrder(Order calldata order) external;\\n\\n    function takeOrders(\\n        TakeOrdersConfig calldata takeOrders\\n    ) external returns (uint256 totalInput, uint256 totalOutput);\\n\\n    function clear(\\n        Order memory a,\\n        Order memory b,\\n        ClearConfig calldata clearConfig\\n    ) external;\\n}\\n\",\"keccak256\":\"0x9ddec3a21a2615b952d076b7fbd8c422cf72fd0c27d4dfae8d327033cb25252b\",\"license\":\"CAL\"},\"contracts/sale/ISaleV2.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// An `ISale` can be in one of 4 possible states and a linear progression is\\n/// expected from an \\\"in flight\\\" status to an immutable definitive outcome.\\n/// - Pending: The sale is deployed onchain but cannot be interacted with yet.\\n/// - Active: The sale can now be bought into and otherwise interacted with.\\n/// - Success: The sale has ended AND reached its minimum raise target.\\n/// - Fail: The sale has ended BUT NOT reached its minimum raise target.\\n/// Once an `ISale` reaches `Active` it MUST NOT return `Pending` ever again.\\n/// Once an `ISale` reaches `Success` or `Fail` it MUST NOT return any other\\n/// status ever again.\\nenum SaleStatus {\\n    Pending,\\n    Active,\\n    Success,\\n    Fail\\n}\\n\\ninterface ISaleV2 {\\n    /// Returns the address of the token being sold in the sale.\\n    /// MUST NOT change during the lifecycle of the sale contract.\\n    function token() external view returns (address);\\n\\n    function remainingTokenInventory() external view returns (uint256);\\n\\n    /// Returns the address of the token that sale prices are denominated in.\\n    /// MUST NOT change during the lifecycle of the sale contract.\\n    function reserve() external view returns (address);\\n\\n    /// total reserve taken in to the sale contract via. buys. Does NOT\\n    /// include any reserve sent directly to the sale contract outside the\\n    /// standard buy/refund loop, e.g. due to a dusting attack.\\n    function totalReserveReceived() external view returns (uint256);\\n\\n    /// Returns the current `SaleStatus` of the sale.\\n    /// Represents a linear progression of the sale through its major lifecycle\\n    /// events.\\n    function saleStatus() external view returns (SaleStatus);\\n}\\n\",\"keccak256\":\"0x4c55a0e1679ee3d00d3d80a76dad6d6eb149a959ed77e6af5b8e914830f7aa87\",\"license\":\"CAL\"},\"contracts/sstore2/SSTORE2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nimport \\\"./utils/Bytecode.sol\\\";\\n\\n/**\\n  @title A key-value storage with auto-generated keys for storing chunks of\\n  data with a lower write & read cost.\\n  @author Agustin Aguilar <aa@horizon.io>\\n\\n  Readme: https://github.com/0xsequence/sstore2#readme\\n*/\\nlibrary SSTORE2 {\\n    error WriteError();\\n\\n    /**\\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\\n    @dev The pointer is a contract address with `_data` as code\\n    @param _data to be written\\n    @return pointer Pointer to the written `_data`\\n  */\\n    function write(bytes memory _data) internal returns (address pointer) {\\n        // Append 00 to _data so contract can't be called\\n        // Build init code\\n        bytes memory code = Bytecode.creationCodeFor(\\n            abi.encodePacked(hex\\\"00\\\", _data)\\n        );\\n\\n        // Deploy contract using create\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := create(0, add(code, 32), mload(code))\\n        }\\n\\n        // Address MUST be non-zero\\n        if (pointer == address(0)) revert WriteError();\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first\\n    byte\\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @return data read from `_pointer` contract\\n  */\\n    function read(address _pointer) internal view returns (bytes memory) {\\n        return Bytecode.codeAt(_pointer, 1, type(uint256).max);\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first\\n    byte\\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @param _start number of bytes to skip\\n    @return data read from `_pointer` contract\\n  */\\n    function read(\\n        address _pointer,\\n        uint256 _start\\n    ) internal view returns (bytes memory) {\\n        return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\\n    }\\n\\n    /**\\n    @notice Reads the contents of the `_pointer` code as data, skips the first\\n    byte\\n    @dev The function is intended for reading pointers generated by `write`\\n    @param _pointer to be read\\n    @param _start number of bytes to skip\\n    @param _end index before which to end extraction\\n    @return data read from `_pointer` contract\\n  */\\n    function read(\\n        address _pointer,\\n        uint256 _start,\\n        uint256 _end\\n    ) internal view returns (bytes memory) {\\n        return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\\n    }\\n}\\n\",\"keccak256\":\"0x86864b4de9a76a67da6c19fd1f921e08bb5c31de2eddef161117e4a8aea97ddd\",\"license\":\"MIT\"},\"contracts/sstore2/utils/Bytecode.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.15;\\n\\nlibrary Bytecode {\\n    error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\\n\\n    /**\\n    @notice Generate a creation code that results on a contract with `_code` as\\n    bytecode\\n    @param _code The returning value of the resulting `creationCode`\\n    @return creationCode (constructor) for new contract\\n  */\\n    function creationCodeFor(\\n        bytes memory _code\\n    ) internal pure returns (bytes memory) {\\n        /*\\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\\n      0x01    0x80         0x80        DUP1                size size\\n      0x02    0x60         0x600e      PUSH1 14            14 size size\\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\\n      0x04    0x39         0x39        CODECOPY            size\\n      0x05    0x60         0x6000      PUSH1 00            0 size\\n      0x06    0xf3         0xf3        RETURN\\n      <CODE>\\n    */\\n\\n        return\\n            abi.encodePacked(\\n                hex\\\"63\\\",\\n                uint32(_code.length),\\n                hex\\\"80_60_0E_60_00_39_60_00_F3\\\",\\n                _code\\n            );\\n    }\\n\\n    /**\\n    @notice Returns the size of the code on a given address\\n    @param _addr Address that may or may not contain code\\n    @return size of the code on the given `_addr`\\n  */\\n    function codeSize(address _addr) internal view returns (uint256 size) {\\n        assembly (\\\"memory-safe\\\") {\\n            size := extcodesize(_addr)\\n        }\\n    }\\n\\n    /**\\n    @notice Returns the code of a given address\\n    @dev It will fail if `_end < _start`\\n    @param _addr Address that may or may not contain code\\n    @param _start number of bytes of code to skip on read\\n    @param _end index before which to end extraction\\n    @return oCode read from `_addr` deployed bytecode\\n\\n    Forked: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\\n  */\\n    function codeAt(\\n        address _addr,\\n        uint256 _start,\\n        uint256 _end\\n    ) internal view returns (bytes memory oCode) {\\n        uint256 csize = codeSize(_addr);\\n        if (csize == 0) return bytes(\\\"\\\");\\n\\n        if (_start > csize) return bytes(\\\"\\\");\\n        if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end);\\n\\n        unchecked {\\n            uint256 reqSize = _end - _start;\\n            uint256 maxSize = csize - _start;\\n\\n            uint256 size = maxSize < reqSize ? maxSize : reqSize;\\n\\n            assembly (\\\"memory-safe\\\") {\\n                // allocate output byte array - this could also be done without\\n                // assembly\\n                // by using o_code = new bytes(size)\\n                oCode := mload(0x40)\\n                // new \\\"memory end\\\" including padding\\n                mstore(\\n                    0x40,\\n                    add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f)))\\n                )\\n                // store length in memory\\n                mstore(oCode, size)\\n                // actually retrieve the code, this needs assembly\\n                extcodecopy(_addr, add(oCode, 0x20), _start, size)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x81b3a2d7c4ca79e6a6e8d097ce05e20432485d9603f2e651f83da90006e6ebc9\",\"license\":\"MIT\"},\"contracts/tier/ITierV2.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// @title ITierV2\\n/// @notice `ITierV2` is a simple interface that contracts can implement to\\n/// provide membership lists for other contracts.\\n///\\n/// There are many use-cases for a time-preserving conditional membership list.\\n///\\n/// Some examples include:\\n///\\n/// - Self-serve whitelist to participate in fundraising\\n/// - Lists of users who can claim airdrops and perks\\n/// - Pooling resources with implied governance/reward tiers\\n/// - POAP style attendance proofs allowing access to future exclusive events\\n///\\n/// @dev Standard interface to a tiered membership.\\n///\\n/// A \\\"membership\\\" can represent many things:\\n/// - Exclusive access.\\n/// - Participation in some event or process.\\n/// - KYC completion.\\n/// - Combination of sub-memberships.\\n/// - Etc.\\n///\\n/// The high level requirements for a contract implementing `ITierV2`:\\n/// - MUST represent held tiers as a `uint`.\\n/// - MUST implement `report`.\\n///   - The report is a `uint256` that SHOULD represent the time each tier has\\n///     been continuously held since encoded as `uint32`.\\n///   - The encoded tiers start at `1`; Tier `0` is implied if no tier has ever\\n///     been held.\\n///   - Tier `0` is NOT encoded in the report, it is simply the fallback value.\\n///   - If a tier is lost the time data is erased for that tier and will be\\n///     set if/when the tier is regained to the new time.\\n///   - If a tier is held but the historical time information is not available\\n///     the report MAY return `0x00000000` for all held tiers.\\n///   - Tiers that are lost or have never been held MUST return `0xFFFFFFFF`.\\n///   - Context can be a list of numbers that MAY pairwise define tiers such as\\n///     minimum thresholds, or MAY simply provide global context such as a\\n///     relevant NFT ID for example.\\n/// - MUST implement `reportTimeForTier`\\n///   - Functions exactly as `report` but only returns a single time for a\\n///     single tier\\n///   - MUST return the same time value `report` would for any given tier and\\n///     context combination.\\n///\\n/// So the four possible states and report values are:\\n/// - Tier is held and time is known: Timestamp is in the report\\n/// - Tier is held but time is NOT known: `0` is in the report\\n/// - Tier is NOT held: `0xFF..` is in the report\\n/// - Tier is unknown: `0xFF..` is in the report\\n///\\n/// The reason `context` is specified as a list of values rather than arbitrary\\n/// bytes is to allow clear and efficient compatibility with interpreter stacks.\\n/// Some N values can be taken from an interpreter stack and used directly as a\\n/// context, which would be difficult or impossible to ensure is safe for\\n/// arbitrary bytes.\\ninterface ITierV2 {\\n    /// Same as report but only returns the time for a single tier.\\n    /// Often the implementing contract can calculate a single tier more\\n    /// efficiently than all 8 tiers. If the consumer only needs one or a few\\n    /// tiers it MAY be much cheaper to request only those tiers individually.\\n    /// This DOES NOT apply to all contracts, an obvious example is token\\n    /// balance based tiers which always return `ALWAYS` or `NEVER` for all\\n    /// tiers so no efficiency is gained.\\n    /// The return value is a `uint256` for gas efficiency but the values will\\n    /// be bounded by `type(uint32).max` as no single tier can report a value\\n    /// higher than this.\\n    function reportTimeForTier(\\n        address account,\\n        uint256 tier,\\n        uint256[] calldata context\\n    ) external view returns (uint256 time);\\n\\n    /// Returns an 8 tier encoded report of 32 bit timestamps for the given\\n    /// account.\\n    ///\\n    /// Same as `ITier` (legacy interface) but with a list of values for\\n    /// `context` which allows a single underlying state to present many\\n    /// different reports dynamically.\\n    ///\\n    /// For example:\\n    /// - Staking ledgers can calculate different tier thresholds\\n    /// - NFTs can give different tiers based on different IDs\\n    /// - Snapshot ERC20s can give different reports based on snapshot ID\\n    ///\\n    /// `context` supercedes `setTier` function and `TierChange` event from\\n    /// `ITier` at the interface level.\\n    function report(\\n        address account,\\n        uint256[] calldata context\\n    ) external view returns (uint256 report);\\n}\\n\",\"keccak256\":\"0xbaa924c1ae43bb50718e2f9f19ae2dffc97eec916b58c544121c50c2ced211d7\",\"license\":\"CAL\"},\"contracts/tier/libraries/TierConstants.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// @title TierConstants\\n/// @notice Constants for use with tier logic.\\nlibrary TierConstants {\\n    /// NEVER is 0xFF.. as it is infinitely in the future.\\n    /// NEVER for an entire report.\\n    uint256 internal constant NEVER_REPORT = type(uint256).max;\\n    /// NEVER for a single tier time.\\n    uint32 internal constant NEVER_TIME = type(uint32).max;\\n\\n    /// Always is 0 as negative timestamps are not possible/supported onchain.\\n    /// Tiers can't predate the chain but they can predate an `ITierV2`\\n    /// contract.\\n    uint256 internal constant ALWAYS = 0;\\n\\n    /// Account has never held a tier.\\n    uint256 internal constant TIER_ZERO = 0;\\n\\n    /// Magic number for tier one.\\n    uint256 internal constant TIER_ONE = 1;\\n    /// Magic number for tier two.\\n    uint256 internal constant TIER_TWO = 2;\\n    /// Magic number for tier three.\\n    uint256 internal constant TIER_THREE = 3;\\n    /// Magic number for tier four.\\n    uint256 internal constant TIER_FOUR = 4;\\n    /// Magic number for tier five.\\n    uint256 internal constant TIER_FIVE = 5;\\n    /// Magic number for tier six.\\n    uint256 internal constant TIER_SIX = 6;\\n    /// Magic number for tier seven.\\n    uint256 internal constant TIER_SEVEN = 7;\\n    /// Magic number for tier eight.\\n    uint256 internal constant TIER_EIGHT = 8;\\n    /// Maximum tier is `TIER_EIGHT`.\\n    uint256 internal constant MAX_TIER = TIER_EIGHT;\\n}\\n\",\"keccak256\":\"0x8b28d4e524cdc6e728bd1c133e5e5bb14c80ddc4f75a04a1351d9f470c98fc0c\",\"license\":\"CAL\"},\"contracts/tier/libraries/TierReport.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\nimport {ITierV2} from \\\"../ITierV2.sol\\\";\\nimport \\\"./TierConstants.sol\\\";\\n\\n/// @title TierReport\\n/// @notice `TierReport` implements several pure functions that can be\\n/// used to interface with reports.\\n/// - `tierAtTimeFromReport`: Returns the highest status achieved relative to\\n/// a block timestamp and report. Statuses gained after that block are ignored.\\n/// - `tierTime`: Returns the timestamp that a given tier has been held\\n/// since according to a report.\\n/// - `truncateTiersAbove`: Resets all the tiers above the reference tier.\\n/// - `updateTimesForTierRange`: Updates a report with a timestamp for every\\n///    tier in a range.\\n/// - `updateReportWithTierAtTime`: Updates a report to a new tier.\\n/// @dev Utilities to consistently read, write and manipulate tiers in reports.\\n/// The low-level bit shifting can be difficult to get right so this\\n/// factors that out.\\nlibrary TierReport {\\n    /// Enforce upper limit on tiers so we can do unchecked math.\\n    /// @param tier_ The tier to enforce bounds on.\\n    modifier maxTier(uint256 tier_) {\\n        require(tier_ <= TierConstants.MAX_TIER, \\\"MAX_TIER\\\");\\n        _;\\n    }\\n\\n    /// Returns the highest tier achieved relative to a block timestamp\\n    /// and report.\\n    ///\\n    /// Note that typically the report will be from the _current_ contract\\n    /// state, i.e. `block.timestamp` but not always. Tiers gained after the\\n    /// reference time are ignored.\\n    ///\\n    /// When the `report` comes from a later block than the `timestamp_` this\\n    /// means the user must have held the tier continuously from `timestamp_`\\n    /// _through_ to the report time.\\n    /// I.e. NOT a snapshot.\\n    ///\\n    /// @param report_ A report as per `ITierV2`.\\n    /// @param timestamp_ The timestamp to check the tiers against.\\n    /// @return tier_ The highest tier held since `timestamp_` as per `report`.\\n    function tierAtTimeFromReport(\\n        uint256 report_,\\n        uint256 timestamp_\\n    ) internal pure returns (uint256 tier_) {\\n        unchecked {\\n            for (tier_ = 0; tier_ < 8; tier_++) {\\n                if (uint32(uint256(report_ >> (tier_ * 32))) > timestamp_) {\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// Returns the timestamp that a given tier has been held since from a\\n    /// report.\\n    ///\\n    /// The report MUST encode \\\"never\\\" as 0xFFFFFFFF. This ensures\\n    /// compatibility with `tierAtTimeFromReport`.\\n    ///\\n    /// @param report_ The report to read a timestamp from.\\n    /// @param tier_ The Tier to read the timestamp for.\\n    /// @return The timestamp the tier has been held since.\\n    function reportTimeForTier(\\n        uint256 report_,\\n        uint256 tier_\\n    ) internal pure maxTier(tier_) returns (uint256) {\\n        unchecked {\\n            // ZERO is a special case. Everyone has always been at least ZERO,\\n            // since block 0.\\n            if (tier_ == 0) {\\n                return 0;\\n            }\\n\\n            uint256 offset_ = (tier_ - 1) * 32;\\n            return uint256(uint32(uint256(report_ >> offset_)));\\n        }\\n    }\\n\\n    /// Resets all the tiers above the reference tier to 0xFFFFFFFF.\\n    ///\\n    /// @param report_ Report to truncate with high bit 1s.\\n    /// @param tier_ Tier to truncate above (exclusive).\\n    /// @return Truncated report.\\n    function truncateTiersAbove(\\n        uint256 report_,\\n        uint256 tier_\\n    ) internal pure maxTier(tier_) returns (uint256) {\\n        unchecked {\\n            uint256 offset_ = tier_ * 32;\\n            uint256 mask_ = (TierConstants.NEVER_REPORT >> offset_) << offset_;\\n            return report_ | mask_;\\n        }\\n    }\\n\\n    /// Updates a report with a timestamp for a given tier.\\n    /// More gas efficient than `updateTimesForTierRange` if only a single\\n    /// tier is being modified.\\n    /// The tier at/above the given tier is updated. E.g. tier `0` will update\\n    /// the time for tier `1`.\\n    /// @param report_ Report to use as the baseline for the updated report.\\n    /// @param tier_ The tier level to update.\\n    /// @param timestamp_ The new block number for `tier_`.\\n    /// @return The newly updated `report_`.\\n    function updateTimeAtTier(\\n        uint256 report_,\\n        uint256 tier_,\\n        uint256 timestamp_\\n    ) internal pure maxTier(tier_) returns (uint256) {\\n        unchecked {\\n            uint256 offset_ = tier_ * 32;\\n            return\\n                (report_ &\\n                    ~uint256(uint256(TierConstants.NEVER_TIME) << offset_)) |\\n                uint256(timestamp_ << offset_);\\n        }\\n    }\\n\\n    /// Updates a report with a block number for every tier in a range.\\n    ///\\n    /// Does nothing if the end status is equal or less than the start tier.\\n    /// @param report_ The report to update.\\n    /// @param startTier_ The tier at the start of the range (exclusive).\\n    /// @param endTier_ The tier at the end of the range (inclusive).\\n    /// @param timestamp_ The timestamp to set for every tier in the range.\\n    /// @return The updated report.\\n    function updateTimesForTierRange(\\n        uint256 report_,\\n        uint256 startTier_,\\n        uint256 endTier_,\\n        uint256 timestamp_\\n    ) internal pure maxTier(endTier_) returns (uint256) {\\n        unchecked {\\n            uint256 offset_;\\n            for (uint256 i_ = startTier_; i_ < endTier_; i_++) {\\n                offset_ = i_ * 32;\\n                report_ =\\n                    (report_ &\\n                        ~uint256(\\n                            uint256(TierConstants.NEVER_TIME) << offset_\\n                        )) |\\n                    uint256(timestamp_ << offset_);\\n            }\\n            return report_;\\n        }\\n    }\\n\\n    /// Updates a report to a new status.\\n    ///\\n    /// Internally dispatches to `truncateTiersAbove` and\\n    /// `updateBlocksForTierRange`.\\n    /// The dispatch is based on whether the new tier is above or below the\\n    /// current tier.\\n    /// The `startTier_` MUST match the result of `tierAtBlockFromReport`.\\n    /// It is expected the caller will know the current tier when\\n    /// calling this function and need to do other things in the calling scope\\n    /// with it.\\n    ///\\n    /// @param report_ The report to update.\\n    /// @param startTier_ The tier to start updating relative to. Data above\\n    /// this tier WILL BE LOST so probably should be the current tier.\\n    /// @param endTier_ The new highest tier held, at the given timestamp_.\\n    /// @param timestamp_ The timestamp_ to update the highest tier to, and\\n    /// intermediate tiers from `startTier_`.\\n    /// @return The updated report.\\n    function updateReportWithTierAtTime(\\n        uint256 report_,\\n        uint256 startTier_,\\n        uint256 endTier_,\\n        uint256 timestamp_\\n    ) internal pure returns (uint256) {\\n        return\\n            endTier_ < startTier_\\n                ? truncateTiersAbove(report_, endTier_)\\n                : updateTimesForTierRange(\\n                    report_,\\n                    startTier_,\\n                    endTier_,\\n                    timestamp_\\n                );\\n    }\\n}\\n\",\"keccak256\":\"0x05fb1319c05c5e40468fe07dc0b322598b721222a8c09cc3a3d0e64b17d1729e\",\"license\":\"CAL\"},\"contracts/tier/libraries/TierwiseCombine.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\nimport \\\"./TierReport.sol\\\";\\nimport \\\"../../math/SaturatingMath.sol\\\";\\n\\nlibrary TierwiseCombine {\\n    using Math for uint256;\\n    using SaturatingMath for uint256;\\n\\n    /// Every lte check in `selectLte` must pass.\\n    uint256 internal constant LOGIC_EVERY = 0;\\n    /// Only one lte check in `selectLte` must pass.\\n    uint256 internal constant LOGIC_ANY = 1;\\n\\n    /// Select the minimum block number from passing blocks in `selectLte`.\\n    uint256 internal constant MODE_MIN = 0;\\n    /// Select the maximum block number from passing blocks in `selectLte`.\\n    uint256 internal constant MODE_MAX = 1;\\n    /// Select the first block number that passes in `selectLte`.\\n    uint256 internal constant MODE_FIRST = 2;\\n\\n    /// Performs a tierwise saturating subtraction of two reports.\\n    /// Intepret as \\\"# of blocks older report was held before newer report\\\".\\n    /// If older report is in fact newer then `0` will be returned.\\n    /// i.e. the diff cannot be negative, older report as simply spent 0 blocks\\n    /// existing before newer report, if it is in truth the newer report.\\n    /// @param newerReport_ Block to subtract from.\\n    /// @param olderReport_ Block to subtract.\\n    function saturatingSub(\\n        uint256 newerReport_,\\n        uint256 olderReport_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 ret_;\\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\\n                uint256 newerBlock_ = TierReport.reportTimeForTier(\\n                    newerReport_,\\n                    tier_\\n                );\\n                uint256 olderBlock_ = TierReport.reportTimeForTier(\\n                    olderReport_,\\n                    tier_\\n                );\\n                uint256 diff_ = newerBlock_.saturatingSub(olderBlock_);\\n                ret_ = TierReport.updateTimeAtTier(ret_, tier_ - 1, diff_);\\n            }\\n            return ret_;\\n        }\\n    }\\n\\n    /// Given a list of reports, selects the best tier in a tierwise fashion.\\n    /// The \\\"best\\\" criteria can be configured by `logic_` and `mode_`.\\n    /// Logic can be \\\"every\\\" or \\\"any\\\", which means that the reports for a given\\n    /// tier must either all or any be less than or equal to the reference\\n    /// `blockNumber_`.\\n    /// Mode can be \\\"min\\\", \\\"max\\\", \\\"first\\\" which selects between all the block\\n    /// numbers for a given tier that meet the lte criteria.\\n    /// IMPORTANT: If the output of `selectLte` is used to write to storage\\n    /// care must be taken to ensure that \\\"upcoming\\\" tiers relative to the\\n    /// `blockNumber_` are not overwritten inappropriately. Typically this\\n    /// function should be used as a filter over reads only from an upstream\\n    /// source of truth.\\n    /// @param reports_ The list of reports to select over.\\n    /// @param blockNumber_ The block number that tier blocks must be lte.\\n    /// @param logic_ `LOGIC_EVERY` or `LOGIC_ANY`.\\n    /// @param mode_ `MODE_MIN`, `MODE_MAX` or `MODE_FIRST`.\\n    function selectLte(\\n        uint256 logic_,\\n        uint256 mode_,\\n        uint256 blockNumber_,\\n        uint256[] memory reports_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 ret_;\\n            uint256 block_;\\n            bool anyLte_;\\n            uint256 length_ = reports_.length;\\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\\n                uint256 accumulator_;\\n                // Nothing lte the reference block for this tier yet.\\n                anyLte_ = false;\\n\\n                // Initialize the accumulator for this tier.\\n                if (mode_ == MODE_MIN) {\\n                    accumulator_ = TierConstants.NEVER_REPORT;\\n                } else {\\n                    accumulator_ = 0;\\n                }\\n\\n                // Filter all the blocks at the current tier from all the\\n                // reports against the reference tier and each other.\\n                for (uint256 i_ = 0; i_ < length_; i_++) {\\n                    block_ = TierReport.reportTimeForTier(reports_[i_], tier_);\\n\\n                    if (block_ <= blockNumber_) {\\n                        // Min and max need to compare current value against\\n                        // the accumulator.\\n                        if (mode_ == MODE_MIN) {\\n                            accumulator_ = block_.min(accumulator_);\\n                        } else if (mode_ == MODE_MAX) {\\n                            accumulator_ = block_.max(accumulator_);\\n                        } else if (mode_ == MODE_FIRST && !anyLte_) {\\n                            accumulator_ = block_;\\n                        }\\n                        anyLte_ = true;\\n                    } else if (logic_ == LOGIC_EVERY) {\\n                        // Can short circuit for an \\\"every\\\" check.\\n                        accumulator_ = TierConstants.NEVER_REPORT;\\n                        break;\\n                    }\\n                }\\n                if (!anyLte_) {\\n                    accumulator_ = TierConstants.NEVER_REPORT;\\n                }\\n                ret_ = TierReport.updateTimeAtTier(\\n                    ret_,\\n                    tier_ - 1,\\n                    accumulator_\\n                );\\n            }\\n            return ret_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa795019166092c4663c1a6f441651a4866c9298ffa310f6f5105439cce8d2554\",\"license\":\"CAL\"},\"contracts/type/LibCast.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../interpreter/run/LibStackPointer.sol\\\";\\nimport \\\"../interpreter/run/LibInterpreterState.sol\\\";\\nimport \\\"../interpreter/deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title LibCast\\n/// @notice Additional type casting logic that the Solidity compiler doesn't\\n/// give us by default. A type cast (vs. conversion) is considered one where the\\n/// structure is unchanged by the cast. The cast does NOT (can't) check that the\\n/// input is a valid output, for example any integer MAY be cast to a function\\n/// pointer but almost all integers are NOT valid function pointers. It is the\\n/// calling context that MUST ensure the validity of the data, the cast will\\n/// merely retype the data in place, generally without additional checks.\\n/// As most structures in solidity have the same memory structure as a `uint256`\\n/// or fixed/dynamic array of `uint256` there are many conversions that can be\\n/// done with near zero or minimal overhead.\\nlibrary LibCast {\\n    /// Retype an integer to an opcode function pointer.\\n    /// @param u_ The integer to cast to an opcode function pointer.\\n    /// @return fn_ The opcode function pointer.\\n    function asOpFunctionPointer(\\n        uint256 u_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(InterpreterState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer) fn_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fn_ := u_\\n        }\\n    }\\n\\n    /// Retype an array of integers to an array of opcode function pointers.\\n    /// @param us_ The array of integers to cast to an array of opcode fuction\\n    /// pointers.\\n    /// @return fns_ The array of opcode function pointers.\\n    function asOpcodeFunctionPointers(\\n        uint256[] memory us_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(InterpreterState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer)[]\\n                memory fns_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fns_ := us_\\n        }\\n    }\\n\\n    /// Retype an integer to an integrity function pointer.\\n    /// @param u_ The integer to cast to an integrity function pointer.\\n    /// @return fn_ The integrity function pointer.\\n    function asIntegrityFunctionPointer(\\n        uint256 u_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(IntegrityCheckState memory, Operand, StackPointer)\\n                internal\\n                view\\n                returns (StackPointer) fn_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fn_ := u_\\n        }\\n    }\\n\\n    /// Retype a list of integrity check function pointers to a `uint256[]`.\\n    /// @param fns_ The list of function pointers.\\n    /// @return us_ The list of pointers as `uint256[]`.\\n    function asUint256Array(\\n        function(IntegrityCheckState memory, Operand, StackPointer)\\n            internal\\n            view\\n            returns (StackPointer)[]\\n            memory fns_\\n    ) internal pure returns (uint256[] memory us_) {\\n        assembly (\\\"memory-safe\\\") {\\n            us_ := fns_\\n        }\\n    }\\n\\n    /// Retype a list of interpreter opcode function pointers to a `uint256[]`.\\n    /// @param fns_ The list of function pointers.\\n    /// @return us_ The list of pointers as `uint256[]`.\\n    function asUint256Array(\\n        function(InterpreterState memory, Operand, StackPointer)\\n            view\\n            returns (StackPointer)[]\\n            memory fns_\\n    ) internal pure returns (uint256[] memory us_) {\\n        assembly (\\\"memory-safe\\\") {\\n            us_ := fns_\\n        }\\n    }\\n\\n    /// Retype a list of `uint256[]` to `address[]`.\\n    /// @param us_ The list of integers to cast to addresses.\\n    /// @return addresses_ The list of addresses cast from each integer.\\n    function asAddresses(\\n        uint256[] memory us_\\n    ) internal pure returns (address[] memory addresses_) {\\n        assembly (\\\"memory-safe\\\") {\\n            addresses_ := us_\\n        }\\n    }\\n\\n    /// Retype a list of integers to integrity check function pointers.\\n    /// @param us_ The list of integers to use as function pointers.\\n    /// @return fns_ The list of integrity check function pointers.\\n    function asIntegrityPointers(\\n        uint256[] memory us_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(IntegrityCheckState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer)[]\\n                memory fns_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fns_ := us_\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9650d8d1876bd61c5a326f1fb5c04dc0f6407e65abcc92fdc29b8f050f5e02d3\",\"license\":\"CAL\"},\"contracts/type/LibConvert.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// @title LibConvert\\n/// @notice Type conversions that require additional structural changes to\\n/// complete safely. These are NOT mere type casts and involve additional\\n/// reads and writes to complete, such as recalculating the length of an array.\\n/// The convention \\\"toX\\\" is adopted from Rust to imply the additional costs and\\n/// consumption of the source to produce the target.\\nlibrary LibConvert {\\n    /// Convert an array of integers to `bytes` data. This requires modifying\\n    /// the length in situ as the integer array length is measured in 32 byte\\n    /// increments while the length of `bytes` is the literal number of bytes.\\n    /// @return bytes_ The integer array converted to `bytes` data.\\n    function toBytes(\\n        uint256[] memory us_\\n    ) internal pure returns (bytes memory bytes_) {\\n        assembly (\\\"memory-safe\\\") {\\n            bytes_ := us_\\n            // Length in bytes is 32x the length in uint256\\n            mstore(bytes_, mul(0x20, mload(bytes_)))\\n        }\\n    }\\n\\n    /// Truncate `uint256[]` values down to `uint16[]` then pack this to `bytes`\\n    /// without padding or length prefix. Unsafe because the starting `uint256`\\n    /// values are not checked for overflow due to the truncation. The caller\\n    /// MUST ensure that all values fit in `type(uint16).max` or that silent\\n    /// overflow is safe.\\n    /// @param us_ The `uint256[]` to truncate and concatenate to 16 bit `bytes`.\\n    /// @return The concatenated 2-byte chunks.\\n    function unsafeTo16BitBytes(\\n        uint256[] memory us_\\n    ) internal pure returns (bytes memory) {\\n        unchecked {\\n            // We will keep 2 bytes (16 bits) from each integer.\\n            bytes memory bytes_ = new bytes(us_.length * 2);\\n            assembly (\\\"memory-safe\\\") {\\n                let replaceMask_ := 0xFFFF\\n                let preserveMask_ := not(replaceMask_)\\n                for {\\n                    let cursor_ := add(us_, 0x20)\\n                    let end_ := add(cursor_, mul(mload(us_), 0x20))\\n                    let bytesCursor_ := add(bytes_, 0x02)\\n                } lt(cursor_, end_) {\\n                    cursor_ := add(cursor_, 0x20)\\n                    bytesCursor_ := add(bytesCursor_, 0x02)\\n                } {\\n                    let data_ := mload(bytesCursor_)\\n                    mstore(\\n                        bytesCursor_,\\n                        or(and(preserveMask_, data_), mload(cursor_))\\n                    )\\n                }\\n            }\\n            return bytes_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd9e2df8b8ad347ec018df890eb4461df536de485407026f3761545753e9191de\",\"license\":\"CAL\"},\"contracts/verify/IVerifyV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\ntype VerifyStatus is uint256;\\n\\ninterface IVerifyV1 {\\n    function accountStatusAtTime(\\n        address account,\\n        uint256 timestamp\\n    ) external view returns (VerifyStatus);\\n}\\n\",\"keccak256\":\"0xb04c15c0c71544132752b8589ae590ff4bad61c027990c550bf3ba09659c0e98\",\"license\":\"CAL\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x60b0215121bf25612a6739fb2f1ec35f31ee82e4a8216c032c8243d904ab3aa9\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b50604051620033a9380380620033a9833981016040819052620000349162000187565b6000816001600160a01b031663f933c72f6040518163ffffffff1660e01b8152600401600060405180830381865afa15801562000075573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526200009f9190810190620001f5565b90506040518060a0016040528060768152602001620033336076913980519060200120818051906020012014620000f65780604051634c1af20160e11b8152600401620000ed9190620002ad565b60405180910390fd5b813f7fda914e60d06a83d8099b6562ac80dd60acbac7c35f0fcee9bffa8e160b377f6381146200013d57604051630eec293f60e11b815260048101829052602401620000ed565b604080513381526001600160a01b03851660208201527ff37e8ef81084fa6f55ef06a1fee409bc7e4dc04c063ecb589e146bafcbd9cbcf910160405180910390a1505050620002e2565b6000602082840312156200019a57600080fd5b81516001600160a01b0381168114620001b257600080fd5b9392505050565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620001ec578181015183820152602001620001d2565b50506000910152565b6000602082840312156200020857600080fd5b81516001600160401b03808211156200022057600080fd5b818401915084601f8301126200023557600080fd5b8151818111156200024a576200024a620001b9565b604051601f8201601f19908116603f01168101908382118183101715620002755762000275620001b9565b816040528281528760208487010111156200028f57600080fd5b620002a2836020830160208801620001cf565b979650505050505050565b6020815260008251806020840152620002ce816040850160208701620001cf565b601f01601f19169190910160400192915050565b61304180620002f26000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80631ed061d914610030575b600080fd5b61004361003e36600461265b565b61006c565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b6000826000015151825111156100c15781518351516040517f7d2d70db000000000000000000000000000000000000000000000000000000008152600481019290925260248201526044015b60405180910390fd5b60006100d4846100cf61024a565b6102c4565b604081015160608201519192509060005b855181101561015e57604084018390526060840182905261014b848261012c60027fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61284e565b89858151811061013e5761013e612862565b60200260200101516103db565b508061015681612891565b9150506100e5565b50600061017c8460800151856040015161050490919063ffffffff16565b90507f810b097bdad06c3daae05fe6acae5885a229381e85b19a35563683b39eea5a5333886040516101af929190612972565b60405180910390a160006101de826040518060a0016040528060768152602001612f96607691398a919061050d565b905060006101eb82610626565b6040805133815273ffffffffffffffffffffffffffffffffffffffff831660208201529192507fdcb4bd7c42c5278a44b5f7b614a5d3751e67c4c803ffd29c00e83a161c1447b0910160405180910390a1955050505050505b92915050565b60408051600180825281830190925260609160009190816020015b61251b8152602001906001900390816102655790505090506106b18160008151811061029357610293612862565b602002602001019067ffffffffffffffff16908167ffffffffffffffff16815250506102be816106ca565b91505090565b6102fd6040518060c001604052806060815260200160008152602001600081526020016000815260200160008152602001606081525090565b6040805160c08101825284518152602080860151519082015290810161034460027fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61284e565b815260200161039c61037760027fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61284e565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe00190565b81526020016103cc60027fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61284e565b81526020019290925250919050565b600060027fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048560400151101561043e576040517f271592cf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b845160208581029091010151805181015b808210156104a957600080600484019350835161ffff8116915061ffff8160101c169250506104a08982898c60a00151868151811061049057610490612862565b602002602001015163ffffffff16565b9650505061044f565b6040870151602090860304808511156104f8576040517ff993c6e700000000000000000000000000000000000000000000000000000000815260048101869052602481018290526044016100b8565b50939695505050505050565b60209190030490565b602083810151516060910260400160005b85515181101561055c576105508660000151828151811061054157610541612862565b60200260200101515160200190565b9091019060010161051e565b5060008167ffffffffffffffff81111561057857610578612525565b6040519080825280601f01601f1916602001820160405280156105a2576020820181803683370190505b50905060006105b2825b60200190565b868152602088810151910191506105ca9082906108f4565b9050606060005b8851518110156106175788518051829081106105ef576105ef612862565b602002602001015191506106038288610914565b61060d8383610973565b92506001016105d1565b509193505050505b9392505050565b6000806106518360405160200161063d9190612a49565b604051602081830303815290604052610993565b90508051602082016000f0915073ffffffffffffffffffffffffffffffffffffffff82166106ab576040517f08d4abb600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50919050565b600061251b6106c18584836109bf565b95945050505050565b606060006040518061076001604052806106e2603a90565b67ffffffffffffffff1667ffffffffffffffff1681526020016109d581526020016109e48152602001610a7881526020016106b18152602001610a848152602001610aa18152602001610b0f8152602001610b7b8152602001610c2a8152602001610d998152602001610da98152602001610db98152602001610dc88152602001610dd78152602001610de68152602001610db98152602001610df58152602001610e048152602001610e138152602001610e238152602001610a788152602001610a788152602001610e338152602001610e4b8152602001610e5a8152602001610e698152602001610e788152602001610e878152602001610e968152602001610ea78152602001610ec48152602001610e968152602001610ed38152602001610ee28152602001610ef18152602001610f008152602001610f108152602001610f208152602001610f308152602001610f408152602001610f508152602001610f608152602001610f708152602001610f808152602001610f908152602001610fa08152602001610fb08152602001610fbf8152602001610fce8152602001610fdd8152602001610fec8152602001610ffb815260200161100a8152602001611019815260200161102981526020016110398152602001611048815260200161109c815250905060006108d6826110ab565b90506108e281856110fa565b805b949350505050565b815260200190565b600061061f8261090e8451866108ec90919063ffffffff16565b90611130565b815161ffff907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000090840160028481019086015b8281101561096a5780518581166002028301518616908516178152600401610947565b50505050505050565b600061061f8261098d8451866108ec90919063ffffffff16565b90611148565b60608151826040516020016109a9929190612a6f565b6040516020818303038152906040529050919050565b60006108e46109ce858561116a565b8590611198565b60006108e484836111a76111b3565b60408301516060840151600091600f85811692600487901c90911691600887901c91610a118988876111c0565b60408a01527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0870160608a0152610a4a898489876103db565b50606089018190526040890151610a63908a9086611222565b60409099019190915250959695505050505050565b60006108e48483611198565b6000826003811115610a9857610a98612b06565b50909392505050565b600060ff8316600f8110610ae4576040517f316e6a37000000000000000000000000000000000000000000000000000000008152600481018290526024016100b8565b60018101600481901b8517610b04610afd8883886109e4565b889061116a565b979650505050505050565b6000600f83811690600885811c91821691600c87901c91828401917efffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0169088901b610f0016178117610b61898886611256565b9650610b6e8982896109e4565b9998505050505050505050565b6000600c83901c600f80851690600486901c1680821015610bf8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f4c4f4f505f4e5f494e505554530000000000000000000000000000000000000060448201526064016100b8565b610fff861660005b84811015610c1d57610c138983896109e4565b9650600101610c00565b5094979650505050505050565b600060018381169084901c81610d38576040860151602090850304808210610c88576040517f1cb73c1600000000000000000000000000000000000000000000000000000000815260048101829052602481018390526044016100b8565b610cd06040518060400160405280600681526020017f6265666f726500000000000000000000000000000000000000000000000000008152508860400151896060015161126a565b60408701516060880151610ce89160208502016112fd565b60608801908152604080518082018252600581527f61667465720000000000000000000000000000000000000000000000000000006020820152908901519151610d32929061126a565b50610d85565b85602001518110610d855760208601516040517f890a8e6a0000000000000000000000000000000000000000000000000000000081526004810191909152602481018290526044016100b8565b610d8f8685611198565b9695505050505050565b600061251b6106c1858483611313565b60006108e4848361132186611370565b60006108e484836113806111b3565b60006108e484836114156109bf565b60006108e48483611486611522565b60006108e484836115336111b3565b60006108e484836115896111b3565b60006108e48483611638611522565b60006108e484836116958661174f565b60006108e4848361176d8661177a565b60006108e4610e42858461116a565b85906008611222565b60006108e484836117876109bf565b60006108e484836117936111b3565b60006108e484836117a96111b3565b60006108e484836117bf6109bf565b60006108e484836117cb6109bf565b600061251b6106c185848387611370565b60006108e4826117d7610ebb866001612b35565b8792919061174f565b60006108e484836117e76111b3565b60006108e484836117eb6111b3565b60006108e484836117ef6109bf565b60006108e484836117f36111b3565b60006108e484836117f786611370565b60006108e4848361183286611370565b60006108e4848361186386611370565b60006108e4848361187986611370565b60006108e4848361188586611370565b60006108e4848361189186611370565b60006108e484836112fd86611370565b60006108e4848361189d86611370565b60006108e484836118ac86611370565b60006108e484836118b886611370565b60006108e484836118c486611370565b60006108e484836118d0611992565b60006108e484836119a36109bf565b60006108e484836119f06109bf565b60006108e48483611a7d6109bf565b60006108e48483611aff6109bf565b60006108e48483611b4c6109bf565b60006108e48483611b99611522565b60006108e48483611bf886611c4f565b60006108e48483611c6286611cfc565b60006108e48483611d0f6111b3565b600060ff8316808203611087576040517f904c1f6d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6106c16110958685846111c0565b8690611198565b60006108e48483611d6e6111b3565b80518190603a146110f55780516040517fc8b569010000000000000000000000000000000000000000000000000000000081526004810191909152603a60248201526044016100b8565b919050565b60405182518251602080830286010183111561111557600080fd5b60208102830160405201835261112b8282611d86565b505050565b600061113c8284611d86565b8151602002830161061f565b600061116183835161115a6105ac8690565b9190611d9a565b8151830161061f565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe00160006106ab8383611e16565b60200160006106ab8383611ebe565b600061061f8383611ed3565b60006108e46109ce858560025b60006112026040518060400160405280600381526020017f706f700000000000000000000000000000000000000000000000000000000000815250838561126a565b811561121a57602082028303925061121a8484611e16565b509092915050565b6000602082028301925060018211801561123f5750836060015183115b1561124c57606084018390525b61121a8484611ebe565b6000602082028301925061121a8484611ebe565b61112b83838360405160240161128293929190612b48565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fca47c4eb0000000000000000000000000000000000000000000000000000000017905261205c565b600081831161130c578161061f565b5090919050565b60006108e4848460026111c0565b6000816040516020016113349190612b6d565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152919052805160209091012092915050565b60006106c16110958686856111c0565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8281166004830152600091908416906370a08231906024015b602060405180830381865afa1580156113f1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061061f9190612ba3565b60008173ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611462573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102449190612ba3565b6040517f4ee2cd7e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83811660048301526024820183905260009190851690634ee2cd7e906044015b602060405180830381865afa1580156114fe573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108e49190612ba3565b60006108e46109ce858560036111c0565b6040517f981b24d00000000000000000000000000000000000000000000000000000000081526004810182905260009073ffffffffffffffffffffffffffffffffffffffff84169063981b24d0906024016113d4565b6040517f6352211e0000000000000000000000000000000000000000000000000000000081526004810182905260009073ffffffffffffffffffffffffffffffffffffffff841690636352211e90602401602060405180830381865afa1580156115f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061161b9190612bbc565b73ffffffffffffffffffffffffffffffffffffffff169392505050565b6040517efdd58e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152602482018390526000919085169062fdd58e906044016114e1565b6040517f4e1273f400000000000000000000000000000000000000000000000000000000815260609073ffffffffffffffffffffffffffffffffffffffff851690634e1273f4906116ec9086908690600401612bf2565b600060405180830381865afa158015611709573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682016040526108e49190810190612c55565b60006106c16117658686600160028702016111c0565b869084611222565b8061177757600080fd5b50565b60006106c18585846111c0565b600061061f828461207d565b60006108e4826117a3858761207d565b906120fd565b60006108e4826117b9858761207d565b90612112565b600061061f8284612127565b600061061f8284612176565b60606000841161121a57816108e4565b1490565b1090565b1590565b1190565b600082820183811061180957806108e4565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff949350505050565b60008260000361184457506000610244565b82820282848281611857576118576127f0565b040361180957806108e4565b600081831161187357600061061f565b50900390565b600061061f8284612b35565b600061061f828461284e565b600061061f8284612dfb565b600081831061130c578161061f565b600061061f8284612e07565b600061061f8284612e1b565b600061061f8284612e32565b6040517fd97b2e4800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84811660048301528381166024830152604482018390526000919086169063d97b2e4890606401602060405180830381865afa15801561194f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119739190612ba3565b73ffffffffffffffffffffffffffffffffffffffff1695945050505050565b60006108e46109ce858560046111c0565b60008173ffffffffffffffffffffffffffffffffffffffff1663ec14b06e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611462573d6000803e3d6000fd5b60008173ffffffffffffffffffffffffffffffffffffffff1663cd3293de6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611a3d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a619190612bbc565b73ffffffffffffffffffffffffffffffffffffffff1692915050565b60008173ffffffffffffffffffffffffffffffffffffffff1663f9020e336040518163ffffffff1660e01b8152600401602060405180830381865afa158015611aca573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611aee9190612e45565b600381111561024457610244612b06565b60008173ffffffffffffffffffffffffffffffffffffffff1663fc0c546a6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611a3d573d6000803e3d6000fd5b60008173ffffffffffffffffffffffffffffffffffffffff166347e4bbb96040518163ffffffff1660e01b8152600401602060405180830381865afa158015611462573d6000803e3d6000fd5b6040517fdb8554fc00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152602482018390526000919085169063db8554fc906044016114e1565b6040517f88d6860400000000000000000000000000000000000000000000000000000000815260009073ffffffffffffffffffffffffffffffffffffffff8516906388d68604906114e19086908690600401612e66565b60006106c16110958686600286016111c0565b6040517fcaa0eb3b00000000000000000000000000000000000000000000000000000000815260009073ffffffffffffffffffffffffffffffffffffffff86169063caa0eb3b90611cbb90879087908790600401612e95565b602060405180830381865afa158015611cd8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106c19190612ba3565b60006106c16110958686600386016111c0565b60008060015b60088111611d66576000611d2986836121d6565b90506000611d3786846121d6565b90506000611d458383611863565b9050611d55856001860383612286565b94505060019092019150611d159050565b509392505050565b60006108e48385600f16600487901c600f1685612310565b600060208301905061112b818385516123b6565b5b60208110611dd85782518252602092830192909101907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe001611d9b565b801561112b577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600882021c80835116811985511617835250505050565b611e5a6040518060400160405280600381526020017f707563000000000000000000000000000000000000000000000000000000000081525082846060015161126a565b81606001518111611eba5760608201516040830151602091030460408301516020908303046040517f625e32e4000000000000000000000000000000000000000000000000000000008152600481019290925260248201526044016100b8565b5050565b8160800151811115611eba5760809190910152565b60008060008473ffffffffffffffffffffffffffffffffffffffff1663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa158015611f23573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f479190612ee4565b5093505092505060008213611f8b576040517f3351e26f000000000000000000000000000000000000000000000000000000008152600481018390526024016100b8565b83611f968242612e32565b1115611fd8576040517f2730eb4800000000000000000000000000000000000000000000000000000000815260048101829052602481018590526044016100b8565b6106c18573ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015612026573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061204a9190612f34565b60ff16612056846123de565b9061207d565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b600080826012036120915783915050610244565b82601211156120bd575060128290036120b56120ae82600a612dfb565b8590611832565b915050610244565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee82016120ec81600a612dfb565b6120b5908561284e565b5092915050565b600061061f83670de0b6b3a76400008461244e565b600061061f8383670de0b6b3a764000061244e565b60008160000b60000361213b575081610244565b60008260000b13156121635761215c61215583600a612f57565b8490611832565b9050610244565b60ff6000839003166120ec81600a612dfb565b6000806012830361218a5783915050610244565b82601211156121a4575060128290036120ec81600a612dfb565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee82016120b56120ae82600a612dfb565b6000816008811115612244576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4d41585f5449455200000000000000000000000000000000000000000000000060448201526064016100b8565b8260000361225557600091506120f6565b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff016020021c63ffffffff1690565b60008260088111156122f4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4d41585f5449455200000000000000000000000000000000000000000000000060448201526064016100b8565b505060209190910290811b63ffffffff90911b19919091161790565b600082600881111561237e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4d41585f5449455200000000000000000000000000000000000000000000000060448201526064016100b8565b6000855b858110156123aa5763ffffffff6020820290811b199890981685891b17979150600101612382565b50959695505050505050565b8060200283015b808410156123d85783518352602093840193909201916123bd565b50505050565b60008082121561244a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f53616665436173743a2076616c7565206d75737420626520706f73697469766560448201526064016100b8565b5090565b600080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff858709858702925082811083820303915050806000036124a65783828161249c5761249c6127f0565b049250505061061f565b8084116124b257600080fd5b60008486880960026001871981018816978890046003810283188082028403028082028403028082028403028082028403028082028403029081029092039091026000889003889004909101858311909403939093029303949094049190911702949350505050565b612523612f66565b565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff8111828210171561257757612577612525565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156125c4576125c4612525565b604052919050565b600067ffffffffffffffff8211156125e6576125e6612525565b5060051b60200190565b600082601f83011261260157600080fd5b81356020612616612611836125cc565b61257d565b82815260059290921b8401810191818101908684111561263557600080fd5b8286015b848110156126505780358352918301918301612639565b509695505050505050565b6000806040838503121561266e57600080fd5b823567ffffffffffffffff8082111561268657600080fd5b908401906040828703121561269a57600080fd5b6126a2612554565b8235828111156126b157600080fd5b8301601f810188136126c257600080fd5b803560206126d2612611836125cc565b82815260059290921b8301810191818101908b8411156126f157600080fd5b8285015b8481101561279b5780358881111561270d5760008081fd5b8601603f81018e1361271f5760008081fd5b848101358981111561273357612733612525565b612763867fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160161257d565b8181528f60408385010111156127795760008081fd5b81604084018883013760009181018701919091528452509183019183016126f5565b50855250858101359250848311156127b257600080fd5b6127be8a8488016125f0565b8482015292965050508501359150808211156127d957600080fd5b506127e6858286016125f0565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60008261285d5761285d6127f0565b500490565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036128c2576128c261281f565b5060010190565b60005b838110156128e45781810151838201526020016128cc565b50506000910152565b600081518084526129058160208601602086016128c9565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b600081518084526020808501945080840160005b838110156129675781518752958201959082019060010161294b565b509495945050505050565b73ffffffffffffffffffffffffffffffffffffffff831681526000602060408184015260808301845160408086015281815180845260a08701915060a08160051b8801019350848301925060005b81811015612a0c577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff608886030183526129fa8585516128ed565b945092850192918501916001016129c0565b50505050908401518382037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc001606085015290610d8f8183612937565b6000815260008251612a628160018501602087016128c9565b9190910160010192915050565b7f630000000000000000000000000000000000000000000000000000000000000081527fffffffff000000000000000000000000000000000000000000000000000000008360e01b1660018201527f80600e6000396000f30000000000000000000000000000000000000000000000600582015260008251612af881600e8501602087016128c9565b91909101600e019392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b808201808211156102445761024461281f565b606081526000612b5b60608301866128ed565b60208301949094525060400152919050565b815160009082906020808601845b83811015612b9757815185529382019390820190600101612b7b565b50929695505050505050565b600060208284031215612bb557600080fd5b5051919050565b600060208284031215612bce57600080fd5b815173ffffffffffffffffffffffffffffffffffffffff8116811461061f57600080fd5b604080825283519082018190526000906020906060840190828701845b82811015612c4157815173ffffffffffffffffffffffffffffffffffffffff1684529284019290840190600101612c0f565b50505083810382850152610d8f8186612937565b60006020808385031215612c6857600080fd5b825167ffffffffffffffff811115612c7f57600080fd5b8301601f81018513612c9057600080fd5b8051612c9e612611826125cc565b81815260059190911b82018301908381019087831115612cbd57600080fd5b928401925b82841015610b0457835182529284019290840190612cc2565b600181815b80851115612d3457817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04821115612d1a57612d1a61281f565b80851615612d2757918102915b93841c9390800290612ce0565b509250929050565b600082612d4b57506001610244565b81612d5857506000610244565b8160018114612d6e5760028114612d7857612d94565b6001915050610244565b60ff841115612d8957612d8961281f565b50506001821b610244565b5060208310610133831016604e8410600b8410161715612db7575081810a610244565b612dc18383612cdb565b807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04821115612df357612df361281f565b029392505050565b600061061f8383612d3c565b600082612e1657612e166127f0565b500690565b80820281158282048414176102445761024461281f565b818103818111156102445761024461281f565b600060208284031215612e5757600080fd5b81516004811061061f57600080fd5b73ffffffffffffffffffffffffffffffffffffffff831681526040602082015260006108e46040830184612937565b73ffffffffffffffffffffffffffffffffffffffff841681528260208201526060604082015260006106c16060830184612937565b805169ffffffffffffffffffff811681146110f557600080fd5b600080600080600060a08688031215612efc57600080fd5b612f0586612eca565b9450602086015193506040860151925060608601519150612f2860808701612eca565b90509295509295909350565b600060208284031215612f4657600080fd5b815160ff8116811461061f57600080fd5b600061061f60ff841683612d3c565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052605160045260246000fdfe0cb50cc30d190d6b0de90e150eae0f780fad0fcb105310621070107e108c1062109a10a810b610c510d410e210f0116811771186119511a411b311fc120e121c124e125c126a12781287129612a512b412c312d212e112f012ff130e131d132b13391347135513631371137f138e139d13ab13f507e5a2646970667358221220b93210b8316c3863574e1ffb7e30677a168f78040f9a572ba897f4994cd10be064736f6c634300081100330cb50cc30d190d6b0de90e150eae0f780fad0fcb105310621070107e108c1062109a10a810b610c510d410e210f0116811771186119511a411b311fc120e121c124e125c126a12781287129612a512b412c312d212e112f012ff130e131d132b13391347135513631371137f138e139d13ab13f507e5",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80631ed061d914610030575b600080fd5b61004361003e36600461265b565b61006c565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b6000826000015151825111156100c15781518351516040517f7d2d70db000000000000000000000000000000000000000000000000000000008152600481019290925260248201526044015b60405180910390fd5b60006100d4846100cf61024a565b6102c4565b604081015160608201519192509060005b855181101561015e57604084018390526060840182905261014b848261012c60027fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61284e565b89858151811061013e5761013e612862565b60200260200101516103db565b508061015681612891565b9150506100e5565b50600061017c8460800151856040015161050490919063ffffffff16565b90507f810b097bdad06c3daae05fe6acae5885a229381e85b19a35563683b39eea5a5333886040516101af929190612972565b60405180910390a160006101de826040518060a0016040528060768152602001612f96607691398a919061050d565b905060006101eb82610626565b6040805133815273ffffffffffffffffffffffffffffffffffffffff831660208201529192507fdcb4bd7c42c5278a44b5f7b614a5d3751e67c4c803ffd29c00e83a161c1447b0910160405180910390a1955050505050505b92915050565b60408051600180825281830190925260609160009190816020015b61251b8152602001906001900390816102655790505090506106b18160008151811061029357610293612862565b602002602001019067ffffffffffffffff16908167ffffffffffffffff16815250506102be816106ca565b91505090565b6102fd6040518060c001604052806060815260200160008152602001600081526020016000815260200160008152602001606081525090565b6040805160c08101825284518152602080860151519082015290810161034460027fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61284e565b815260200161039c61037760027fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61284e565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe00190565b81526020016103cc60027fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff61284e565b81526020019290925250919050565b600060027fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048560400151101561043e576040517f271592cf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b845160208581029091010151805181015b808210156104a957600080600484019350835161ffff8116915061ffff8160101c169250506104a08982898c60a00151868151811061049057610490612862565b602002602001015163ffffffff16565b9650505061044f565b6040870151602090860304808511156104f8576040517ff993c6e700000000000000000000000000000000000000000000000000000000815260048101869052602481018290526044016100b8565b50939695505050505050565b60209190030490565b602083810151516060910260400160005b85515181101561055c576105508660000151828151811061054157610541612862565b60200260200101515160200190565b9091019060010161051e565b5060008167ffffffffffffffff81111561057857610578612525565b6040519080825280601f01601f1916602001820160405280156105a2576020820181803683370190505b50905060006105b2825b60200190565b868152602088810151910191506105ca9082906108f4565b9050606060005b8851518110156106175788518051829081106105ef576105ef612862565b602002602001015191506106038288610914565b61060d8383610973565b92506001016105d1565b509193505050505b9392505050565b6000806106518360405160200161063d9190612a49565b604051602081830303815290604052610993565b90508051602082016000f0915073ffffffffffffffffffffffffffffffffffffffff82166106ab576040517f08d4abb600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50919050565b600061251b6106c18584836109bf565b95945050505050565b606060006040518061076001604052806106e2603a90565b67ffffffffffffffff1667ffffffffffffffff1681526020016109d581526020016109e48152602001610a7881526020016106b18152602001610a848152602001610aa18152602001610b0f8152602001610b7b8152602001610c2a8152602001610d998152602001610da98152602001610db98152602001610dc88152602001610dd78152602001610de68152602001610db98152602001610df58152602001610e048152602001610e138152602001610e238152602001610a788152602001610a788152602001610e338152602001610e4b8152602001610e5a8152602001610e698152602001610e788152602001610e878152602001610e968152602001610ea78152602001610ec48152602001610e968152602001610ed38152602001610ee28152602001610ef18152602001610f008152602001610f108152602001610f208152602001610f308152602001610f408152602001610f508152602001610f608152602001610f708152602001610f808152602001610f908152602001610fa08152602001610fb08152602001610fbf8152602001610fce8152602001610fdd8152602001610fec8152602001610ffb815260200161100a8152602001611019815260200161102981526020016110398152602001611048815260200161109c815250905060006108d6826110ab565b90506108e281856110fa565b805b949350505050565b815260200190565b600061061f8261090e8451866108ec90919063ffffffff16565b90611130565b815161ffff907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000090840160028481019086015b8281101561096a5780518581166002028301518616908516178152600401610947565b50505050505050565b600061061f8261098d8451866108ec90919063ffffffff16565b90611148565b60608151826040516020016109a9929190612a6f565b6040516020818303038152906040529050919050565b60006108e46109ce858561116a565b8590611198565b60006108e484836111a76111b3565b60408301516060840151600091600f85811692600487901c90911691600887901c91610a118988876111c0565b60408a01527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0870160608a0152610a4a898489876103db565b50606089018190526040890151610a63908a9086611222565b60409099019190915250959695505050505050565b60006108e48483611198565b6000826003811115610a9857610a98612b06565b50909392505050565b600060ff8316600f8110610ae4576040517f316e6a37000000000000000000000000000000000000000000000000000000008152600481018290526024016100b8565b60018101600481901b8517610b04610afd8883886109e4565b889061116a565b979650505050505050565b6000600f83811690600885811c91821691600c87901c91828401917efffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0169088901b610f0016178117610b61898886611256565b9650610b6e8982896109e4565b9998505050505050505050565b6000600c83901c600f80851690600486901c1680821015610bf8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600d60248201527f4c4f4f505f4e5f494e505554530000000000000000000000000000000000000060448201526064016100b8565b610fff861660005b84811015610c1d57610c138983896109e4565b9650600101610c00565b5094979650505050505050565b600060018381169084901c81610d38576040860151602090850304808210610c88576040517f1cb73c1600000000000000000000000000000000000000000000000000000000815260048101829052602481018390526044016100b8565b610cd06040518060400160405280600681526020017f6265666f726500000000000000000000000000000000000000000000000000008152508860400151896060015161126a565b60408701516060880151610ce89160208502016112fd565b60608801908152604080518082018252600581527f61667465720000000000000000000000000000000000000000000000000000006020820152908901519151610d32929061126a565b50610d85565b85602001518110610d855760208601516040517f890a8e6a0000000000000000000000000000000000000000000000000000000081526004810191909152602481018290526044016100b8565b610d8f8685611198565b9695505050505050565b600061251b6106c1858483611313565b60006108e4848361132186611370565b60006108e484836113806111b3565b60006108e484836114156109bf565b60006108e48483611486611522565b60006108e484836115336111b3565b60006108e484836115896111b3565b60006108e48483611638611522565b60006108e484836116958661174f565b60006108e4848361176d8661177a565b60006108e4610e42858461116a565b85906008611222565b60006108e484836117876109bf565b60006108e484836117936111b3565b60006108e484836117a96111b3565b60006108e484836117bf6109bf565b60006108e484836117cb6109bf565b600061251b6106c185848387611370565b60006108e4826117d7610ebb866001612b35565b8792919061174f565b60006108e484836117e76111b3565b60006108e484836117eb6111b3565b60006108e484836117ef6109bf565b60006108e484836117f36111b3565b60006108e484836117f786611370565b60006108e4848361183286611370565b60006108e4848361186386611370565b60006108e4848361187986611370565b60006108e4848361188586611370565b60006108e4848361189186611370565b60006108e484836112fd86611370565b60006108e4848361189d86611370565b60006108e484836118ac86611370565b60006108e484836118b886611370565b60006108e484836118c486611370565b60006108e484836118d0611992565b60006108e484836119a36109bf565b60006108e484836119f06109bf565b60006108e48483611a7d6109bf565b60006108e48483611aff6109bf565b60006108e48483611b4c6109bf565b60006108e48483611b99611522565b60006108e48483611bf886611c4f565b60006108e48483611c6286611cfc565b60006108e48483611d0f6111b3565b600060ff8316808203611087576040517f904c1f6d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6106c16110958685846111c0565b8690611198565b60006108e48483611d6e6111b3565b80518190603a146110f55780516040517fc8b569010000000000000000000000000000000000000000000000000000000081526004810191909152603a60248201526044016100b8565b919050565b60405182518251602080830286010183111561111557600080fd5b60208102830160405201835261112b8282611d86565b505050565b600061113c8284611d86565b8151602002830161061f565b600061116183835161115a6105ac8690565b9190611d9a565b8151830161061f565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe00160006106ab8383611e16565b60200160006106ab8383611ebe565b600061061f8383611ed3565b60006108e46109ce858560025b60006112026040518060400160405280600381526020017f706f700000000000000000000000000000000000000000000000000000000000815250838561126a565b811561121a57602082028303925061121a8484611e16565b509092915050565b6000602082028301925060018211801561123f5750836060015183115b1561124c57606084018390525b61121a8484611ebe565b6000602082028301925061121a8484611ebe565b61112b83838360405160240161128293929190612b48565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fca47c4eb0000000000000000000000000000000000000000000000000000000017905261205c565b600081831161130c578161061f565b5090919050565b60006108e4848460026111c0565b6000816040516020016113349190612b6d565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152919052805160209091012092915050565b60006106c16110958686856111c0565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8281166004830152600091908416906370a08231906024015b602060405180830381865afa1580156113f1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061061f9190612ba3565b60008173ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611462573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102449190612ba3565b6040517f4ee2cd7e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83811660048301526024820183905260009190851690634ee2cd7e906044015b602060405180830381865afa1580156114fe573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108e49190612ba3565b60006108e46109ce858560036111c0565b6040517f981b24d00000000000000000000000000000000000000000000000000000000081526004810182905260009073ffffffffffffffffffffffffffffffffffffffff84169063981b24d0906024016113d4565b6040517f6352211e0000000000000000000000000000000000000000000000000000000081526004810182905260009073ffffffffffffffffffffffffffffffffffffffff841690636352211e90602401602060405180830381865afa1580156115f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061161b9190612bbc565b73ffffffffffffffffffffffffffffffffffffffff169392505050565b6040517efdd58e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152602482018390526000919085169062fdd58e906044016114e1565b6040517f4e1273f400000000000000000000000000000000000000000000000000000000815260609073ffffffffffffffffffffffffffffffffffffffff851690634e1273f4906116ec9086908690600401612bf2565b600060405180830381865afa158015611709573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682016040526108e49190810190612c55565b60006106c16117658686600160028702016111c0565b869084611222565b8061177757600080fd5b50565b60006106c18585846111c0565b600061061f828461207d565b60006108e4826117a3858761207d565b906120fd565b60006108e4826117b9858761207d565b90612112565b600061061f8284612127565b600061061f8284612176565b60606000841161121a57816108e4565b1490565b1090565b1590565b1190565b600082820183811061180957806108e4565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff949350505050565b60008260000361184457506000610244565b82820282848281611857576118576127f0565b040361180957806108e4565b600081831161187357600061061f565b50900390565b600061061f8284612b35565b600061061f828461284e565b600061061f8284612dfb565b600081831061130c578161061f565b600061061f8284612e07565b600061061f8284612e1b565b600061061f8284612e32565b6040517fd97b2e4800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff84811660048301528381166024830152604482018390526000919086169063d97b2e4890606401602060405180830381865afa15801561194f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119739190612ba3565b73ffffffffffffffffffffffffffffffffffffffff1695945050505050565b60006108e46109ce858560046111c0565b60008173ffffffffffffffffffffffffffffffffffffffff1663ec14b06e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611462573d6000803e3d6000fd5b60008173ffffffffffffffffffffffffffffffffffffffff1663cd3293de6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611a3d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a619190612bbc565b73ffffffffffffffffffffffffffffffffffffffff1692915050565b60008173ffffffffffffffffffffffffffffffffffffffff1663f9020e336040518163ffffffff1660e01b8152600401602060405180830381865afa158015611aca573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611aee9190612e45565b600381111561024457610244612b06565b60008173ffffffffffffffffffffffffffffffffffffffff1663fc0c546a6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611a3d573d6000803e3d6000fd5b60008173ffffffffffffffffffffffffffffffffffffffff166347e4bbb96040518163ffffffff1660e01b8152600401602060405180830381865afa158015611462573d6000803e3d6000fd5b6040517fdb8554fc00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8381166004830152602482018390526000919085169063db8554fc906044016114e1565b6040517f88d6860400000000000000000000000000000000000000000000000000000000815260009073ffffffffffffffffffffffffffffffffffffffff8516906388d68604906114e19086908690600401612e66565b60006106c16110958686600286016111c0565b6040517fcaa0eb3b00000000000000000000000000000000000000000000000000000000815260009073ffffffffffffffffffffffffffffffffffffffff86169063caa0eb3b90611cbb90879087908790600401612e95565b602060405180830381865afa158015611cd8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106c19190612ba3565b60006106c16110958686600386016111c0565b60008060015b60088111611d66576000611d2986836121d6565b90506000611d3786846121d6565b90506000611d458383611863565b9050611d55856001860383612286565b94505060019092019150611d159050565b509392505050565b60006108e48385600f16600487901c600f1685612310565b600060208301905061112b818385516123b6565b5b60208110611dd85782518252602092830192909101907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe001611d9b565b801561112b577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600882021c80835116811985511617835250505050565b611e5a6040518060400160405280600381526020017f707563000000000000000000000000000000000000000000000000000000000081525082846060015161126a565b81606001518111611eba5760608201516040830151602091030460408301516020908303046040517f625e32e4000000000000000000000000000000000000000000000000000000008152600481019290925260248201526044016100b8565b5050565b8160800151811115611eba5760809190910152565b60008060008473ffffffffffffffffffffffffffffffffffffffff1663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa158015611f23573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f479190612ee4565b5093505092505060008213611f8b576040517f3351e26f000000000000000000000000000000000000000000000000000000008152600481018390526024016100b8565b83611f968242612e32565b1115611fd8576040517f2730eb4800000000000000000000000000000000000000000000000000000000815260048101829052602481018590526044016100b8565b6106c18573ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015612026573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061204a9190612f34565b60ff16612056846123de565b9061207d565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b600080826012036120915783915050610244565b82601211156120bd575060128290036120b56120ae82600a612dfb565b8590611832565b915050610244565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee82016120ec81600a612dfb565b6120b5908561284e565b5092915050565b600061061f83670de0b6b3a76400008461244e565b600061061f8383670de0b6b3a764000061244e565b60008160000b60000361213b575081610244565b60008260000b13156121635761215c61215583600a612f57565b8490611832565b9050610244565b60ff6000839003166120ec81600a612dfb565b6000806012830361218a5783915050610244565b82601211156121a4575060128290036120ec81600a612dfb565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee82016120b56120ae82600a612dfb565b6000816008811115612244576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4d41585f5449455200000000000000000000000000000000000000000000000060448201526064016100b8565b8260000361225557600091506120f6565b50507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff016020021c63ffffffff1690565b60008260088111156122f4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4d41585f5449455200000000000000000000000000000000000000000000000060448201526064016100b8565b505060209190910290811b63ffffffff90911b19919091161790565b600082600881111561237e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600860248201527f4d41585f5449455200000000000000000000000000000000000000000000000060448201526064016100b8565b6000855b858110156123aa5763ffffffff6020820290811b199890981685891b17979150600101612382565b50959695505050505050565b8060200283015b808410156123d85783518352602093840193909201916123bd565b50505050565b60008082121561244a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f53616665436173743a2076616c7565206d75737420626520706f73697469766560448201526064016100b8565b5090565b600080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff858709858702925082811083820303915050806000036124a65783828161249c5761249c6127f0565b049250505061061f565b8084116124b257600080fd5b60008486880960026001871981018816978890046003810283188082028403028082028403028082028403028082028403028082028403029081029092039091026000889003889004909101858311909403939093029303949094049190911702949350505050565b612523612f66565b565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff8111828210171561257757612577612525565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156125c4576125c4612525565b604052919050565b600067ffffffffffffffff8211156125e6576125e6612525565b5060051b60200190565b600082601f83011261260157600080fd5b81356020612616612611836125cc565b61257d565b82815260059290921b8401810191818101908684111561263557600080fd5b8286015b848110156126505780358352918301918301612639565b509695505050505050565b6000806040838503121561266e57600080fd5b823567ffffffffffffffff8082111561268657600080fd5b908401906040828703121561269a57600080fd5b6126a2612554565b8235828111156126b157600080fd5b8301601f810188136126c257600080fd5b803560206126d2612611836125cc565b82815260059290921b8301810191818101908b8411156126f157600080fd5b8285015b8481101561279b5780358881111561270d5760008081fd5b8601603f81018e1361271f5760008081fd5b848101358981111561273357612733612525565b612763867fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160161257d565b8181528f60408385010111156127795760008081fd5b81604084018883013760009181018701919091528452509183019183016126f5565b50855250858101359250848311156127b257600080fd5b6127be8a8488016125f0565b8482015292965050508501359150808211156127d957600080fd5b506127e6858286016125f0565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60008261285d5761285d6127f0565b500490565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036128c2576128c261281f565b5060010190565b60005b838110156128e45781810151838201526020016128cc565b50506000910152565b600081518084526129058160208601602086016128c9565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b600081518084526020808501945080840160005b838110156129675781518752958201959082019060010161294b565b509495945050505050565b73ffffffffffffffffffffffffffffffffffffffff831681526000602060408184015260808301845160408086015281815180845260a08701915060a08160051b8801019350848301925060005b81811015612a0c577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff608886030183526129fa8585516128ed565b945092850192918501916001016129c0565b50505050908401518382037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc001606085015290610d8f8183612937565b6000815260008251612a628160018501602087016128c9565b9190910160010192915050565b7f630000000000000000000000000000000000000000000000000000000000000081527fffffffff000000000000000000000000000000000000000000000000000000008360e01b1660018201527f80600e6000396000f30000000000000000000000000000000000000000000000600582015260008251612af881600e8501602087016128c9565b91909101600e019392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b808201808211156102445761024461281f565b606081526000612b5b60608301866128ed565b60208301949094525060400152919050565b815160009082906020808601845b83811015612b9757815185529382019390820190600101612b7b565b50929695505050505050565b600060208284031215612bb557600080fd5b5051919050565b600060208284031215612bce57600080fd5b815173ffffffffffffffffffffffffffffffffffffffff8116811461061f57600080fd5b604080825283519082018190526000906020906060840190828701845b82811015612c4157815173ffffffffffffffffffffffffffffffffffffffff1684529284019290840190600101612c0f565b50505083810382850152610d8f8186612937565b60006020808385031215612c6857600080fd5b825167ffffffffffffffff811115612c7f57600080fd5b8301601f81018513612c9057600080fd5b8051612c9e612611826125cc565b81815260059190911b82018301908381019087831115612cbd57600080fd5b928401925b82841015610b0457835182529284019290840190612cc2565b600181815b80851115612d3457817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04821115612d1a57612d1a61281f565b80851615612d2757918102915b93841c9390800290612ce0565b509250929050565b600082612d4b57506001610244565b81612d5857506000610244565b8160018114612d6e5760028114612d7857612d94565b6001915050610244565b60ff841115612d8957612d8961281f565b50506001821b610244565b5060208310610133831016604e8410600b8410161715612db7575081810a610244565b612dc18383612cdb565b807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04821115612df357612df361281f565b029392505050565b600061061f8383612d3c565b600082612e1657612e166127f0565b500690565b80820281158282048414176102445761024461281f565b818103818111156102445761024461281f565b600060208284031215612e5757600080fd5b81516004811061061f57600080fd5b73ffffffffffffffffffffffffffffffffffffffff831681526040602082015260006108e46040830184612937565b73ffffffffffffffffffffffffffffffffffffffff841681528260208201526060604082015260006106c16060830184612937565b805169ffffffffffffffffffff811681146110f557600080fd5b600080600080600060a08688031215612efc57600080fd5b612f0586612eca565b9450602086015193506040860151925060608601519150612f2860808701612eca565b90509295509295909350565b600060208284031215612f4657600080fd5b815160ff8116811461061f57600080fd5b600061061f60ff841683612d3c565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052605160045260246000fdfe0cb50cc30d190d6b0de90e150eae0f780fad0fcb105310621070107e108c1062109a10a810b610c510d410e210f0116811771186119511a411b311fc120e121c124e125c126a12781287129612a512b412c312d212e112f012ff130e131d132b13391347135513631371137f138e139d13ab13f507e5a2646970667358221220b93210b8316c3863574e1ffb7e30677a168f78040f9a572ba897f4994cd10be064736f6c63430008110033",
  "devdoc": {
    "errors": {
      "MinFinalStack(uint256,uint256)": [
        {
          "params": {
            "actualStackOutputs": "The final stack height after evaluating a source. Will be less than the min stack outputs if this error is thrown.",
            "minStackOutputs": "The required minimum stack height."
          }
        }
      ],
      "MissingEntrypoint(uint256,uint256)": [
        {
          "details": "There are more entrypoints defined by the minimum stack outputs than there are provided sources. This means the calling contract WILL attempt to eval a dangling reference to a non-existent source at some point, so this MUST REVERT."
        }
      ],
      "NotPosIntPrice(int256)": [
        {
          "params": {
            "price": "The price that is not a positive integer."
          }
        }
      ],
      "StackPopUnderflow(uint256,uint256)": [
        {
          "params": {
            "stackHighwaterIndex": "Index of the stack highwater at the moment of underflow.",
            "stackTopIndex": "Index of the stack top at the moment of underflow."
          }
        }
      ],
      "StalePrice(uint256,uint256)": [
        {
          "params": {
            "staleAfter": "The maximum number of seconds the caller allows between the block timestamp and the updated time.",
            "updatedAt": "The latest time the oracle was updated according to the oracle."
          }
        }
      ],
      "UnexpectedInterpreterBytecodeHash(bytes32)": [
        {
          "details": "Thrown when the bytecode hash known to the expression deployer DOES NOT match the interpreter it is constructed for. This WILL cause undefined expression behaviour so MUST REVERT."
        }
      ],
      "UnexpectedPointers(bytes)": [
        {
          "details": "Thrown when the pointers known to the expression deployer DO NOT match the interpreter it is constructed for. This WILL cause undefined expression behaviour so MUST REVERT."
        }
      ]
    },
    "events": {
      "ExpressionConfig(address,(bytes[],uint256[]))": {
        "params": {
          "config": "The config for the deployed expression.",
          "sender": "The caller of `deployExpression`."
        }
      },
      "ExpressionDeployed(address,address)": {
        "params": {
          "expression": "The address of the deployed expression.",
          "sender": "The caller of `deployExpression`."
        }
      },
      "ValidInterpreter(address,address)": {
        "params": {
          "interpreter": "The address of the interpreter that the expression deployer agrees to perform integrity checks for. Note that the pairing between interpreter and expression deployer needs to be checked and enforced elsewhere offchain and/or onchain.",
          "sender": "The account that constructed the expression deployer."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "deployExpression((bytes[],uint256[]),uint256[])": {
        "params": {
          "config": "All the state config associated with an expression.",
          "minOutputs": "The first N sources on the state config are entrypoints to the expression where N is the length of the `minOutputs` array. Each item in the `minOutputs` array specifies the number of outputs that MUST be present on the final stack for an evaluation of each entrypoint. The minimum output for some entrypoint MAY be zero if the expectation is that the expression only applies checks and error logic. Non-entrypoint sources MUST NOT have a minimum outputs length specified."
        },
        "returns": {
          "_0": "The onchain address of the deployed expression."
        }
      }
    },
    "title": "RainterpreterExpressionDeployer",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "BadDynamicLength(uint256,uint256)": [
        {
          "notice": "Thrown when a dynamic length array is NOT 1 more than a fixed length array. Should never happen outside a major breaking change to memory layouts."
        }
      ],
      "DoWhileMaxInputs(uint256)": [
        {
          "notice": "More inputs were encoded in the operand than can be dispatched internally by a do-while loop."
        }
      ],
      "MinFinalStack(uint256,uint256)": [
        {
          "notice": "The final stack produced by some source did not hit the minimum required for its calling context."
        }
      ],
      "MinStackBottom()": [
        {
          "notice": "It is a misconfiguration to set the initial stack bottom to zero or some small value as this trivially exposes the integrity check to potential underflow issues that are gas intensive to repeatedly guard against on every pop. The initial stack bottom for an `IntegrityCheckState` should be `INITIAL_STACK_BOTTOM` to safely avoid the need for underflow checks due to pops and pushes."
        }
      ],
      "NotPosIntPrice(int256)": [
        {
          "notice": "Thrown if a price is zero or negative as this is probably not anticipated or useful for most users of a price feed. Of course there are use cases where zero or negative _oracle values_ in general are useful, such as negative temperatures from a thermometer, but these are unlikely to be useful _prices_ for assets. Zero value prices are likely to result in division by zero downstream or giving away assets for free, negative price values could result in even weirder behaviour due to token amounts being `uint256` and the subtleties of signed vs. unsigned integer conversions."
        }
      ],
      "OutOfBoundsConstantsRead(uint256,uint256)": [
        {
          "notice": "Thrown when a constant read index is outside the constants array."
        }
      ],
      "OutOfBoundsStackRead(uint256,uint256)": [
        {
          "notice": "Thrown when a stack read index is outside the current stack top."
        }
      ],
      "StackPopUnderflow(uint256,uint256)": [
        {
          "notice": "The virtual stack top has underflowed the stack highwater (or zero) during an integrity check. The highwater will initially be the stack bottom but MAY move higher due to certain operations such as placing multiple outputs on the stack or copying from a stack position. The highwater prevents subsequent popping of values that are considered immutable."
        }
      ],
      "StalePrice(uint256,uint256)": [
        {
          "notice": "Thrown when the updatedAt time from the Chainlink oracle is more than staleAfter seconds prior to the current block timestamp. Prevents stale prices from being used within the constraints set by the caller."
        }
      ],
      "ZeroInputs()": [
        {
          "notice": "Zero inputs to select lte is NOT supported."
        }
      ]
    },
    "events": {
      "ExpressionConfig(address,(bytes[],uint256[]))": {
        "notice": "The config of the deployed expression including uncompiled sources. Will only be emitted after the config passes the integrity check."
      },
      "ExpressionDeployed(address,address)": {
        "notice": "The address of the deployed expression. Will only be emitted once the expression can be loaded and deserialized into an evaluable interpreter state."
      },
      "ValidInterpreter(address,address)": {
        "notice": "The interpreter passed in construction is valid. The only valid interpreter has the exact bytecode hash known to the expression deployer."
      }
    },
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "THIS IS NOT A SECURITY CHECK. IT IS AN INTEGRITY CHECK TO PREVENT HONEST MISTAKES. IT CANNOT PREVENT EITHER A MALICIOUS INTERPRETER OR DEPLOYER FROM BEING EXECUTED."
      },
      "deployExpression((bytes[],uint256[]),uint256[])": {
        "notice": "Expressions are expected to be deployed onchain as immutable contract code with a first class address like any other contract or account. Technically this is optional in the sense that all the tools required to eval some expression and define all its opcodes are available as libraries. In practise there are enough advantages to deploying the sources directly onchain as contract data and loading them from the interpreter at eval time: - Loading and storing binary data is gas efficient as immutable contract data - Expressions need to be immutable between their deploy time integrity check   and runtime evaluation - Passing the address of an expression through calldata to an interpreter is   cheaper than passing an entire expression through calldata - Conceptually a very simple approach, even if implementations like SSTORE2   are subtle under the hood The expression deployer MUST perform an integrity check of the source code before it puts the expression onchain at a known address. The integrity check MUST at a minimum (it is free to do additional static analysis) calculate the memory required to be allocated for the stack in total, and that no out of bounds memory reads/writes occur within this stack. A simple example of an invalid source would be one that pushes one value to the stack then attempts to pops two values, clearly we cannot remove more values than we added. The `IExpressionDeployerV1` MUST revert in the case of any integrity failure, all integrity checks MUST pass in order for the deployment to complete. Once the integrity check is complete the `IExpressionDeployerV1` MUST do any additional processing required by its paired interpreter. For example, the `IExpressionDeployerV1` MAY NEED to replace the indexed opcodes in the `StateConfig` sources with real function pointers from the corresponding interpreter."
      }
    },
    "notice": "Minimal binding of the `IExpressionDeployerV1` interface to the `LibIntegrityCheck.ensureIntegrity` loop and `AllStandardOps`.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}