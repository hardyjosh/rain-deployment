{
  "address": "0x3AEe716841E9a4f8a5a0C896B41A7Ac2d79982A8",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "child",
          "type": "address"
        }
      ],
      "name": "DuplicateChild",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        }
      ],
      "name": "Implementation",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "child",
          "type": "address"
        }
      ],
      "name": "NewChild",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data_",
          "type": "bytes"
        }
      ],
      "name": "createChild",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "string",
              "name": "uri",
              "type": "string"
            },
            {
              "components": [
                {
                  "internalType": "bytes[]",
                  "name": "sources",
                  "type": "bytes[]"
                },
                {
                  "internalType": "uint256[]",
                  "name": "constants",
                  "type": "uint256[]"
                }
              ],
              "internalType": "struct StateConfig",
              "name": "stateConfig",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "expressionDeployer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "interpreter",
                  "type": "address"
                },
                {
                  "components": [
                    {
                      "internalType": "bytes[]",
                      "name": "sources",
                      "type": "bytes[]"
                    },
                    {
                      "internalType": "uint256[]",
                      "name": "constants",
                      "type": "uint256[]"
                    }
                  ],
                  "internalType": "struct StateConfig[]",
                  "name": "flows",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct FlowCommonConfig",
              "name": "flowConfig",
              "type": "tuple"
            }
          ],
          "internalType": "struct FlowERC1155Config",
          "name": "config_",
          "type": "tuple"
        }
      ],
      "name": "createChildTyped",
      "outputs": [
        {
          "internalType": "contract FlowERC1155",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "implementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "maybeChild_",
          "type": "address"
        }
      ],
      "name": "isChild",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x056ee6e10d41aee8b806eec5dc06bd861250dde141657d180510e2b3858fb881",
  "receipt": {
    "to": null,
    "from": "0xbF334f8BD1420a1CbFE15407f73919424934B1B3",
    "contractAddress": "0x3AEe716841E9a4f8a5a0C896B41A7Ac2d79982A8",
    "transactionIndex": 5,
    "gasUsed": "6087803",
    "logsBloom": "0x00000000000000020000000000000000000000040000002008000000800000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000200000000000000000000000000000000000080000000010000000000010000000000000000000000000000000000000080000000000000000000200000000000000020008000000400000001000000000000000000000000004010000000000000000001000000040000000000010000010000100040000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x5918f497a92a04adc081fe6fb8da6b8b298b279fbf7d56d1d1f44eba35efb0e0",
    "transactionHash": "0x056ee6e10d41aee8b806eec5dc06bd861250dde141657d180510e2b3858fb881",
    "logs": [
      {
        "transactionIndex": 5,
        "blockNumber": 30456799,
        "transactionHash": "0x056ee6e10d41aee8b806eec5dc06bd861250dde141657d180510e2b3858fb881",
        "address": "0x3AEe716841E9a4f8a5a0C896B41A7Ac2d79982A8",
        "topics": [
          "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000000000000000ff",
        "logIndex": 8,
        "blockHash": "0x5918f497a92a04adc081fe6fb8da6b8b298b279fbf7d56d1d1f44eba35efb0e0"
      },
      {
        "transactionIndex": 5,
        "blockNumber": 30456799,
        "transactionHash": "0x056ee6e10d41aee8b806eec5dc06bd861250dde141657d180510e2b3858fb881",
        "address": "0x125cCf3809E3141Bb989dA5aed50b71727925e07",
        "topics": [
          "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000000000000000ff",
        "logIndex": 9,
        "blockHash": "0x5918f497a92a04adc081fe6fb8da6b8b298b279fbf7d56d1d1f44eba35efb0e0"
      },
      {
        "transactionIndex": 5,
        "blockNumber": 30456799,
        "transactionHash": "0x056ee6e10d41aee8b806eec5dc06bd861250dde141657d180510e2b3858fb881",
        "address": "0x3AEe716841E9a4f8a5a0C896B41A7Ac2d79982A8",
        "topics": [
          "0x7fac34ecf0b1b374cd9659e3d17db602659d53f1162b1f20142e6c02694aed70"
        ],
        "data": "0x000000000000000000000000bf334f8bd1420a1cbfe15407f73919424934b1b3000000000000000000000000125ccf3809e3141bb989da5aed50b71727925e07",
        "logIndex": 10,
        "blockHash": "0x5918f497a92a04adc081fe6fb8da6b8b298b279fbf7d56d1d1f44eba35efb0e0"
      },
      {
        "transactionIndex": 5,
        "blockNumber": 30456799,
        "transactionHash": "0x056ee6e10d41aee8b806eec5dc06bd861250dde141657d180510e2b3858fb881",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000bf334f8bd1420a1cbfe15407f73919424934b1b3",
          "0x000000000000000000000000c26880a0af2ea0c7e8130e6ec47af756465452e8"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000076a10122f48822000000000000000000000000000000000000000000000000a4580ea8822737af0000000000000000000000000000000000000000000018b754b948fd0b06296c000000000000000000000000000000000000000000000000a3e16da75f32af8d0000000000000000000000000000000000000000000018b7552fe9fe2dfab18e",
        "logIndex": 11,
        "blockHash": "0x5918f497a92a04adc081fe6fb8da6b8b298b279fbf7d56d1d1f44eba35efb0e0"
      }
    ],
    "blockNumber": 30456799,
    "cumulativeGasUsed": "7538754",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "0a2c1cfb658e0cd1c4b0edc075963ea3",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"child\",\"type\":\"address\"}],\"name\":\"DuplicateChild\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Implementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"child\",\"type\":\"address\"}],\"name\":\"NewChild\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"createChild\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"bytes[]\",\"name\":\"sources\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"internalType\":\"struct StateConfig\",\"name\":\"stateConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"expressionDeployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"interpreter\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes[]\",\"name\":\"sources\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"internalType\":\"struct StateConfig[]\",\"name\":\"flows\",\"type\":\"tuple[]\"}],\"internalType\":\"struct FlowCommonConfig\",\"name\":\"flowConfig\",\"type\":\"tuple\"}],\"internalType\":\"struct FlowERC1155Config\",\"name\":\"config_\",\"type\":\"tuple\"}],\"name\":\"createChildTyped\",\"outputs\":[{\"internalType\":\"contract FlowERC1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"maybeChild_\",\"type\":\"address\"}],\"name\":\"isChild\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"createChild(bytes)\":{\"params\":{\"data_\":\"Encoded data to pass down to child contract constructor.\"},\"returns\":{\"_0\":\"New child contract address.\"}},\"createChildTyped((string,(bytes[],uint256[]),(address,address,(bytes[],uint256[])[])))\":{\"params\":{\"config_\":\"`FlowERC1155` constructor configuration.\"},\"returns\":{\"_0\":\"New `FlowERC1155` child contract address.\"}},\"isChild(address)\":{\"params\":{\"maybeChild_\":\"Address of child contract to look up.\"},\"returns\":{\"_0\":\"Returns `true` if address is a contract created by this contract factory, otherwise `false`.\"}}},\"title\":\"EmissionsERC1155Factory\",\"version\":1},\"userdoc\":{\"errors\":{\"DuplicateChild(address)\":[{\"notice\":\"Thrown when a new factory deployment creates a child that was already created by a previous deployment. This should never happen without some kind of precompute such as CREATE2 and is generally unsupported at this time.\"}]},\"events\":{\"Implementation(address,address)\":{\"notice\":\"Factories that clone a template contract MUST emit an event any time they set the implementation being cloned. Factories that deploy new contracts without cloning do NOT need to emit this.\"},\"NewChild(address,address)\":{\"notice\":\"Whenever a new child contract is deployed, a `NewChild` event containing the new child contract address MUST be emitted.\"}},\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"Build the reference implementation to clone for each child.\"},\"createChild(bytes)\":{\"notice\":\"Implements `IFactory`. Calls the `_createChild` hook that inheriting contracts must override. Registers child contract address such that `isChild` is `true`. Emits `NewChild` event.\"},\"createChildTyped((string,(bytes[],uint256[]),(address,address,(bytes[],uint256[])[])))\":{\"notice\":\"Allows calling `createChild` with `FlowERC1155Config` struct. Use original `Factory` `createChild` function signature if function parameters are already encoded.\"},\"implementation()\":{\"notice\":\"Template contract to clone. Deployed by the constructor.\"},\"isChild(address)\":{\"notice\":\"Implements `IFactory`. Checks if address is registered as a child contract of this factory.\"}},\"notice\":\"Factory for deploying and registering `FlowERC1155` contracts.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/flow/erc1155/FlowERC1155Factory.sol\":\"FlowERC1155Factory\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/interfaces/IERC1271Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271Upgradeable {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0x4473c09c087ee1a48c5547b23799c0474b2e08cde6fec5921c628171c4ebcdc0\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary ClonesUpgradeable {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0xc43e6a7d186cdbeb31f332a959fe6ea040937670251ec1740fd31c9c77c3977b\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0xe798cadb41e2da274913e4b3183a80f50fb057a42238fe8467e077268100ec27\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x2b3005a0064cfc558bdf64b2bae94b565f4574a536aadd61c13838d4f2157790\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/ERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155Upgradeable.sol\\\";\\nimport \\\"./IERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURIUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\\n    using AddressUpgradeable for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\\n        __ERC1155_init_unchained(uri_);\\n    }\\n\\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: address zero is not a valid owner\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not token owner or approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _balances[id][to] += amount;\\n        emit TransferSingle(operator, address(0), to, id, amount);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n        uint256[] memory ids = _asSingletonArray(id);\\n        uint256[] memory amounts = _asSingletonArray(amount);\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, from, address(0), id, amount);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\n\\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155ReceiverUpgradeable.onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non-ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[47] private __gap;\\n}\\n\",\"keccak256\":\"0x6de308cde403f95519bf4b25123cbfe9126f2e0212564bb2ad3c23ac99f1a9cb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xffcb29612efb57efc8f0d4897deb5abaeac830022c59a3aa17446d698dbc856b\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x091a49ef99a2be002680781a10cc9dd74c0f348301ede5482c4ea625f79a8ffe\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0xa350df12a8c10e821af05e0863f44e8317a0efa44df27bfd5dc1d63fdfa3c448\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {\\n    function __ERC1155Holder_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1155Holder_init_unchained() internal onlyInitializing {\\n    }\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xa8a1f16aa62b4d8c9e380057d9c3ee5c992e4a10dccc5650b26e38d4c61287d4\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\\n    function __ERC1155Receiver_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1155Receiver_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xa1b77d6d0f4591359c42b747a31375f20b0571b5e1fb62652d8184fb10f1d63a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4e733d3164f73f461eaf9d8087a7ad1ea180bdc8ba0d3d61b0e1ae16d8e63dff\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xcc70d8e2281fb3ff69e8ab242500f10142cd0a7fa8dd9e45882be270d4d09024\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/draft-IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x220c4a5af915e656be2aaa85ca57505d102418e476b1e2ef6c62e0c6ac143871\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xbb2ed8106d94aeae6858e2551a1e7174df73994b77b13ebd120ccaaef80155f5\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x2c0b89cef83f353c6f9488c013d8a5968587ffdd6dfc26aad53774214b97e229\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\\n    function __ERC721Holder_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC721Holder_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xb7f90ab8af7dae0bd4acfa088f9e606ea039110face097ca7c8beef563f71e90\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2edcb41c121abc510932e8d83ff8b82cf9cdde35e7c297622f5c29ef0af25183\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AddressUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract MulticallUpgradeable is Initializable {\\n    function __Multicall_init() internal onlyInitializing {\\n    }\\n\\n    function __Multicall_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract.\\n     */\\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = _functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return AddressUpgradeable.verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xb8709268fac307114f6cbb5e3cee798d91cd0adfea4d337c4920f8f0b2414f15\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/MathUpgradeable.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = MathUpgradeable.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\",\"keccak256\":\"0x6b9a5d35b744b25529a2856a8093e7c03fb35a34b1c4fb5499e560f8ade140da\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../StringsUpgradeable.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSAUpgradeable {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", StringsUpgradeable.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0x12f297cafe6e2847ae0378502f155654d0764b532a9873c8afe4350950fa7971\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/cryptography/SignatureCheckerUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSAUpgradeable.sol\\\";\\nimport \\\"../AddressUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IERC1271Upgradeable.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureCheckerUpgradeable {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (address recovered, ECDSAUpgradeable.RecoverError error) = ECDSAUpgradeable.tryRecover(hash, signature);\\n        if (error == ECDSAUpgradeable.RecoverError.NoError && recovered == signer) {\\n            return true;\\n        }\\n\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271Upgradeable.isValidSignature.selector, hash, signature)\\n        );\\n        return (success &&\\n            result.length == 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271Upgradeable.isValidSignature.selector));\\n    }\\n}\\n\",\"keccak256\":\"0x5f6f34a77bdf88981d8985a33ebdb727df972172df6bdbb2a1bd480ce0bd43cb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x9a3b990bd56d139df3e454a9edf1c64668530b5a77fc32eb063bc206f958274a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc6cef87559d0aeffdf0a99803de655938a7779ec0a3cd5d4383483ad85565a09\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc1bd5b53319c68f84e3becd75694d941e8f4be94049903232cd8bc7c535aaa5a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCastUpgradeable {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0xcef50f95b43b038aa40aed25b62fc45906c681a5c1d504a4fdcf3bc6330a8d4b\",\"license\":\"MIT\"},\"contracts/array/LibUint256Array.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// Thrown if a truncated length is longer than the array being truncated. It is\\n/// not possible to truncate something and increase its length as the memory\\n/// region after the array MAY be allocated for something else already.\\nerror OutOfBoundsTruncate(uint256 arrayLength, uint256 truncatedLength);\\n\\n/// @title Uint256Array\\n/// @notice Things we want to do carefully and efficiently with uint256 arrays\\n/// that Solidity doesn't give us native tools for.\\nlibrary LibUint256Array {\\n    using LibUint256Array for uint256[];\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ a single integer to build an array around.\\n    /// @return the newly allocated array including a_ as a single item.\\n    function arrayFrom(uint256 a_) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](1);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ the first integer to build an array around.\\n    /// @param b_ the second integer to build an array around.\\n    /// @return the newly allocated array including a_ and b_ as the only items.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](2);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ the first integer to build an array around.\\n    /// @param b_ the second integer to build an array around.\\n    /// @param c_ the third integer to build an array around.\\n    /// @return the newly allocated array including a_, b_ and c_ as the only\\n    /// items.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](3);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ the first integer to build an array around.\\n    /// @param b_ the second integer to build an array around.\\n    /// @param c_ the third integer to build an array around.\\n    /// @param d_ the fourth integer to build an array around.\\n    /// @return the newly allocated array including a_, b_, c_ and d_ as the only\\n    /// items.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](4);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n            mstore(add(array_, 0x80), d_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ the first integer to build an array around.\\n    /// @param b_ the second integer to build an array around.\\n    /// @param c_ the third integer to build an array around.\\n    /// @param d_ the fourth integer to build an array around.\\n    /// @param e_ the fifth integer to build an array around.\\n    /// @return the newly allocated array including a_, b_, c_, d_ and e_ as the\\n    /// only items.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_,\\n        uint256 e_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](5);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n            mstore(add(array_, 0x80), d_)\\n            mstore(add(array_, 0xA0), e_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ the first integer to build an array around.\\n    /// @param b_ the second integer to build an array around.\\n    /// @param c_ the third integer to build an array around.\\n    /// @param d_ the fourth integer to build an array around.\\n    /// @param e_ the fifth integer to build an array around.\\n    /// @param f_ the sixth integer to build an array around.\\n    /// @return the newly allocated array including a_, b_, c_, d_, e_ and f_ as\\n    /// the only items.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_,\\n        uint256 e_,\\n        uint256 f_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](6);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n            mstore(add(array_, 0x60), c_)\\n            mstore(add(array_, 0x80), d_)\\n            mstore(add(array_, 0xA0), e_)\\n            mstore(add(array_, 0xC0), f_)\\n        }\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ The head of the new array.\\n    /// @param tail_ The tail of the new array.\\n    /// @return The new array.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256[] memory tail_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](1);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n        }\\n        array_.extend(tail_);\\n        return array_;\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a_ The first item of the new array.\\n    /// @param b_ The second item of the new array.\\n    /// @param tail_ The tail of the new array.\\n    /// @return The new array.\\n    function arrayFrom(\\n        uint256 a_,\\n        uint256 b_,\\n        uint256[] memory tail_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_ = new uint256[](2);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(array_, 0x20), a_)\\n            mstore(add(array_, 0x40), b_)\\n        }\\n        array_.extend(tail_);\\n        return array_;\\n    }\\n\\n    /// 2-dimensional analogue of `arrayFrom`. Takes a 1-dimensional array and\\n    /// coerces it to a 2-dimensional matrix where the first and only item in the\\n    /// matrix is the 1-dimensional array.\\n    /// @param a_ The 1-dimensional array to coerce.\\n    /// @return The 2-dimensional matrix containing `a_`.\\n    function matrixFrom(\\n        uint256[] memory a_\\n    ) internal pure returns (uint256[][] memory) {\\n        uint256[][] memory matrix_ = new uint256[][](1);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(matrix_, 0x20), a_)\\n        }\\n        return matrix_;\\n    }\\n\\n    /// Solidity provides no way to change the length of in-memory arrays but\\n    /// it also does not deallocate memory ever. It is always safe to shrink an\\n    /// array that has already been allocated, with the caveat that the\\n    /// truncated items will effectively become inaccessible regions of memory.\\n    /// That is to say, we deliberately \\\"leak\\\" the truncated items, but that is\\n    /// no worse than Solidity's native behaviour of leaking everything always.\\n    /// The array is MUTATED in place so there is no return value and there is\\n    /// no new allocation or copying of data either.\\n    /// @param array_ The array to truncate.\\n    /// @param newLength_ The new length of the array after truncation.\\n    function truncate(\\n        uint256[] memory array_,\\n        uint256 newLength_\\n    ) internal pure {\\n        if (newLength_ > array_.length) {\\n            revert OutOfBoundsTruncate(array_.length, newLength_);\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(array_, newLength_)\\n        }\\n    }\\n\\n    /// Extends `base_` with `extend_` by allocating additional `extend_.length`\\n    /// uints onto `base_`. Reverts if some other memory has been allocated\\n    /// after `base_` already, in which case it is NOT safe to copy inline.\\n    /// If `base_` is large this MAY be significantly more efficient than\\n    /// allocating `base_.length + extend_.length` for an entirely new array and\\n    /// copying both `base_` and `extend_` into the new array one item at a\\n    /// time in Solidity.\\n    /// The Solidity compiler MAY rearrange sibling statements in a code block\\n    /// EVEN IF THE OPTIMIZER IS DISABLED such that it becomes unsafe to use\\n    /// `extend` for memory allocated in different code blocks. It is ONLY safe\\n    /// to `extend` arrays that were allocated in the same lexical scope and you\\n    /// WILL see subtle errors that revert transactions otherwise.\\n    /// i.e. the `new` keyword MUST appear in the same code block as `extend`.\\n    /// @param base_ The base integer array that will be extended by `extend_`.\\n    /// @param extend_ The integer array that extends `base_`.\\n    function extend(\\n        uint256[] memory base_,\\n        uint256[] memory extend_\\n    ) internal pure {\\n        uint256 freeMemoryPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            // Solidity stores free memory pointer at 0x40\\n            freeMemoryPointer_ := mload(0x40)\\n            let baseLength_ := mload(base_)\\n            let extendLength_ := mload(extend_)\\n\\n            // The freeMemoryPointer_ does NOT point to the end of `base_` so\\n            // it is NOT safe to copy `extend_` over the top of already\\n            // allocated memory. This happens whenever some memory is allocated\\n            // after `base_` is allocated but before `extend` is called.\\n            if gt(\\n                freeMemoryPointer_,\\n                add(base_, add(0x20, mul(0x20, baseLength_)))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            // Move the free memory pointer by the length of extend_, excluding\\n            // the length slot of extend as that will NOT be copied to `base_`.\\n            mstore(0x40, add(freeMemoryPointer_, mul(0x20, extendLength_)))\\n\\n            // Update the length of base to be the length of base+extend.\\n            mstore(base_, add(baseLength_, extendLength_))\\n        }\\n\\n        unsafeCopyValuesTo(extend_, freeMemoryPointer_);\\n    }\\n\\n    /// Copies `inputs_` to `outputCursor_` with NO attempt to check that this\\n    /// is safe to do so. The caller MUST ensure that there exists allocated\\n    /// memory at `outputCursor_` in which it is safe and appropriate to copy\\n    /// ALL `inputs_` to. Anything that was already written to memory at\\n    /// `[outputCursor_:outputCursor_+(inputs_.length * 32 bytes)]` will be\\n    /// overwritten. The length of `inputs_` is NOT copied to the output\\n    /// location, ONLY the `uint256` values of the `inputs_` array are copied.\\n    /// There is no return value as memory is modified directly.\\n    /// @param inputs_ The input array that will be copied from EXCLUDING the\\n    /// length at the start of the array in memory.\\n    /// @param outputCursor_ Location in memory that the values will be copied\\n    /// to linearly.\\n    function unsafeCopyValuesTo(\\n        uint256[] memory inputs_,\\n        uint256 outputCursor_\\n    ) internal pure {\\n        uint256 inputCursor_;\\n        assembly (\\\"memory-safe\\\") {\\n            inputCursor_ := add(inputs_, 0x20)\\n        }\\n        unsafeCopyValuesTo(inputCursor_, outputCursor_, inputs_.length);\\n    }\\n\\n    /// Copies `length_` 32 byte words from `inputCursor_` to a newly allocated\\n    /// uint256[] array with NO attempt to check that the inputs are sane.\\n    /// This function is safe in that the outputs are guaranteed to be copied\\n    /// to newly allocated memory so no existing data will be overwritten.\\n    /// This function is subtle in that the `inputCursor_` is NOT validated in\\n    /// any way so the caller MUST ensure it points to a sensible memory\\n    /// location to read (e.g. to exclude the length from input arrays etc.).\\n    /// @param inputCursor_ The start of the memory that will be copied to the\\n    /// newly allocated array.\\n    /// @param length_ Number of 32 byte words to copy starting at\\n    /// `inputCursor_` to the items of the newly allocated array.\\n    /// @return The newly allocated `uint256[]` array.\\n    function copyToNewUint256Array(\\n        uint256 inputCursor_,\\n        uint256 length_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory outputs_ = new uint256[](length_);\\n        uint256 outputCursor_;\\n        assembly (\\\"memory-safe\\\") {\\n            outputCursor_ := add(outputs_, 0x20)\\n        }\\n        unsafeCopyValuesTo(inputCursor_, outputCursor_, length_);\\n        return outputs_;\\n    }\\n\\n    /// Copies `length_` uint256 values starting from `inputsCursor_` to\\n    /// `outputCursor_` with NO attempt to check that this is safe to do so.\\n    /// The caller MUST ensure that there exists allocated memory at\\n    /// `outputCursor_` in which it is safe and appropriate to copy\\n    /// `length_ * 32` bytes to. Anything that was already written to memory at\\n    /// `[outputCursor_:outputCursor_+(length_ * 32 bytes)]` will be\\n    /// overwritten.\\n    /// There is no return value as memory is modified directly.\\n    /// @param inputCursor_ The starting position in memory that data will be\\n    /// copied from.\\n    /// @param outputCursor_ The starting position in memory that data will be\\n    /// copied to.\\n    /// @param length_ The number of 32 byte (i.e. `uint256`) values that will\\n    /// be copied.\\n    function unsafeCopyValuesTo(\\n        uint256 inputCursor_,\\n        uint256 outputCursor_,\\n        uint256 length_\\n    ) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n                let end_ := add(inputCursor_, mul(0x20, length_))\\n            } lt(inputCursor_, end_) {\\n                inputCursor_ := add(inputCursor_, 0x20)\\n                outputCursor_ := add(outputCursor_, 0x20)\\n            } {\\n                mstore(outputCursor_, mload(inputCursor_))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x118cb5bba9671ac311c8e196984e6213390334712f53dea901284fa4ba208b84\",\"license\":\"CAL\"},\"contracts/bytes/LibBytes.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// @title LibBytes\\n/// @notice Things we want to do carefully and efficiently with `bytes` in memory\\n/// that Solidity doesn't give us native tools for.\\nlibrary LibBytes {\\n    /// Copy an arbitrary number of bytes from one location in memory to another.\\n    /// As we can only read/write bytes in 32 byte chunks we first have to loop\\n    /// over 32 byte values to copy then handle any unaligned remaining data. The\\n    /// remaining data will be appropriately masked with the existing data in the\\n    /// final chunk so as to not write past the desired length. Note that the\\n    /// final unaligned write will be more gas intensive than the prior aligned\\n    /// writes. The writes are completely unsafe, the caller MUST ensure that\\n    /// sufficient memory is allocated and reading/writing the requested number\\n    /// of bytes from/to the requested locations WILL NOT corrupt memory in the\\n    /// opinion of solidity or other subsequent read/write operations.\\n    /// @param inputCursor_ The starting location in memory to read from.\\n    /// @param outputCursor_ The starting location in memory to write to.\\n    /// @param remaining_ The number of bytes to read/write.\\n    function unsafeCopyBytesTo(\\n        uint256 inputCursor_,\\n        uint256 outputCursor_,\\n        uint256 remaining_\\n    ) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n\\n            } iszero(lt(remaining_, 0x20)) {\\n                remaining_ := sub(remaining_, 0x20)\\n                inputCursor_ := add(inputCursor_, 0x20)\\n                outputCursor_ := add(outputCursor_, 0x20)\\n            } {\\n                mstore(outputCursor_, mload(inputCursor_))\\n            }\\n\\n            if gt(remaining_, 0) {\\n                let mask_ := shr(\\n                    mul(remaining_, 8),\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n                // preserve existing bytes\\n                mstore(\\n                    outputCursor_,\\n                    or(\\n                        // input\\n                        and(mload(inputCursor_), not(mask_)),\\n                        and(mload(outputCursor_), mask_)\\n                    )\\n                )\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x613125e88688bca7d52cc48447a70fd2a17b3a120ef41c7c61092b3b523aa121\",\"license\":\"CAL\"},\"contracts/factory/Factory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport {IFactory} from \\\"./IFactory.sol\\\";\\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\n/// Thrown when a new factory deployment creates a child that was already created\\n/// by a previous deployment. This should never happen without some kind of\\n/// precompute such as CREATE2 and is generally unsupported at this time.\\nerror DuplicateChild(address child);\\n\\n/// @title Factory\\n/// @notice Base contract for deploying and registering child contracts.\\nabstract contract Factory is IFactory, ReentrancyGuard {\\n    /// @dev state to track each deployed contract address. A `Factory` will\\n    /// never lie about deploying a child, unless `isChild` is overridden to do\\n    /// so.\\n    mapping(address => bool) private contracts;\\n\\n    constructor() {\\n        // Technically `ReentrancyGuard` is initializable but allowing it to be\\n        // initialized is a foot-gun as the status will be set to _NOT_ENTERED.\\n        // This would allow re-entrant behaviour upon initialization of the\\n        // `Factory` and is unnecessary as the reentrancy guard always restores\\n        // _NOT_ENTERED after every call anyway.\\n        _disableInitializers();\\n    }\\n\\n    /// Implements `IFactory`.\\n    ///\\n    /// `_createChild` hook must be overridden to actually create child\\n    /// contract.\\n    ///\\n    /// Implementers may want to overload this function with a typed equivalent\\n    /// to expose domain specific structs etc. to the compiled ABI consumed by\\n    /// tooling and other scripts. To minimise gas costs for deployment it is\\n    /// expected that the tooling will consume the typed ABI, then encode the\\n    /// arguments and pass them to this function directly.\\n    ///\\n    /// @param data_ ABI encoded data to pass to child contract constructor.\\n    function _createChild(\\n        bytes memory data_\\n    ) internal virtual returns (address);\\n\\n    /// Implements `IFactory`.\\n    ///\\n    /// Calls the `_createChild` hook that inheriting contracts must override.\\n    /// Registers child contract address such that `isChild` is `true`.\\n    /// Emits `NewChild` event.\\n    ///\\n    /// @param data_ Encoded data to pass down to child contract constructor.\\n    /// @return New child contract address.\\n    function createChild(\\n        bytes memory data_\\n    ) public virtual override nonReentrant returns (address) {\\n        // Create child contract using hook.\\n        address child_ = _createChild(data_);\\n\\n        // Ensure the child at this address has not previously been deployed.\\n        if (contracts[child_]) {\\n            revert DuplicateChild(child_);\\n        }\\n\\n        // Register child contract address to `contracts` mapping.\\n        contracts[child_] = true;\\n        // Emit `NewChild` event with child contract address.\\n        emit IFactory.NewChild(msg.sender, child_);\\n        return child_;\\n    }\\n\\n    /// Implements `IFactory`.\\n    ///\\n    /// Checks if address is registered as a child contract of this factory.\\n    ///\\n    /// @param maybeChild_ Address of child contract to look up.\\n    /// @return Returns `true` if address is a contract created by this\\n    /// contract factory, otherwise `false`.\\n    function isChild(\\n        address maybeChild_\\n    ) external view virtual override returns (bool) {\\n        return contracts[maybeChild_];\\n    }\\n}\\n\",\"keccak256\":\"0x873231476d939747b642536d09eabe42f20a0baaca1c49e820f17a999723149e\",\"license\":\"CAL\"},\"contracts/factory/IFactory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\ninterface IFactory {\\n    /// Whenever a new child contract is deployed, a `NewChild` event\\n    /// containing the new child contract address MUST be emitted.\\n    /// @param sender `msg.sender` that deployed the contract (factory).\\n    /// @param child address of the newly deployed child.\\n    event NewChild(address sender, address child);\\n\\n    /// Factories that clone a template contract MUST emit an event any time\\n    /// they set the implementation being cloned. Factories that deploy new\\n    /// contracts without cloning do NOT need to emit this.\\n    /// @param sender `msg.sender` that deployed the implementation (factory).\\n    /// @param implementation address of the implementation contract that will\\n    /// be used for future clones if relevant.\\n    event Implementation(address sender, address implementation);\\n\\n    /// Creates a new child contract.\\n    ///\\n    /// @param data_ Domain specific data for the child contract constructor.\\n    /// @return New child contract address.\\n    function createChild(bytes calldata data_) external returns (address);\\n\\n    /// Checks if address is registered as a child contract of this factory.\\n    ///\\n    /// Addresses that were not deployed by `createChild` MUST NOT return\\n    /// `true` from `isChild`. This is CRITICAL to the security guarantees for\\n    /// any contract implementing `IFactory`.\\n    ///\\n    /// @param maybeChild_ Address to check registration for.\\n    /// @return `true` if address was deployed by this contract factory,\\n    /// otherwise `false`.\\n    function isChild(address maybeChild_) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x3e9ca6613b0c19d98c4e19a7586d4109e498db2cf7d6e38e34fc2d2c0dbc32e2\",\"license\":\"CAL\"},\"contracts/flow/FlowCommon.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"./libraries/LibFlow.sol\\\";\\nimport \\\"../interpreter/deploy/IExpressionDeployerV1.sol\\\";\\nimport \\\"../interpreter/run/IInterpreterV1.sol\\\";\\nimport \\\"../interpreter/run/LibEncodedDispatch.sol\\\";\\nimport \\\"../interpreter/run/LibContext.sol\\\";\\nimport \\\"../interpreter/run/LibInterpreterState.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {MulticallUpgradeable as Multicall} from \\\"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\\\";\\nimport {ERC721HolderUpgradeable as ERC721Holder} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\\\";\\nimport {ERC1155HolderUpgradeable as ERC1155Holder} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\\\";\\n\\nuint256 constant FLAG_COLUMN_FLOW_ID = 0;\\nuint256 constant FLAG_ROW_FLOW_ID = 0;\\nuint256 constant FLAG_COLUMN_FLOW_TIME = 0;\\nuint256 constant FLAG_ROW_FLOW_TIME = 2;\\n\\nuint256 constant MIN_FLOW_SENTINELS = 4;\\n\\nSourceIndex constant FLOW_ENTRYPOINT = SourceIndex.wrap(0);\\nuint256 constant FLOW_MAX_OUTPUTS = type(uint16).max;\\n\\nstruct FlowCommonConfig {\\n    address expressionDeployer;\\n    address interpreter;\\n    StateConfig[] flows;\\n}\\n\\ncontract FlowCommon is ERC721Holder, ERC1155Holder, Multicall {\\n    using LibInterpreterState for InterpreterState;\\n    using LibStackPointer for StackPointer;\\n    using LibStackPointer for uint256[];\\n    using LibUint256Array for uint256;\\n    using LibUint256Array for uint256[];\\n\\n    IInterpreterV1 internal _interpreter;\\n\\n    /// flow expression pointer => is registered\\n    mapping(EncodedDispatch => uint256) internal _flows;\\n\\n    event FlowInitialized(\\n        address sender,\\n        address interpreter,\\n        EncodedDispatch dispatch\\n    );\\n\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function __FlowCommon_init(\\n        FlowCommonConfig memory config_,\\n        uint256 flowMinOutputs_\\n    ) internal onlyInitializing {\\n        __ERC721Holder_init();\\n        __ERC1155Holder_init();\\n        __Multicall_init();\\n        require(flowMinOutputs_ >= MIN_FLOW_SENTINELS, \\\"BAD MIN STACKS LENGTH\\\");\\n        _interpreter = IInterpreterV1(config_.interpreter);\\n        for (uint256 i_ = 0; i_ < config_.flows.length; i_++) {\\n            address expression_ = IExpressionDeployerV1(\\n                config_.expressionDeployer\\n            ).deployExpression(\\n                    config_.flows[i_],\\n                    LibUint256Array.arrayFrom(flowMinOutputs_)\\n                );\\n            EncodedDispatch dispatch_ = LibEncodedDispatch.encode(\\n                expression_,\\n                FLOW_ENTRYPOINT,\\n                FLOW_MAX_OUTPUTS\\n            );\\n            _flows[dispatch_] = 1;\\n            emit FlowInitialized(msg.sender, config_.interpreter, dispatch_);\\n        }\\n    }\\n\\n    modifier onlyRegisteredDispatch(EncodedDispatch dispatch_) {\\n        require(_flows[dispatch_] > 0, \\\"UNREGISTERED_FLOW\\\");\\n        _;\\n    }\\n\\n    function flowStack(\\n        EncodedDispatch dispatch_,\\n        uint256[] memory callerContext_,\\n        SignedContext[] memory signedContexts_\\n    )\\n        internal\\n        view\\n        onlyRegisteredDispatch(dispatch_)\\n        returns (StackPointer, StackPointer, uint256[] memory)\\n    {\\n        (uint256[] memory stack_, uint256[] memory stateChanges_) = _interpreter\\n            .eval(\\n                dispatch_,\\n                LibContext.build(\\n                    new uint256[][](0),\\n                    callerContext_,\\n                    signedContexts_\\n                )\\n            );\\n        return (\\n            stack_.asStackPointerUp(),\\n            stack_.asStackPointerAfter(),\\n            stateChanges_\\n        );\\n    }\\n\\n    receive() external payable virtual {}\\n}\\n\",\"keccak256\":\"0x9f0799da019c4b88d8e2088764202caf60102cbea2603843b35f2013039e6976\",\"license\":\"CAL\"},\"contracts/flow/erc1155/FlowERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"../../sentinel/LibSentinel.sol\\\";\\nimport \\\"../libraries/LibFlow.sol\\\";\\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"../FlowCommon.sol\\\";\\nimport {ERC1155Upgradeable as ERC1155} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\\\";\\nimport {ERC1155ReceiverUpgradeable as ERC1155Receiver} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"../../interpreter/run/LibEncodedDispatch.sol\\\";\\n\\nuint256 constant RAIN_FLOW_ERC1155_SENTINEL = uint256(\\n    keccak256(bytes(\\\"RAIN_FLOW_ERC1155_SENTINEL\\\")) | SENTINEL_HIGH_BITS\\n);\\n\\nstruct FlowERC1155Config {\\n    string uri;\\n    StateConfig stateConfig;\\n    FlowCommonConfig flowConfig;\\n}\\n\\nstruct ERC1155SupplyChange {\\n    address account;\\n    uint256 id;\\n    uint256 amount;\\n}\\n\\nstruct FlowERC1155IO {\\n    ERC1155SupplyChange[] mints;\\n    ERC1155SupplyChange[] burns;\\n    FlowTransfer flow;\\n}\\n\\nSourceIndex constant CAN_TRANSFER_ENTRYPOINT = SourceIndex.wrap(0);\\nuint256 constant CAN_TRANSFER_MIN_OUTPUTS = 1;\\nuint256 constant CAN_TRANSFER_MAX_OUTPUTS = 1;\\n\\nuint256 constant FLOW_ERC1155_MIN_OUTPUTS = MIN_FLOW_SENTINELS + 2;\\n\\ncontract FlowERC1155 is ReentrancyGuard, FlowCommon, ERC1155 {\\n    using LibStackPointer for StackPointer;\\n    using LibStackPointer for uint256[];\\n    using LibUint256Array for uint256;\\n    using LibUint256Array for uint256[];\\n\\n    event Initialize(address sender, FlowERC1155Config config);\\n\\n    EncodedDispatch internal _dispatch;\\n\\n    function initialize(\\n        FlowERC1155Config calldata config_\\n    ) external initializer {\\n        emit Initialize(msg.sender, config_);\\n        __ReentrancyGuard_init();\\n        __ERC1155_init(config_.uri);\\n        // Ignoring context scratch here as we never use it, all context is\\n        // provided unconditionally.\\n        address expression_ = IExpressionDeployerV1(\\n            config_.flowConfig.expressionDeployer\\n        ).deployExpression(\\n                config_.stateConfig,\\n                LibUint256Array.arrayFrom(CAN_TRANSFER_MIN_OUTPUTS)\\n            );\\n\\n        _dispatch = LibEncodedDispatch.encode(\\n            expression_,\\n            CAN_TRANSFER_ENTRYPOINT,\\n            CAN_TRANSFER_MAX_OUTPUTS\\n        );\\n        __FlowCommon_init(config_.flowConfig, FLOW_ERC1155_MIN_OUTPUTS);\\n    }\\n\\n    /// Needed here to fix Open Zeppelin implementing `supportsInterface` on\\n    /// multiple base contracts.\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(ERC1155, ERC1155Receiver) returns (bool) {\\n        return super.supportsInterface(interfaceId);\\n    }\\n\\n    /// @inheritdoc ERC1155\\n    function _afterTokenTransfer(\\n        address operator_,\\n        address from_,\\n        address to_,\\n        uint256[] memory ids_,\\n        uint256[] memory amounts_,\\n        bytes memory data_\\n    ) internal virtual override {\\n        unchecked {\\n            super._afterTokenTransfer(\\n                operator_,\\n                from_,\\n                to_,\\n                ids_,\\n                amounts_,\\n                data_\\n            );\\n            // Mint and burn access MUST be handled by flow.\\n            // CAN_TRANSFER will only restrict subsequent transfers.\\n            if (!(from_ == address(0) || to_ == address(0))) {\\n                IInterpreterV1 interpreter_ = _interpreter;\\n                EncodedDispatch dispatch_ = _dispatch;\\n\\n                for (uint256 i_ = 0; i_ < ids_.length; i_++) {\\n                    uint256[][] memory context_ = LibUint256Array\\n                        .arrayFrom(\\n                            uint(uint160(msg.sender)),\\n                            uint(uint160(operator_)),\\n                            uint256(uint160(from_)),\\n                            uint256(uint160(to_)),\\n                            ids_[i_],\\n                            amounts_[i_]\\n                        )\\n                        .matrixFrom();\\n                    (\\n                        uint256[] memory stack_,\\n                        uint256[] memory stateChanges_\\n                    ) = interpreter_.eval(dispatch_, context_);\\n                    require(\\n                        stack_.asStackPointerAfter().peek() > 0,\\n                        \\\"INVALID_TRANSFER\\\"\\n                    );\\n                    if (stateChanges_.length > 0) {\\n                        interpreter_.stateChanges(stateChanges_);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function _previewFlow(\\n        EncodedDispatch dispatch_,\\n        uint256[] memory callerContext_,\\n        SignedContext[] memory signedContexts_\\n    ) internal view returns (FlowERC1155IO memory, uint256[] memory) {\\n        uint256[] memory refs_;\\n        FlowERC1155IO memory flowIO_;\\n        (\\n            StackPointer stackBottom_,\\n            StackPointer stackTop_,\\n            uint256[] memory stateChanges_\\n        ) = flowStack(dispatch_, callerContext_, signedContexts_);\\n        (stackTop_, refs_) = stackTop_.consumeStructs(\\n            stackBottom_,\\n            RAIN_FLOW_ERC1155_SENTINEL,\\n            3\\n        );\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(flowIO_, refs_)\\n        }\\n        (stackTop_, refs_) = stackTop_.consumeStructs(\\n            stackBottom_,\\n            RAIN_FLOW_ERC1155_SENTINEL,\\n            3\\n        );\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(add(flowIO_, 0x20), refs_)\\n        }\\n        flowIO_.flow = LibFlow.stackToFlow(stackBottom_, stackTop_);\\n        return (flowIO_, stateChanges_);\\n    }\\n\\n    function _flow(\\n        EncodedDispatch dispatch_,\\n        uint256[] memory callerContext_,\\n        SignedContext[] memory signedContexts_\\n    ) internal virtual nonReentrant returns (FlowERC1155IO memory) {\\n        unchecked {\\n            (\\n                FlowERC1155IO memory flowIO_,\\n                uint256[] memory stateChanges_\\n            ) = _previewFlow(dispatch_, callerContext_, signedContexts_);\\n            for (uint256 i_ = 0; i_ < flowIO_.mints.length; i_++) {\\n                // @todo support data somehow.\\n                _mint(\\n                    flowIO_.mints[i_].account,\\n                    flowIO_.mints[i_].id,\\n                    flowIO_.mints[i_].amount,\\n                    \\\"\\\"\\n                );\\n            }\\n            for (uint256 i_ = 0; i_ < flowIO_.burns.length; i_++) {\\n                _burn(\\n                    flowIO_.burns[i_].account,\\n                    flowIO_.burns[i_].id,\\n                    flowIO_.burns[i_].amount\\n                );\\n            }\\n            LibFlow.flow(flowIO_.flow, _interpreter, stateChanges_);\\n            return flowIO_;\\n        }\\n    }\\n\\n    function previewFlow(\\n        EncodedDispatch dispatch_,\\n        uint256[] memory callerContext_,\\n        SignedContext[] memory signedContexts_\\n    ) external view virtual returns (FlowERC1155IO memory) {\\n        (FlowERC1155IO memory flowERC1155IO_, ) = _previewFlow(\\n            dispatch_,\\n            callerContext_,\\n            signedContexts_\\n        );\\n        return flowERC1155IO_;\\n    }\\n\\n    function flow(\\n        EncodedDispatch dispatch_,\\n        uint256[] memory callerContext_,\\n        SignedContext[] memory signedContexts_\\n    ) external payable virtual returns (FlowERC1155IO memory) {\\n        return _flow(dispatch_, callerContext_, signedContexts_);\\n    }\\n}\\n\",\"keccak256\":\"0x4dc9ae91fd3b4170a9383367fa8d03291d9ea99a646964258906ab3597673990\",\"license\":\"CAL\"},\"contracts/flow/erc1155/FlowERC1155Factory.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport {Factory} from \\\"../../factory/Factory.sol\\\";\\nimport {FlowERC1155, FlowERC1155Config} from \\\"./FlowERC1155.sol\\\";\\nimport {ClonesUpgradeable as Clones} from \\\"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\\\";\\n\\n/// @title EmissionsERC1155Factory\\n/// @notice Factory for deploying and registering `FlowERC1155` contracts.\\ncontract FlowERC1155Factory is Factory {\\n    /// Template contract to clone.\\n    /// Deployed by the constructor.\\n    address public immutable implementation;\\n\\n    /// Build the reference implementation to clone for each child.\\n    constructor() {\\n        address implementation_ = address(new FlowERC1155());\\n        emit Implementation(msg.sender, implementation_);\\n        implementation = implementation_;\\n    }\\n\\n    /// @inheritdoc Factory\\n    function _createChild(\\n        bytes memory data_\\n    ) internal virtual override returns (address) {\\n        FlowERC1155Config memory config_ = abi.decode(\\n            data_,\\n            (FlowERC1155Config)\\n        );\\n        address clone_ = Clones.clone(implementation);\\n        FlowERC1155(payable(clone_)).initialize(config_);\\n        return clone_;\\n    }\\n\\n    /// Allows calling `createChild` with `FlowERC1155Config` struct.\\n    /// Use original `Factory` `createChild` function signature if function\\n    /// parameters are already encoded.\\n    ///\\n    /// @param config_ `FlowERC1155` constructor configuration.\\n    /// @return New `FlowERC1155` child contract address.\\n    function createChildTyped(\\n        FlowERC1155Config memory config_\\n    ) external returns (FlowERC1155) {\\n        return FlowERC1155(payable(createChild(abi.encode(config_))));\\n    }\\n}\\n\",\"keccak256\":\"0x6e765630968e566aaf5cb52623e4402fa7df35d438860a230a47dde8434de9d6\",\"license\":\"CAL\"},\"contracts/flow/libraries/LibFlow.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../../interpreter/run/LibStackPointer.sol\\\";\\nimport {IERC20Upgradeable as IERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {SafeERC20Upgradeable as SafeERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport {IERC721Upgradeable as IERC721} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport {IERC1155Upgradeable as IERC1155} from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\";\\nimport {AddressUpgradeable as Address} from \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../sentinel/LibSentinel.sol\\\";\\nimport {SafeCastUpgradeable as SafeCast} from \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\\\";\\n\\n/// @dev We want a sentinel with the following properties:\\n/// - Won't collide with token amounts (| with very large number)\\n/// - Won't collide with token addresses\\n/// - Won't collide with common values like `type(uint256).max` and\\n///   `type(uint256).min`\\n/// - Won't collide with other sentinels from unrelated contexts\\nuint256 constant RAIN_FLOW_SENTINEL = uint256(\\n    keccak256(bytes(\\\"RAIN_FLOW_SENTINEL\\\")) | SENTINEL_HIGH_BITS\\n);\\n\\nstruct NativeTransfer {\\n    address from;\\n    address to;\\n    uint256 amount;\\n}\\n\\nstruct ERC20Transfer {\\n    address token;\\n    address from;\\n    address to;\\n    uint256 amount;\\n}\\n\\nstruct ERC721Transfer {\\n    address token;\\n    address from;\\n    address to;\\n    uint256 id;\\n}\\n\\nstruct ERC1155Transfer {\\n    address token;\\n    address from;\\n    address to;\\n    uint256 id;\\n    uint256 amount;\\n}\\n\\nstruct FlowTransfer {\\n    NativeTransfer[] native;\\n    ERC20Transfer[] erc20;\\n    ERC721Transfer[] erc721;\\n    ERC1155Transfer[] erc1155;\\n}\\n\\nlibrary LibFlow {\\n    using Address for address payable;\\n    using SafeERC20 for IERC20;\\n    using LibStackPointer for StackPointer;\\n    using SafeCast for uint256;\\n    using LibFlow for FlowTransfer;\\n    using LibUint256Array for uint256[];\\n\\n    function stackToFlow(\\n        StackPointer stackBottom_,\\n        StackPointer stackTop_\\n    ) internal pure returns (FlowTransfer memory) {\\n        unchecked {\\n            FlowTransfer memory transfer_;\\n            uint256[] memory refs_;\\n            // native\\n            (stackTop_, refs_) = stackTop_.consumeStructs(\\n                stackBottom_,\\n                RAIN_FLOW_SENTINEL,\\n                3\\n            );\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(transfer_, refs_)\\n            }\\n            // erc20\\n            (stackTop_, refs_) = stackTop_.consumeStructs(\\n                stackBottom_,\\n                RAIN_FLOW_SENTINEL,\\n                4\\n            );\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(add(transfer_, 0x20), refs_)\\n            }\\n            // erc721\\n            (stackTop_, refs_) = stackTop_.consumeStructs(\\n                stackBottom_,\\n                RAIN_FLOW_SENTINEL,\\n                4\\n            );\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(add(transfer_, 0x40), refs_)\\n            }\\n            // erc1155\\n            (stackTop_, refs_) = stackTop_.consumeStructs(\\n                stackBottom_,\\n                RAIN_FLOW_SENTINEL,\\n                5\\n            );\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(add(transfer_, 0x60), refs_)\\n            }\\n            return transfer_;\\n        }\\n    }\\n\\n    function flowNative(FlowTransfer memory flowTransfer_) internal {\\n        unchecked {\\n            uint256 youToMe_ = 0;\\n            uint256 meToYou_ = 0;\\n            NativeTransfer memory transfer_;\\n            for (uint256 i_ = 0; i_ < flowTransfer_.native.length; i_++) {\\n                transfer_ = flowTransfer_.native[i_];\\n                if (transfer_.from == msg.sender) {\\n                    require(\\n                        transfer_.to == address(this),\\n                        \\\"UNSUPPORTED_NATIVE_FLOW\\\"\\n                    );\\n                    youToMe_ += transfer_.amount;\\n                } else {\\n                    require(\\n                        transfer_.from == address(this),\\n                        \\\"UNSUPPORTED_NATIVE_FLOW\\\"\\n                    );\\n                    if (transfer_.to == msg.sender) {\\n                        meToYou_ += transfer_.amount;\\n                    } else {\\n                        payable(transfer_.to).sendValue(transfer_.amount);\\n                    }\\n                }\\n            }\\n\\n            if (youToMe_ > 0) {\\n                // This will overflow if the msg.value is less than youToMe_.\\n                // Will refund any excess incoming value.\\n                meToYou_ += msg.value - youToMe_;\\n            }\\n            if (meToYou_ > 0) {\\n                payable(msg.sender).sendValue(meToYou_);\\n            }\\n        }\\n    }\\n\\n    function flowERC20(FlowTransfer memory flowTransfer_) internal {\\n        unchecked {\\n            ERC20Transfer memory transfer_;\\n            for (uint256 i_ = 0; i_ < flowTransfer_.erc20.length; i_++) {\\n                transfer_ = flowTransfer_.erc20[i_];\\n                if (transfer_.from == msg.sender) {\\n                    IERC20(transfer_.token).safeTransferFrom(\\n                        msg.sender,\\n                        transfer_.to,\\n                        transfer_.amount\\n                    );\\n                } else if (transfer_.from == address(this)) {\\n                    IERC20(transfer_.token).safeTransfer(\\n                        transfer_.to,\\n                        transfer_.amount\\n                    );\\n                } else {\\n                    // We don't support `from` as anyone other than `you` or `me`\\n                    // as this would allow for all kinds of issues re: approvals.\\n                    revert(\\\"UNSUPPORTED_ERC20_FLOW\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function flowERC721(FlowTransfer memory flowTransfer_) internal {\\n        unchecked {\\n            ERC721Transfer memory transfer_;\\n            for (uint256 i_ = 0; i_ < flowTransfer_.erc721.length; i_++) {\\n                transfer_ = flowTransfer_.erc721[i_];\\n                require(\\n                    transfer_.from == msg.sender ||\\n                        transfer_.from == address(this),\\n                    \\\"UNSUPPORTED_ERC721_FLOW\\\"\\n                );\\n                IERC721(transfer_.token).safeTransferFrom(\\n                    transfer_.from,\\n                    transfer_.to,\\n                    transfer_.id\\n                );\\n            }\\n        }\\n    }\\n\\n    function flowERC1155(FlowTransfer memory flowTransfer_) internal {\\n        unchecked {\\n            ERC1155Transfer memory transfer_;\\n            for (uint256 i_ = 0; i_ < flowTransfer_.erc1155.length; i_++) {\\n                transfer_ = flowTransfer_.erc1155[i_];\\n                require(\\n                    transfer_.from == msg.sender ||\\n                        transfer_.from == address(this),\\n                    \\\"UNSUPPORTED_ERC1155_FLOW\\\"\\n                );\\n                // @todo safeBatchTransferFrom support.\\n                // @todo data support.\\n                IERC1155(transfer_.token).safeTransferFrom(\\n                    transfer_.from,\\n                    transfer_.to,\\n                    transfer_.id,\\n                    transfer_.amount,\\n                    \\\"\\\"\\n                );\\n            }\\n        }\\n    }\\n\\n    function flow(\\n        FlowTransfer memory flowTransfer_,\\n        IInterpreterV1 interpreter_,\\n        uint256[] memory stateChanges_\\n    ) internal {\\n        if (stateChanges_.length > 0) {\\n            interpreter_.stateChanges(stateChanges_);\\n        }\\n        flowTransfer_.flowNative();\\n        flowTransfer_.flowERC20();\\n        flowTransfer_.flowERC721();\\n        flowTransfer_.flowERC1155();\\n    }\\n}\\n\",\"keccak256\":\"0x209d2b27c7bcf64cb185d6a9240c2602b16b7a8bb35746e2f553e9a43aa12487\",\"license\":\"CAL\"},\"contracts/interpreter/deploy/IExpressionDeployerV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\n/// Config required to build a new `State`.\\n/// @param sources Sources verbatim. These sources MUST be provided in their\\n/// sequential/index opcode form as the deployment process will need to index\\n/// into BOTH the integrity check and the final runtime function pointers.\\n/// This will be emitted in an event for offchain processing to use the indexed\\n/// opcode sources. The first N sources are considered entrypoints and will be\\n/// integrity checked by the expression deployer against a starting stack height\\n/// of 0. Non-entrypoint sources MAY be provided for internal use such as the\\n/// `call` opcode but will NOT be integrity checked UNLESS entered by an opcode\\n/// in an entrypoint.\\n/// @param constants Constants verbatim. Constants are provided alongside sources\\n/// rather than inline as it allows us to avoid variable length opcodes and can\\n/// be more memory efficient if the same constant is referenced several times\\n/// from the sources.\\nstruct StateConfig {\\n    bytes[] sources;\\n    uint256[] constants;\\n}\\n\\n/// @title IExpressionDeployerV1\\n/// @notice Companion to `IInterpreterV1` responsible for onchain static code\\n/// analysis and deploying expressions. Each `IExpressionDeployerV1` is tightly\\n/// coupled at the bytecode level to some interpreter that it knows how to\\n/// analyse and deploy expressions for. The expression deployer can perform an\\n/// integrity check \\\"dry run\\\" of candidate source code for the intepreter. The\\n/// critical analysis/transformation includes:\\n///\\n/// - Enforcement of no out of bounds memory reads/writes\\n/// - Calculation of memory required to eval the stack with a single allocation\\n/// - Replacing index based opcodes with absolute interpreter function pointers\\n/// - Enforcement that all opcodes and operands used exist and are valid\\n///\\n/// This analysis is highly sensitive to the specific implementation and position\\n/// of all opcodes and function pointers as compiled into the interpreter. This\\n/// is what makes the coupling between an interpreter and expression deployer\\n/// so tight. Ideally all responsibilities would be handled by a single contract\\n/// but this introduces code size issues quickly by roughly doubling the compiled\\n/// logic of each opcode (half for the integrity check and half for evaluation).\\n///\\n/// Interpreters MUST assume that expression deployers are malicious and fail\\n/// gracefully if the integrity check is corrupt/bypassed and/or function\\n/// pointers are incorrect, etc. i.e. the interpreter MUST always return a stack\\n/// from `eval` in a read only way or error. I.e. it is the expression deployer's\\n/// responsibility to do everything it can to prevent undefined behaviour in the\\n/// interpreter, and the interpreter's responsibility to handle the expression\\n/// deployer completely failing to do so.\\ninterface IExpressionDeployerV1 {\\n    /// Expressions are expected to be deployed onchain as immutable contract\\n    /// code with a first class address like any other contract or account.\\n    /// Technically this is optional in the sense that all the tools required to\\n    /// eval some expression and define all its opcodes are available as libraries.\\n    ///\\n    /// In practise there are enough advantages to deploying the sources directly\\n    /// onchain as contract data and loading them from the interpreter at eval time:\\n    ///\\n    /// - Loading and storing binary data is gas efficient as immutable contract data\\n    /// - Expressions need to be immutable between their deploy time integrity check\\n    ///   and runtime evaluation\\n    /// - Passing the address of an expression through calldata to an interpreter is\\n    ///   cheaper than passing an entire expression through calldata\\n    /// - Conceptually a very simple approach, even if implementations like SSTORE2\\n    ///   are subtle under the hood\\n    ///\\n    /// The expression deployer MUST perform an integrity check of the source code\\n    /// before it puts the expression onchain at a known address. The integrity check\\n    /// MUST at a minimum (it is free to do additional static analysis) calculate the\\n    /// memory required to be allocated for the stack in total, and that no out of\\n    /// bounds memory reads/writes occur within this stack. A simple example of an\\n    /// invalid source would be one that pushes one value to the stack then attempts\\n    /// to pops two values, clearly we cannot remove more values than we added. The\\n    /// `IExpressionDeployerV1` MUST revert in the case of any integrity failure, all\\n    /// integrity checks MUST pass in order for the deployment to complete.\\n    ///\\n    /// Once the integrity check is complete the `IExpressionDeployerV1` MUST do any\\n    /// additional processing required by its paired interpreter. For example, the\\n    /// `IExpressionDeployerV1` MAY NEED to replace the indexed opcodes in the\\n    /// `StateConfig` sources with real function pointers from the corresponding\\n    /// interpreter.\\n    ///\\n    /// @param config All the state config associated with an expression.\\n    /// @param minOutputs The first N sources on the state config are entrypoints to\\n    /// the expression where N is the length of the `minOutputs` array. Each item in\\n    /// the `minOutputs` array specifies the number of outputs that MUST be present\\n    /// on the final stack for an evaluation of each entrypoint. The minimum output\\n    /// for some entrypoint MAY be zero if the expectation is that the expression\\n    /// only applies checks and error logic. Non-entrypoint sources MUST NOT have a\\n    /// minimum outputs length specified.\\n    /// @return expression The onchain address of the deployed expression.\\n    function deployExpression(\\n        StateConfig memory config,\\n        uint256[] memory minOutputs\\n    ) external returns (address expression);\\n}\\n\",\"keccak256\":\"0x90685338765adf8780a7ccc6990a2b2e312d595b37858e18319bf80e2e559f40\",\"license\":\"CAL\"},\"contracts/interpreter/deploy/LibIntegrityCheck.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../run/LibStackPointer.sol\\\";\\nimport {MathUpgradeable as Math} from \\\"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\\\";\\n\\nimport \\\"./IExpressionDeployerV1.sol\\\";\\nimport \\\"../run/IInterpreterV1.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @dev The virtual stack pointers are never read or written so don't need to\\n/// point to a real location in memory. We only care that the stack never moves\\n/// below its starting point at the stack bottom. For the virtual stack used by\\n/// the integrity check we can start it in the middle of the `uint256` range and\\n/// achieve something analogous to signed integers with unsigned integer types.\\nStackPointer constant INITIAL_STACK_BOTTOM = StackPointer.wrap(\\n    type(uint256).max / 2\\n);\\n\\n/// It is a misconfiguration to set the initial stack bottom to zero or some\\n/// small value as this trivially exposes the integrity check to potential\\n/// underflow issues that are gas intensive to repeatedly guard against on every\\n/// pop. The initial stack bottom for an `IntegrityCheckState` should be\\n/// `INITIAL_STACK_BOTTOM` to safely avoid the need for underflow checks due to\\n/// pops and pushes.\\nerror MinStackBottom();\\n\\n/// The virtual stack top has underflowed the stack highwater (or zero) during an\\n/// integrity check. The highwater will initially be the stack bottom but MAY\\n/// move higher due to certain operations such as placing multiple outputs on the\\n/// stack or copying from a stack position. The highwater prevents subsequent\\n/// popping of values that are considered immutable.\\n/// @param stackHighwaterIndex Index of the stack highwater at the moment of\\n/// underflow.\\n/// @param stackTopIndex Index of the stack top at the moment of underflow.\\nerror StackPopUnderflow(uint256 stackHighwaterIndex, uint256 stackTopIndex);\\n\\n/// The final stack produced by some source did not hit the minimum required for\\n/// its calling context.\\n/// @param minStackOutputs The required minimum stack height.\\n/// @param actualStackOutputs The final stack height after evaluating a source.\\n/// Will be less than the min stack outputs if this error is thrown.\\nerror MinFinalStack(uint256 minStackOutputs, uint256 actualStackOutputs);\\n\\n/// Running an integrity check is a stateful operation. As well as the basic\\n/// configuration of what is being checked such as the sources and size of the\\n/// constants, the current and maximum stack height is being recomputed on every\\n/// checked opcode. The stack is virtual during the integrity check so whatever\\n/// the `StackPointer` values are during the check, it's always undefined\\n/// behaviour to actually try to read/write to them.\\n///\\n/// @param sources All the sources of the expression are provided to the\\n/// integrity check as any entrypoint and non-entrypoint can `call` into some\\n/// other source at any time, provided the overall inputs and outputs to the\\n/// stack are valid.\\n/// @param constantsLength The integrity check assumes the existence of some\\n/// opcode that will read from a predefined list of constants. Technically this\\n/// opcode MAY NOT exist in some interpreter but it seems highly likely to be\\n/// included in most setups. The integrity check only needs the length of the\\n/// constants array to check for out of bounds reads, which allows runtime\\n/// behaviour to read without additional gas for OOB index checks.\\n/// @param stackBottom Pointer to the bottom of the virtual stack that the\\n/// integrity check uses to simulate a real eval.\\n/// @param stackMaxTop Pointer to the maximum height the virtual stack has\\n/// reached during the integrity check. The current virtual stack height will\\n/// be handled separately to the state during the check.\\n/// @param integrityFunctionPointers We pass an array of all the function\\n/// pointers to per-opcode integrity checks around with the state to facilitate\\n/// simple recursive integrity checking.\\nstruct IntegrityCheckState {\\n    // Sources in zeroth position as we read from it in assembly without paying\\n    // gas to calculate offsets.\\n    bytes[] sources;\\n    uint256 constantsLength;\\n    StackPointer stackBottom;\\n    StackPointer stackHighwater;\\n    StackPointer stackMaxTop;\\n    function(IntegrityCheckState memory, Operand, StackPointer)\\n        view\\n        returns (StackPointer)[] integrityFunctionPointers;\\n}\\n\\n/// @title LibIntegrityCheck\\n/// @notice \\\"Dry run\\\" versions of the key logic from `LibStackPointer` that\\n/// allows us to simulate a virtual stack based on the Solidity type system\\n/// itself. The core loop of an integrity check is to dispatch an integrity-only\\n/// version of a runtime opcode that then uses `LibIntegrityCheck` to apply a\\n/// function that simulates a stack movement. The simulated stack movement will\\n/// move a pointer to memory in the same way as a real pop/push would at runtime\\n/// but without any associated logic or even allocating and writing data in\\n/// memory on the other side of the pointer. Every pop is checked for out of\\n/// bounds reads, even if it is an intermediate pop within the logic of a single\\n/// opcode. The _gross_ stack movement is just as important as the net movement.\\n/// For example, consider a simple ERC20 total supply read. The _net_ movement\\n/// of a total supply read is 0, it pops the token address then pushes the total\\n/// supply. However the _gross_ movement is first -1 then +1, so we have to guard\\n/// against the -1 underflowing while reading the token address _during_ the\\n/// simulated opcode dispatch. In general this can be subtle, complex and error\\n/// prone, which is why `LibIntegrityCheck` and `LibStackPointer` take function\\n/// signatures as arguments, so that the overloading mechanism in Solidity itself\\n/// enforces correct pop/push calculations for every opcode.\\nlibrary LibIntegrityCheck {\\n    using LibIntegrityCheck for IntegrityCheckState;\\n    using LibStackPointer for StackPointer;\\n    using Math for uint256;\\n\\n    function newState(\\n        StateConfig memory config_,\\n        function(IntegrityCheckState memory, Operand, StackPointer)\\n            view\\n            returns (StackPointer)[]\\n            memory integrityFns_\\n    ) internal pure returns (IntegrityCheckState memory) {\\n        return\\n            IntegrityCheckState(\\n                config_.sources,\\n                config_.constants.length,\\n                INITIAL_STACK_BOTTOM,\\n                // Highwater starts underneath stack bottom as it errors on an\\n                // greater than _or equal to_ check.\\n                INITIAL_STACK_BOTTOM.down(),\\n                INITIAL_STACK_BOTTOM,\\n                integrityFns_\\n            );\\n    }\\n\\n    /// If the given stack pointer is above the current state of the max stack\\n    /// top, the max stack top will be moved to the stack pointer.\\n    /// i.e. this works like `stackMaxTop = stackMaxTop.max(stackPointer_)` but\\n    /// with the type unwrapping boilerplate included for convenience.\\n    /// @param integrityCheckState_ The state of the current integrity check\\n    /// including the current max stack top.\\n    /// @param stackPointer_ The stack pointer to compare and potentially swap\\n    /// the max stack top for.\\n    function syncStackMaxTop(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackPointer_\\n    ) internal pure {\\n        if (\\n            StackPointer.unwrap(stackPointer_) >\\n            StackPointer.unwrap(integrityCheckState_.stackMaxTop)\\n        ) {\\n            integrityCheckState_.stackMaxTop = stackPointer_;\\n        }\\n    }\\n\\n    /// The main integrity check loop. Designed so that it can be called\\n    /// recursively by the dispatched integrity opcodes to support arbitrary\\n    /// nesting of sources and substacks, loops, etc.\\n    /// If ANY of the integrity checks for ANY opcode fails the entire integrity\\n    /// check will revert.\\n    /// @param integrityCheckState_ Current state of the integrity check passed\\n    /// by reference to allow for recursive/nested integrity checking.\\n    /// @param sourceIndex_ The source to check the integrity of which can be\\n    /// either an entrypoint or a non-entrypoint source if this is a recursive\\n    /// call to `ensureIntegrity`.\\n    /// @param stackTop_ The current top of the virtual stack as a pointer. This\\n    /// can be manipulated to create effective substacks/scoped/immutable\\n    /// runtime values by restricting how the `stackTop_` can move at deploy\\n    /// time.\\n    /// @param minStackOutputs_ The minimum stack height required by the end of\\n    /// this integrity check. The caller MUST ensure that it sets this value high\\n    /// enough so that it can safely read enough values from the final stack\\n    /// without out of bounds reads. The external interface to the expression\\n    /// deployer accepts an array of minimum stack heights against entrypoints,\\n    /// but the internal checks can be recursive against non-entrypoints and each\\n    /// opcode such as `call` can build scoped stacks, etc. so here we just put\\n    /// defining the requirements back on the caller.\\n    function ensureIntegrity(\\n        IntegrityCheckState memory integrityCheckState_,\\n        SourceIndex sourceIndex_,\\n        StackPointer stackTop_,\\n        uint256 minStackOutputs_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            // It's generally more efficient to ensure the stack bottom has\\n            // plenty of headroom to make underflows from pops impossible rather\\n            // than guard every single pop against underflow.\\n            if (\\n                StackPointer.unwrap(integrityCheckState_.stackBottom) <\\n                StackPointer.unwrap(INITIAL_STACK_BOTTOM)\\n            ) {\\n                revert MinStackBottom();\\n            }\\n            uint256 cursor_;\\n            uint256 end_;\\n            assembly (\\\"memory-safe\\\") {\\n                cursor_ := mload(\\n                    add(\\n                        mload(integrityCheckState_),\\n                        add(0x20, mul(0x20, sourceIndex_))\\n                    )\\n                )\\n                end_ := add(cursor_, mload(cursor_))\\n            }\\n\\n            // Loop until complete.\\n            while (cursor_ < end_) {\\n                uint256 opcode_;\\n                Operand operand_;\\n                cursor_ += 4;\\n                assembly (\\\"memory-safe\\\") {\\n                    let op_ := mload(cursor_)\\n                    operand_ := and(op_, 0xFFFF)\\n                    opcode_ := and(shr(16, op_), 0xFFFF)\\n                }\\n                // We index into the function pointers here to ensure that any\\n                // opcodes that we don't have a pointer for will error.\\n                stackTop_ = integrityCheckState_.integrityFunctionPointers[\\n                    opcode_\\n                ](integrityCheckState_, operand_, stackTop_);\\n            }\\n            uint256 finalStackOutputs_ = integrityCheckState_\\n                .stackBottom\\n                .toIndex(stackTop_);\\n            if (minStackOutputs_ > finalStackOutputs_) {\\n                revert MinFinalStack(minStackOutputs_, finalStackOutputs_);\\n            }\\n            return stackTop_;\\n        }\\n    }\\n\\n    /// Push a single virtual item onto the virtual stack.\\n    /// Simply moves the stack top up one and syncs the interpreter max stack\\n    /// height with it if needed.\\n    /// @param integrityCheckState_ The state of the current integrity check.\\n    /// @param stackTop_ The pointer to the virtual stack top for the current\\n    /// integrity check.\\n    /// @return The stack top after it has pushed an item.\\n    function push(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_\\n    ) internal pure returns (StackPointer) {\\n        stackTop_ = stackTop_.up();\\n        integrityCheckState_.syncStackMaxTop(stackTop_);\\n        return stackTop_;\\n    }\\n\\n    /// Overloaded `push` to support `n_` pushes in a single movement.\\n    /// `n_` MAY be 0 and this is a virtual noop stack movement.\\n    /// @param integrityCheckState_ as per `push`.\\n    /// @param stackTop_ as per `push`.\\n    /// @param n_ The number of items to push to the virtual stack.\\n    function push(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        stackTop_ = stackTop_.up(n_);\\n        // Any time we push more than 1 item to the stack we move the highwater\\n        // _past_ it as nested multioutput is disallowed.\\n        if (\\n            n_ > 1 &&\\n            StackPointer.unwrap(stackTop_) >\\n            StackPointer.unwrap(integrityCheckState_.stackHighwater)\\n        ) {\\n            integrityCheckState_.stackHighwater = stackTop_;\\n        }\\n        integrityCheckState_.syncStackMaxTop(stackTop_);\\n        return stackTop_;\\n    }\\n\\n    /// As push for 0+ values. Does NOT move the highwater. This may be useful if\\n    /// the highwater is already calculated somehow by the caller.\\n    function pushIgnoreHighwater(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        stackTop_ = stackTop_.up(n_);\\n        integrityCheckState_.syncStackMaxTop(stackTop_);\\n        return stackTop_;\\n    }\\n\\n    /// Move the stock top down one item then check that it hasn't underflowed\\n    /// the stack bottom. If all virtual stack movements are defined in terms\\n    /// of pops and pushes this will enforce that the gross stack movements do\\n    /// not underflow, which would lead to out of bounds stack reads at runtime.\\n    /// @param integrityCheckState_ The state of the current integrity check.\\n    /// @param stackTop_ The virtual stack top before an item is popped.\\n    /// @return The virtual stack top after the pop.\\n    function pop(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        stackTop_ = stackTop_.down();\\n        integrityCheckState_.popUnderflowCheck(stackTop_);\\n        return stackTop_;\\n    }\\n\\n    /// Overloaded `pop` to support `n_` pops in a single movement.\\n    /// `n_` MAY be 0 and this is a virtual noop stack movement.\\n    /// @param integrityCheckState_ as per `pop`.\\n    /// @param stackTop_ as per `pop`.\\n    /// @param n_ The number of items to pop off the virtual stack.\\n    function pop(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        uint256 n_\\n    ) internal view returns (StackPointer) {\\n        console.log(\\\"pop\\\", n_, StackPointer.unwrap(stackTop_));\\n        if (n_ > 0) {\\n            stackTop_ = stackTop_.down(n_);\\n            integrityCheckState_.popUnderflowCheck(stackTop_);\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Ensures that pops have not underflowed the stack, i.e. that the stack\\n    /// top is not below the stack bottom. We set a large stack bottom that is\\n    /// impossible to underflow within gas limits with realistic pops so that\\n    /// we don't have to deal with a numeric underflow of the stack top.\\n    /// @param integrityCheckState_ As per `pop`.\\n    /// @param stackTop_ as per `pop`.\\n    function popUnderflowCheck(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_\\n    ) internal view {\\n        console.log(\\\"puc\\\", StackPointer.unwrap(stackTop_), StackPointer.unwrap(integrityCheckState_.stackHighwater));\\n        if (\\n            StackPointer.unwrap(stackTop_) <=\\n            StackPointer.unwrap(integrityCheckState_.stackHighwater)\\n        ) {\\n            revert StackPopUnderflow(\\n                integrityCheckState_.stackBottom.toIndex(\\n                    integrityCheckState_.stackHighwater\\n                ),\\n                integrityCheckState_.stackBottom.toIndex(stackTop_)\\n            );\\n        }\\n    }\\n\\n    /// Maps `function(uint256, uint256) internal view returns (uint256)` to pops\\n    /// and pushes repeatedly N times. The function itself is irrelevant we only\\n    /// care about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param n_ The number of times the function is applied to the stack.\\n    /// @return The stack top after the function has been applied n times.\\n    function applyFnN(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256) internal view returns (uint256),\\n        uint256 n_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, n_));\\n    }\\n\\n    /// Maps `function(uint256) internal view` to pops and pushes repeatedly N\\n    /// times. The function itself is irrelevant we only care about the\\n    /// signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param n_ The number of times the function is applied to the stack.\\n    /// @return The stack top after the function has been applied n times.\\n    function applyFnN(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256) internal view,\\n        uint256 n_\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.pop(stackTop_, n_);\\n    }\\n\\n    /// Maps `function(uint256) internal view returns (uint256)` to pops and\\n    /// pushes once. The function itself is irrelevant we only care about the\\n    /// signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256) internal view returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.push(integrityCheckState_.pop(stackTop_));\\n    }\\n\\n    /// Maps `function(uint256, uint256) internal view` to pops and pushes once.\\n    /// The function itself is irrelevant we only care about the signature to\\n    /// know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256) internal view\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.pop(stackTop_, 2);\\n    }\\n\\n    /// Maps `function(uint256, uint256) internal view returns (uint256)` to\\n    /// pops and pushes once. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256) internal view returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, 2));\\n    }\\n\\n    /// Maps\\n    /// `function(uint256, uint256, uint256) internal view returns (uint256)` to\\n    /// pops and pushes once. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256) internal view returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, 3));\\n    }\\n\\n    /// Maps\\n    /// ```\\n    /// function(uint256, uint256, uint256, uint256)\\n    ///     internal\\n    ///     view\\n    ///     returns (uint256)\\n    /// ```\\n    /// to pops and pushes once. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256, uint256)\\n            internal\\n            view\\n            returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, 4));\\n    }\\n\\n    /// Maps `function(uint256[] memory) internal view returns (uint256)` to\\n    /// pops and pushes once given that we know the length of the dynamic array\\n    /// at deploy time. The function itself is irrelevant we only care about the\\n    /// signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param length_ The length of the dynamic input array.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256[] memory) internal view returns (uint256),\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(\\n                integrityCheckState_.pop(stackTop_, length_)\\n            );\\n    }\\n\\n    /// Maps\\n    /// ```\\n    /// function(uint256, uint256, uint256[] memory)\\n    ///     internal\\n    ///     view\\n    ///     returns (uint256)\\n    /// ```\\n    /// to pops and pushes once given that we know the length of the dynamic\\n    /// array at deploy time. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param length_ The length of the dynamic input array.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256),\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            return\\n                integrityCheckState_.push(\\n                    integrityCheckState_.pop(stackTop_, length_ + 2)\\n                );\\n        }\\n    }\\n\\n    /// Maps\\n    /// ```\\n    /// function(uint256, uint256, uint256, uint256[] memory)\\n    ///     internal\\n    ///     view\\n    ///     returns (uint256)\\n    /// ```\\n    /// to pops and pushes once given that we know the length of the dynamic\\n    /// array at deploy time. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param length_ The length of the dynamic input array.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256),\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            return\\n                integrityCheckState_.push(\\n                    integrityCheckState_.pop(stackTop_, length_ + 3)\\n                );\\n        }\\n    }\\n\\n    /// Maps\\n    /// ```\\n    /// function(uint256, uint256[] memory, uint256[] memory)\\n    ///     internal\\n    ///     view\\n    ///     returns (uint256[] memory)\\n    /// ```\\n    /// to pops and pushes once given that we know the length of the dynamic\\n    /// array at deploy time. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @param length_ The length of the dynamic input array.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(uint256, uint256[] memory, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256[] memory),\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            return\\n                integrityCheckState_.push(\\n                    integrityCheckState_.pop(stackTop_, length_ * 2 + 1),\\n                    length_\\n                );\\n        }\\n    }\\n\\n    /// Maps `function(Operand, uint256) internal view returns (uint256)` to\\n    /// pops and pushes once. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    ///\\n    /// The operand MUST NOT influence the stack movements if this application\\n    /// is to be valid.\\n    ///\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(Operand, uint256) internal view returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return integrityCheckState_.push(integrityCheckState_.pop(stackTop_));\\n    }\\n\\n    /// Maps\\n    /// `function(Operand, uint256, uint256) internal view returns (uint256)` to\\n    /// pops and pushes once. The function itself is irrelevant we only care\\n    /// about the signature to know how many items are popped/pushed.\\n    ///\\n    /// The operand MUST NOT influence the stack movements if this application\\n    /// is to be valid.\\n    ///\\n    /// @param integrityCheckState_ as per `pop` and `push`.\\n    /// @param stackTop_ as per `pop` and `push`.\\n    /// @return The stack top after the function has been applied once.\\n    function applyFn(\\n        IntegrityCheckState memory integrityCheckState_,\\n        StackPointer stackTop_,\\n        function(Operand, uint256, uint256) internal view returns (uint256)\\n    ) internal view returns (StackPointer) {\\n        return\\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, 2));\\n    }\\n}\\n\",\"keccak256\":\"0x8f15d85e24237a4905e2a96def5b31d508950440f3da8bf18c8f4cc7c002f8b5\",\"license\":\"CAL\"},\"contracts/interpreter/run/IInterpreterV1.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.0;\\n\\n/// @dev The index of a source within a deployed expression that can be evaluated\\n/// by an `IInterpreterV1`. MAY be an entrypoint or the index of a source called\\n/// internally such as by the `call` opcode.\\ntype SourceIndex is uint256;\\n/// @dev Encoded information about a specific evaluation including the expression\\n/// address onchain, entrypoint and expected return values.\\ntype EncodedDispatch is uint256;\\n/// @dev The namespace for state changes as requested by the calling contract.\\n/// The interpreter MUST apply this namespace IN ADDITION to namespacing by\\n/// caller etc.\\ntype StateNamespace is uint256;\\n/// @dev Additional bytes that can be used to configure a single opcode dispatch.\\n/// Commonly used to specify the number of inputs to a variadic function such\\n/// as addition or multiplication.\\ntype Operand is uint256;\\n\\n/// @title IInterpreterV1\\n/// Interface into a standard interpreter that supports:\\n///\\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\\n///   to the evaluated logic\\n/// - handling subsequent state changes in bulk in response to evaluated logic\\n/// - namespacing state changes according to the caller's preferences to avoid\\n///   unwanted key collisions\\n/// - exposing its internal function pointers to support external precompilation\\n///   of logic for more gas efficient runtime evaluation by the interpreter\\n///\\n/// The interface is designed to be stable across many versions and\\n/// implementations of an interpreter, balancing minimalism with features\\n/// required for a general purpose onchain interpreted compute environment.\\n///\\n/// The security model of an interpreter is that it MUST be resilient to\\n/// malicious expressions even if they dispatch arbitrary internal function\\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\\n/// undefined behaviour or error during an eval, _provided that no state changes\\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\\n/// malicious expression can be negatively impacted by the result. In turn, the\\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\\n/// return values from any interpreter that it requests an expression from. And\\n/// so on and so forth up to the externally owned account (EOA) who signs the\\n/// transaction and agrees to a specific combination of contracts, expressions\\n/// and interpreters, who can presumably make an informed decision about which\\n/// ones to trust to get the job done.\\n///\\n/// The state changes for an interpreter are expected to be produces by an `eval`\\n/// and passed back to the interpreter as-is by the caller, after the caller has\\n/// had an opportunity to apply their own intermediate logic such as reentrancy\\n/// defenses against malicious interpreters. The interpreter is free to structure\\n/// the state changes however it wants but MUST guard against the calling\\n/// contract corrupting the changes between `eval` and `stateChanges`. For\\n/// example an interpreter could sandbox storage writes per-caller so that a\\n/// malicious caller can only damage their own state changes, while honest\\n/// callers respect, benefit from and are protected by the interpreter's state\\n/// change handling.\\n///\\n/// The two step eval-state model allows eval to be read-only which provides\\n/// security guarantees for the caller such as no stateful reentrancy, either\\n/// from the interpreter or some contract interface used by some word, while\\n/// still allowing for storage writes. As the storage writes happen on the\\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\\n/// need to trust the interpreter, which allows for permissionless selection of\\n/// interpreters by end users. Delegate call always implies an admin key on the\\n/// caller because the delegatee contract can write arbitrarily to the state of\\n/// the delegator, which severely limits the generality of contract composition.\\ninterface IInterpreterV1 {\\n    /// Exposes the function pointers as `uint16` values packed into a single\\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\\n    ///\\n    /// `IExpressionDeployerV1` contracts use these function pointers to\\n    /// \\\"compile\\\" the expression into something that an interpreter can dispatch\\n    /// directly without paying gas to lookup the same at runtime. As the\\n    /// validity of any integrity check and subsequent dispatch is highly\\n    /// sensitive to both the function pointers and overall bytecode of the\\n    /// interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\\n    /// against accidentally being deployed onchain paired against an unknown\\n    /// interpreter. It is very easy for an apparent compatible pairing to be\\n    /// subtly and critically incompatible due to addition/removal/reordering of\\n    /// opcodes and compiler optimisations on the interpreter bytecode.\\n    ///\\n    /// This MAY return different values during construction vs. all other times\\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\\n    /// on function pointers reported during contract construction.\\n    function functionPointers() external view returns (bytes memory);\\n\\n    /// The raison d'etre for an interpreter. Given some expression and per-call\\n    /// additional contextual data, produce a stack of results and a set of state\\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\\n    /// call to `stateChanges`.\\n    /// @param dispatch All the information required for the interpreter to load\\n    /// an expression, select an entrypoint and return the values expected by the\\n    /// caller. The interpreter MAY encode dispatches differently to\\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\\n    /// calling contracts that hardcode the encoding logic.\\n    /// @param context A 2-dimensional array of data that can be indexed into at\\n    /// runtime by the interpreter. The calling contract is responsible for\\n    /// ensuring the authenticity and completeness of context data. The\\n    /// interpreter MUST revert at runtime if an expression attempts to index\\n    /// into some context value that is not provided by the caller. This implies\\n    /// that context reads cannot be checked for out of bounds reads at deploy\\n    /// time, as the runtime context MAY be provided in a different shape to what\\n    /// the expression is expecting.\\n    function eval(\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    )\\n        external\\n        view\\n        returns (uint256[] memory stack, uint256[] memory stateChanges);\\n\\n    /// Applies state changes from a prior eval to the storage of the\\n    /// interpreter. The interpreter is responsible for ensuring that applying\\n    /// these state changes is safe from key collisions, both with any internal\\n    /// state the interpreter needs for itself and with calls to `stateChanges`\\n    /// from different `msg.sender` callers. I.e. it MUST NOT be possible for\\n    /// a caller to modify the state changes associated with some other caller.\\n    ///\\n    /// The interpreter defines the shape of its own state changes, which is\\n    /// opaque to the calling contract. For example, some interpreter may treat\\n    /// the list of state changes as a pairwise key/value set, and some other\\n    /// interpreter may treat it as a literal list to be stored as-is.\\n    ///\\n    /// The interpreter MUST assume the state changes have been corrupted by the\\n    /// calling contract due to bugs or malicious intent, and enforce state\\n    /// isolation between callers despite arbitrarily invalid state changes. The\\n    /// interpreter MUST revert if it can detect invalid state changes, such\\n    /// as a key/value list having an odd number of items, but this MAY NOT be\\n    /// possible if the corruption is undetectable.\\n    ///\\n    /// @param stateChanges The list of changes to apply to the interpreter's\\n    /// internal state.\\n    function stateChanges(uint256[] calldata stateChanges) external;\\n\\n    /// Same as `eval` but allowing the caller to specify a namespace under which\\n    /// the state changes will be applied. The interpeter MUST ensure that keys\\n    /// will never collide across namespaces, even if, for example:\\n    ///\\n    /// - The calling contract is malicious and attempts to craft a collision\\n    ///   with state changes from another contract\\n    /// - The expression is malicious and attempts to craft a collision with\\n    ///   other expressions evaluated by the same calling contract\\n    ///\\n    /// A malicious entity MAY have access to significant offchain resources to\\n    /// attempt to precompute key collisions through brute force. The collision\\n    /// resistance of namespaces should be comparable or equivalent to the\\n    /// collision resistance of the hashing algorithms employed by the blockchain\\n    /// itself, such as the design of `mapping` in Solidity that hashes each\\n    /// nested key to produce a collision resistant compound key.\\n    ///\\n    /// Calls to `eval` without a namespace are implied to be under namespace `0`\\n    /// so an interpreter MAY implement `eval` in terms of `evalWithNamespace` if\\n    /// this simplifies the implementation.\\n    ///\\n    /// @param namespace The namespace specified by the calling contract.\\n    /// @param dispatch As per `eval`.\\n    /// @param context As per `eval`.\\n    /// @return stack As per `eval`.\\n    /// @return stateChanges As per `eval`.\\n    function evalWithNamespace(\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    )\\n        external\\n        view\\n        returns (uint256[] memory stack, uint256[] memory stateChanges);\\n\\n    /// Same as `stateChanges` but following `evalWithNamespace`. The caller MUST\\n    /// use the same namespace for both `evalWithNamespace` and\\n    /// `stateChangesWithNamespace` for a given expression evaluation.\\n    /// @param namespace As per `evalWithNamespace`.\\n    /// @param stateChanges as per `stateChanges`.\\n    function stateChangesWithNamespace(\\n        StateNamespace namespace,\\n        uint256[] calldata stateChanges\\n    ) external;\\n}\\n\",\"keccak256\":\"0x143cef02a6d24775f36fea669df20262836082fbcfc23282378d07e6b5862062\",\"license\":\"CAL\"},\"contracts/interpreter/run/LibContext.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"../../array/LibUint256Array.sol\\\";\\n\\nimport {SignatureCheckerUpgradeable as SignatureChecker} from \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/SignatureCheckerUpgradeable.sol\\\";\\nimport {ECDSAUpgradeable as ECDSA} from \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\\\";\\n\\n/// Thrown when the ith signature from a list of signed contexts is invalid.\\nerror InvalidSignature(uint256 i);\\n\\n/// Typed embodiment of some context data with associated signer and signature.\\n/// The signature MUST be over the packed encoded bytes of the context array,\\n/// i.e. the context array concatenated as bytes without the length prefix, then\\n/// hashed, then handled as per EIP-191 to produce a final hash to be signed.\\n///\\n/// The calling contract (likely with the help of `LibContext`) is responsible\\n/// for ensuring the authenticity of the signature, but not authorizing _who_ can\\n/// sign. IN ADDITION to authorisation of the signer to known-good entities the\\n/// expression is also responsible for:\\n///\\n/// - Enforcing the context is the expected data (e.g. with a domain separator)\\n/// - Tracking and enforcing nonces if signed contexts are only usable one time\\n/// - Tracking and enforcing uniqueness of signed data if relevant\\n/// - Checking and enforcing expiry times if present and relevant in the context\\n/// - Many other potential constraints that expressions may want to enforce\\n///\\n/// EIP-1271 smart contract signatures are supported in addition to EOA\\n/// signatures via. the Open Zeppelin `SignatureChecker` library, which is\\n/// wrapped by `LibContext.build`. As smart contract signatures are checked\\n/// onchain they CAN BE REVOKED AT ANY MOMENT as the smart contract can simply\\n/// return `false` when it previously returned `true`.\\n///\\n/// @param signer The account that produced the signature for `context`. The\\n/// calling contract MUST authenticate that the signer produced the signature.\\n/// @param signature The cryptographic signature for `context`. The calling\\n/// contract MUST authenticate that the signature is valid for the `signer` and\\n/// `context`.\\n/// @param context The signed data in a format that can be merged into a\\n/// 2-dimensional context matrix as-is.\\nstruct SignedContext {\\n    address signer;\\n    bytes signature;\\n    uint256[] context;\\n}\\n\\n/// @title LibContext\\n/// @notice Conventions for working with context as a calling contract. All of\\n/// this functionality is OPTIONAL but probably useful for the majority of use\\n/// cases. By building and authenticating onchain, caller provided and signed\\n/// contexts all in a standard way the overall usability of context is greatly\\n/// improved for expression authors and readers. Any calling contract that can\\n/// match the context expectations of an existing expression is one large step\\n/// closer to compatibility and portability, inheriting network effects of what\\n/// has already been authored elsewhere.\\nlibrary LibContext {\\n    using LibUint256Array for uint256[];\\n\\n    /// The base context is the `msg.sender` and address of the calling contract.\\n    /// As the interpreter itself is called via an external interface and may be\\n    /// statically calling itself, it MAY NOT have any ability to inspect either\\n    /// of these values. Even if this were not the case the calling contract\\n    /// cannot assume the existence of some opcode(s) in the interpreter that\\n    /// inspect the caller, so providing these two values as context is\\n    /// sufficient to decouple the calling contract from the interpreter. It is\\n    /// STRONGLY RECOMMENDED that even if the calling contract has \\\"no context\\\"\\n    /// that it still provides this base to every `eval`.\\n    ///\\n    /// Calling contracts DO NOT need to call this directly. It is built and\\n    /// merged automatically into the standard context built by `build`.\\n    ///\\n    /// @return The `msg.sender` and address of the calling contract using this\\n    /// library, as a context-compatible array.\\n    function base() internal view returns (uint256[] memory) {\\n        return\\n            LibUint256Array.arrayFrom(\\n                uint(uint160(msg.sender)),\\n                uint(uint160(address(this)))\\n            );\\n    }\\n\\n    /// Standard hashing process over a list of signed contexts. Situationally\\n    /// useful if the calling contract wants to record that it has seen a set of\\n    /// signed data then later compare it against some input (e.g. to ensure that\\n    /// many calls of some function all share the same input values). Note that\\n    /// unlike the internals of `build`, this hashes over the signer and the\\n    /// signature, to ensure that some data cannot be re-signed and used under\\n    /// a different provenance later.\\n    /// @param signedContexts_ The list of signed contexts to hash over.\\n    /// @return The hash of the signed contexts.\\n    function hash(\\n        SignedContext[] memory signedContexts_\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(signedContexts_));\\n    }\\n\\n    /// Builds a standard 2-dimensional context array from base, calling and\\n    /// signed contexts. Note that \\\"columns\\\" of a context array refer to each\\n    /// `uint256[]` and each item within a `uint256[]` is a \\\"row\\\".\\n    ///\\n    /// @param baseContext_ Anything the calling contract can provide without\\n    /// input from the `msg.sender`. More strictly the `msg.sender` MUST NOT be\\n    /// able to directly modify any of these values, although the values MAY be\\n    /// derived from user activity broadly, such as current vault balances after\\n    /// a series of deposits and withdrawals. The default base context from\\n    /// `LibContext.base()` DOES NOT need to be provided by the caller, this\\n    /// matrix MAY be empty and will be simply merged into the final context. The\\n    /// base context matrix MUST contain a consistent number of columns from the\\n    /// calling contract so that the expression can always predict how many\\n    /// columns there will be when it runs.\\n    /// @param callingContext_ Calling context is provided by the `msg.sender`\\n    /// and so should be treated as self-signed data. As an attestation/proof of\\n    /// some external event or state it is highly suspect, but as an indicator\\n    /// of the intent of `msg.sender` it may be treated as gospel. Calling\\n    /// context MAY be empty but a zero length column will still be reserved in\\n    /// the final built context. This ensures that expressions can always\\n    /// predict how many columns there will be when they run.\\n    /// @param signedContexts_ Signed contexts are provided by the `msg.sender`\\n    /// but signed by a third party. The expression (author) defines _who_ may\\n    /// sign and the calling contract authenticates the signature over the\\n    /// signed data. Technically `build` handles all the authentication inline\\n    /// for the calling contract so if some context builds it can be treated as\\n    /// authentic. The builder WILL REVERT if any of the signatures are invalid.\\n    /// Note two things about the structure of the final built context re: signed\\n    /// contexts:\\n    /// - The first column is a list of the signers in order of what they signed\\n    /// - The `msg.sender` can provide an arbitrary number of signed contexts so\\n    ///   expressions DO NOT know exactly how many columns there are.\\n    /// The expression is responsible for defining e.g. a domain separator in a\\n    /// position that would force signed context to be provided in the \\\"correct\\\"\\n    /// order, rather than relying on the `msg.sender` to honestly present data\\n    /// in any particular structure/order.\\n    function build(\\n        uint256[][] memory baseContext_,\\n        uint256[] memory callingContext_,\\n        SignedContext[] memory signedContexts_\\n    ) internal view returns (uint256[][] memory) {\\n        unchecked {\\n            uint256[] memory signers_ = new uint256[](signedContexts_.length);\\n\\n            // - LibContext.base() + whatever we are provided.\\n            // - calling context always even if empty\\n            // - signed contexts + signers if they exist else nothing.\\n            uint256 contextLength_ = 1 +\\n                baseContext_.length +\\n                1 +\\n                (signedContexts_.length > 0 ? signedContexts_.length + 1 : 0);\\n\\n            uint256[][] memory context_ = new uint256[][](contextLength_);\\n            uint256 offset_ = 0;\\n            context_[offset_] = LibContext.base();\\n\\n            for (uint256 i_ = 0; i_ < baseContext_.length; i_++) {\\n                offset_++;\\n                context_[offset_] = baseContext_[i_];\\n            }\\n\\n            // Calling context is added unconditionally so that a 0 length array\\n            // is simply an empty column. We don't want callers to be able to\\n            // manipulate the overall structure of context columns that the\\n            // expression indexes into.\\n            offset_++;\\n            context_[offset_] = callingContext_;\\n\\n            if (signedContexts_.length > 0) {\\n                offset_++;\\n                context_[offset_] = signers_;\\n\\n                for (uint256 i_ = 0; i_ < signedContexts_.length; i_++) {\\n                    if (\\n                        !SignatureChecker.isValidSignatureNow(\\n                            signedContexts_[i_].signer,\\n                            ECDSA.toEthSignedMessageHash(\\n                                // Unlike `LibContext.hash` we can only hash over\\n                                // the context as it's impossible for a signature\\n                                // to sign itself.\\n                                keccak256(\\n                                    abi.encodePacked(\\n                                        signedContexts_[i_].context\\n                                    )\\n                                )\\n                            ),\\n                            signedContexts_[i_].signature\\n                        )\\n                    ) {\\n                        revert InvalidSignature(i_);\\n                    }\\n\\n                    signers_[i_] = uint256(uint160(signedContexts_[i_].signer));\\n                    offset_++;\\n                    context_[offset_] = signedContexts_[i_].context;\\n                }\\n            }\\n\\n            return context_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6461a0131c22f4ca5220eaebe25b3889e16a84962a23e9d8418e40fb3b480111\",\"license\":\"CAL\"},\"contracts/interpreter/run/LibEncodedDispatch.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.17;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// @title LibEncodedDispatch\\n/// @notice Establishes and implements a convention for encoding an interpreter\\n/// dispatch. Handles encoding of several things required for efficient dispatch.\\nlibrary LibEncodedDispatch {\\n    /// Builds an `EncodedDispatch` from its constituent parts.\\n    /// @param expression_ The onchain address of the expression to run.\\n    /// @param sourceIndex_ The index of the source to run within the expression\\n    /// as an entrypoint.\\n    /// @param maxOutputs_ The maximum outputs the caller can meaningfully use.\\n    /// If the interpreter returns a larger stack than this it is merely wasting\\n    /// gas across the external call boundary.\\n    /// @return The encoded dispatch.\\n    function encode(\\n        address expression_,\\n        SourceIndex sourceIndex_,\\n        uint256 maxOutputs_\\n    ) internal pure returns (EncodedDispatch) {\\n        return\\n            EncodedDispatch.wrap(\\n                (uint256(uint160(expression_)) << 32) |\\n                    (SourceIndex.unwrap(sourceIndex_) << 16) |\\n                    maxOutputs_\\n            );\\n    }\\n\\n    /// Decodes an `EncodedDispatch` to its constituent parts.\\n    /// @param dispatch_ The `EncodedDispatch` to decode.\\n    /// @return The expression, source index, and max outputs as per `encode`.\\n    function decode(\\n        EncodedDispatch dispatch_\\n    ) internal pure returns (address, SourceIndex, uint256) {\\n        return (\\n            address(uint160(EncodedDispatch.unwrap(dispatch_) >> 32)),\\n            SourceIndex.wrap((EncodedDispatch.unwrap(dispatch_) >> 16) & 0xFF),\\n            EncodedDispatch.unwrap(dispatch_) & 0xFF\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xb3b870af36f1fe88ec0a0cd63f5d6e245a7107aa0fd070d2fb4afb613ca0878b\",\"license\":\"CAL\"},\"contracts/interpreter/run/LibInterpreterState.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../run/IInterpreterV1.sol\\\";\\nimport \\\"../deploy/IExpressionDeployerV1.sol\\\";\\nimport \\\"./LibStackPointer.sol\\\";\\nimport \\\"../../type/LibCast.sol\\\";\\nimport \\\"../../type/LibConvert.sol\\\";\\nimport \\\"../../array/LibUint256Array.sol\\\";\\nimport \\\"../../memory/LibMemorySize.sol\\\";\\nimport {SafeCastUpgradeable as SafeCast} from \\\"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\\\";\\nimport \\\"../../kv/LibMemoryKV.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// Debugging options for a standard console log over the interpreter state.\\n/// - Stack: Log the entire stack, respects the current stack top, i.e. DOES NOT\\n///   log every value of the underlying `uint256[]` unless the stack top points\\n///   to the end of the array.\\n/// - Constant: Log every constant available to the current expression.\\n/// - Context: Log every column/row of context available to the current eval.\\n/// - Source: Log all the raw bytes of the compiled sources being evaluated.\\nenum DebugStyle {\\n    Stack,\\n    Constant,\\n    Context,\\n    Source\\n}\\n\\n/// A fully qualified namespace includes the interpreter's own namespacing logic\\n/// IN ADDITION to the calling contract's requested `StateNamespace`. Typically\\n/// this involves hashing the `msg.sender` into the `StateNamespace` so that each\\n/// caller operates within its own disjoint state universe. Intepreters MUST NOT\\n/// allow either the caller nor any expression/word to modify this directly on\\n/// pain of potential key collisions on writes to the interpreter's own storage.\\ntype FullyQualifiedNamespace is uint256;\\n\\n/// The standard in-memory representation of an interpreter that facilitates\\n/// decoupled coordination between opcodes. Opcodes MAY:\\n///\\n/// - push and pop values to the shared stack\\n/// - read per-expression constants\\n/// - write to the final state changes set within the fully qualified namespace\\n/// - read per-eval context values\\n/// - recursively evaluate any compiled source associated with the expression\\n///\\n/// As the interpreter defines the opcodes it is its responsibility to ensure the\\n/// opcodes are incapable of doing anything to undermine security or correctness.\\n/// For example, a hypothetical opcode could modify the current namespace from\\n/// the stack, but this would be a very bad idea as it would allow expressions\\n/// to hijack storage values associated with other callers, fundamentally\\n/// breaking the state sandbox model.\\n///\\n/// The iterpreter MAY skip any runtime integrity checks that can be reasonably\\n/// assumed to have been performed by a competent expression deployer, such as\\n/// guarding against stack underflow. A competent expression deployer MAY NOT\\n/// have deployed the currently evaluating expression, so the interpreter MUST\\n/// avoid state changes during evaluation, but MAY return garbage data if the\\n/// calling contract fails to leverage an appropriate expression deployer.\\n///\\n/// @param stackBottom Opcodes write to the stack starting at the stack bottom,\\n/// ideally using `LibStackPointer` to normalise push and pop behaviours. A\\n/// competent expression deployer will calculate a memory preallocation that\\n/// pushes and pops above the stack bottom effectively allocate and deallocate\\n/// memory within.\\n/// @param constantsBottom Opcodes read constants starting at the pointer to\\n/// the bottom of the constants array. As the name implies the interpreter MUST\\n/// NOT write to the constants, it is read only.\\n/// @param stateKV The in memory key/value store that tracks reads/writes over\\n/// the underlying interpreter storage for the duration of a single expression\\n/// evaluation.\\n/// @param namespace The fully qualified namespace that all state reads and\\n/// writes MUST be performed under.\\n/// @param context A 2-dimensional array of per-eval data provided by the calling\\n/// contract. Opaque to the interpreter but presumably meaningful to the\\n/// expression.\\n/// @param compiledSources A list of sources that can be directly evaluated by\\n/// the interpreter, either as a top level entrypoint or nested e.g. under a\\n/// dispatch by `call`.\\nstruct InterpreterState {\\n    StackPointer stackBottom;\\n    StackPointer constantsBottom;\\n    MemoryKV stateKV;\\n    FullyQualifiedNamespace namespace;\\n    uint256[][] context;\\n    bytes[] compiledSources;\\n}\\n\\n/// @dev squiggly lines to make the debug output easier to read. Intentionlly\\n/// short to keep compiled code size down.\\nstring constant DEBUG_DELIMETER = \\\"~~~\\\";\\n\\n/// @title LibInterpreterState\\n/// @notice Main workhorse for `InterpeterState` including:\\n///\\n/// - the standard `eval` loop\\n/// - source compilation from opcodes\\n/// - state (de)serialization (more gas efficient than abi encoding)\\n/// - low level debugging utility\\n///\\n/// Interpreters are designed to be highly moddable behind the `IInterpreterV1`\\n/// interface, but pretty much any interpreter that uses `InterpreterState` will\\n/// need these low level facilities verbatim. Further, these facilities\\n/// (with possible exception of debugging logic), while relatively short in terms\\n/// of lines of code, are surprisingly fragile to maintain in a gas efficient way\\n/// so we don't recommend reinventing this wheel.\\nlibrary LibInterpreterState {\\n    using SafeCast for uint256;\\n    using LibMemorySize for uint256;\\n    using LibMemorySize for uint256[];\\n    using LibMemorySize for bytes;\\n    using LibUint256Array for uint256[];\\n    using LibUint256Array for uint256;\\n    using LibInterpreterState for StackPointer;\\n    using LibStackPointer for uint256[];\\n    using LibStackPointer for StackPointer;\\n    using LibStackPointer for bytes;\\n    using LibCast for uint256;\\n    using LibCast for function(\\n        InterpreterState memory,\\n        SourceIndex,\\n        StackPointer\\n    ) view returns (StackPointer);\\n    using LibCast for function(InterpreterState memory, Operand, StackPointer)\\n        view\\n        returns (StackPointer)[];\\n    using LibConvert for uint256[];\\n\\n    /// Thin wrapper around hardhat's `console.log` that loops over any array\\n    /// and logs each value delimited by `DEBUG_DELIMITER`.\\n    /// @param array_ The array to debug.\\n    function debugArray(uint256[] memory array_) internal view {\\n        console.log(DEBUG_DELIMETER);\\n        for (uint256 i_ = 0; i_ < array_.length; i_++) {\\n            console.log(i_, array_[i_]);\\n        }\\n        console.log(DEBUG_DELIMETER);\\n    }\\n\\n    /// Copies the stack to a new array then debugs it. Definitely NOT gas\\n    /// efficient, but affords simple and effective debugging.\\n    /// @param stackBottom_ Pointer to the bottom of the stack.\\n    /// @param stackTop_ Pointer to the top of the stack.\\n    function debugStack(\\n        StackPointer stackBottom_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        uint256 length_ = stackBottom_.toIndex(stackTop_);\\n        debugArray(\\n            StackPointer.unwrap(stackTop_.down(length_)).copyToNewUint256Array(\\n                length_\\n            )\\n        );\\n        return stackTop_;\\n    }\\n\\n    /// Console log various aspects of the Interpreter state. Gas intensive and\\n    /// relies on hardhat console so not intended for production but great for\\n    /// debugging expressions. MAY be exposed as an opcode so expression authors\\n    /// can debug the expressions directly onchain.\\n    /// @param state_ The interpreter state to debug the internals of.\\n    /// @param stackTop_ Pointer to the current stack top.\\n    /// @param debugStyle_ Enum variant defining what should be debugged from the\\n    /// interpreter state.\\n    function debug(\\n        InterpreterState memory state_,\\n        StackPointer stackTop_,\\n        DebugStyle debugStyle_\\n    ) internal view returns (StackPointer) {\\n        if (debugStyle_ == DebugStyle.Source) {\\n            for (uint256 i_ = 0; i_ < state_.compiledSources.length; i_++) {\\n                console.logBytes(state_.compiledSources[i_]);\\n            }\\n        } else {\\n            if (debugStyle_ == DebugStyle.Stack) {\\n                state_.stackBottom.debugStack(stackTop_);\\n            } else if (debugStyle_ == DebugStyle.Constant) {\\n                debugArray(state_.constantsBottom.down().asUint256Array());\\n            } else {\\n                for (uint256 i_ = 0; i_ < state_.context.length; i_++) {\\n                    debugArray(state_.context[i_]);\\n                }\\n            }\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Efficiently serializes some `IInterpreterV1` state config into bytes that\\n    /// can be deserialized to an `InterpreterState` without memory allocation or\\n    /// copying of data on the return trip. This is achieved by mutating data in\\n    /// place for both serialization and deserialization so it is much more gas\\n    /// efficient than abi encode/decode but is NOT SAFE to use the `StateConfig`\\n    /// after it has been serialized. Notably the index based opcodes in the\\n    /// sources in `StateConfig` will be replaced by function pointer based\\n    /// opcodes in place, so are no longer usable in a portable format.\\n    /// @param config_ State config as per `IInterpreterV1`.\\n    /// @param stackLength_ Stack length calculated by `IExpressionDeployerV1`\\n    /// that will be used to allocate memory for the stack upon deserialization.\\n    /// @param opcodeFunctionPointers_ As per `IInterpreterV1.functionPointers`,\\n    /// bytes to be compiled into the final `InterpreterState.compiledSources`.\\n    function serialize(\\n        StateConfig memory config_,\\n        uint256 stackLength_,\\n        bytes memory opcodeFunctionPointers_\\n    ) internal pure returns (bytes memory) {\\n        unchecked {\\n            uint256 size_ = 0;\\n            size_ += stackLength_.size();\\n            size_ += config_.constants.size();\\n            for (uint256 i_ = 0; i_ < config_.sources.length; i_++) {\\n                size_ += config_.sources[i_].size();\\n            }\\n            bytes memory serialized_ = new bytes(size_);\\n            StackPointer cursor_ = serialized_.asStackPointer().up();\\n\\n            // Copy stack length.\\n            cursor_ = cursor_.push(stackLength_);\\n\\n            // Then the constants.\\n            cursor_ = cursor_.pushWithLength(config_.constants);\\n\\n            // Last the sources.\\n            bytes memory source_;\\n            for (uint256 i_ = 0; i_ < config_.sources.length; i_++) {\\n                source_ = config_.sources[i_];\\n                compile(source_, opcodeFunctionPointers_);\\n                cursor_ = cursor_.unalignedPushWithLength(source_);\\n            }\\n            return serialized_;\\n        }\\n    }\\n\\n    /// Return trip from `serialize` but targets an `InterpreterState` NOT a\\n    /// `StateConfig`. Allows serialized bytes to be written directly into\\n    /// contract code on the other side of an expression address, then loaded\\n    /// directly into an eval-able memory layout. The only allocation required\\n    /// is to initialise the stack for eval, there is no copying in memory from\\n    /// the serialized data as the deserialization merely calculates Solidity\\n    /// compatible pointers to positions in the raw serialized data. This is much\\n    /// more gas efficient than an equivalent abi.decode call which would involve\\n    /// more processing, copying and allocating.\\n    ///\\n    /// Note that per-eval data such as namespace and context is NOT initialised\\n    /// by the deserialization process and so will need to be handled by the\\n    /// interpreter as part of `eval`.\\n    ///\\n    /// @param serialized_ Bytes previously serialized by\\n    /// `LibInterpreterState.serialize`.\\n    /// @return An eval-able interpreter state with initialized stack.\\n    function deserialize(\\n        bytes memory serialized_\\n    ) internal pure returns (InterpreterState memory) {\\n        unchecked {\\n            InterpreterState memory state_;\\n\\n            // Context will probably be overridden by the caller according to the\\n            // context scratch that we deserialize so best to just set it empty\\n            // here.\\n            state_.context = new uint256[][](0);\\n\\n            StackPointer cursor_ = serialized_.asStackPointer().up();\\n            // The end of processing is the end of the state bytes.\\n            StackPointer end_ = cursor_.upBytes(cursor_.peek());\\n\\n            // Read the stack length and build a stack.\\n            cursor_ = cursor_.up();\\n            uint256 stackLength_ = cursor_.peek();\\n\\n            // The stack is never stored in stack bytes so we allocate a new\\n            // array for it with length as per the indexes and point the state\\n            // at it.\\n            uint256[] memory stack_ = new uint256[](stackLength_);\\n            state_.stackBottom = stack_.asStackPointerUp();\\n\\n            // Reference the constants array and move cursor past it.\\n            cursor_ = cursor_.up();\\n            state_.constantsBottom = cursor_;\\n            cursor_ = cursor_.up(cursor_.peek());\\n\\n            // Rebuild the sources array.\\n            uint256 i_ = 0;\\n            StackPointer lengthCursor_ = cursor_;\\n            uint256 sourcesLength_ = 0;\\n            while (\\n                StackPointer.unwrap(lengthCursor_) < StackPointer.unwrap(end_)\\n            ) {\\n                lengthCursor_ = lengthCursor_\\n                    .upBytes(lengthCursor_.peekUp())\\n                    .up();\\n                sourcesLength_++;\\n            }\\n            state_.compiledSources = new bytes[](sourcesLength_);\\n            while (StackPointer.unwrap(cursor_) < StackPointer.unwrap(end_)) {\\n                state_.compiledSources[i_] = cursor_.asBytes();\\n                cursor_ = cursor_.upBytes(cursor_.peekUp()).up();\\n                i_++;\\n            }\\n            return state_;\\n        }\\n    }\\n\\n    /// Given a source in opcodes compile to an equivalent source with real\\n    /// function pointers for a given Interpreter contract. The \\\"compilation\\\"\\n    /// involves simply replacing the opcode with the pointer at the index of\\n    /// the opcode. i.e. opcode 4 will be replaced with `pointers_[4]`.\\n    /// Relies heavily on the integrity checks ensuring opcodes used are not OOB\\n    /// and that the pointers provided are valid and in the correct order. As the\\n    /// expression deployer is typically handling compilation during\\n    /// serialization, NOT the interpreter, the interpreter MUST guard against\\n    /// the compilation being garbage or outright hostile during `eval` by\\n    /// pointing to arbitrary internal functions of the interpreter.\\n    /// @param source_ The input source as index based opcodes.\\n    /// @param pointers_ The function pointers ordered by index to replace the\\n    /// index based opcodes with.\\n    function compile(\\n        bytes memory source_,\\n        bytes memory pointers_\\n    ) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n                let replaceMask_ := 0xFFFF\\n                let preserveMask_ := not(replaceMask_)\\n                let sourceLength_ := mload(source_)\\n                let pointersBottom_ := add(pointers_, 2)\\n                let cursor_ := add(source_, 2)\\n                let end_ := add(source_, sourceLength_)\\n            } lt(cursor_, end_) {\\n                cursor_ := add(cursor_, 4)\\n            } {\\n                let data_ := mload(cursor_)\\n                let pointer_ := and(\\n                    replaceMask_,\\n                    mload(\\n                        add(pointersBottom_, mul(2, and(data_, replaceMask_)))\\n                    )\\n                )\\n                mstore(cursor_, or(and(data_, preserveMask_), pointer_))\\n            }\\n        }\\n    }\\n\\n    /// The main eval loop. Does as little as possible as it is an extremely hot\\n    /// performance and critical security path. Loads opcode/operand pairs from\\n    /// a precompiled source in the interpreter state and calls the function\\n    /// that the opcode points to. This function is in turn responsible for\\n    /// actually pushing/popping from the stack, etc. As `eval` receives the\\n    /// source index and stack top alongside its state, it supports recursive\\n    /// calls via. opcodes that can manage scoped substacks, etc. without `eval`\\n    /// needing to house that complexity itself.\\n    /// @param state_ The interpreter state to evaluate a source over.\\n    /// @param sourceIndex_ The index of the source to evaluate. MAY be an\\n    /// entrypoint or a nested call.\\n    /// @param stackTop_ The current stack top, MUST be equal to the stack bottom\\n    /// on the intepreter state if the current eval is for an entrypoint.\\n    function eval(\\n        InterpreterState memory state_,\\n        SourceIndex sourceIndex_,\\n        StackPointer stackTop_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 cursor_;\\n            uint256 end_;\\n            assembly (\\\"memory-safe\\\") {\\n                cursor_ := mload(\\n                    add(\\n                        mload(add(state_, 0xA0)),\\n                        add(0x20, mul(0x20, sourceIndex_))\\n                    )\\n                )\\n                end_ := add(cursor_, mload(cursor_))\\n            }\\n\\n            // Loop until complete.\\n            while (cursor_ < end_) {\\n                function(InterpreterState memory, Operand, StackPointer)\\n                    internal\\n                    view\\n                    returns (StackPointer) fn_;\\n                Operand operand_;\\n                cursor_ += 4;\\n                {\\n                    uint256 op_;\\n                    assembly (\\\"memory-safe\\\") {\\n                        op_ := mload(cursor_)\\n                        operand_ := and(op_, 0xFFFF)\\n                        fn_ := and(shr(16, op_), 0xFFFF)\\n                    }\\n                }\\n                stackTop_ = fn_(state_, operand_, stackTop_);\\n            }\\n            return stackTop_;\\n        }\\n    }\\n\\n    /// Standard way to elevate a caller-provided state namespace to a universal\\n    /// namespace that is disjoint from all other caller-provided namespaces.\\n    /// Essentially just hashes the `msg.sender` into the state namespace as-is.\\n    ///\\n    /// This is deterministic such that the same combination of state namespace\\n    /// and caller will produce the same fully qualified namespace, even across\\n    /// multiple transactions/blocks.\\n    ///\\n    /// @param stateNamespace_ The state namespace as specified by the caller.\\n    /// @return A fully qualified namespace that cannot collide with any other\\n    /// state namespace specified by any other caller.\\n    function qualifyNamespace(\\n        StateNamespace stateNamespace_\\n    ) internal view returns (FullyQualifiedNamespace) {\\n        return\\n            FullyQualifiedNamespace.wrap(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            msg.sender,\\n                            StateNamespace.unwrap(stateNamespace_)\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0xd680c532d927ae63ac71369949e3b4c847828350bac9f327a2b6d4783ff6680a\",\"license\":\"CAL\"},\"contracts/interpreter/run/LibStackPointer.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\nimport \\\"../../array/LibUint256Array.sol\\\";\\nimport \\\"../../bytes/LibBytes.sol\\\";\\n\\n/// Thrown when the length of an array as the result of an applied function does\\n/// not match expectations.\\nerror UnexpectedResultLength(uint256 expectedLength, uint256 actualLength);\\n\\n/// Custom type to point to memory ostensibly in a stack.\\ntype StackPointer is uint256;\\n\\n/// @title LibStackPointer\\n/// @notice A `StackPointer` is just a pointer to some memory. Ostensibly it is\\n/// pointing at a stack item in memory used by the `RainInterpreter` so that\\n/// means it can move \\\"up\\\" and \\\"down\\\" (increment and decrement) by `uint256`\\n/// (32 bytes) increments. Structurally a stack is a `uint256[]` but we can save\\n/// a lot of gas vs. default Solidity handling of array indexes by using assembly\\n/// to bypass runtime bounds checks on every read and write. Of course, this\\n/// means we have to introduce some mechanism that gives us equivalent guarantees\\n/// and we do, in the form of the `IExpressionDeployerV1` integrity check.\\n///\\n/// The pointer to the bottom of a stack points at the 0th item, NOT the length\\n/// of the implied `uint256[]` and the top of a stack points AFTER the last item.\\n/// e.g. consider a `uint256[]` in memory with values `3 A B C` and assume this\\n/// starts at position `0` in memory, i.e. `0` points to value `3` for the\\n/// array length. In this case the stack bottom would be\\n/// `StackPointer.wrap(0x20)` (32 bytes above 0, past the length) and the stack\\n/// top would be `StackPointer.wrap(0x80)` (96 bytes above the stack bottom).\\n///\\n/// Most of the functions in this library are equivalent to each other via\\n/// composition, i.e. everything could be achieved with just `up`, `down`,\\n/// `pop`, `push`, `peek`. The reason there is so much overloaded/duplicated\\n/// logic is that the Solidity compiler seems to fail at inlining equivalent\\n/// logic quite a lot. Perhaps once the IR compilation of Solidity is better\\n/// supported by tooling etc. we could remove a lot of this duplication as the\\n/// compiler itself would handle the optimisations.\\nlibrary LibStackPointer {\\n    using LibStackPointer for StackPointer;\\n    using LibStackPointer for uint256[];\\n    using LibStackPointer for bytes;\\n    using LibUint256Array for uint256[];\\n    using LibBytes for uint256;\\n\\n    /// Reads the value above the stack pointer. If the stack pointer is the\\n    /// current stack top this is an out of bounds read! The caller MUST ensure\\n    /// that this is not the case and that the stack pointer being read is within\\n    /// the stack and not after it.\\n    /// @param stackPointer_ Position to read past/above.\\n    function peekUp(\\n        StackPointer stackPointer_\\n    ) internal pure returns (uint256) {\\n        uint256 a_;\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(stackPointer_)\\n        }\\n        return a_;\\n    }\\n\\n    /// Read the value immediately below the given stack pointer. Equivalent to\\n    /// calling `pop` and discarding the `stackPointerAfter_` value, so may be\\n    /// less gas than setting and discarding a value.\\n    /// @param stackPointer_ The stack pointer to read below.\\n    /// @return a_ The value that was read.\\n    function peek(StackPointer stackPointer_) internal pure returns (uint256) {\\n        uint256 a_;\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(sub(stackPointer_, 0x20))\\n        }\\n        return a_;\\n    }\\n\\n    /// Reads 2 values below the given stack pointer.\\n    /// The following statements are equivalent but A may use gas if the\\n    /// compiler fails to inline some function calls.\\n    /// A:\\n    /// ```\\n    /// (uint256 a_, uint256 b_) = stackPointer_.peek2();\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// uint256 b_;\\n    /// (stackPointer_, b_) = stackPointer_.pop();\\n    /// uint256 a_ = stackPointer_.peek();\\n    /// ```\\n    /// @param stackPointer_ The stack top to peek below.\\n    function peek2(\\n        StackPointer stackPointer_\\n    ) internal pure returns (uint256, uint256) {\\n        uint256 a_;\\n        uint256 b_;\\n        assembly (\\\"memory-safe\\\") {\\n            a_ := mload(sub(stackPointer_, 0x40))\\n            b_ := mload(sub(stackPointer_, 0x20))\\n        }\\n        return (a_, b_);\\n    }\\n\\n    /// Read the value immediately below the given stack pointer and return the\\n    /// stack pointer that points to the value that was read alongside the value.\\n    /// The following are equivalent but A may be cheaper if the compiler\\n    /// fails to inline some function calls:\\n    /// A:\\n    /// ```\\n    /// uint256 a_;\\n    /// (stackPointer_, a_) = stackPointer_.pop();\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackPointer_ = stackPointer_.down();\\n    /// uint256 a_ = stackPointer_.peekUp();\\n    /// ```\\n    /// @param stackPointer_ The stack pointer to read below.\\n    /// @return stackPointerAfter_ Points to the value that was read.\\n    /// @return a_ The value that was read.\\n    function pop(\\n        StackPointer stackPointer_\\n    ) internal pure returns (StackPointer, uint256) {\\n        StackPointer stackPointerAfter_;\\n        uint256 a_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointerAfter_ := sub(stackPointer_, 0x20)\\n            a_ := mload(stackPointerAfter_)\\n        }\\n        return (stackPointerAfter_, a_);\\n    }\\n\\n    /// Given two stack pointers that bound a stack build an array of all values\\n    /// above the given sentinel value. The sentinel will be _replaced_ by the\\n    /// length of the array, allowing for efficient construction of a valid\\n    /// `uint256[]` without additional allocation or copying in memory. As the\\n    /// returned value is a `uint256[]` it can be treated as a substack and the\\n    /// same (or different) sentinel can be consumed many times to build many\\n    /// arrays from the main stack.\\n    ///\\n    /// As the sentinel is mutated in place into a length it is NOT safe to call\\n    /// this in a context where the stack is expected to be immutable.\\n    ///\\n    /// The sentinel MUST be chosen to have a negligible chance of colliding with\\n    /// a real value in the array, otherwise an intended array item will be\\n    /// interpreted as a sentinel and the array will be split into two slices.\\n    ///\\n    /// If the sentinel is absent in the stack this WILL REVERT. The intent is\\n    /// to represent dynamic length arrays without forcing expression authors to\\n    /// calculate lengths on the stack. If the expression author wants to model\\n    /// an empty/optional/absent value they MAY provided a sentinel for a zero\\n    /// length array and the calling contract SHOULD handle this.\\n    ///\\n    /// @param stackTop_ Pointer to the top of the stack.\\n    /// @param stackBottom_ Pointer to the bottom of the stack.\\n    /// @param sentinel_ The value to expect as the sentinel. MUST be present in\\n    /// the stack or `consumeSentinel` will revert. MUST NOT collide with valid\\n    /// stack items (or be cryptographically improbable to do so).\\n    /// @param stepSize_ Number of items to move over in the array per loop\\n    /// iteration. If the array has a known multiple of items it can be more\\n    /// efficient to find a sentinel moving in N-item increments rather than\\n    /// reading every item individually.\\n    function consumeSentinel(\\n        StackPointer stackTop_,\\n        StackPointer stackBottom_,\\n        uint256 sentinel_,\\n        uint256 stepSize_\\n    ) internal pure returns (StackPointer, uint256[] memory) {\\n        uint256[] memory array_;\\n        assembly (\\\"memory-safe\\\") {\\n            // Underflow is not allowed and pointing at position 0 in memory is\\n            // corrupt behaviour anyway.\\n            if iszero(stackBottom_) {\\n                revert(0, 0)\\n            }\\n            let sentinelLocation_ := 0\\n            let length_ := 0\\n            let step_ := mul(stepSize_, 0x20)\\n            for {\\n                stackTop_ := sub(stackTop_, 0x20)\\n                let end_ := sub(stackBottom_, 0x20)\\n            } gt(stackTop_, end_) {\\n                stackTop_ := sub(stackTop_, step_)\\n                length_ := add(length_, stepSize_)\\n            } {\\n                if eq(sentinel_, mload(stackTop_)) {\\n                    sentinelLocation_ := stackTop_\\n                    break\\n                }\\n            }\\n            // Sentinel MUST exist in the stack if consumer expects it to there.\\n            if iszero(sentinelLocation_) {\\n                revert(0, 0)\\n            }\\n            mstore(sentinelLocation_, length_)\\n            array_ := sentinelLocation_\\n        }\\n        return (stackTop_, array_);\\n    }\\n\\n    /// Abstraction over `consumeSentinel` to build an array of solidity structs.\\n    /// Solidity won't exactly allow this due to its type system not supporting\\n    /// generics, so instead we return an array of references to struct data that\\n    /// can be assigned/cast to an array of structs easily with assembly. This\\n    /// is NOT intended to be a general purpose workhorse for this task, only\\n    /// structs of pointers to `uint256[]` values are supported.\\n    ///\\n    /// ```\\n    /// struct Foo {\\n    ///   uint256[] a;\\n    ///   uint256[] b;\\n    /// }\\n    ///\\n    /// (StackPointer stackPointer_, uint256[] memory refs_) = consumeStructs(...);\\n    /// Foo[] memory foo_;\\n    /// assembly (\\\"memory-safe\\\") {\\n    ///   mstore(foo_, refs_)\\n    /// }\\n    /// ```\\n    ///\\n    /// @param stackTop_ The top of the stack as per `consumeSentinel`.\\n    /// @param stackBottom_ The bottom of the stack as per `consumeSentinel`.\\n    /// @param sentinel_ The sentinel as per `consumeSentinel`.\\n    /// @param structSize_ The number of `uint256[]` fields on the struct.\\n    function consumeStructs(\\n        StackPointer stackTop_,\\n        StackPointer stackBottom_,\\n        uint256 sentinel_,\\n        uint256 structSize_\\n    ) internal pure returns (StackPointer, uint256[] memory) {\\n        (StackPointer stackTopAfter_, uint256[] memory tempArray_) = stackTop_\\n            .consumeSentinel(stackBottom_, sentinel_, structSize_);\\n        uint256 structsLength_ = tempArray_.length / structSize_;\\n        uint256[] memory refs_ = new uint256[](structsLength_);\\n        assembly (\\\"memory-safe\\\") {\\n            for {\\n                let refCursor_ := add(refs_, 0x20)\\n                let refEnd_ := add(refCursor_, mul(structsLength_, 0x20))\\n                let tempCursor_ := add(tempArray_, 0x20)\\n                let tempStepSize_ := mul(structSize_, 0x20)\\n            } lt(refCursor_, refEnd_) {\\n                refCursor_ := add(refCursor_, 0x20)\\n                tempCursor_ := add(tempCursor_, tempStepSize_)\\n            } {\\n                mstore(refCursor_, tempCursor_)\\n            }\\n        }\\n        return (stackTopAfter_, refs_);\\n    }\\n\\n    /// Write a value at the stack pointer. Typically only useful as intermediate\\n    /// logic within some opcode etc. as the value will be treated as an out of\\n    /// bounds for future reads unless the stack top after the opcode logic is\\n    /// above the pointer.\\n    /// @param stackPointer_ The stack top to write the value at.\\n    /// @param a_ The value to write.\\n    function set(StackPointer stackPointer_, uint256 a_) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackPointer_, a_)\\n        }\\n    }\\n\\n    /// Store a `uint256` at the stack pointer and return the stack pointer\\n    /// above the written value. The following statements are equivalent in\\n    /// functionality but A may be less gas if the compiler fails to inline\\n    /// some function calls.\\n    /// A:\\n    /// ```\\n    /// stackPointer_ = stackPointer_.push(a_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackPointer_.set(a_);\\n    /// stackPointer_ = stackPointer_.up();\\n    /// ```\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param a_ The value to write.\\n    /// @return The stack pointer above where `a_` was written to.\\n    function push(\\n        StackPointer stackPointer_,\\n        uint256 a_\\n    ) internal pure returns (StackPointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackPointer_, a_)\\n            stackPointer_ := add(stackPointer_, 0x20)\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Store a `uint256[]` at the stack pointer and return the stack pointer\\n    /// above the written values. The length of the array is NOT written to the\\n    /// stack, ONLY the array values are copied to the stack. The following\\n    /// statements are equivalent in functionality but A may be less gas if the\\n    /// compiler fails to inline some function calls.\\n    /// A:\\n    /// ```\\n    /// stackPointer_ = stackPointer_.push(array_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// unchecked {\\n    ///   for (uint256 i_ = 0; i_ < array_.length; i_++) {\\n    ///     stackPointer_ = stackPointer_.push(array_[i_]);\\n    ///   }\\n    /// }\\n    /// ```\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param array_ The array of values to write.\\n    /// @return The stack pointer above the array.\\n    function push(\\n        StackPointer stackPointer_,\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        array_.unsafeCopyValuesTo(StackPointer.unwrap(stackPointer_));\\n        return stackPointer_.up(array_.length);\\n    }\\n\\n    /// Store a `uint256[]` at the stack pointer and return the stack pointer\\n    /// above the written values. The length of the array IS written to the\\n    /// stack.\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param array_ The array of values and length to write.\\n    /// @return The stack pointer above the array.\\n    function pushWithLength(\\n        StackPointer stackPointer_,\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        return stackPointer_.push(array_.length).push(array_);\\n    }\\n\\n    /// Store `bytes` at the stack pointer and return the stack pointer above\\n    /// the written bytes. The length of the bytes is NOT written to the stack,\\n    /// ONLY the bytes are written. As `bytes` may be of arbitrary length, i.e.\\n    /// it MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\\n    /// ensure that this is safe in context of subsequent reads and writes.\\n    /// @param stackPointer_ The stack top to write at.\\n    /// @param bytes_ The bytes to write at the stack top.\\n    /// @return The stack top above the written bytes.\\n    function unalignedPush(\\n        StackPointer stackPointer_,\\n        bytes memory bytes_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer.unwrap(bytes_.asStackPointer().up()).unsafeCopyBytesTo(\\n            StackPointer.unwrap(stackPointer_),\\n            bytes_.length\\n        );\\n        return stackPointer_.upBytes(bytes_.length);\\n    }\\n\\n    /// Store `bytes` at the stack pointer and return the stack top above the\\n    /// written bytes. The length of the bytes IS written to the stack in\\n    /// addition to the bytes. As `bytes` may be of arbitrary length, i.e. it\\n    /// MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\\n    /// ensure that this is safe in context of subsequent reads and writes.\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param bytes_ The bytes to write with their length at the stack pointer.\\n    /// @return The stack pointer above the written bytes.\\n    function unalignedPushWithLength(\\n        StackPointer stackPointer_,\\n        bytes memory bytes_\\n    ) internal pure returns (StackPointer) {\\n        return stackPointer_.push(bytes_.length).unalignedPush(bytes_);\\n    }\\n\\n    /// Store 8x `uint256` at the stack pointer and return the stack pointer\\n    /// above the written value. The following statements are equivalent in\\n    /// functionality but A may be cheaper if the compiler fails to\\n    /// inline some function calls.\\n    /// A:\\n    /// ```\\n    /// stackPointer_ = stackPointer_.push(a_, b_, c_, d_, e_, f_, g_, h_);\\n    /// ```\\n    /// B:\\n    /// ```\\n    /// stackPointer_ = stackPointer_\\n    ///   .push(a_)\\n    ///   .push(b_)\\n    ///   .push(c_)\\n    ///   .push(d_)\\n    ///   .push(e_)\\n    ///   .push(f_)\\n    ///   .push(g_)\\n    ///   .push(h_);\\n    /// @param stackPointer_ The stack pointer to write at.\\n    /// @param a_ The first value to write.\\n    /// @param b_ The second value to write.\\n    /// @param c_ The third value to write.\\n    /// @param d_ The fourth value to write.\\n    /// @param e_ The fifth value to write.\\n    /// @param f_ The sixth value to write.\\n    /// @param g_ The seventh value to write.\\n    /// @param h_ The eighth value to write.\\n    /// @return The stack pointer above where `h_` was written.\\n    function push(\\n        StackPointer stackPointer_,\\n        uint256 a_,\\n        uint256 b_,\\n        uint256 c_,\\n        uint256 d_,\\n        uint256 e_,\\n        uint256 f_,\\n        uint256 g_,\\n        uint256 h_\\n    ) internal pure returns (StackPointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(stackPointer_, a_)\\n            mstore(add(stackPointer_, 0x20), b_)\\n            mstore(add(stackPointer_, 0x40), c_)\\n            mstore(add(stackPointer_, 0x60), d_)\\n            mstore(add(stackPointer_, 0x80), e_)\\n            mstore(add(stackPointer_, 0xA0), f_)\\n            mstore(add(stackPointer_, 0xC0), g_)\\n            mstore(add(stackPointer_, 0xE0), h_)\\n            stackPointer_ := add(stackPointer_, 0x100)\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        a_ = fn_(a_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(Operand, uint256) internal view returns (uint256) fn_,\\n        Operand operand_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n        }\\n        a_ = fn_(operand_, a_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x20)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n        }\\n        a_ = fn_(a_, b_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Reduce a function N times, reading and writing inputs and the accumulated\\n    /// result on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param n_ The number of times to apply fn_ to accumulate a final result.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFnN(\\n        StackPointer stackTop_,\\n        function(uint256, uint256) internal view returns (uint256) fn_,\\n        uint256 n_\\n    ) internal view returns (StackPointer) {\\n        unchecked {\\n            uint256 bottom_;\\n            uint256 cursor_;\\n            uint256 a_;\\n            uint256 b_;\\n            StackPointer stackTopAfter_;\\n            assembly (\\\"memory-safe\\\") {\\n                bottom_ := sub(stackTop_, mul(n_, 0x20))\\n                a_ := mload(bottom_)\\n                stackTopAfter_ := add(bottom_, 0x20)\\n                cursor_ := stackTopAfter_\\n            }\\n            while (cursor_ < StackPointer.unwrap(stackTop_)) {\\n                assembly (\\\"memory-safe\\\") {\\n                    b_ := mload(cursor_)\\n                }\\n                a_ = fn_(a_, b_);\\n                cursor_ += 0x20;\\n            }\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(bottom_, a_)\\n            }\\n            return stackTopAfter_;\\n        }\\n    }\\n\\n    /// Reduce a function N times, reading and writing inputs and the accumulated\\n    /// result on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param n_ The number of times to apply fn_ to accumulate a final result.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFnN(\\n        StackPointer stackTop_,\\n        function(uint256) internal view fn_,\\n        uint256 n_\\n    ) internal view returns (StackPointer) {\\n        uint256 cursor_;\\n        uint256 a_;\\n        StackPointer stackTopAfter_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTopAfter_ := sub(stackTop_, mul(n_, 0x20))\\n            cursor_ := stackTopAfter_\\n        }\\n        while (cursor_ < StackPointer.unwrap(stackTop_)) {\\n            assembly (\\\"memory-safe\\\") {\\n                a_ := mload(cursor_)\\n                cursor_ := add(cursor_, 0x20)\\n            }\\n            fn_(a_);\\n        }\\n        return stackTopAfter_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256) internal view returns (uint256) fn_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 c_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x40)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n            c_ := mload(add(stackTop_, 0x20))\\n        }\\n        a_ = fn_(a_, b_, c_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256, uint256)\\n            internal\\n            view\\n            returns (uint256) fn_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 c_;\\n        uint256 d_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x60)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n            c_ := mload(add(stackTop_, 0x20))\\n            d_ := mload(add(stackTop_, 0x40))\\n        }\\n        a_ = fn_(a_, b_, c_, d_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param operand_ Operand is passed from the source instead of the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(Operand, uint256, uint256) internal view returns (uint256) fn_,\\n        Operand operand_\\n    ) internal view returns (StackPointer) {\\n        uint256 a_;\\n        uint256 b_;\\n        uint256 location_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackTop_ := sub(stackTop_, 0x20)\\n            location_ := sub(stackTop_, 0x20)\\n            a_ := mload(location_)\\n            b_ := mload(stackTop_)\\n        }\\n        a_ = fn_(operand_, a_, b_);\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(location_, a_)\\n        }\\n        return stackTop_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the array to pass to fn_ from the stack.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256[] memory) internal view returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        (uint256 a_, uint256[] memory tail_) = stackTop_.list(length_);\\n        uint256 b_ = fn_(tail_);\\n        return tail_.asStackPointer().push(a_).push(b_);\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the array to pass to fn_ from the stack.\\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        (uint256 b_, uint256[] memory tail_) = stackTop_.list(length_);\\n        StackPointer stackTopAfter_ = tail_.asStackPointer();\\n        (StackPointer location_, uint256 a_) = stackTopAfter_.pop();\\n        location_.set(fn_(a_, b_, tail_));\\n        return stackTopAfter_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the array to pass to fn_ from the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256, uint256, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256) fn_,\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        (uint256 c_, uint256[] memory tail_) = stackTop_.list(length_);\\n        (StackPointer stackTopAfter_, uint256 b_) = tail_\\n            .asStackPointer()\\n            .pop();\\n        uint256 a_ = stackTopAfter_.peek();\\n        stackTopAfter_.down().set(fn_(a_, b_, c_, tail_));\\n        return stackTopAfter_;\\n    }\\n\\n    /// Execute a function, reading and writing inputs and outputs on the stack.\\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\\n    /// @param stackTop_ The stack top to read and write to.\\n    /// @param fn_ The function to run on the stack.\\n    /// @param length_ The length of the arrays to pass to fn_ from the stack.\\n    /// @return The new stack top above the outputs of fn_.\\n    function applyFn(\\n        StackPointer stackTop_,\\n        function(uint256, uint256[] memory, uint256[] memory)\\n            internal\\n            view\\n            returns (uint256[] memory) fn_,\\n        uint256 length_\\n    ) internal view returns (StackPointer) {\\n        StackPointer csStart_ = stackTop_.down(length_);\\n        uint256[] memory cs_ = LibUint256Array.copyToNewUint256Array(\\n            StackPointer.unwrap(csStart_),\\n            length_\\n        );\\n        (uint256 a_, uint256[] memory bs_) = csStart_.list(length_);\\n\\n        uint256[] memory results_ = fn_(a_, bs_, cs_);\\n        if (results_.length != length_) {\\n            revert UnexpectedResultLength(length_, results_.length);\\n        }\\n\\n        StackPointer bottom_ = bs_.asStackPointer();\\n        LibUint256Array.unsafeCopyValuesTo(\\n            results_,\\n            StackPointer.unwrap(bottom_)\\n        );\\n        return bottom_.up(length_);\\n    }\\n\\n    /// Returns `length_` values from the stack as an array without allocating\\n    /// new memory. As arrays always start with their length, this requires\\n    /// writing the length value to the stack below the array values. The value\\n    /// that is overwritten in the process is also returned so that data is not\\n    /// lost. For example, imagine a stack `[ A B C D ]` and we list 2 values.\\n    /// This will write the stack to look like `[ A 2 C D ]` and return both `B`\\n    /// and a pointer to `2` represented as a `uint256[]`.\\n    /// The returned array is ONLY valid for as long as the stack DOES NOT move\\n    /// back into its memory. As soon as the stack moves up again and writes into\\n    /// the array it will be corrupt. The caller MUST ensure that it does not\\n    /// read from the returned array after it has been corrupted by subsequent\\n    /// stack writes.\\n    /// @param stackPointer_ The stack pointer to read the values below into an\\n    /// array.\\n    /// @param length_ The number of values to include in the returned array.\\n    /// @return head_ The value that was overwritten with the length.\\n    /// @return tail_ The array constructed from the stack memory.\\n    function list(\\n        StackPointer stackPointer_,\\n        uint256 length_\\n    ) internal pure returns (uint256, uint256[] memory) {\\n        uint256 head_;\\n        uint256[] memory tail_;\\n        assembly (\\\"memory-safe\\\") {\\n            tail_ := sub(stackPointer_, add(0x20, mul(length_, 0x20)))\\n            head_ := mload(tail_)\\n            mstore(tail_, length_)\\n        }\\n        return (head_, tail_);\\n    }\\n\\n    /// Cast a `uint256[]` array to a stack pointer. The stack pointer will\\n    /// point to the length of the array, NOT its first value.\\n    /// @param array_ The array to cast to a stack pointer.\\n    /// @return stackPointer_ The stack pointer that points to the length of the\\n    /// array.\\n    function asStackPointer(\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer stackPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointer_ := array_\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Cast a stack pointer to an array. The value immediately above the stack\\n    /// pointer will be treated as the length of the array, so the proceeding\\n    /// length values will be the items of the array. The caller MUST ensure the\\n    /// values above the stack position constitute a valid array. The returned\\n    /// array will be corrupt if/when the stack subsequently moves into it and\\n    /// writes to those memory locations. The caller MUST ensure that it does\\n    /// NOT read from the returned array after the stack writes over it.\\n    /// @param stackPointer_ The stack pointer that will be cast to an array.\\n    /// @return array_ The array above the stack pointer.\\n    function asUint256Array(\\n        StackPointer stackPointer_\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory array_;\\n        assembly (\\\"memory-safe\\\") {\\n            array_ := stackPointer_\\n        }\\n        return array_;\\n    }\\n\\n    /// Cast a stack position to bytes. The value immediately above the stack\\n    /// position will be treated as the length of the `bytes`, so the proceeding\\n    /// length bytes will be the data of the `bytes`. The caller MUST ensure the\\n    /// length and bytes above the stack top constitute valid `bytes` data. The\\n    /// returned `bytes` will be corrupt if/when the stack subsequently moves\\n    /// into it and writes to those memory locations. The caller MUST ensure\\n    // that it does NOT read from the returned bytes after the stack writes over\\n    /// it.\\n    /// @param stackPointer_ The stack pointer that will be cast to bytes.\\n    /// @return bytes_ The bytes above the stack top.\\n    function asBytes(\\n        StackPointer stackPointer_\\n    ) internal pure returns (bytes memory) {\\n        bytes memory bytes_;\\n        assembly (\\\"memory-safe\\\") {\\n            bytes_ := stackPointer_\\n        }\\n        return bytes_;\\n    }\\n\\n    /// Cast a `uint256[]` array to a stack pointer after its length. The stack\\n    /// pointer will point to the first item of the array, NOT its length.\\n    /// @param array_ The array to cast to a stack pointer.\\n    /// @return stackPointer_ The stack pointer that points to the first item of\\n    /// the array.\\n    function asStackPointerUp(\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer stackPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointer_ := add(array_, 0x20)\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Cast a `uint256[]` array to a stack pointer after its items. The stack\\n    /// pointer will point after the last item of the array. It is out of bounds\\n    /// to read above the returned pointer. This can be interpreted as the stack\\n    /// top assuming the entire given array is a valid stack.\\n    /// @param array_ The array to cast to a stack pointer.\\n    /// @return stackPointer_ The stack pointer that points after the last item\\n    /// of the array.\\n    function asStackPointerAfter(\\n        uint256[] memory array_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer stackPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointer_ := add(array_, add(0x20, mul(mload(array_), 0x20)))\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Cast `bytes` to a stack pointer. The stack pointer will point to the\\n    /// length of the `bytes`, NOT the first byte.\\n    /// @param bytes_ The `bytes` to cast to a stack pointer.\\n    /// @return stackPointer_ The stack top that points to the length of the\\n    /// bytes.\\n    function asStackPointer(\\n        bytes memory bytes_\\n    ) internal pure returns (StackPointer) {\\n        StackPointer stackPointer_;\\n        assembly (\\\"memory-safe\\\") {\\n            stackPointer_ := bytes_\\n        }\\n        return stackPointer_;\\n    }\\n\\n    /// Returns the stack pointer 32 bytes above/past the given stack pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @return The stack pointer 32 bytes above the input stack pointer.\\n    function up(\\n        StackPointer stackPointer_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return StackPointer.wrap(StackPointer.unwrap(stackPointer_) + 0x20);\\n        }\\n    }\\n\\n    /// Returns the stack pointer `n_ * 32` bytes above/past the given stack\\n    /// pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @param n_ The multiplier on the stack movement. MAY be zero.\\n    /// @return The stack pointer `n_ * 32` bytes above/past the input stack\\n    /// pointer.\\n    function up(\\n        StackPointer stackPointer_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return\\n                StackPointer.wrap(\\n                    StackPointer.unwrap(stackPointer_) + 0x20 * n_\\n                );\\n        }\\n    }\\n\\n    /// Returns the stack pointer `n_` bytes above/past the given stack pointer.\\n    /// The returned stack pointer MAY NOT be aligned with the given stack\\n    /// pointer for subsequent 32 byte reads and writes. The caller MUST ensure\\n    /// that it is safe to read and write data relative to the returned stack\\n    /// pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @param n_ The number of bytes to move.\\n    /// @return The stack pointer `n_` bytes above/past the given stack pointer.\\n    function upBytes(\\n        StackPointer stackPointer_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return StackPointer.wrap(StackPointer.unwrap(stackPointer_) + n_);\\n        }\\n    }\\n\\n    /// Returns the stack pointer 32 bytes below/before the given stack pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @return The stack pointer 32 bytes below/before the given stack pointer.\\n    function down(\\n        StackPointer stackPointer_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return StackPointer.wrap(StackPointer.unwrap(stackPointer_) - 0x20);\\n        }\\n    }\\n\\n    /// Returns the stack pointer `n_ * 32` bytes below/before the given stack\\n    /// pointer.\\n    /// @param stackPointer_ The stack pointer at the starting position.\\n    /// @param n_ The multiplier on the movement.\\n    /// @return The stack pointer `n_ * 32` bytes below/before the given stack\\n    /// pointer.\\n    function down(\\n        StackPointer stackPointer_,\\n        uint256 n_\\n    ) internal pure returns (StackPointer) {\\n        unchecked {\\n            return\\n                StackPointer.wrap(\\n                    StackPointer.unwrap(stackPointer_) - 0x20 * n_\\n                );\\n        }\\n    }\\n\\n    /// Convert two stack pointer values to a single stack index. A stack index\\n    /// is the distance in 32 byte increments between two stack pointers. The\\n    /// calculations assumes the two stack pointers are aligned. The caller MUST\\n    /// ensure the alignment of both values. The calculation is unchecked and MAY\\n    /// underflow. The caller MUST ensure that the stack top is always above the\\n    /// stack bottom.\\n    /// @param stackBottom_ The lower of the two values.\\n    /// @param stackTop_ The higher of the two values.\\n    /// @return The stack index as 32 byte distance between the top and bottom.\\n    function toIndex(\\n        StackPointer stackBottom_,\\n        StackPointer stackTop_\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            return\\n                (StackPointer.unwrap(stackTop_) -\\n                    StackPointer.unwrap(stackBottom_)) / 0x20;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe9c7ce66b490126433ff8e1cf52c92ea78eb2a4e93c88e20c2f6fd8a716b1e96\",\"license\":\"CAL\"},\"contracts/kv/LibMemoryKV.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../math/Binary.sol\\\";\\n\\n/// Thrown when attempting to read a value from the other side of a zero pointer.\\nerror InvalidPtr(MemoryKVPtr ptr);\\n\\n/// Entrypoint into the key/value store. Is a mutable pointer to the head of the\\n/// linked list. Initially points to `0` for an empty list. The total length of\\n/// the linked list is also encoded alongside the pointer to allow efficient O(1)\\n/// memory allocation for a `uint256[]` in the case of a final snapshot/export.\\ntype MemoryKV is uint256;\\n/// The key associated with the value for each item in the linked list.\\ntype MemoryKVKey is uint256;\\n/// The pointer to the next item in the list. `0` signifies the end of the list.\\ntype MemoryKVPtr is uint256;\\n/// The value associated with the key for each item in the linked list.\\ntype MemoryKVVal is uint256;\\n\\n/// @title LibMemoryKV\\n/// @notice Implements an in-memory key/value store in terms of a linked list\\n/// that can be snapshotted/exported to a `uint256[]` of pairwise keys/values as\\n/// its items. Ostensibly supports reading/writing to storage within a read only\\n/// context in an interpreter `eval` by tracking changes requested by an\\n/// expression in memory as a cache-like structure over the underlying storage.\\n///\\n/// A linked list is required because unlike stack movements we do NOT have any\\n/// way to precalculate how many items will be included in the final set at\\n/// deploy time. Any two writes may share the same key known only at runtime, so\\n/// any two writes may result in either 2 or 1 insertions (and 0 or 1 updates).\\n/// We could attempt to solve this by allowing duplicate keys and simply append\\n/// values for each write, so two writes will always insert 2 values, but then\\n/// looping constructs such as `OpDoWhile` and `OpFoldContext` with net 0 stack\\n/// movements (i.e. predictably deallocateable memory) can still cause\\n/// unbounded/unknown inserts for our state changes. The linked list allows us\\n/// to both dedupe same-key writes and also safely handle an unknown\\n/// (at deploy time) number of upserts. New items are inserted at the head of\\n/// the list and a pointer to `0` is the sentinel that defines the end of the\\n/// list. It is an error to dereference the `0` pointer.\\n///\\n/// Currently implemented as O(n) where n is likely relatively small, in future\\n/// could be reimplemented as 8 linked lists over a single `MemoryKV` by packing\\n/// many `MemoryKVPtr` and using `%` to distribute keys between lists. The\\n/// extremely high gas cost of writing to storage itself should be a natural\\n/// disincentive for n getting large enough to cause the linked list traversal\\n/// to be a significant gas cost itself.\\n///\\n/// Currently implemented in terms of raw `uint256` custom types that represent\\n/// keys, values and pointers. Could be reimplemented in terms of an equivalent\\n/// struct with key, value and pointer fields.\\nlibrary LibMemoryKV {\\n    /// Reads the `MemoryKVVal` that some `MemoryKVPtr` is pointing to. It is an\\n    /// error to call this if `ptr_` is `0`.\\n    /// @param ptr_ The pointer to read the value\\n    function readPtrVal(\\n        MemoryKVPtr ptr_\\n    ) internal pure returns (MemoryKVVal v_) {\\n        // This is ALWAYS a bug. It means the caller did not check if the ptr is\\n        // nonzero before trying to read from it.\\n        if (MemoryKVPtr.unwrap(ptr_) == 0) {\\n            revert InvalidPtr(ptr_);\\n        }\\n\\n        assembly (\\\"memory-safe\\\") {\\n            v_ := mload(add(ptr_, 0x20))\\n        }\\n    }\\n\\n    /// Finds the pointer to the item that holds the value associated with the\\n    /// given key. Walks the linked list from the entrypoint into the key/value\\n    /// store until it finds the specified key. As the last pointer in the list\\n    /// is always `0`, `0` is what will be returned if the key is not found. Any\\n    /// non-zero pointer implies the value it points to is for the provided key.\\n    /// @param kv_ The entrypoint to the key/value store.\\n    /// @param k_ The key to lookup a pointer for.\\n    /// @return ptr_ The _pointer_ to the value for the key, if it exists, else\\n    /// a pointer to `0`. If the pointer is non-zero the associated value can be\\n    /// read to a `MemoryKVVal` with `LibMemoryKV.readPtrVal`.\\n    function getPtr(\\n        MemoryKV kv_,\\n        MemoryKVKey k_\\n    ) internal pure returns (MemoryKVPtr ptr_) {\\n        uint256 mask_ = MASK_16BIT;\\n        assembly (\\\"memory-safe\\\") {\\n            // loop until k found or give up if ptr is zero\\n            for {\\n                ptr_ := and(kv_, mask_)\\n            } iszero(iszero(ptr_)) {\\n                ptr_ := mload(add(ptr_, 0x40))\\n            } {\\n                if eq(k_, mload(ptr_)) {\\n                    break\\n                }\\n            }\\n        }\\n    }\\n\\n    /// Upserts a value in the set by its key. I.e. if the key exists then the\\n    /// associated value will be mutated in place, else a new key/value pair will\\n    /// be inserted. The key/value store pointer will be mutated and returned as\\n    /// it MAY point to a new list item in memory.\\n    /// @param kv_ The key/value store pointer to modify.\\n    /// @param k_ The key to upsert against.\\n    /// @param v_ The value to associate with the upserted key.\\n    /// @return The final value of `kv_` as it MAY be modified if the upsert\\n    /// resulted in an insert operation.\\n    function setVal(\\n        MemoryKV kv_,\\n        MemoryKVKey k_,\\n        MemoryKVVal v_\\n    ) internal pure returns (MemoryKV) {\\n        MemoryKVPtr ptr_ = getPtr(kv_, k_);\\n        uint256 mask_ = MASK_16BIT;\\n        // update\\n        if (MemoryKVPtr.unwrap(ptr_) > 0) {\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(add(ptr_, 0x20), v_)\\n            }\\n        }\\n        // insert\\n        else {\\n            assembly (\\\"memory-safe\\\") {\\n                // allocate new memory\\n                ptr_ := mload(0x40)\\n                mstore(0x40, add(ptr_, 0x60))\\n                // set k/v/ptr\\n                mstore(ptr_, k_)\\n                mstore(add(ptr_, 0x20), v_)\\n                mstore(add(ptr_, 0x40), and(kv_, mask_))\\n                // kv must point to new insertion and update array len\\n                kv_ := or(\\n                    // inc len by 2\\n                    shl(16, add(shr(16, kv_), 2)),\\n                    // set ptr\\n                    ptr_\\n                )\\n            }\\n        }\\n        return kv_;\\n    }\\n\\n    /// Export/snapshot the underlying linked list of the key/value store into\\n    /// a standard `uint256[]`. Reads the total length to preallocate the\\n    /// `uint256[]` then walks the entire linked list, copying every key and\\n    /// value into the array, until it reaches a pointer to `0`. Note this is a\\n    /// one time export, if the key/value store is subsequently mutated the built\\n    /// array will not reflect these mutations.\\n    /// @param kv_ The entrypoint into the key/value store.\\n    /// @return All the keys and values copied pairwise into a `uint256[]`.\\n    function toUint256Array(\\n        MemoryKV kv_\\n    ) internal pure returns (uint256[] memory) {\\n        unchecked {\\n            uint256 ptr_ = MemoryKV.unwrap(kv_) & MASK_16BIT;\\n            uint256 length_ = MemoryKV.unwrap(kv_) >> 16;\\n            uint256[] memory arr_ = new uint256[](length_);\\n            assembly (\\\"memory-safe\\\") {\\n                for {\\n                    let cursor_ := add(arr_, 0x20)\\n                    let end_ := add(cursor_, mul(mload(arr_), 0x20))\\n                } lt(cursor_, end_) {\\n                    cursor_ := add(cursor_, 0x20)\\n                    ptr_ := mload(add(ptr_, 0x40))\\n                } {\\n                    // key\\n                    mstore(cursor_, mload(ptr_))\\n                    cursor_ := add(cursor_, 0x20)\\n                    // value\\n                    mstore(cursor_, mload(add(ptr_, 0x20)))\\n                }\\n            }\\n            return arr_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbf745ef2a8e5918ff93548a431296811dded10b727bfadbfcc35c6f742cba91a\",\"license\":\"CAL\"},\"contracts/math/Binary.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// @dev Binary 1.\\nuint256 constant B_1 = 2 ** 1 - 1;\\n/// @dev Binary 11.\\nuint256 constant B_11 = 2 ** 2 - 1;\\n/// @dev Binary 111.\\nuint256 constant B_111 = 2 ** 3 - 1;\\n/// @dev Binary 1111.\\nuint256 constant B_1111 = 2 ** 4 - 1;\\n/// @dev Binary 11111.\\nuint256 constant B_11111 = 2 ** 5 - 1;\\n/// @dev Binary 111111.\\nuint256 constant B_111111 = 2 ** 6 - 1;\\n/// @dev Binary 1111111.\\nuint256 constant B_1111111 = 2 ** 7 - 1;\\n/// @dev Binary 11111111.\\nuint256 constant B_11111111 = 2 ** 8 - 1;\\n/// @dev Binary 111111111.\\nuint256 constant B_111111111 = 2 ** 9 - 1;\\n/// @dev Binary 1111111111.\\nuint256 constant B_1111111111 = 2 ** 10 - 1;\\n/// @dev Binary 11111111111.\\nuint256 constant B_11111111111 = 2 ** 11 - 1;\\n/// @dev Binary 111111111111.\\nuint256 constant B_111111111111 = 2 ** 12 - 1;\\n/// @dev Binary 1111111111111.\\nuint256 constant B_1111111111111 = 2 ** 13 - 1;\\n/// @dev Binary 11111111111111.\\nuint256 constant B_11111111111111 = 2 ** 14 - 1;\\n/// @dev Binary 111111111111111.\\nuint256 constant B_111111111111111 = 2 ** 15 - 1;\\n/// @dev Binary 1111111111111111.\\nuint256 constant B_1111111111111111 = 2 ** 16 - 1;\\n\\n/// @dev Bitmask for 1 bit.\\nuint256 constant MASK_1BIT = B_1;\\n/// @dev Bitmask for 2 bits.\\nuint256 constant MASK_2BIT = B_11;\\n/// @dev Bitmask for 3 bits.\\nuint256 constant MASK_3BIT = B_111;\\n/// @dev Bitmask for 4 bits.\\nuint256 constant MASK_4BIT = B_1111;\\n/// @dev Bitmask for 5 bits.\\nuint256 constant MASK_5BIT = B_11111;\\n/// @dev Bitmask for 6 bits.\\nuint256 constant MASK_6BIT = B_111111;\\n/// @dev Bitmask for 7 bits.\\nuint256 constant MASK_7BIT = B_1111111;\\n/// @dev Bitmask for 8 bits.\\nuint256 constant MASK_8BIT = B_11111111;\\n/// @dev Bitmask for 9 bits.\\nuint256 constant MASK_9BIT = B_111111111;\\n/// @dev Bitmask for 10 bits.\\nuint256 constant MASK_10BIT = B_1111111111;\\n/// @dev Bitmask for 11 bits.\\nuint256 constant MASK_11BIT = B_11111111111;\\n/// @dev Bitmask for 12 bits.\\nuint256 constant MASK_12BIT = B_111111111111;\\n/// @dev Bitmask for 13 bits.\\nuint256 constant MASK_13BIT = B_1111111111111;\\n/// @dev Bitmask for 14 bits.\\nuint256 constant MASK_14BIT = B_11111111111111;\\n/// @dev Bitmask for 15 bits.\\nuint256 constant MASK_15BIT = B_111111111111111;\\n/// @dev Bitmask for 16 bits.\\nuint256 constant MASK_16BIT = B_1111111111111111;\\n\",\"keccak256\":\"0x63a0b41ebb7c6b78d7e8a9f8b33900421c5d641276a36a6258e97fab4310cdf2\",\"license\":\"CAL\"},\"contracts/memory/LibMemorySize.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.10;\\n\\n/// @title LibMemorySize\\n/// @notice Reports the size in bytes of type data that represents contigious\\n/// regions of memory. Pointers to regions of memory that may not be congigious\\n/// are not supported, e.g. fields on structs may point to dynamic data that is\\n/// separate to the struct. Length slots for dynamic data are included in the\\n/// size and the size is always measured in bytes.\\nlibrary LibMemorySize {\\n    /// Reports the size of a `uint256` in bytes. Is always 32.\\n    /// @return 32.\\n    function size(uint256) internal pure returns (uint256) {\\n        return 0x20;\\n    }\\n\\n    /// Reports the size of a `uint256[]` in bytes. Is the size of the length\\n    /// slot (32 bytes) plus the length of the array multiplied by 32 bytes per\\n    /// item.\\n    /// @return The size of the array data including its length slot size.\\n    function size(uint256[] memory array_) internal pure returns (uint256) {\\n        unchecked {\\n            return 0x20 + (array_.length * 0x20);\\n        }\\n    }\\n\\n    /// Reports the size of `bytes` data. Is the size of the length slot\\n    /// (32 bytes) plus the number of bytes as per its length.\\n    /// @return The size of the `bytes` data including its length slot size.\\n    function size(bytes memory bytes_) internal pure returns (uint256) {\\n        unchecked {\\n            return 0x20 + bytes_.length;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8d83afcdf42bce8f16b93f7c00f7059e02d86234e78f97ed9d2e19651da616d5\",\"license\":\"CAL\"},\"contracts/sentinel/LibSentinel.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nbytes32 constant SENTINEL_HIGH_BITS = bytes32(\\n    0xF000000000000000000000000000000000000000000000000000000000000000\\n);\\n\",\"keccak256\":\"0xd25db816643a702af32a6e0b14bc4ec4ed1acc7cb81c2e7c99f5bec324761c52\",\"license\":\"CAL\"},\"contracts/type/LibCast.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\nimport \\\"../interpreter/run/LibStackPointer.sol\\\";\\nimport \\\"../interpreter/run/LibInterpreterState.sol\\\";\\nimport \\\"../interpreter/deploy/LibIntegrityCheck.sol\\\";\\n\\n/// @title LibCast\\n/// @notice Additional type casting logic that the Solidity compiler doesn't\\n/// give us by default. A type cast (vs. conversion) is considered one where the\\n/// structure is unchanged by the cast. The cast does NOT (can't) check that the\\n/// input is a valid output, for example any integer MAY be cast to a function\\n/// pointer but almost all integers are NOT valid function pointers. It is the\\n/// calling context that MUST ensure the validity of the data, the cast will\\n/// merely retype the data in place, generally without additional checks.\\n/// As most structures in solidity have the same memory structure as a `uint256`\\n/// or fixed/dynamic array of `uint256` there are many conversions that can be\\n/// done with near zero or minimal overhead.\\nlibrary LibCast {\\n    /// Retype an integer to an opcode function pointer.\\n    /// @param u_ The integer to cast to an opcode function pointer.\\n    /// @return fn_ The opcode function pointer.\\n    function asOpFunctionPointer(\\n        uint256 u_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(InterpreterState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer) fn_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fn_ := u_\\n        }\\n    }\\n\\n    /// Retype an array of integers to an array of opcode function pointers.\\n    /// @param us_ The array of integers to cast to an array of opcode fuction\\n    /// pointers.\\n    /// @return fns_ The array of opcode function pointers.\\n    function asOpcodeFunctionPointers(\\n        uint256[] memory us_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(InterpreterState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer)[]\\n                memory fns_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fns_ := us_\\n        }\\n    }\\n\\n    /// Retype an integer to an integrity function pointer.\\n    /// @param u_ The integer to cast to an integrity function pointer.\\n    /// @return fn_ The integrity function pointer.\\n    function asIntegrityFunctionPointer(\\n        uint256 u_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(IntegrityCheckState memory, Operand, StackPointer)\\n                internal\\n                view\\n                returns (StackPointer) fn_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fn_ := u_\\n        }\\n    }\\n\\n    /// Retype a list of integrity check function pointers to a `uint256[]`.\\n    /// @param fns_ The list of function pointers.\\n    /// @return us_ The list of pointers as `uint256[]`.\\n    function asUint256Array(\\n        function(IntegrityCheckState memory, Operand, StackPointer)\\n            internal\\n            view\\n            returns (StackPointer)[]\\n            memory fns_\\n    ) internal pure returns (uint256[] memory us_) {\\n        assembly (\\\"memory-safe\\\") {\\n            us_ := fns_\\n        }\\n    }\\n\\n    /// Retype a list of interpreter opcode function pointers to a `uint256[]`.\\n    /// @param fns_ The list of function pointers.\\n    /// @return us_ The list of pointers as `uint256[]`.\\n    function asUint256Array(\\n        function(InterpreterState memory, Operand, StackPointer)\\n            view\\n            returns (StackPointer)[]\\n            memory fns_\\n    ) internal pure returns (uint256[] memory us_) {\\n        assembly (\\\"memory-safe\\\") {\\n            us_ := fns_\\n        }\\n    }\\n\\n    /// Retype a list of `uint256[]` to `address[]`.\\n    /// @param us_ The list of integers to cast to addresses.\\n    /// @return addresses_ The list of addresses cast from each integer.\\n    function asAddresses(\\n        uint256[] memory us_\\n    ) internal pure returns (address[] memory addresses_) {\\n        assembly (\\\"memory-safe\\\") {\\n            addresses_ := us_\\n        }\\n    }\\n\\n    /// Retype a list of integers to integrity check function pointers.\\n    /// @param us_ The list of integers to use as function pointers.\\n    /// @return fns_ The list of integrity check function pointers.\\n    function asIntegrityPointers(\\n        uint256[] memory us_\\n    )\\n        internal\\n        pure\\n        returns (\\n            function(IntegrityCheckState memory, Operand, StackPointer)\\n                view\\n                returns (StackPointer)[]\\n                memory fns_\\n        )\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            fns_ := us_\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9650d8d1876bd61c5a326f1fb5c04dc0f6407e65abcc92fdc29b8f050f5e02d3\",\"license\":\"CAL\"},\"contracts/type/LibConvert.sol\":{\"content\":\"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.15;\\n\\n/// @title LibConvert\\n/// @notice Type conversions that require additional structural changes to\\n/// complete safely. These are NOT mere type casts and involve additional\\n/// reads and writes to complete, such as recalculating the length of an array.\\n/// The convention \\\"toX\\\" is adopted from Rust to imply the additional costs and\\n/// consumption of the source to produce the target.\\nlibrary LibConvert {\\n    /// Convert an array of integers to `bytes` data. This requires modifying\\n    /// the length in situ as the integer array length is measured in 32 byte\\n    /// increments while the length of `bytes` is the literal number of bytes.\\n    /// @return bytes_ The integer array converted to `bytes` data.\\n    function toBytes(\\n        uint256[] memory us_\\n    ) internal pure returns (bytes memory bytes_) {\\n        assembly (\\\"memory-safe\\\") {\\n            bytes_ := us_\\n            // Length in bytes is 32x the length in uint256\\n            mstore(bytes_, mul(0x20, mload(bytes_)))\\n        }\\n    }\\n\\n    /// Truncate `uint256[]` values down to `uint16[]` then pack this to `bytes`\\n    /// without padding or length prefix. Unsafe because the starting `uint256`\\n    /// values are not checked for overflow due to the truncation. The caller\\n    /// MUST ensure that all values fit in `type(uint16).max` or that silent\\n    /// overflow is safe.\\n    /// @param us_ The `uint256[]` to truncate and concatenate to 16 bit `bytes`.\\n    /// @return The concatenated 2-byte chunks.\\n    function unsafeTo16BitBytes(\\n        uint256[] memory us_\\n    ) internal pure returns (bytes memory) {\\n        unchecked {\\n            // We will keep 2 bytes (16 bits) from each integer.\\n            bytes memory bytes_ = new bytes(us_.length * 2);\\n            assembly (\\\"memory-safe\\\") {\\n                let replaceMask_ := 0xFFFF\\n                let preserveMask_ := not(replaceMask_)\\n                for {\\n                    let cursor_ := add(us_, 0x20)\\n                    let end_ := add(cursor_, mul(mload(us_), 0x20))\\n                    let bytesCursor_ := add(bytes_, 0x02)\\n                } lt(cursor_, end_) {\\n                    cursor_ := add(cursor_, 0x20)\\n                    bytesCursor_ := add(bytesCursor_, 0x02)\\n                } {\\n                    let data_ := mload(bytesCursor_)\\n                    mstore(\\n                        bytesCursor_,\\n                        or(and(preserveMask_, data_), mload(cursor_))\\n                    )\\n                }\\n            }\\n            return bytes_;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd9e2df8b8ad347ec018df890eb4461df536de485407026f3761545753e9191de\",\"license\":\"CAL\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x60b0215121bf25612a6739fb2f1ec35f31ee82e4a8216c032c8243d904ab3aa9\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b50610019610099565b600060405161002790610159565b604051809103906000f080158015610043573d6000803e3d6000fd5b50604080513381526001600160a01b03831660208201529192507f7fac34ecf0b1b374cd9659e3d17db602659d53f1162b1f20142e6c02694aed70910160405180910390a16001600160a01b0316608052610167565b600054610100900460ff16156101055760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b60005460ff9081161015610157576000805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b615df5806200109a83390190565b608051610f116200018960003960008181609301526103020152610f116000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c80632ea72a49146100515780635c60da1b1461008e57806396c766bd146100b5578063fc91a897146100c8575b600080fd5b61006461005f3660046105ed565b610111565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b6100647f000000000000000000000000000000000000000000000000000000000000000081565b6100646100c336600461089b565b61023f565b6101016100d6366004610964565b73ffffffffffffffffffffffffffffffffffffffff1660009081526033602052604090205460ff1690565b6040519015158152602001610085565b600061011b61026f565b6000610126836102e2565b73ffffffffffffffffffffffffffffffffffffffff811660009081526033602052604090205490915060ff16156101a6576040517fd23867da00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff821660048201526024015b60405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff811660008181526033602090815260409182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790558151338152908101929092527f7da70c4e5387d7038610b79ca7d304caaef815826e51e67cf247135387a79bce910160405180910390a1905061023a60018055565b919050565b6000610269826040516020016102559190610ab4565b604051602081830303815290604052610111565b92915050565b6002600154036102db576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015260640161019d565b6002600155565b600080828060200190518101906102f99190610e21565b905060006103267f00000000000000000000000000000000000000000000000000000000000000006103b5565b6040517f178f03a100000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff82169063178f03a19061037b908590600401610ab4565b600060405180830381600087803b15801561039557600080fd5b505af11580156103a9573d6000803e3d6000fd5b50929695505050505050565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008260601b60e81c176000526e5af43d82803e903d91602b57fd5bf38260781b17602052603760096000f0905073ffffffffffffffffffffffffffffffffffffffff811661023a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f455243313136373a20637265617465206661696c656400000000000000000000604482015260640161019d565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156104ca576104ca610478565b60405290565b6040516060810167ffffffffffffffff811182821017156104ca576104ca610478565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561053a5761053a610478565b604052919050565b600067ffffffffffffffff82111561055c5761055c610478565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b600061059b61059684610542565b6104f3565b90508281528383830111156105af57600080fd5b828260208301376000602084830101529392505050565b600082601f8301126105d757600080fd5b6105e683833560208501610588565b9392505050565b6000602082840312156105ff57600080fd5b813567ffffffffffffffff81111561061657600080fd5b610622848285016105c6565b949350505050565b600067ffffffffffffffff82111561064457610644610478565b5060051b60200190565b600082601f83011261065f57600080fd5b8135602061066f6105968361062a565b82815260059290921b8401810191818101908684111561068e57600080fd5b8286015b848110156106a95780358352918301918301610692565b509695505050505050565b6000604082840312156106c657600080fd5b6106ce6104a7565b9050813567ffffffffffffffff808211156106e857600080fd5b818401915084601f8301126106fc57600080fd5b8135602061070c6105968361062a565b82815260059290921b8401810191818101908884111561072b57600080fd5b8286015b84811015610763578035868111156107475760008081fd5b6107558b86838b01016105c6565b84525091830191830161072f565b508652508581013593508284111561077a57600080fd5b6107868785880161064e565b818601525050505092915050565b73ffffffffffffffffffffffffffffffffffffffff811681146107b657600080fd5b50565b6000606082840312156107cb57600080fd5b6107d36104d0565b905081356107e081610794565b81526020828101356107f181610794565b82820152604083013567ffffffffffffffff8082111561081057600080fd5b818501915085601f83011261082457600080fd5b81356108326105968261062a565b81815260059190911b8301840190848101908883111561085157600080fd5b8585015b838110156108895780358581111561086d5760008081fd5b61087b8b89838a01016106b4565b845250918601918601610855565b50604087015250939695505050505050565b6000602082840312156108ad57600080fd5b813567ffffffffffffffff808211156108c557600080fd5b90830190606082860312156108d957600080fd5b6108e16104d0565b8235828111156108f057600080fd5b8301601f8101871361090157600080fd5b61091087823560208401610588565b82525060208301358281111561092557600080fd5b610931878286016106b4565b60208301525060408301358281111561094957600080fd5b610955878286016107b9565b60408301525095945050505050565b60006020828403121561097657600080fd5b81356105e681610794565b60005b8381101561099c578181015183820152602001610984565b50506000910152565b600081518084526109bd816020860160208601610981565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b60006040830182516040855281815180845260608701915060608160051b88010193506020808401935060005b82811015610a68577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0898703018452610a568686516109a5565b95509381019392810192600101610a1c565b508681015188860389830152805180875290820195600095508201935091505b81841015610aa85784518352938401936001939093019291820191610a88565b50909695505050505050565b600060208083528351606082850152610ad060808501826109a5565b9050818501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe080868403016040870152610b0b83836109ef565b92506040870151915080868403016060870152506060820173ffffffffffffffffffffffffffffffffffffffff8083511684528085840151168585015250604082015191506060604084015280825180835260808501915060808160051b8601019250858401935060005b81811015610bc2577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80868503018352610bb08486516109ef565b94870194935091860191600101610b76565b509198975050505050505050565b6000610bde61059684610542565b9050828152838383011115610bf257600080fd5b6105e6836020830184610981565b600082601f830112610c1157600080fd5b81516020610c216105968361062a565b82815260059290921b84018101918181019086841115610c4057600080fd5b8286015b848110156106a95780518352918301918301610c44565b60006040808385031215610c6e57600080fd5b610c766104a7565b9150825167ffffffffffffffff80821115610c9057600080fd5b818501915085601f830112610ca457600080fd5b81516020610cb46105968361062a565b82815260059290921b84018101918181019089841115610cd357600080fd5b8286015b84811015610d1f57805186811115610cef5760008081fd5b8701603f81018c13610d015760008081fd5b610d118c868301518b8401610bd0565b845250918301918301610cd7565b5087525086810151945082851115610d3657600080fd5b610d4288868901610c00565b81870152505050505092915050565b600060608284031215610d6357600080fd5b610d6b6104d0565b90508151610d7881610794565b8152602082810151610d8981610794565b82820152604083015167ffffffffffffffff80821115610da857600080fd5b818501915085601f830112610dbc57600080fd5b8151610dca6105968261062a565b81815260059190911b83018401908481019088831115610de957600080fd5b8585015b8381101561088957805185811115610e055760008081fd5b610e138b89838a0101610c5b565b845250918601918601610ded565b600060208284031215610e3357600080fd5b815167ffffffffffffffff80821115610e4b57600080fd5b9083019060608286031215610e5f57600080fd5b610e676104d0565b825182811115610e7657600080fd5b8301601f81018713610e8757600080fd5b610e9687825160208401610bd0565b825250602083015182811115610eab57600080fd5b610eb787828601610c5b565b602083015250604083015182811115610ecf57600080fd5b61095587828601610d5156fea2646970667358221220a3ed6d5590676d1d26ca39ddf3151745da9ebf20662533a0f164b84baf10b0b164736f6c6343000811003360806040523480156200001157600080fd5b506200001c62000022565b620000e4565b600054610100900460ff16156200008f5760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b60005460ff9081161015620000e2576000805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b615d0180620000f46000396000f3fe6080604052600436106100eb5760003560e01c8063522fb10b1161008a578063bc197c8111610059578063bc197c81146102d4578063e985e9c514610319578063f23a6e6114610370578063f242432a146103b557600080fd5b8063522fb10b14610247578063a22cb46514610267578063ac9650d814610287578063ae910b3d146102b457600080fd5b8063150b7a02116100c6578063150b7a0214610187578063178f03a1146101d85780632eb2c2d6146101fa5780634e1273f41461021a57600080fd5b8062fdd58e146100f757806301ffc9a71461012a5780630e89341c1461015a57600080fd5b366100f257005b600080fd5b34801561010357600080fd5b50610117610112366004614439565b6103d5565b6040519081526020015b60405180910390f35b34801561013657600080fd5b5061014a610145366004614493565b6104b8565b6040519015158152602001610121565b34801561016657600080fd5b5061017a6101753660046144b0565b6104c3565b6040516101219190614537565b34801561019357600080fd5b506101a76101a236600461469c565b610558565b6040517fffffffff000000000000000000000000000000000000000000000000000000009091168152602001610121565b3480156101e457600080fd5b506101f86101f3366004614708565b610582565b005b34801561020657600080fd5b506101f86102153660046147cd565b610897565b34801561022657600080fd5b5061023a61023536600461487b565b610960565b6040516101219190614983565b61025a610255366004614996565b610ab8565b6040516101219190614c4d565b34801561027357600080fd5b506101f8610282366004614d7c565b610ad5565b34801561029357600080fd5b506102a76102a2366004614db5565b610ae0565b6040516101219190614e7c565b3480156102c057600080fd5b5061025a6102cf366004614996565b610bd5565b3480156102e057600080fd5b506101a76102ef3660046147cd565b7fbc197c810000000000000000000000000000000000000000000000000000000095945050505050565b34801561032557600080fd5b5061014a610334366004614e8f565b73ffffffffffffffffffffffffffffffffffffffff91821660009081526101626020908152604080832093909416825291909152205460ff1690565b34801561037c57600080fd5b506101a761038b366004614ebd565b7ff23a6e610000000000000000000000000000000000000000000000000000000095945050505050565b3480156103c157600080fd5b506101f86103d0366004614ebd565b610bf4565b600073ffffffffffffffffffffffffffffffffffffffff831661047f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f455243313135353a2061646472657373207a65726f206973206e6f742061207660448201527f616c6964206f776e65720000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b5060008181526101616020908152604080832073ffffffffffffffffffffffffffffffffffffffff861684529091529020545b92915050565b60006104b282610cb6565b606061016380546104d390614f26565b80601f01602080910402602001604051908101604052809291908181526020018280546104ff90614f26565b801561054c5780601f106105215761010080835404028352916020019161054c565b820191906000526020600020905b81548152906001019060200180831161052f57829003601f168201915b50505050509050919050565b7f150b7a02000000000000000000000000000000000000000000000000000000005b949350505050565b600054610100900460ff16158080156105a25750600054600160ff909116105b806105bc5750303b1580156105bc575060005460ff166001145b610648576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152608401610476565b600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600117905580156106a657600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff166101001790555b7f19380e2469ce4204d94902f1afc612d3c14171ee7acf924ccedc6d16f189e21f33836040516106d79291906151b5565b60405180910390a16106e7610d58565b61072e6106f4838061533b565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610df992505050565b600061073d60408401846153a0565b61074b9060208101906153de565b73ffffffffffffffffffffffffffffffffffffffff16631ed061d961077360208601866153fb565b61077d6001610e9c565b6040518363ffffffff1660e01b815260040161079a92919061542f565b6020604051808303816000875af11580156107b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107dd9190615454565b9050602081901b77ffffffffffffffffffffffffffffffffffffffff00000000166001176101935561082f61081560408501856153a0565b61081e90615471565b61082a6004600261567e565b610ece565b50801561089357600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00ff169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5050565b73ffffffffffffffffffffffffffffffffffffffff85163314806108c057506108c08533610334565b61094c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f455243313135353a2063616c6c6572206973206e6f7420746f6b656e206f776e60448201527f6572206f7220617070726f7665640000000000000000000000000000000000006064820152608401610476565b61095985858585856111a1565b5050505050565b606081518351146109f3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f455243313135353a206163636f756e747320616e6420696473206c656e67746860448201527f206d69736d6174636800000000000000000000000000000000000000000000006064820152608401610476565b6000835167ffffffffffffffff811115610a0f57610a0f61454a565b604051908082528060200260200182016040528015610a38578160200160208202803683370190505b50905060005b8451811015610ab057610a83858281518110610a5c57610a5c615691565b6020026020010151858381518110610a7657610a76615691565b60200260200101516103d5565b828281518110610a9557610a95615691565b6020908102919091010152610aa9816156c0565b9050610a3e565b509392505050565b610ac06143ce565b610acb8484846114ee565b90505b9392505050565b610893338383611661565b60608167ffffffffffffffff811115610afb57610afb61454a565b604051908082528060200260200182016040528015610b2e57816020015b6060815260200190600190039081610b195790505b50905060005b82811015610bce57610b9e30858584818110610b5257610b52615691565b9050602002810190610b64919061533b565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506117b592505050565b828281518110610bb057610bb0615691565b60200260200101819052508080610bc6906156c0565b915050610b34565b5092915050565b610bdd6143ce565b6000610bea8585856118f4565b5095945050505050565b73ffffffffffffffffffffffffffffffffffffffff8516331480610c1d5750610c1d8533610334565b610ca9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f455243313135353a2063616c6c6572206973206e6f7420746f6b656e206f776e60448201527f6572206f7220617070726f7665640000000000000000000000000000000000006064820152608401610476565b6109598585858585611a13565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167fd9b67a26000000000000000000000000000000000000000000000000000000001480610d4957507fffffffff0000000000000000000000000000000000000000000000000000000082167f0e89341c00000000000000000000000000000000000000000000000000000000145b806104b257506104b282611c65565b600054610100900460ff16610def576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152608401610476565b610df7611cfc565b565b600054610100900460ff16610e90576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152608401610476565b610e9981611d99565b50565b604080516001808252818301909252606091600091906020808301908036833750505060208101939093525090919050565b600054610100900460ff16610f65576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152608401610476565b610f6d611e39565b610f75611e39565b610f7d611e39565b6004811015610fe8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f424144204d494e20535441434b53204c454e47544800000000000000000000006044820152606401610476565b602082015161015f80547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff90921691909117905560005b82604001515181101561119c576000836000015173ffffffffffffffffffffffffffffffffffffffff16631ed061d98560400151848151811061107a5761107a615691565b602002602001015161108b86610e9c565b6040518363ffffffff1660e01b81526004016110a89291906156f8565b6020604051808303816000875af11580156110c7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110eb9190615454565b90506000602082901b77ffffffffffffffffffffffffffffffffffffffff000000001661ffff17600081815261016060209081526040918290206001905587810151825133815273ffffffffffffffffffffffffffffffffffffffff909116918101919091529081018290529091507f0392789afa55e5b564b41f5e52285c849fc771b31ccc0e222999b6de72bc55949060600160405180910390a150508080611194906156c0565b915050611035565b505050565b8151835114611232576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f455243313135353a2069647320616e6420616d6f756e7473206c656e6774682060448201527f6d69736d617463680000000000000000000000000000000000000000000000006064820152608401610476565b73ffffffffffffffffffffffffffffffffffffffff84166112d5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f455243313135353a207472616e7366657220746f20746865207a65726f20616460448201527f64726573730000000000000000000000000000000000000000000000000000006064820152608401610476565b3360005b845181101561144b5760008582815181106112f6576112f6615691565b60200260200101519050600085838151811061131457611314615691565b60209081029190910181015160008481526101618352604080822073ffffffffffffffffffffffffffffffffffffffff8e1683529093529190912054909150818110156113e3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f455243313135353a20696e73756666696369656e742062616c616e636520666f60448201527f72207472616e73666572000000000000000000000000000000000000000000006064820152608401610476565b60008381526101616020908152604080832073ffffffffffffffffffffffffffffffffffffffff8e8116855292528083208585039055908b1682528120805484929061143090849061567e565b9250508190555050505080611444906156c0565b90506112d9565b508473ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff167f4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb87876040516114c2929190615763565b60405180910390a46114d8818787878787611ed0565b6114e68187878787876121bc565b505050505050565b6114f66143ce565b6114fe61244f565b60008061150c8686866118f4565b9150915060005b8251518110156115a35761159b8360000151828151811061153657611536615691565b6020026020010151600001518460000151838151811061155857611558615691565b6020026020010151602001518560000151848151811061157a5761157a615691565b602002602001015160400151604051806020016040528060008152506124c2565b600101611513565b5060005b82602001515181101561162a57611622836020015182815181106115cd576115cd615691565b602002602001015160000151846020015183815181106115ef576115ef615691565b6020026020010151602001518560200151848151811061161157611611615691565b60200260200101516040015161263c565b6001016115a7565b50604082015161015f54611655919073ffffffffffffffffffffffffffffffffffffffff1683612855565b509050610ace60018055565b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff160361171c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602960248201527f455243313135353a2073657474696e6720617070726f76616c2073746174757360448201527f20666f722073656c6600000000000000000000000000000000000000000000006064820152608401610476565b73ffffffffffffffffffffffffffffffffffffffff8381166000818152610162602090815260408083209487168084529482529182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001686151590811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a3505050565b606073ffffffffffffffffffffffffffffffffffffffff83163b61185b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e747261637400000000000000000000000000000000000000000000000000006064820152608401610476565b6000808473ffffffffffffffffffffffffffffffffffffffff16846040516118839190615776565b600060405180830381855af49150503d80600081146118be576040519150601f19603f3d011682016040523d82523d6000602084013e6118c3565b606091505b50915091506118eb8282604051806060016040528060278152602001615ca560279139612905565b95945050505050565b6118fc6143ce565b6060806119076143ce565b60008060006119178a8a8a61291e565b60408051808201909152601a81527f5241494e5f464c4f575f455243313135355f53454e54494e454c0000000000006020909101529194509250905061198082847ff3d9dabdb0009f2a4a1d315a6b607c74e619b5620e01f1130e4142970ffaf7676003612aa6565b80865260408051808201909152601a81527f5241494e5f464c4f575f455243313135355f53454e54494e454c000000000000602090910152955091506119e982847ff3d9dabdb0009f2a4a1d315a6b607c74e619b5620e01f1130e4142970ffaf7676003612aa6565b60208601819052955091506119fe8383612b57565b60408501529299929850919650505050505050565b73ffffffffffffffffffffffffffffffffffffffff8416611ab6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f455243313135353a207472616e7366657220746f20746865207a65726f20616460448201527f64726573730000000000000000000000000000000000000000000000000000006064820152608401610476565b336000611ac285612d63565b90506000611acf85612d63565b905060008681526101616020908152604080832073ffffffffffffffffffffffffffffffffffffffff8c16845290915290205485811015611b92576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f455243313135353a20696e73756666696369656e742062616c616e636520666f60448201527f72207472616e73666572000000000000000000000000000000000000000000006064820152608401610476565b60008781526101616020908152604080832073ffffffffffffffffffffffffffffffffffffffff8d8116855292528083208985039055908a16825281208054889290611bdf90849061567e565b9091555050604080518881526020810188905273ffffffffffffffffffffffffffffffffffffffff808b16928c821692918816917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a4611c4c848a8a86868a611ed0565b611c5a848a8a8a8a8a612dae565b505050505050505050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f4e2312e00000000000000000000000000000000000000000000000000000000014806104b257507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316146104b2565b600054610100900460ff16611d93576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152608401610476565b60018055565b600054610100900460ff16611e30576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152608401610476565b610e9981612f5b565b600054610100900460ff16610df7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e670000000000000000000000000000000000000000006064820152608401610476565b73ffffffffffffffffffffffffffffffffffffffff85161580611f07575073ffffffffffffffffffffffffffffffffffffffff8416155b6114e65761015f546101935473ffffffffffffffffffffffffffffffffffffffff9091169060005b8551811015611c5a576000611fda611fd53373ffffffffffffffffffffffffffffffffffffffff168c73ffffffffffffffffffffffffffffffffffffffff168c73ffffffffffffffffffffffffffffffffffffffff168c73ffffffffffffffffffffffffffffffffffffffff168c8881518110611fae57611fae615691565b60200260200101518c8981518110611fc857611fc8615691565b6020026020010151612f68565b612fb8565b90506000808573ffffffffffffffffffffffffffffffffffffffff166390e7d00b86856040518363ffffffff1660e01b815260040161201a929190615788565b600060405180830381865afa158015612037573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016820160405261207d9190810190615876565b9150915060006120be61209884805160209081029091010190565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015190565b11612125576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f494e56414c49445f5452414e53464552000000000000000000000000000000006044820152606401610476565b8051156121b1576040517fce0dd62800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff87169063ce0dd6289061217e908490600401614983565b600060405180830381600087803b15801561219857600080fd5b505af11580156121ac573d6000803e3d6000fd5b505050505b505050600101611f2f565b73ffffffffffffffffffffffffffffffffffffffff84163b156114e6576040517fbc197c8100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff85169063bc197c819061223390899089908890889088906004016158d0565b6020604051808303816000875af192505050801561228c575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01682019092526122899181019061592f565b60015b6123755761229861594c565b806308c379a0036122eb57506122ac615968565b806122b757506122ed565b806040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104769190614537565b505b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603460248201527f455243313135353a207472616e7366657220746f206e6f6e2d4552433131353560448201527f526563656976657220696d706c656d656e7465720000000000000000000000006064820152608401610476565b7fffffffff0000000000000000000000000000000000000000000000000000000081167fbc197c810000000000000000000000000000000000000000000000000000000014612446576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f455243313135353a204552433131353552656365697665722072656a6563746560448201527f6420746f6b656e730000000000000000000000000000000000000000000000006064820152608401610476565b50505050505050565b6002600154036124bb576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610476565b6002600155565b73ffffffffffffffffffffffffffffffffffffffff8416612565576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602160248201527f455243313135353a206d696e7420746f20746865207a65726f2061646472657360448201527f73000000000000000000000000000000000000000000000000000000000000006064820152608401610476565b33600061257185612d63565b9050600061257e85612d63565b905060008681526101616020908152604080832073ffffffffffffffffffffffffffffffffffffffff8b168452909152812080548792906125c090849061567e565b9091555050604080518781526020810187905273ffffffffffffffffffffffffffffffffffffffff808a1692600092918716917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a461262d83600089858589611ed0565b61244683600089898989612dae565b73ffffffffffffffffffffffffffffffffffffffff83166126df576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602360248201527f455243313135353a206275726e2066726f6d20746865207a65726f206164647260448201527f65737300000000000000000000000000000000000000000000000000000000006064820152608401610476565b3360006126eb84612d63565b905060006126f884612d63565b6040805160208082018352600091829052888252610161815282822073ffffffffffffffffffffffffffffffffffffffff8b16835290522054909150848110156127c3576040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f455243313135353a206275726e20616d6f756e7420657863656564732062616c60448201527f616e6365000000000000000000000000000000000000000000000000000000006064820152608401610476565b60008681526101616020908152604080832073ffffffffffffffffffffffffffffffffffffffff8b81168086529184528285208a8703905582518b81529384018a90529092908816917fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62910160405180910390a461244684886000868660405180602001604052806000815250611ed0565b8051156128e1576040517fce0dd62800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83169063ce0dd628906128ae908490600401614983565b600060405180830381600087803b1580156128c857600080fd5b505af11580156128dc573d6000803e3d6000fd5b505050505b6128ea83612ff6565b6128f38361322a565b6128fc836133b8565b61119c83613575565b60608315612914575081610ace565b610ace8383613751565b600083815261016060205260408120548190606090869061299b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f554e524547495354455245445f464c4f570000000000000000000000000000006044820152606401610476565b61015f54600090819073ffffffffffffffffffffffffffffffffffffffff166390e7d00b8a6129ff846040519080825280602002602001820160405280156129f757816020015b60608152602001906001900390816129e25790505b508c8c613761565b6040518363ffffffff1660e01b8152600401612a1c929190615788565b600060405180830381865afa158015612a39573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052612a7f9190810190615876565b91509150612a8d8260200190565b8251909a60209182029093010198509650945050505050565b600060608180612ab888888888613acb565b915091506000858251612acb9190615a10565b905060008167ffffffffffffffff811115612ae857612ae861454a565b604051908082528060200260200182016040528015612b11578160200160208202803683370190505b509050602081016020830281016020850160208a025b82841015612b415781845260209093019290810190612b27565b5095975091955050505050505b94509492505050565b612b826040518060800160405280606081526020016060815260200160608152602001606081525090565b612bad6040518060800160405280606081526020016060815260200160608152602001606081525090565b60408051808201909152601281527f5241494e5f464c4f575f53454e54494e454c00000000000000000000000000006020909101526060612c1184867ffea74d0c9bf4a3c28f0dd0674db22a3d7f8bf259c56af19f4ac1e735b156974f6003612aa6565b80845260408051808201909152601281527f5241494e5f464c4f575f53454e54494e454c00000000000000000000000000006020909101529094509050612c7b84867ffea74d0c9bf4a3c28f0dd0674db22a3d7f8bf259c56af19f4ac1e735b156974f6004612aa6565b602084810182905260408051808201909152601281527f5241494e5f464c4f575f53454e54494e454c00000000000000000000000000009101529094509050612ce784867ffea74d0c9bf4a3c28f0dd0674db22a3d7f8bf259c56af19f4ac1e735b156974f6004612aa6565b60408481018290528051808201909152601281527f5241494e5f464c4f575f53454e54494e454c00000000000000000000000000006020909101529094509050612d5484867ffea74d0c9bf4a3c28f0dd0674db22a3d7f8bf259c56af19f4ac1e735b156974f6005612aa6565b60608401525090949350505050565b60408051600180825281830190925260609160009190602080830190803683370190505090508281600081518110612d9d57612d9d615691565b602090810291909101015292915050565b73ffffffffffffffffffffffffffffffffffffffff84163b156114e6576040517ff23a6e6100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff85169063f23a6e6190612e259089908990889088908890600401615a4b565b6020604051808303816000875af1925050508015612e7e575060408051601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201909252612e7b9181019061592f565b60015b612e8a5761229861594c565b7fffffffff0000000000000000000000000000000000000000000000000000000081167ff23a6e610000000000000000000000000000000000000000000000000000000014612446576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f455243313135353a204552433131353552656365697665722072656a6563746560448201527f6420746f6b656e730000000000000000000000000000000000000000000000006064820152608401610476565b6101636108938282615ad6565b60408051600680825260e08201909252606091600091906020820160c0803683375050506020810198909852505060408601949094526060850192909252608084015260a083015260c082015290565b60408051600180825281830190925260609160009190816020015b6060815260200190600190039081612fd357505060208101939093525090919050565b60408051606081018252600080825260208201819052918101829052819060005b84515181101561320557845180518290811061303557613035615691565b602002602001015191503373ffffffffffffffffffffffffffffffffffffffff16826000015173ffffffffffffffffffffffffffffffffffffffff160361310757602082015173ffffffffffffffffffffffffffffffffffffffff1630146130f9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f554e535550504f525445445f4e41544956455f464c4f570000000000000000006044820152606401610476565b8160400151840193506131fd565b815173ffffffffffffffffffffffffffffffffffffffff163014613187576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f554e535550504f525445445f4e41544956455f464c4f570000000000000000006044820152606401610476565b3373ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff16036131cc578160400151830192506131fd565b6131fd8260400151836020015173ffffffffffffffffffffffffffffffffffffffff16613b2b90919063ffffffff16565b600101613017565b50821561321457823403820191505b8115613224576132243383613b2b565b50505050565b6040805160808101825260008082526020820181905291810182905260608101829052905b82602001515181101561119c578260200151818151811061327257613272615691565b602002602001015191503373ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff16036132e9576040820151606083015183516132e49273ffffffffffffffffffffffffffffffffffffffff90911691339190613c85565b6133b0565b3073ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff160361334e576040820151606083015183516132e49273ffffffffffffffffffffffffffffffffffffffff90911691613d61565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f554e535550504f525445445f45524332305f464c4f57000000000000000000006044820152606401610476565b60010161324f565b6040805160808101825260008082526020820181905291810182905260608101829052905b82604001515181101561119c578260400151818151811061340057613400615691565b602002602001015191503373ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff1614806134615750602082015173ffffffffffffffffffffffffffffffffffffffff1630145b6134c7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f554e535550504f525445445f4552433732315f464c4f570000000000000000006044820152606401610476565b81516020830151604080850151606086015191517f42842e0e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9384166004820152908316602482015260448101919091529116906342842e0e90606401600060405180830381600087803b15801561355157600080fd5b505af1158015613565573d6000803e3d6000fd5b5050600190920191506133dd9050565b6040805160a0810182526000808252602082018190529181018290526060810182905260808101829052905b82606001515181101561119c57826060015181815181106135c4576135c4615691565b602002602001015191503373ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff1614806136255750602082015173ffffffffffffffffffffffffffffffffffffffff1630145b61368b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f554e535550504f525445445f455243313135355f464c4f5700000000000000006044820152606401610476565b815160208301516040808501516060860151608087015192517ff242432a00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff948516600482015291841660248301526044820152606481019190915260a06084820152600060a482015291169063f242432a9060c401600060405180830381600087803b15801561372d57600080fd5b505af1158015613741573d6000803e3d6000fd5b5050600190920191506135a19050565b8151156122b75781518083602001fd5b60606000825167ffffffffffffffff81111561377f5761377f61454a565b6040519080825280602002602001820160405280156137a8578160200160208202803683370190505b5090506000808451116137bc5760006137c2565b83516001015b865101600201905060008167ffffffffffffffff8111156137e5576137e561454a565b60405190808252806020026020018201604052801561381857816020015b60608152602001906001900390816138035790505b5090506000613825613db7565b82828151811061383757613837615691565b602002602001018190525060005b885181101561389557818060010192505088818151811061386857613868615691565b602002602001015183838151811061388257613882615691565b6020908102919091010152600101613845565b508080600101915050868282815181106138b1576138b1615691565b6020908102919091010152855115613ac0578080600101915050838282815181106138de576138de615691565b602002602001018190525060005b8651811015613abe576139e887828151811061390a5761390a615691565b6020026020010151600001516139c589848151811061392b5761392b615691565b6020026020010151604001516040516020016139479190615bf0565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081840301815282825280516020918201207f19457468657265756d205369676e6564204d6573736167653a0a33320000000084830152603c8085019190915282518085039091018152605c909301909152815191012090565b8984815181106139d7576139d7615691565b602002602001015160200151613dc8565b613a21576040517f52bf984800000000000000000000000000000000000000000000000000000000815260048101829052602401610476565b868181518110613a3357613a33615691565b60200260200101516000015173ffffffffffffffffffffffffffffffffffffffff16858281518110613a6757613a67615691565b6020026020010181815250508180600101925050868181518110613a8d57613a8d615691565b602002602001015160400151838381518110613aab57613aab615691565b60209081029190910101526001016138ec565b505b509695505050505050565b600060608085613ada57600080fd5b6000806020860260208a039950602089035b808b1115613b12578a518903613b04578a9350613b12565b998190039991870191613aec565b505081613b1e57600080fd5b8152969795505050505050565b80471015613b95576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a20696e73756666696369656e742062616c616e63650000006044820152606401610476565b60008273ffffffffffffffffffffffffffffffffffffffff168260405160006040518083038185875af1925050503d8060008114613bef576040519150601f19603f3d011682016040523d82523d6000602084013e613bf4565b606091505b505090508061119c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f416464726573733a20756e61626c6520746f2073656e642076616c75652c207260448201527f6563697069656e74206d617920686176652072657665727465640000000000006064820152608401610476565b60405173ffffffffffffffffffffffffffffffffffffffff808516602483015283166044820152606481018290526132249085907f23b872dd00000000000000000000000000000000000000000000000000000000906084015b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152613f95565b60405173ffffffffffffffffffffffffffffffffffffffff831660248201526044810182905261119c9084907fa9059cbb0000000000000000000000000000000000000000000000000000000090606401613cdf565b6060613dc333306140a1565b905090565b6000806000613dd785856140d5565b90925090506000816004811115613df057613df0615c26565b148015613e2857508573ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b15613e3857600192505050610ace565b6000808773ffffffffffffffffffffffffffffffffffffffff16631626ba7e60e01b8888604051602401613e6d929190615c55565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909416939093179092529051613ef69190615776565b600060405180830381855afa9150503d8060008114613f31576040519150601f19603f3d011682016040523d82523d6000602084013e613f36565b606091505b5091509150818015613f49575080516020145b8015613f89575080517f1626ba7e0000000000000000000000000000000000000000000000000000000090613f879083016020908101908401615c6e565b145b98975050505050505050565b6000613ff7826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c65648152508573ffffffffffffffffffffffffffffffffffffffff1661411a9092919063ffffffff16565b80519091501561119c57808060200190518101906140159190615c87565b61119c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f742073756363656564000000000000000000000000000000000000000000006064820152608401610476565b6040805160028082526060808301845292600092919060208301908036833750505060208101949094525050604082015290565b600080825160410361410b5760208301516040840151606085015160001a6140ff87828585614129565b94509450505050614113565b506000905060025b9250929050565b6060610acb8484600085614215565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08311156141605750600090506003612b4e565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa1580156141b4573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff811661420857600060019250925050612b4e565b9660009650945050505050565b6060824710156142a7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c00000000000000000000000000000000000000000000000000006064820152608401610476565b6000808673ffffffffffffffffffffffffffffffffffffffff1685876040516142d09190615776565b60006040518083038185875af1925050503d806000811461430d576040519150601f19603f3d011682016040523d82523d6000602084013e614312565b606091505b50915091506143238783838761432e565b979650505050505050565b606083156143c45782516000036143bd5773ffffffffffffffffffffffffffffffffffffffff85163b6143bd576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610476565b508161057a565b61057a8383613751565b604051806060016040528060608152602001606081526020016144126040518060800160405280606081526020016060815260200160608152602001606081525090565b905290565b73ffffffffffffffffffffffffffffffffffffffff81168114610e9957600080fd5b6000806040838503121561444c57600080fd5b823561445781614417565b946020939093013593505050565b7fffffffff0000000000000000000000000000000000000000000000000000000081168114610e9957600080fd5b6000602082840312156144a557600080fd5b8135610ace81614465565b6000602082840312156144c257600080fd5b5035919050565b60005b838110156144e45781810151838201526020016144cc565b50506000910152565b600081518084526145058160208601602086016144c9565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526000610ace60208301846144ed565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6060810181811067ffffffffffffffff821117156145995761459961454a565b60405250565b6040810181811067ffffffffffffffff821117156145995761459961454a565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f830116810181811067ffffffffffffffff821117156146035761460361454a565b6040525050565b600082601f83011261461b57600080fd5b813567ffffffffffffffff8111156146355761463561454a565b60405161466a60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f85011601826145bf565b81815284602083860101111561467f57600080fd5b816020850160208301376000918101602001919091529392505050565b600080600080608085870312156146b257600080fd5b84356146bd81614417565b935060208501356146cd81614417565b925060408501359150606085013567ffffffffffffffff8111156146f057600080fd5b6146fc8782880161460a565b91505092959194509250565b60006020828403121561471a57600080fd5b813567ffffffffffffffff81111561473157600080fd5b820160608185031215610ace57600080fd5b600067ffffffffffffffff82111561475d5761475d61454a565b5060051b60200190565b600082601f83011261477857600080fd5b8135602061478582614743565b60405161479282826145bf565b83815260059390931b85018201928281019150868411156147b257600080fd5b8286015b84811015613ac057803583529183019183016147b6565b600080600080600060a086880312156147e557600080fd5b85356147f081614417565b9450602086013561480081614417565b9350604086013567ffffffffffffffff8082111561481d57600080fd5b61482989838a01614767565b9450606088013591508082111561483f57600080fd5b61484b89838a01614767565b9350608088013591508082111561486157600080fd5b5061486e8882890161460a565b9150509295509295909350565b6000806040838503121561488e57600080fd5b823567ffffffffffffffff808211156148a657600080fd5b818501915085601f8301126148ba57600080fd5b813560206148c782614743565b6040516148d482826145bf565b83815260059390931b85018201928281019150898411156148f457600080fd5b948201945b8386101561491b57853561490c81614417565b825294820194908201906148f9565b9650508601359250508082111561493157600080fd5b5061493e85828601614767565b9150509250929050565b600081518084526020808501945080840160005b838110156149785781518752958201959082019060010161495c565b509495945050505050565b602081526000610ace6020830184614948565b6000806000606084860312156149ab57600080fd5b8335925060208085013567ffffffffffffffff808211156149cb57600080fd5b6149d788838901614767565b945060408701359150808211156149ed57600080fd5b818701915087601f830112614a0157600080fd5b8135614a0c81614743565b604051614a1982826145bf565b82815260059290921b840185019185810191508a831115614a3957600080fd5b8585015b83811015614afc57803585811115614a5457600080fd5b86016060818e037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0011215614a8857600080fd5b604051614a9481614579565b88820135614aa181614417565b8152604082013587811115614ab557600080fd5b614ac38f8b8386010161460a565b8a83015250606082013587811115614ada57600080fd5b614ae88f8b83860101614767565b604083015250845250918601918601614a3d565b508096505050505050509250925092565b600081518084526020808501945080840160005b83811015614978578151805173ffffffffffffffffffffffffffffffffffffffff16885283810151848901526040908101519088015260609096019590820190600101614b21565b600081518084526020808501945080840160005b83811015614978578151805173ffffffffffffffffffffffffffffffffffffffff9081168952848201518116858a0152604080830151909116908901526060908101519088015260809096019590820190600101614b7d565b600081518084526020808501945080840160005b83811015614978578151805173ffffffffffffffffffffffffffffffffffffffff9081168952848201518116858a015260408083015190911690890152606080820151908901526080908101519088015260a09096019590820190600101614bea565b60006020808352835160608083860152614c6a6080860183614b0d565b9150828601517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe06040818886030181890152614ca68584614b0d565b89820151898203909301858a01528251608080835281519083018190529196509293509186019160009060a08701905b80831015614d20578451805173ffffffffffffffffffffffffffffffffffffffff90811684528a820151168a84015284015184830152938801936001929092019190860190614cd6565b5087850151935086810388880152614d388185614b69565b975050508083015191508486038186015250614d548582614b69565b945050818101519050828403828401526143238482614bd6565b8015158114610e9957600080fd5b60008060408385031215614d8f57600080fd5b8235614d9a81614417565b91506020830135614daa81614d6e565b809150509250929050565b60008060208385031215614dc857600080fd5b823567ffffffffffffffff80821115614de057600080fd5b818501915085601f830112614df457600080fd5b813581811115614e0357600080fd5b8660208260051b8501011115614e1857600080fd5b60209290920196919550909350505050565b6000815180845260208085019450848260051b860182860160005b85811015614e6f578383038952614e5d8383516144ed565b98850198925090840190600101614e45565b5090979650505050505050565b602081526000610ace6020830184614e2a565b60008060408385031215614ea257600080fd5b8235614ead81614417565b91506020830135614daa81614417565b600080600080600060a08688031215614ed557600080fd5b8535614ee081614417565b94506020860135614ef081614417565b93506040860135925060608601359150608086013567ffffffffffffffff811115614f1a57600080fd5b61486e8882890161460a565b600181811c90821680614f3a57607f821691505b602082108103614f73577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b50919050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112614fae57600080fd5b830160208101925035905067ffffffffffffffff811115614fce57600080fd5b80360382131561411357600080fd5b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc183360301811261505a57600080fd5b90910192915050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261509857600080fd5b830160208101925035905067ffffffffffffffff8111156150b857600080fd5b8060051b360382131561411357600080fd5b6000604083016150da8384615063565b604086528281845260608701905060608260051b88010193508260005b83811015615152577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa08987030183526151308286614f79565b61513b888284614fdd565b9750505060209283019291909101906001016150f7565b50505050506151646020840184615063565b85830360208701528083527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81111561519c57600080fd5b60051b8082602085013791909101602001949350505050565b600073ffffffffffffffffffffffffffffffffffffffff808516835260206040818501526151e38586614f79565b606060408701526151f860a087018284614fdd565b91505061520782870187615026565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc08087840301606088015261523c83836150ca565b9250604088013591507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa188360301821261527557600080fd5b868303016080870152860160608201813561528f81614417565b85168352818401356152a081614417565b8516838501526152b36040830183615063565b95509150606060408401528085825260808401905060808660051b85010191508260005b8781101561532b577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80868503018352615319846153148488615026565b6150ca565b935091860191908601906001016152d7565b50919a9950505050505050505050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261537057600080fd5b83018035915067ffffffffffffffff82111561538b57600080fd5b60200191503681900382131561411357600080fd5b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa18336030181126153d457600080fd5b9190910192915050565b6000602082840312156153f057600080fd5b8135610ace81614417565b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc18336030181126153d457600080fd5b60408152600061544260408301856150ca565b82810360208401526118eb8185614948565b60006020828403121561546657600080fd5b8151610ace81614417565b60006060823603121561548357600080fd5b60405161548f81614579565b6154998335614417565b823581526020808401356154ac81614417565b82820152604084013567ffffffffffffffff808211156154cb57600080fd5b9085019036601f8301126154de57600080fd5b6154e88235614743565b6040516154f582826145bf565b8335808252858201925060051b840185013681111561551357600080fd5b8585015b8181101561563d57848135111561552d57600080fd5b8035860160407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe082360301121561556357600080fd5b60405161556f8161459f565b888201358781111561558057600080fd5b820136603f82011261559157600080fd5b8981013561559e81614743565b6040516155ab82826145bf565b82815260059290921b8301604001918c81019150368311156155cc57600080fd5b604084015b83811015615604578b813511156155e757600080fd5b6155f7366040833588010161460a565b8352918d01918d016155d1565b50845250505060408201358781111561561c57600080fd5b61562a368b83860101614767565b828b015250855250928601928601615517565b50506040860152509295945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b808201808211156104b2576104b261564f565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036156f1576156f161564f565b5060010190565b60408152600083516040808401526157136080840182614e2a565b905060208501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc084830301606085015261574e8282614948565b91505082810360208401526118eb8185614948565b6040815260006154426040830185614948565b600082516153d48184602087016144c9565b600060408201848352602060408185015281855180845260608601915060608160051b870101935082870160005b82811015615802577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa08887030184526157f0868351614948565b955092840192908401906001016157b6565b509398975050505050505050565b600082601f83011261582157600080fd5b8151602061582e82614743565b60405161583b82826145bf565b83815260059390931b850182019282810191508684111561585b57600080fd5b8286015b84811015613ac0578051835291830191830161585f565b6000806040838503121561588957600080fd5b825167ffffffffffffffff808211156158a157600080fd5b6158ad86838701615810565b935060208501519150808211156158c357600080fd5b5061493e85828601615810565b600073ffffffffffffffffffffffffffffffffffffffff808816835280871660208401525060a0604083015261590960a0830186614948565b828103606084015261591b8186614948565b90508281036080840152613f8981856144ed565b60006020828403121561594157600080fd5b8151610ace81614465565b600060033d11156159655760046000803e5060005160e01c5b90565b600060443d10156159765790565b6040517ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc803d016004833e81513d67ffffffffffffffff81602484011181841117156159c457505050505090565b82850191508151818111156159dc5750505050505090565b843d87010160208285010111156159f65750505050505090565b615a05602082860101876145bf565b509095945050505050565b600082615a46577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b600073ffffffffffffffffffffffffffffffffffffffff808816835280871660208401525084604083015283606083015260a0608083015261432360a08301846144ed565b601f82111561119c57600081815260208120601f850160051c81016020861015615ab75750805b601f850160051c820191505b818110156114e657828155600101615ac3565b815167ffffffffffffffff811115615af057615af061454a565b615b0481615afe8454614f26565b84615a90565b602080601f831160018114615b575760008415615b215750858301515b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600386901b1c1916600185901b1785556114e6565b6000858152602081207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08616915b82811015615ba457888601518255948401946001909101908401615b85565b5085821015615be057878501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600388901b60f8161c191681555b5050505050600190811b01905550565b815160009082906020808601845b83811015615c1a57815185529382019390820190600101615bfe565b50929695505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b828152604060208201526000610acb60408301846144ed565b600060208284031215615c8057600080fd5b5051919050565b600060208284031215615c9957600080fd5b8151610ace81614d6e56fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220f592585ad1252581402e3b64b7faadb322b9c142eb02bfe61aadbe09328abb6064736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c80632ea72a49146100515780635c60da1b1461008e57806396c766bd146100b5578063fc91a897146100c8575b600080fd5b61006461005f3660046105ed565b610111565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b6100647f000000000000000000000000000000000000000000000000000000000000000081565b6100646100c336600461089b565b61023f565b6101016100d6366004610964565b73ffffffffffffffffffffffffffffffffffffffff1660009081526033602052604090205460ff1690565b6040519015158152602001610085565b600061011b61026f565b6000610126836102e2565b73ffffffffffffffffffffffffffffffffffffffff811660009081526033602052604090205490915060ff16156101a6576040517fd23867da00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff821660048201526024015b60405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff811660008181526033602090815260409182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790558151338152908101929092527f7da70c4e5387d7038610b79ca7d304caaef815826e51e67cf247135387a79bce910160405180910390a1905061023a60018055565b919050565b6000610269826040516020016102559190610ab4565b604051602081830303815290604052610111565b92915050565b6002600154036102db576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015260640161019d565b6002600155565b600080828060200190518101906102f99190610e21565b905060006103267f00000000000000000000000000000000000000000000000000000000000000006103b5565b6040517f178f03a100000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff82169063178f03a19061037b908590600401610ab4565b600060405180830381600087803b15801561039557600080fd5b505af11580156103a9573d6000803e3d6000fd5b50929695505050505050565b6000763d602d80600a3d3981f3363d3d373d3d3d363d730000008260601b60e81c176000526e5af43d82803e903d91602b57fd5bf38260781b17602052603760096000f0905073ffffffffffffffffffffffffffffffffffffffff811661023a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f455243313136373a20637265617465206661696c656400000000000000000000604482015260640161019d565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156104ca576104ca610478565b60405290565b6040516060810167ffffffffffffffff811182821017156104ca576104ca610478565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff8111828210171561053a5761053a610478565b604052919050565b600067ffffffffffffffff82111561055c5761055c610478565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b600061059b61059684610542565b6104f3565b90508281528383830111156105af57600080fd5b828260208301376000602084830101529392505050565b600082601f8301126105d757600080fd5b6105e683833560208501610588565b9392505050565b6000602082840312156105ff57600080fd5b813567ffffffffffffffff81111561061657600080fd5b610622848285016105c6565b949350505050565b600067ffffffffffffffff82111561064457610644610478565b5060051b60200190565b600082601f83011261065f57600080fd5b8135602061066f6105968361062a565b82815260059290921b8401810191818101908684111561068e57600080fd5b8286015b848110156106a95780358352918301918301610692565b509695505050505050565b6000604082840312156106c657600080fd5b6106ce6104a7565b9050813567ffffffffffffffff808211156106e857600080fd5b818401915084601f8301126106fc57600080fd5b8135602061070c6105968361062a565b82815260059290921b8401810191818101908884111561072b57600080fd5b8286015b84811015610763578035868111156107475760008081fd5b6107558b86838b01016105c6565b84525091830191830161072f565b508652508581013593508284111561077a57600080fd5b6107868785880161064e565b818601525050505092915050565b73ffffffffffffffffffffffffffffffffffffffff811681146107b657600080fd5b50565b6000606082840312156107cb57600080fd5b6107d36104d0565b905081356107e081610794565b81526020828101356107f181610794565b82820152604083013567ffffffffffffffff8082111561081057600080fd5b818501915085601f83011261082457600080fd5b81356108326105968261062a565b81815260059190911b8301840190848101908883111561085157600080fd5b8585015b838110156108895780358581111561086d5760008081fd5b61087b8b89838a01016106b4565b845250918601918601610855565b50604087015250939695505050505050565b6000602082840312156108ad57600080fd5b813567ffffffffffffffff808211156108c557600080fd5b90830190606082860312156108d957600080fd5b6108e16104d0565b8235828111156108f057600080fd5b8301601f8101871361090157600080fd5b61091087823560208401610588565b82525060208301358281111561092557600080fd5b610931878286016106b4565b60208301525060408301358281111561094957600080fd5b610955878286016107b9565b60408301525095945050505050565b60006020828403121561097657600080fd5b81356105e681610794565b60005b8381101561099c578181015183820152602001610984565b50506000910152565b600081518084526109bd816020860160208601610981565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b60006040830182516040855281815180845260608701915060608160051b88010193506020808401935060005b82811015610a68577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0898703018452610a568686516109a5565b95509381019392810192600101610a1c565b508681015188860389830152805180875290820195600095508201935091505b81841015610aa85784518352938401936001939093019291820191610a88565b50909695505050505050565b600060208083528351606082850152610ad060808501826109a5565b9050818501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe080868403016040870152610b0b83836109ef565b92506040870151915080868403016060870152506060820173ffffffffffffffffffffffffffffffffffffffff8083511684528085840151168585015250604082015191506060604084015280825180835260808501915060808160051b8601019250858401935060005b81811015610bc2577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80868503018352610bb08486516109ef565b94870194935091860191600101610b76565b509198975050505050505050565b6000610bde61059684610542565b9050828152838383011115610bf257600080fd5b6105e6836020830184610981565b600082601f830112610c1157600080fd5b81516020610c216105968361062a565b82815260059290921b84018101918181019086841115610c4057600080fd5b8286015b848110156106a95780518352918301918301610c44565b60006040808385031215610c6e57600080fd5b610c766104a7565b9150825167ffffffffffffffff80821115610c9057600080fd5b818501915085601f830112610ca457600080fd5b81516020610cb46105968361062a565b82815260059290921b84018101918181019089841115610cd357600080fd5b8286015b84811015610d1f57805186811115610cef5760008081fd5b8701603f81018c13610d015760008081fd5b610d118c868301518b8401610bd0565b845250918301918301610cd7565b5087525086810151945082851115610d3657600080fd5b610d4288868901610c00565b81870152505050505092915050565b600060608284031215610d6357600080fd5b610d6b6104d0565b90508151610d7881610794565b8152602082810151610d8981610794565b82820152604083015167ffffffffffffffff80821115610da857600080fd5b818501915085601f830112610dbc57600080fd5b8151610dca6105968261062a565b81815260059190911b83018401908481019088831115610de957600080fd5b8585015b8381101561088957805185811115610e055760008081fd5b610e138b89838a0101610c5b565b845250918601918601610ded565b600060208284031215610e3357600080fd5b815167ffffffffffffffff80821115610e4b57600080fd5b9083019060608286031215610e5f57600080fd5b610e676104d0565b825182811115610e7657600080fd5b8301601f81018713610e8757600080fd5b610e9687825160208401610bd0565b825250602083015182811115610eab57600080fd5b610eb787828601610c5b565b602083015250604083015182811115610ecf57600080fd5b61095587828601610d5156fea2646970667358221220a3ed6d5590676d1d26ca39ddf3151745da9ebf20662533a0f164b84baf10b0b164736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "createChild(bytes)": {
        "params": {
          "data_": "Encoded data to pass down to child contract constructor."
        },
        "returns": {
          "_0": "New child contract address."
        }
      },
      "createChildTyped((string,(bytes[],uint256[]),(address,address,(bytes[],uint256[])[])))": {
        "params": {
          "config_": "`FlowERC1155` constructor configuration."
        },
        "returns": {
          "_0": "New `FlowERC1155` child contract address."
        }
      },
      "isChild(address)": {
        "params": {
          "maybeChild_": "Address of child contract to look up."
        },
        "returns": {
          "_0": "Returns `true` if address is a contract created by this contract factory, otherwise `false`."
        }
      }
    },
    "title": "EmissionsERC1155Factory",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "DuplicateChild(address)": [
        {
          "notice": "Thrown when a new factory deployment creates a child that was already created by a previous deployment. This should never happen without some kind of precompute such as CREATE2 and is generally unsupported at this time."
        }
      ]
    },
    "events": {
      "Implementation(address,address)": {
        "notice": "Factories that clone a template contract MUST emit an event any time they set the implementation being cloned. Factories that deploy new contracts without cloning do NOT need to emit this."
      },
      "NewChild(address,address)": {
        "notice": "Whenever a new child contract is deployed, a `NewChild` event containing the new child contract address MUST be emitted."
      }
    },
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "Build the reference implementation to clone for each child."
      },
      "createChild(bytes)": {
        "notice": "Implements `IFactory`. Calls the `_createChild` hook that inheriting contracts must override. Registers child contract address such that `isChild` is `true`. Emits `NewChild` event."
      },
      "createChildTyped((string,(bytes[],uint256[]),(address,address,(bytes[],uint256[])[])))": {
        "notice": "Allows calling `createChild` with `FlowERC1155Config` struct. Use original `Factory` `createChild` function signature if function parameters are already encoded."
      },
      "implementation()": {
        "notice": "Template contract to clone. Deployed by the constructor."
      },
      "isChild(address)": {
        "notice": "Implements `IFactory`. Checks if address is registered as a child contract of this factory."
      }
    },
    "notice": "Factory for deploying and registering `FlowERC1155` contracts.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 855,
        "contract": "contracts/flow/erc1155/FlowERC1155Factory.sol:FlowERC1155Factory",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 858,
        "contract": "contracts/flow/erc1155/FlowERC1155Factory.sol:FlowERC1155Factory",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 1031,
        "contract": "contracts/flow/erc1155/FlowERC1155Factory.sol:FlowERC1155Factory",
        "label": "_status",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 1089,
        "contract": "contracts/flow/erc1155/FlowERC1155Factory.sol:FlowERC1155Factory",
        "label": "__gap",
        "offset": 0,
        "slot": "2",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 12002,
        "contract": "contracts/flow/erc1155/FlowERC1155Factory.sol:FlowERC1155Factory",
        "label": "contracts",
        "offset": 0,
        "slot": "51",
        "type": "t_mapping(t_address,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}