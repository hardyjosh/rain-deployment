{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC1271Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271Upgradeable {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20Upgradeable.sol\";\nimport \"../token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626Upgradeable is IERC20Upgradeable, IERC20MetadataUpgradeable {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary ClonesUpgradeable {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155Upgradeable.sol\";\nimport \"./IERC1155ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC1155MetadataURIUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\n    using AddressUpgradeable for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Upgradeable.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155ReceiverUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155HolderUpgradeable is Initializable, ERC1155ReceiverUpgradeable {\n    function __ERC1155Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Holder_init_unchained() internal onlyInitializing {\n    }\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155ReceiverUpgradeable.sol\";\nimport \"../../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\n    function __ERC1155Receiver_init() internal onlyInitializing {\n    }\n\n    function __ERC1155Receiver_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/extensions/ERC20Snapshot.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ArraysUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\n * total supply at the time are recorded for later access.\n *\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\n * In naive implementations it's possible to perform a \"double spend\" attack by reusing the same balance from different\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\n * used to create an efficient ERC20 forking mechanism.\n *\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\n * and the account address.\n *\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\n * return `block.number` will trigger the creation of snapshot at the beginning of each new block. When overriding this\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\n *\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\n * alternative consider {ERC20Votes}.\n *\n * ==== Gas Costs\n *\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\n *\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\n * transfers will have normal cost until the next snapshot, and so on.\n */\n\nabstract contract ERC20SnapshotUpgradeable is Initializable, ERC20Upgradeable {\n    function __ERC20Snapshot_init() internal onlyInitializing {\n    }\n\n    function __ERC20Snapshot_init_unchained() internal onlyInitializing {\n    }\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\n    // https://github.com/Giveth/minime/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\n\n    using ArraysUpgradeable for uint256[];\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\n    // Snapshot struct, but that would impede usage of functions that work on an array.\n    struct Snapshots {\n        uint256[] ids;\n        uint256[] values;\n    }\n\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\n    Snapshots private _totalSupplySnapshots;\n\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\n    CountersUpgradeable.Counter private _currentSnapshotId;\n\n    /**\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\n     */\n    event Snapshot(uint256 id);\n\n    /**\n     * @dev Creates a new snapshot and returns its snapshot id.\n     *\n     * Emits a {Snapshot} event that contains the same id.\n     *\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\n     *\n     * [WARNING]\n     * ====\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\n     * you must consider that it can potentially be used by attackers in two ways.\n     *\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\n     * section above.\n     *\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\n     * ====\n     */\n    function _snapshot() internal virtual returns (uint256) {\n        _currentSnapshotId.increment();\n\n        uint256 currentId = _getCurrentSnapshotId();\n        emit Snapshot(currentId);\n        return currentId;\n    }\n\n    /**\n     * @dev Get the current snapshotId\n     */\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\n        return _currentSnapshotId.current();\n    }\n\n    /**\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n     */\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\n\n        return snapshotted ? value : balanceOf(account);\n    }\n\n    /**\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\n     */\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\n\n        return snapshotted ? value : totalSupply();\n    }\n\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from == address(0)) {\n            // mint\n            _updateAccountSnapshot(to);\n            _updateTotalSupplySnapshot();\n        } else if (to == address(0)) {\n            // burn\n            _updateAccountSnapshot(from);\n            _updateTotalSupplySnapshot();\n        } else {\n            // transfer\n            _updateAccountSnapshot(from);\n            _updateAccountSnapshot(to);\n        }\n    }\n\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\n        require(snapshotId > 0, \"ERC20Snapshot: id is 0\");\n        require(snapshotId <= _getCurrentSnapshotId(), \"ERC20Snapshot: nonexistent id\");\n\n        // When a valid snapshot is queried, there are three possibilities:\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\n        //  to this id is the current one.\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\n        //  requested id, and its value is the one to return.\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\n        //  larger than the requested one.\n        //\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\n        // exactly this.\n\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\n\n        if (index == snapshots.ids.length) {\n            return (false, 0);\n        } else {\n            return (true, snapshots.values[index]);\n        }\n    }\n\n    function _updateAccountSnapshot(address account) private {\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\n    }\n\n    function _updateTotalSupplySnapshot() private {\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\n    }\n\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\n        uint256 currentId = _getCurrentSnapshotId();\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\n            snapshots.ids.push(currentId);\n            snapshots.values.push(currentValue);\n        }\n    }\n\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\n        if (ids.length == 0) {\n            return 0;\n        } else {\n            return ids[ids.length - 1];\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../utils/SafeERC20Upgradeable.sol\";\nimport \"../../../interfaces/IERC4626Upgradeable.sol\";\nimport \"../../../utils/math/MathUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * CAUTION: Deposits and withdrawals may incur unexpected slippage. Users should verify that the amount received of\n * shares or assets is as expected. EOAs should operate through a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * _Available since v4.7._\n */\nabstract contract ERC4626Upgradeable is Initializable, ERC20Upgradeable, IERC4626Upgradeable {\n    using MathUpgradeable for uint256;\n\n    IERC20Upgradeable private _asset;\n    uint8 private _decimals;\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).\n     */\n    function __ERC4626_init(IERC20Upgradeable asset_) internal onlyInitializing {\n        __ERC4626_init_unchained(asset_);\n    }\n\n    function __ERC4626_init_unchained(IERC20Upgradeable asset_) internal onlyInitializing {\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _decimals = success ? assetDecimals : super.decimals();\n        _asset = asset_;\n    }\n\n    /**\n     * @dev Attempts to fetch the asset decimals. A return value of false indicates that the attempt failed in some way.\n     */\n    function _tryGetAssetDecimals(IERC20Upgradeable asset_) private returns (bool, uint8) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).call(\n            abi.encodeWithSelector(IERC20MetadataUpgradeable.decimals.selector)\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Decimals are read from the underlying asset in the constructor and cached. If this fails (e.g., the asset\n     * has not been created yet), the cached value is set to a default obtained by `super.decimals()` (which depends on\n     * inheritance but is most likely 18). Override this function in order to set a guaranteed hardcoded value.\n     * See {IERC20Metadata-decimals}.\n     */\n    function decimals() public view virtual override(IERC20MetadataUpgradeable, ERC20Upgradeable) returns (uint8) {\n        return _decimals;\n    }\n\n    /** @dev See {IERC4626-asset}. */\n    function asset() public view virtual override returns (address) {\n        return address(_asset);\n    }\n\n    /** @dev See {IERC4626-totalAssets}. */\n    function totalAssets() public view virtual override returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n\n    /** @dev See {IERC4626-convertToShares}. */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256 shares) {\n        return _convertToShares(assets, MathUpgradeable.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-convertToAssets}. */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256 assets) {\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-maxDeposit}. */\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return _isVaultCollateralized() ? type(uint256).max : 0;\n    }\n\n    /** @dev See {IERC4626-maxMint}. */\n    function maxMint(address) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4626-maxWithdraw}. */\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\n        return _convertToAssets(balanceOf(owner), MathUpgradeable.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-maxRedeem}. */\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4626-previewDeposit}. */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, MathUpgradeable.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-previewMint}. */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Up);\n    }\n\n    /** @dev See {IERC4626-previewWithdraw}. */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, MathUpgradeable.Rounding.Up);\n    }\n\n    /** @dev See {IERC4626-previewRedeem}. */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Down);\n    }\n\n    /** @dev See {IERC4626-deposit}. */\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\n        require(assets <= maxDeposit(receiver), \"ERC4626: deposit more than max\");\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-mint}. */\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\n        require(shares <= maxMint(receiver), \"ERC4626: mint more than max\");\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4626-withdraw}. */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max\");\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4626-redeem}. */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     *\n     * Will revert if assets > 0, totalSupply > 0 and totalAssets = 0. That corresponds to a case where any asset\n     * would represent an infinite amount of shares.\n     */\n    function _convertToShares(uint256 assets, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        return\n            (assets == 0 || supply == 0)\n                ? _initialConvertToShares(assets, rounding)\n                : assets.mulDiv(supply, totalAssets(), rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) to apply when the vault is empty.\n     *\n     * NOTE: Make sure to keep this function consistent with {_initialConvertToAssets} when overriding it.\n     */\n    function _initialConvertToShares(\n        uint256 assets,\n        MathUpgradeable.Rounding /*rounding*/\n    ) internal view virtual returns (uint256 shares) {\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return\n            (supply == 0) ? _initialConvertToAssets(shares, rounding) : shares.mulDiv(totalAssets(), supply, rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) to apply when the vault is empty.\n     *\n     * NOTE: Make sure to keep this function consistent with {_initialConvertToShares} when overriding it.\n     */\n    function _initialConvertToAssets(\n        uint256 shares,\n        MathUpgradeable.Rounding /*rounding*/\n    ) internal view virtual returns (uint256 assets) {\n        return shares;\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        // If _asset is ERC777, `transferFrom` can trigger a reenterancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20Upgradeable.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If _asset is ERC777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20Upgradeable.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _isVaultCollateralized() private view returns (bool) {\n        return totalAssets() > 0 || totalSupply() == 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721ReceiverUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\n    function __ERC721Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC721Holder_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ArraysUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Arrays.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./StorageSlotUpgradeable.sol\";\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary ArraysUpgradeable {\n    using StorageSlotUpgradeable for bytes32;\n\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlotUpgradeable.AddressSlot storage) {\n        bytes32 slot;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getAddressSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlotUpgradeable.Bytes32Slot storage) {\n        bytes32 slot;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getBytes32Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlotUpgradeable.Uint256Slot storage) {\n        bytes32 slot;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0, arr.slot)\n            slot := add(keccak256(0, 0x20), pos)\n        }\n        return slot.getUint256Slot();\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/SignatureCheckerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../AddressUpgradeable.sol\";\nimport \"../../interfaces/IERC1271Upgradeable.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureCheckerUpgradeable {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (address recovered, ECDSAUpgradeable.RecoverError error) = ECDSAUpgradeable.tryRecover(hash, signature);\n        if (error == ECDSAUpgradeable.RecoverError.NoError && recovered == signer) {\n            return true;\n        }\n\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271Upgradeable.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length == 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271Upgradeable.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165CheckerUpgradeable {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165Upgradeable).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165Upgradeable.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./AddressUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\nabstract contract MulticallUpgradeable is Initializable {\n    function __Multicall_init() internal onlyInitializing {\n    }\n\n    function __Multicall_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = _functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/array/LibUint256Array.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\n/// Thrown if a truncated length is longer than the array being truncated. It is\n/// not possible to truncate something and increase its length as the memory\n/// region after the array MAY be allocated for something else already.\nerror OutOfBoundsTruncate(uint256 arrayLength, uint256 truncatedLength);\n\n/// @title Uint256Array\n/// @notice Things we want to do carefully and efficiently with uint256 arrays\n/// that Solidity doesn't give us native tools for.\nlibrary LibUint256Array {\n    using LibUint256Array for uint256[];\n\n    /// Building arrays from literal components is a common task that introduces\n    /// boilerplate that is either inefficient or error prone.\n    /// @param a_ a single integer to build an array around.\n    /// @return the newly allocated array including a_ as a single item.\n    function arrayFrom(uint256 a_) internal pure returns (uint256[] memory) {\n        uint256[] memory array_ = new uint256[](1);\n        assembly (\"memory-safe\") {\n            mstore(add(array_, 0x20), a_)\n        }\n        return array_;\n    }\n\n    /// Building arrays from literal components is a common task that introduces\n    /// boilerplate that is either inefficient or error prone.\n    /// @param a_ the first integer to build an array around.\n    /// @param b_ the second integer to build an array around.\n    /// @return the newly allocated array including a_ and b_ as the only items.\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory array_ = new uint256[](2);\n        assembly (\"memory-safe\") {\n            mstore(add(array_, 0x20), a_)\n            mstore(add(array_, 0x40), b_)\n        }\n        return array_;\n    }\n\n    /// Building arrays from literal components is a common task that introduces\n    /// boilerplate that is either inefficient or error prone.\n    /// @param a_ the first integer to build an array around.\n    /// @param b_ the second integer to build an array around.\n    /// @param c_ the third integer to build an array around.\n    /// @return the newly allocated array including a_, b_ and c_ as the only\n    /// items.\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_,\n        uint256 c_\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory array_ = new uint256[](3);\n        assembly (\"memory-safe\") {\n            mstore(add(array_, 0x20), a_)\n            mstore(add(array_, 0x40), b_)\n            mstore(add(array_, 0x60), c_)\n        }\n        return array_;\n    }\n\n    /// Building arrays from literal components is a common task that introduces\n    /// boilerplate that is either inefficient or error prone.\n    /// @param a_ the first integer to build an array around.\n    /// @param b_ the second integer to build an array around.\n    /// @param c_ the third integer to build an array around.\n    /// @param d_ the fourth integer to build an array around.\n    /// @return the newly allocated array including a_, b_, c_ and d_ as the only\n    /// items.\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_,\n        uint256 c_,\n        uint256 d_\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory array_ = new uint256[](4);\n        assembly (\"memory-safe\") {\n            mstore(add(array_, 0x20), a_)\n            mstore(add(array_, 0x40), b_)\n            mstore(add(array_, 0x60), c_)\n            mstore(add(array_, 0x80), d_)\n        }\n        return array_;\n    }\n\n    /// Building arrays from literal components is a common task that introduces\n    /// boilerplate that is either inefficient or error prone.\n    /// @param a_ the first integer to build an array around.\n    /// @param b_ the second integer to build an array around.\n    /// @param c_ the third integer to build an array around.\n    /// @param d_ the fourth integer to build an array around.\n    /// @param e_ the fifth integer to build an array around.\n    /// @return the newly allocated array including a_, b_, c_, d_ and e_ as the\n    /// only items.\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_,\n        uint256 c_,\n        uint256 d_,\n        uint256 e_\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory array_ = new uint256[](5);\n        assembly (\"memory-safe\") {\n            mstore(add(array_, 0x20), a_)\n            mstore(add(array_, 0x40), b_)\n            mstore(add(array_, 0x60), c_)\n            mstore(add(array_, 0x80), d_)\n            mstore(add(array_, 0xA0), e_)\n        }\n        return array_;\n    }\n\n    /// Building arrays from literal components is a common task that introduces\n    /// boilerplate that is either inefficient or error prone.\n    /// @param a_ the first integer to build an array around.\n    /// @param b_ the second integer to build an array around.\n    /// @param c_ the third integer to build an array around.\n    /// @param d_ the fourth integer to build an array around.\n    /// @param e_ the fifth integer to build an array around.\n    /// @param f_ the sixth integer to build an array around.\n    /// @return the newly allocated array including a_, b_, c_, d_, e_ and f_ as\n    /// the only items.\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_,\n        uint256 c_,\n        uint256 d_,\n        uint256 e_,\n        uint256 f_\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory array_ = new uint256[](6);\n        assembly (\"memory-safe\") {\n            mstore(add(array_, 0x20), a_)\n            mstore(add(array_, 0x40), b_)\n            mstore(add(array_, 0x60), c_)\n            mstore(add(array_, 0x80), d_)\n            mstore(add(array_, 0xA0), e_)\n            mstore(add(array_, 0xC0), f_)\n        }\n        return array_;\n    }\n\n    /// Building arrays from literal components is a common task that introduces\n    /// boilerplate that is either inefficient or error prone.\n    /// @param a_ The head of the new array.\n    /// @param tail_ The tail of the new array.\n    /// @return The new array.\n    function arrayFrom(\n        uint256 a_,\n        uint256[] memory tail_\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory array_ = new uint256[](1);\n        assembly (\"memory-safe\") {\n            mstore(add(array_, 0x20), a_)\n        }\n        array_.extend(tail_);\n        return array_;\n    }\n\n    /// Building arrays from literal components is a common task that introduces\n    /// boilerplate that is either inefficient or error prone.\n    /// @param a_ The first item of the new array.\n    /// @param b_ The second item of the new array.\n    /// @param tail_ The tail of the new array.\n    /// @return The new array.\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_,\n        uint256[] memory tail_\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory array_ = new uint256[](2);\n        assembly (\"memory-safe\") {\n            mstore(add(array_, 0x20), a_)\n            mstore(add(array_, 0x40), b_)\n        }\n        array_.extend(tail_);\n        return array_;\n    }\n\n    /// 2-dimensional analogue of `arrayFrom`. Takes a 1-dimensional array and\n    /// coerces it to a 2-dimensional matrix where the first and only item in the\n    /// matrix is the 1-dimensional array.\n    /// @param a_ The 1-dimensional array to coerce.\n    /// @return The 2-dimensional matrix containing `a_`.\n    function matrixFrom(\n        uint256[] memory a_\n    ) internal pure returns (uint256[][] memory) {\n        uint256[][] memory matrix_ = new uint256[][](1);\n        assembly (\"memory-safe\") {\n            mstore(add(matrix_, 0x20), a_)\n        }\n        return matrix_;\n    }\n\n    /// Solidity provides no way to change the length of in-memory arrays but\n    /// it also does not deallocate memory ever. It is always safe to shrink an\n    /// array that has already been allocated, with the caveat that the\n    /// truncated items will effectively become inaccessible regions of memory.\n    /// That is to say, we deliberately \"leak\" the truncated items, but that is\n    /// no worse than Solidity's native behaviour of leaking everything always.\n    /// The array is MUTATED in place so there is no return value and there is\n    /// no new allocation or copying of data either.\n    /// @param array_ The array to truncate.\n    /// @param newLength_ The new length of the array after truncation.\n    function truncate(\n        uint256[] memory array_,\n        uint256 newLength_\n    ) internal pure {\n        if (newLength_ > array_.length) {\n            revert OutOfBoundsTruncate(array_.length, newLength_);\n        }\n        assembly (\"memory-safe\") {\n            mstore(array_, newLength_)\n        }\n    }\n\n    /// Extends `base_` with `extend_` by allocating additional `extend_.length`\n    /// uints onto `base_`. Reverts if some other memory has been allocated\n    /// after `base_` already, in which case it is NOT safe to copy inline.\n    /// If `base_` is large this MAY be significantly more efficient than\n    /// allocating `base_.length + extend_.length` for an entirely new array and\n    /// copying both `base_` and `extend_` into the new array one item at a\n    /// time in Solidity.\n    /// The Solidity compiler MAY rearrange sibling statements in a code block\n    /// EVEN IF THE OPTIMIZER IS DISABLED such that it becomes unsafe to use\n    /// `extend` for memory allocated in different code blocks. It is ONLY safe\n    /// to `extend` arrays that were allocated in the same lexical scope and you\n    /// WILL see subtle errors that revert transactions otherwise.\n    /// i.e. the `new` keyword MUST appear in the same code block as `extend`.\n    /// @param base_ The base integer array that will be extended by `extend_`.\n    /// @param extend_ The integer array that extends `base_`.\n    function extend(\n        uint256[] memory base_,\n        uint256[] memory extend_\n    ) internal pure {\n        uint256 freeMemoryPointer_;\n        assembly (\"memory-safe\") {\n            // Solidity stores free memory pointer at 0x40\n            freeMemoryPointer_ := mload(0x40)\n            let baseLength_ := mload(base_)\n            let extendLength_ := mload(extend_)\n\n            // The freeMemoryPointer_ does NOT point to the end of `base_` so\n            // it is NOT safe to copy `extend_` over the top of already\n            // allocated memory. This happens whenever some memory is allocated\n            // after `base_` is allocated but before `extend` is called.\n            if gt(\n                freeMemoryPointer_,\n                add(base_, add(0x20, mul(0x20, baseLength_)))\n            ) {\n                revert(0, 0)\n            }\n\n            // Move the free memory pointer by the length of extend_, excluding\n            // the length slot of extend as that will NOT be copied to `base_`.\n            mstore(0x40, add(freeMemoryPointer_, mul(0x20, extendLength_)))\n\n            // Update the length of base to be the length of base+extend.\n            mstore(base_, add(baseLength_, extendLength_))\n        }\n\n        unsafeCopyValuesTo(extend_, freeMemoryPointer_);\n    }\n\n    /// Copies `inputs_` to `outputCursor_` with NO attempt to check that this\n    /// is safe to do so. The caller MUST ensure that there exists allocated\n    /// memory at `outputCursor_` in which it is safe and appropriate to copy\n    /// ALL `inputs_` to. Anything that was already written to memory at\n    /// `[outputCursor_:outputCursor_+(inputs_.length * 32 bytes)]` will be\n    /// overwritten. The length of `inputs_` is NOT copied to the output\n    /// location, ONLY the `uint256` values of the `inputs_` array are copied.\n    /// There is no return value as memory is modified directly.\n    /// @param inputs_ The input array that will be copied from EXCLUDING the\n    /// length at the start of the array in memory.\n    /// @param outputCursor_ Location in memory that the values will be copied\n    /// to linearly.\n    function unsafeCopyValuesTo(\n        uint256[] memory inputs_,\n        uint256 outputCursor_\n    ) internal pure {\n        uint256 inputCursor_;\n        assembly (\"memory-safe\") {\n            inputCursor_ := add(inputs_, 0x20)\n        }\n        unsafeCopyValuesTo(inputCursor_, outputCursor_, inputs_.length);\n    }\n\n    /// Copies `length_` 32 byte words from `inputCursor_` to a newly allocated\n    /// uint256[] array with NO attempt to check that the inputs are sane.\n    /// This function is safe in that the outputs are guaranteed to be copied\n    /// to newly allocated memory so no existing data will be overwritten.\n    /// This function is subtle in that the `inputCursor_` is NOT validated in\n    /// any way so the caller MUST ensure it points to a sensible memory\n    /// location to read (e.g. to exclude the length from input arrays etc.).\n    /// @param inputCursor_ The start of the memory that will be copied to the\n    /// newly allocated array.\n    /// @param length_ Number of 32 byte words to copy starting at\n    /// `inputCursor_` to the items of the newly allocated array.\n    /// @return The newly allocated `uint256[]` array.\n    function copyToNewUint256Array(\n        uint256 inputCursor_,\n        uint256 length_\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory outputs_ = new uint256[](length_);\n        uint256 outputCursor_;\n        assembly (\"memory-safe\") {\n            outputCursor_ := add(outputs_, 0x20)\n        }\n        unsafeCopyValuesTo(inputCursor_, outputCursor_, length_);\n        return outputs_;\n    }\n\n    /// Copies `length_` uint256 values starting from `inputsCursor_` to\n    /// `outputCursor_` with NO attempt to check that this is safe to do so.\n    /// The caller MUST ensure that there exists allocated memory at\n    /// `outputCursor_` in which it is safe and appropriate to copy\n    /// `length_ * 32` bytes to. Anything that was already written to memory at\n    /// `[outputCursor_:outputCursor_+(length_ * 32 bytes)]` will be\n    /// overwritten.\n    /// There is no return value as memory is modified directly.\n    /// @param inputCursor_ The starting position in memory that data will be\n    /// copied from.\n    /// @param outputCursor_ The starting position in memory that data will be\n    /// copied to.\n    /// @param length_ The number of 32 byte (i.e. `uint256`) values that will\n    /// be copied.\n    function unsafeCopyValuesTo(\n        uint256 inputCursor_,\n        uint256 outputCursor_,\n        uint256 length_\n    ) internal pure {\n        assembly (\"memory-safe\") {\n            for {\n                let end_ := add(inputCursor_, mul(0x20, length_))\n            } lt(inputCursor_, end_) {\n                inputCursor_ := add(inputCursor_, 0x20)\n                outputCursor_ := add(outputCursor_, 0x20)\n            } {\n                mstore(outputCursor_, mload(inputCursor_))\n            }\n        }\n    }\n}\n"
    },
    "contracts/bytes/LibBytes.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\n/// @title LibBytes\n/// @notice Things we want to do carefully and efficiently with `bytes` in memory\n/// that Solidity doesn't give us native tools for.\nlibrary LibBytes {\n    /// Copy an arbitrary number of bytes from one location in memory to another.\n    /// As we can only read/write bytes in 32 byte chunks we first have to loop\n    /// over 32 byte values to copy then handle any unaligned remaining data. The\n    /// remaining data will be appropriately masked with the existing data in the\n    /// final chunk so as to not write past the desired length. Note that the\n    /// final unaligned write will be more gas intensive than the prior aligned\n    /// writes. The writes are completely unsafe, the caller MUST ensure that\n    /// sufficient memory is allocated and reading/writing the requested number\n    /// of bytes from/to the requested locations WILL NOT corrupt memory in the\n    /// opinion of solidity or other subsequent read/write operations.\n    /// @param inputCursor_ The starting location in memory to read from.\n    /// @param outputCursor_ The starting location in memory to write to.\n    /// @param remaining_ The number of bytes to read/write.\n    function unsafeCopyBytesTo(\n        uint256 inputCursor_,\n        uint256 outputCursor_,\n        uint256 remaining_\n    ) internal pure {\n        assembly (\"memory-safe\") {\n            for {\n\n            } iszero(lt(remaining_, 0x20)) {\n                remaining_ := sub(remaining_, 0x20)\n                inputCursor_ := add(inputCursor_, 0x20)\n                outputCursor_ := add(outputCursor_, 0x20)\n            } {\n                mstore(outputCursor_, mload(inputCursor_))\n            }\n\n            if gt(remaining_, 0) {\n                let mask_ := shr(\n                    mul(remaining_, 8),\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                )\n                // preserve existing bytes\n                mstore(\n                    outputCursor_,\n                    or(\n                        // input\n                        and(mload(inputCursor_), not(mask_)),\n                        and(mload(outputCursor_), mask_)\n                    )\n                )\n            }\n        }\n    }\n}\n"
    },
    "contracts/chainlink/LibChainlink.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../math/FixedPointMath.sol\";\n\n/// Thrown if a price is zero or negative as this is probably not anticipated or\n/// useful for most users of a price feed. Of course there are use cases where\n/// zero or negative _oracle values_ in general are useful, such as negative\n/// temperatures from a thermometer, but these are unlikely to be useful _prices_\n/// for assets. Zero value prices are likely to result in division by zero\n/// downstream or giving away assets for free, negative price values could result\n/// in even weirder behaviour due to token amounts being `uint256` and the\n/// subtleties of signed vs. unsigned integer conversions.\n/// @param price The price that is not a positive integer.\nerror NotPosIntPrice(int256 price);\n\n/// Thrown when the updatedAt time from the Chainlink oracle is more than\n/// staleAfter seconds prior to the current block timestamp. Prevents stale\n/// prices from being used within the constraints set by the caller.\n/// @param updatedAt The latest time the oracle was updated according to the\n/// oracle.\n/// @param staleAfter The maximum number of seconds the caller allows between\n/// the block timestamp and the updated time.\nerror StalePrice(uint256 updatedAt, uint256 staleAfter);\n\nlibrary LibChainlink {\n    using SafeCast for int256;\n    using FixedPointMath for uint256;\n\n    function price(\n        address feed_,\n        uint256 staleAfter_\n    ) internal view returns (uint256) {\n        (, int256 answer_, , uint256 updatedAt_, ) = AggregatorV3Interface(\n            feed_\n        ).latestRoundData();\n\n        if (answer_ <= 0) {\n            revert NotPosIntPrice(answer_);\n        }\n\n        // Checked time comparison ensures no updates from the future as that\n        // would overflow, and no stale prices.\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp - updatedAt_ > staleAfter_) {\n            revert StalePrice(updatedAt_, staleAfter_);\n        }\n\n        // Safely cast the answer to uint256 and scale it to 18 decimal FP.\n        return\n            answer_.toUint256().scale18(\n                AggregatorV3Interface(feed_).decimals()\n            );\n    }\n}\n"
    },
    "contracts/cooldown/Cooldown.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// @title Cooldown\n/// @notice `Cooldown` is a base contract that rate limits functions on\n/// the implementing contract per `msg.sender`.\n///\n/// Each time a function with the `onlyAfterCooldown` modifier is called the\n/// `msg.sender` must wait N seconds before calling any modified function.\n///\n/// This does nothing to prevent sybils who can generate an arbitrary number of\n/// `msg.sender` values in parallel to spam a contract.\n///\n/// `Cooldown` is intended to prevent rapid state cycling to grief a contract,\n/// such as rapidly locking and unlocking a large amount of capital in the\n/// `SeedERC20` contract.\n///\n/// Requiring a lock/deposit of significant economic stake that sybils will not\n/// have access to AND applying a cooldown IS a sybil mitigation. The economic\n/// stake alone is NOT sufficient if gas is cheap as sybils can cycle the same\n/// stake between each other. The cooldown alone is NOT sufficient as many\n/// sybils can be created, each as a new `msg.sender`.\n///\n/// @dev Base for anything that enforces a cooldown delay on functions.\n/// `Cooldown` requires a minimum time in seconds to elapse between actions\n/// that cooldown. The modifier `onlyAfterCooldown` both enforces and triggers\n/// the cooldown. There is a single cooldown across all functions per-contract\n/// so any function call that requires a cooldown will also trigger it for\n/// all other functions.\n///\n/// Cooldown is NOT an effective sybil resistance alone, as the cooldown is\n/// per-address only. It is always possible for many accounts to be created\n/// to spam a contract with dust in parallel.\n/// Cooldown is useful to stop a single account rapidly cycling contract\n/// state in a way that can be disruptive to peers. Cooldown works best when\n/// coupled with economic stake associated with each state change so that\n/// peers must lock capital during the cooldown. `Cooldown` tracks the first\n/// `msg.sender` it sees for a call stack so cooldowns are enforced across\n/// reentrant code. Any function that enforces a cooldown also has reentrancy\n/// protection.\ncontract Cooldown {\n    event CooldownInitialize(address sender, uint256 cooldownDuration);\n    event CooldownTriggered(address caller, uint256 cooldown);\n    /// Time in seconds to restrict access to modified functions.\n    uint256 internal cooldownDuration;\n\n    /// Every caller has its own cooldown, the minimum time that the caller\n    /// call another function sharing the same cooldown state.\n    mapping(address => uint256) private cooldowns;\n    address private caller;\n\n    /// Initialize the cooldown duration.\n    /// The cooldown duration is global to the contract.\n    /// Cooldown duration must be greater than 0.\n    /// Cooldown duration can only be set once.\n    /// @param cooldownDuration_ The global cooldown duration.\n    function initializeCooldown(uint256 cooldownDuration_) internal {\n        require(cooldownDuration_ > 0, \"COOLDOWN_0\");\n        require(cooldownDuration_ <= type(uint32).max, \"COOLDOWN_MAX\");\n        // Reinitialization is a bug.\n        assert(cooldownDuration == 0);\n        cooldownDuration = cooldownDuration_;\n        emit CooldownInitialize(msg.sender, cooldownDuration_);\n    }\n\n    /// Modifies a function to enforce the cooldown for `msg.sender`.\n    /// Saves the original caller so that cooldowns are enforced across\n    /// reentrant code.\n    modifier onlyAfterCooldown() {\n        address caller_ = caller == address(0) ? caller = msg.sender : caller;\n        require(cooldowns[caller_] <= block.timestamp, \"COOLDOWN\");\n        // Every action that requires a cooldown also triggers a cooldown.\n        uint256 cooldown_ = block.timestamp + cooldownDuration;\n        cooldowns[caller_] = cooldown_;\n        emit CooldownTriggered(caller_, cooldown_);\n        _;\n        // Refund as much gas as we can.\n        delete caller;\n    }\n}\n"
    },
    "contracts/dance/SeedDance.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport \"../math/FixedPointMath.sol\";\n\n/// Represents a minimum and maximum duration for the dance in a structure that\n/// can fit in a single slot. uint32 representation for timestamps is inline\n/// with the rest of the rain protocol.\n/// @param baseDuration Every participant will be able to reveal for at least\n/// this amount of seconds after the start of the dance.\n/// @param maxExtraTime The theoretical maximum number of additional seconds\n/// above the baseDuration that an individual participant may reveal during. In\n/// practical terms the seed is reallocating extra time randomly on this range\n/// every time anyone reveals, so it is very unlikely that a given participant\n/// will be able to utilise this maximum extra time.\nstruct TimeBound {\n    uint32 baseDuration;\n    uint32 maxExtraTime;\n}\n\ntype Seed is uint256;\ntype Secret is uint256;\ntype Commitment is uint256;\n\nlibrary LibSeed {\n    /// Generates a new unpredictable, cryptographic strength seed by hashing\n    /// an existing seed with some value. All values used to build the new seed\n    /// are equally valid due to hashing guarantees but of course same seed and\n    /// value will give the same output. That is to say, `with` is entirely\n    /// deterministic for any given inputs. In this context \"unpredictable\"\n    /// means, \"unpredictable provided you don't know both seed and val\".\n    /// @param seed_ An existing seed.\n    /// @param val_ Can be literally any uint256 as the hashing will ensure the\n    /// returned seed is unpredictable.\n    /// @return newSeed_ The result of applying `val_` to `seed_`.\n    function with(Seed seed_, uint256 val_) internal pure returns (Seed) {\n        return Seed.wrap(uint256(keccak256(abi.encodePacked(seed_, val_))));\n    }\n}\n\nlibrary LibCommitment {\n    /// Equality check for commitments.\n    /// @param a_ First commitment to compare.\n    /// @param b_ Second commitment to compare.\n    /// @return eq_ True if a_ equals b_, else false.\n    function eq(Commitment a_, Commitment b_) internal pure returns (bool) {\n        return Commitment.unwrap(a_) == Commitment.unwrap(b_);\n    }\n\n    /// Build the commitment for a secret.\n    /// Standard commitment build is by hashing the secret as bytes.\n    /// DO NOT EXPOSE THIS ONCHAIN. Replicate the functionality offchain so it\n    /// can and WILL be run locally to the secret generation process.\n    /// It is far too difficult to ensure that secrets will stay secret if\n    /// users are expected to be forwarding them around to RPCs etc. just to\n    /// find the value of their commitments.\n    /// DO NOT SEND SECRETS ANYWHERE, LEAVE THEM WHERE YOU MADE THEM.\n    /// DO NOT REUSE SECRETS, GENERATE A NEW ONE FOR EVERY COMMITMENT.\n    /// Of course, you MAY send a secret if and only if it is being revealed as\n    /// part of a dance.\n    function fromSecret(Secret secret_) internal pure returns (Commitment) {\n        return Commitment.wrap(uint256(keccak256(abi.encodePacked(secret_))));\n    }\n\n    /// The nil valued commitment.\n    /// No secret can match this commitment, or at least probably nobody knows\n    /// the secret that does match this commitment.\n    /// @return nil_ Nil valued commitment.\n    function nil() internal pure returns (Commitment) {\n        return Commitment.wrap(0);\n    }\n}\n\n/// @title SeedDance\n/// @notice A multiparty commit/reveal scheme designed to generate a shared\n/// seed that impacts involved parties directly. For example, generating the\n/// seed for a lottery/shuffle mechanic that maps NFT IDs to their metadata.\n///\n/// SeedDance does NOT implement any access or integrity checks (e.g. to ensure\n/// that the correct `TimeBound` is passed to `_reveal`) as it is unopinionated\n/// as to how inheriting contracts expose the dance to end users. Therefore it\n/// is insecure by default, until the implementing contract carefully defines\n/// participants and time bounds.\n///\n/// Assuming that interactive seed generation is an acceptible UX/workflow, the\n/// main problem with commit/reveal schemes such as this is the \"last actor\"\n/// weakness. Whoever is the last party to reveal the secret can see every\n/// prior reveal, and knows the outcome of revealing their secret, so has an\n/// outsized degree of control over the final result. The last actor can choose\n/// if (can simply refuse to reveal) and when (dangerous if able to collude\n/// with minter to manipulate results) they reveal.\n///\n/// Common mitigation strategies involve rewards for revealing and punishments\n/// for not revealing. SeedDance makes some assumptions about how the seed is\n/// to be generated and used, allowing it to focus on _fairness_ of outcome\n/// rather than trying to avoid there being a last actor.\n///\n/// There WILL always be some last actor in every seed dance, but:\n/// - Nobody can predict who the last actor is ahead of time\n/// - It is difficult to predict who the last actor will be _during_ the dance\n/// - Everyone is equally likely to be in the position of last actor\n/// - Everyone chooses for themselves if/when to act, the order is not preset\n/// - Anyone who can currently reveal during the dance may randomise all other\n///   actor's ability to act\n///\n/// This is achieved by granting every address a random (up to a maximum)\n/// additional duration during which they may reveal their secret. Only the\n/// commiter of a secret may reveal it and have the shared secret updated, so\n/// we can restrict the time window during which each agent may meaningfully\n/// reveal the secret. Of course an agent may reveal a secret in a failed\n/// transaction and then everyone will be able to see it, but it won't change\n/// the seed. Every time a secret is revealed, it randomises everyone's time\n/// windows, thus implicitly changing who MAY be the last actor. This random\n/// shuffling MAY remove someone's ability to reveal that they previously had,\n/// or grant the ability to reveal to someone who had previously timed out.\n/// This mitigates the ability to manipulate the system by trying to be the\n/// last actor in the following ways:\n/// - The current last actor has only 1/N chance of being the last actor after\n///   each reveal\n/// - The longer the current last actor waits to reveal, the more likely it is\n///   they will lose the ability to reveal at all the next time their window is\n///   randomised, as they MAY be randomised to a time in the past\n/// - The longer any actor waits to reveal, the more likely they are to be\n///   front run on their reveal and have the subsequent shuffle rollback their\n///   attempt to reveal (because other agents know their own secret and can see\n///   the reveal in the mempool before it exists onchain)\n/// - As the reveal times are frequently being shuffled it is much more\n///   difficult for an agent to manipulate or censor a single or several blocks\n///   as/with a miner/validator to manipulate the overall outcome of the dance\n///\n/// Note that as the secret is broadcast to the mempool as soon as reveal is\n/// called, all other participants MAY front run the reveal in an attempt to\n/// grief that reveal. Similarly miners can reorg or exclude any\n/// reveal within a single block arbitrarily. While this likely will\n/// disadvantage the greifee it will still result in at least one global reseed\n/// and the greifer will consume their secret and commitment in the process.\n/// Subsequently some other seeder MAY roll the seed again in a way that\n/// allows the griefee access to the dance once more, but the griefer will have\n/// used their secret and so cannot attack a second time.\n///\n/// It is entirely that cartels form attempting to reseed the dance in their\n/// favour. In this case the best defense is a statistical one, for example an\n/// NFT project can engineer their rarities such that a large cartel implies a\n/// large sample size, so each reseed becomes increasingly boring as the cartel\n/// grows, thus undermining the advantage of having a cartel in the first place.\n/// This can work as statistically the chance of achieving an average outcome\n/// increases as the number of samples (members of the cartel) increases.\n///\n/// However, a griefing cartel MAY form with the sole goal to prevent a single\n/// or small number of addresses from acheiving a desirable outcome. In this\n/// case the attack MAY succeed if the cartel represents a large percentage of\n/// the dancers, but it still only requires a single reseed after the cartel\n/// performs its actions to completely negate all cartel actions. There is no\n/// specific defense against this kind of attack, other than to hope the chaos\n/// of the dance thwarts the cartel in the moment. One must ask why a cartel\n/// would form (which involves e.g. mass minting/buying NFTs) in the first\n/// place merely to perform a DOS style attack on a single wallet. It MAY\n/// happen sometime, but we expect it is unlikely to be a common occurance.\n///\n/// As there are no external or financial incentives required by the system,\n/// the dance instead relies on \"skin in the game\". The addresses that are\n/// allowed to commit secrets before the dance should only be those that are\n/// DIRECTLY impacted by the outcome of the final seed. For example, in the NFT\n/// mint/reveal workflow the dancers should be restricted to those addresses\n/// that bought/minted NFT IDs and so are impacted by the metadata assignment.\n/// By disallowing unaffected third parties it helps minimise the participation\n/// of wallets who simply want to grief some address with no cost (besides gas)\n/// to themselves.\n///\n/// Of course, as with all commit/reveal schemes, the secrets must be commited\n/// before the dance starts and the reveal will fail if the secret provided\n/// does not match the commitment. This prevents trivial manipulation of the\n/// outcome by \"revealing\" arbitrary secrets designed to benefit the revealer.\n///\n/// The dance starts when `_start` is called. This is an internal function that\n/// will fail if called more than once, but has no access controls by default.\n/// There is no explicit end to the dance. The dance is complete when no more\n/// agents will reveal their secret. This can only be observed once either all\n/// secrets are revealed or all times have expired, but it MAY be effectively\n/// true but impossible to measure when all parties are satisfied with the\n/// outcome of the dance and so will choose not to reveal.\n///\n/// There is no requirement that everyone reveals their secrets and the choice\n/// of initial seed is almost arbitrary. A block hash or similar can be used\n/// as all participants may immediately reseed any initial seed that they are\n/// not satisfied with. Even if a miner were to manipulate the starting seed it\n/// would be very likely to be hashed into something else that the miner cannot\n/// control or predict.\ncontract SeedDance {\n    using FixedPointMath for uint256;\n    using LibCommitment for Commitment;\n\n    /// The dance has started.\n    /// @param sender `msg.sender` that started the dance.\n    /// @param initialSeed The initial seed for the dance.\n    event Start(address sender, Seed initialSeed);\n\n    /// A new commitment is made.\n    /// @param sender `msg.sender` that is committing a secret.\n    /// @param commitment The cryptographic commitment (hash) for the secret.\n    event Commit(address sender, Commitment commitment);\n\n    /// A secret has been revealed.\n    /// @param sender `msg.sender` that has revealed their secret.\n    /// @param secret The secret that was successfully revealed\n    /// i.e. it matched the commitment within the time bounds.\n    /// @param newSeed The new shared seed resulting from hashing the revealed\n    /// secret with the old shared seed.\n    event Reveal(address sender, Secret secret, Seed newSeed);\n\n    /// The current shared seed that embodies all current revealed secrets from\n    /// the dance. Will be initialized when `_start` is called and zero before.\n    Seed internal _sharedSeed;\n\n    /// The timestamp the dance was started at. Will be 0 before the dance has\n    /// started.\n    uint32 private _startedAt;\n\n    /// All AVAILABLE commitments from all addresses who called `_commit`.\n    /// Each commitment is DELETED from storage when the owner calls `_reveal`.\n    /// owner => secret\n    mapping(address => Commitment) private _commitments;\n\n    /// Require this function to only be callable before the dance has started.\n    modifier onlyNotStarted() {\n        if (_startedAt > 0) {\n            require(block.timestamp < _startedAt, \"STARTED\");\n        }\n        _;\n    }\n\n    /// Start the dance. Can only happen once.\n    /// Has no access control so the implementing contract must safeguard the\n    /// workflow and decide when to start.\n    /// @param initialSeed_ The seed to start the dance with. Either all\n    /// dancers will be satisfied and do nothing or it will be quickly hashed\n    /// into oblivion during the dance.\n    function _start(Seed initialSeed_) internal onlyNotStarted {\n        // Initialize the dance.\n        _startedAt = uint32(block.timestamp);\n        _sharedSeed = initialSeed_;\n\n        // Tell the world.\n        emit Start(msg.sender, initialSeed_);\n    }\n\n    /// Before the dance starts anyone can commit a secret.\n    /// Has no access control so if committers is to be a closed set it must be\n    /// enforced by the implementing contract. The implementing contract SHOULD\n    /// ensure that only users with \"skin in the game\" can commit secrets, to\n    /// mitigate griefing strategies where sybils endlessly reseed at no cost\n    /// to themselves.\n    /// Users are free to commit as many times as they like prior to the dance\n    /// starting, which will overwrite previous commitments rending them\n    /// unusable during the dance. Once the dance starts no further additions\n    /// or changes to commitments can be made.\n    /// @param commitment_ The commitment (hash) for the secret that only\n    /// `msg.sender` knows. MUST match the secret or the subsequent reveal will\n    /// fail.\n    function _commit(Commitment commitment_) internal onlyNotStarted {\n        // Store the commitment over whatever was there before.\n        _commitments[msg.sender] = commitment_;\n\n        // Tell the world.\n        emit Commit(msg.sender, commitment_);\n    }\n\n    /// `msg.sender` reveals a valid secret, changing the shared seed and\n    /// consuming their commitment. To successfully reveal the sender MUST\n    /// complete the reveal within their personal time as defined by the\n    /// provided time bounds and current shared seed.\n    /// The implementing contract MUST ensure the validity of the time bounds\n    /// being passed in and any additional access controls for reveals.\n    /// Each secret can only be revealed once as the commitment will be deleted\n    /// after the first reveal per-secret.\n    /// Users can ONLY reveal their own commitments BUT their secret will be\n    /// publicly visible as soon as the transaction hits the mempool, so they\n    /// SHOULD NOT attempt a reveal if they believe the transaction will fail,\n    /// including due to being front run by other reveals reshuffling times.\n    /// @param timeBound_ The time bounds to check for the reveal. These are\n    /// NOT checked for validity so the caller MUST NOT trust user provided\n    /// bounds without verifying them.\n    /// @param secret_ The secret revealed by the user. MUST be revealed\n    /// within the user's personal time and match their prior commitment. MUST\n    /// be 32 bytes as we want to discourage predictable secrets and\n    /// unnecessarily long secrets.\n    function _reveal(TimeBound memory timeBound_, Secret secret_) internal {\n        // Enforce individual time constraints.\n        require(\n            block.timestamp <=\n                canRevealUntil(_sharedSeed, _startedAt, timeBound_, msg.sender),\n            \"CANT_REVEAL\"\n        );\n\n        // This will fail if the commitment was already consumed, we don't\n        // need an additional check for that case.\n        require(\n            _commitments[msg.sender].eq(LibCommitment.fromSecret(secret_)),\n            \"BAD_SECRET\"\n        );\n        // Clear out commitment so it can't be used again for the same seed.\n        // Also a lil' gas refund.\n        _commitments[msg.sender] = LibCommitment.nil();\n\n        // Build the new shared seed.\n        Seed newSeed_ = LibSeed.with(_sharedSeed, Secret.unwrap(secret_));\n        _sharedSeed = newSeed_;\n\n        // Notify the world.\n        emit Reveal(msg.sender, secret_, newSeed_);\n    }\n\n    /// Every owner can reveal until some time but this time is different for\n    /// every owner, and is reshuffled for every new shared secret.\n    /// @param seed_ The seed to calculate the final timestamp from. Will be\n    /// the shared seed when called from within `_reveal`.\n    /// @param start_ The start timestamp to calculate the final timestamp\n    /// relative to. Will be `_startedAt` when called from within `_reveal`. If\n    /// start_ is 0 then the returned `until_` will always be 0.\n    /// @param timeBound_ The time bounds to check for the hypothetical reveal.\n    /// This is not checked for validity so it is the responsibility of the\n    /// caller to ensure the bounds are correct or the return value will be\n    /// incorrect.\n    /// @param owner_ Owner of the secret that would hypothetically be revealed.\n    /// @return until_ The last second that the the owner can reveal, given all\n    /// the above parameters. Note that in real usage the above parameters can\n    /// change very quickly and unpredictably, including multiple times in a\n    /// single block. Even if a user checks their reveal time before calling\n    /// `_reveal`, they MAY be front run by another reveal that negates their\n    /// ability to reveal, potentially permanently. If `start_` is 0 then the\n    /// returned `until_` will always be 0.\n    function canRevealUntil(\n        Seed seed_,\n        uint256 start_,\n        TimeBound memory timeBound_,\n        address owner_\n    ) public pure returns (uint256 until_) {\n        unchecked {\n            // Default is to just return 0.\n            until_ = start_;\n\n            // If it isn't 0 then we've started so add the relevant duration.\n            if (until_ > 0) {\n                // Technically this means the duration will be [0, extra)\n                // rather than (0, extra] because of the % but let's assume\n                // nobody cares about the missing second enough to pay the gas\n                // to calculate it.\n                uint256 ownerExtraTime_ = Seed.unwrap(\n                    LibSeed.with(seed_, uint256(uint160(owner_)))\n                ) % timeBound_.maxExtraTime;\n                until_ += timeBound_.baseDuration + ownerExtraTime_;\n            }\n        }\n    }\n}\n"
    },
    "contracts/debug/LibDebug.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"hardhat/console.sol\";\n\n/// @title LibDebug\n/// @notice Development tools not intended for production usage.\nlibrary LibDebug {\n    event DebugEvent(uint256 value);\n    event DebugEvent(uint256[] values);\n    event DebugEvent(bytes value);\n\n    /// Outputs the entire allocated memory in the opinion of Solidity to an\n    /// event. Avoids allocating new memory in the process of emitting the event.\n    /// If memory has been written past the Solidity free memory pointer at 0x40\n    /// then it will NOT be included in the dump.\n    function dumpMemory() internal {\n        assembly (\"memory-safe\") {\n            log0(0, mload(0x40))\n        }\n    }\n\n    /// Logs the current position of the Solidity free memory pointer at 0x40.\n    function logFreeMemoryPointer() internal view {\n        uint256 ptr_;\n        assembly (\"memory-safe\") {\n            ptr_ := mload(0x40)\n        }\n        console.log(\"memory pointer: %s\", ptr_);\n    }\n\n    function emitEvent(uint256 value_) internal {\n        emit DebugEvent(value_);\n    }\n\n    function emitEvent(uint256[] memory values_) internal {\n        emit DebugEvent(values_);\n    }\n\n    function emitEvent(bytes memory value_) internal {\n        emit DebugEvent(value_);\n    }\n}\n"
    },
    "contracts/erc20/ERC20Config.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// Constructor config for standard Open Zeppelin ERC20.\n/// @param name Name as defined by Open Zeppelin ERC20.\n/// @param symbol Symbol as defined by Open Zeppelin ERC20.\n/// @param distributor Distributor address of the initial supply.\n/// MAY be zero.\n/// @param initialSupply Initial supply to mint.\n/// MAY be zero.\nstruct ERC20Config {\n    string name;\n    string symbol;\n    address distributor;\n    uint256 initialSupply;\n}\n"
    },
    "contracts/erc20/ERC20Redeem.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\ncontract ERC20Redeem is ERC20BurnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    /// Anon has burned their tokens in exchange for some treasury assets.\n    /// Emitted once per redeemed asset.\n    /// @param sender `msg.sender` is burning.\n    /// @param treasuryAsset Treasury asset being sent to redeemer.\n    /// @param redeemAmount Amount of token being burned.\n    /// @param assetAmount Amount of treasury asset being sent.\n    event Redeem(\n        address sender,\n        address treasuryAsset,\n        uint256 redeemAmount,\n        uint256 assetAmount\n    );\n\n    /// Anon can notify the world that they are adding treasury assets to the\n    /// contract. Indexers are strongly encouraged to ignore untrusted anons.\n    /// @param sender `msg.sender` adding a treasury asset.\n    /// @param asset The treasury asset being added.\n    event TreasuryAsset(address sender, address asset);\n\n    /// Anon can emit a `TreasuryAsset` event to notify token holders that\n    /// an asset could be redeemed by burning `RedeemableERC20` tokens.\n    /// As this is callable by anon the events should be filtered by the\n    /// indexer to those from trusted entities only.\n    /// @param newTreasuryAsset_ The asset to log.\n    function newTreasuryAsset(address newTreasuryAsset_) public {\n        emit TreasuryAsset(msg.sender, newTreasuryAsset_);\n    }\n\n    /// Burn tokens for a prorata share of the current treasury.\n    ///\n    /// The assets to be redeemed for must be specified as an array. This keeps\n    /// the redeem functionality:\n    /// - Gas efficient as we avoid tracking assets in storage\n    /// - Decentralised as any user can deposit any asset to be redeemed\n    /// - Error resistant as any individual asset reverting can be avoided by\n    ///   redeeming againt sans the problematic asset.\n    /// It is also a super sharp edge if someone burns their tokens prematurely\n    /// or with an incorrect asset list. Implementing contracts are strongly\n    /// encouraged to implement additional safety rails to prevent high value\n    /// mistakes.\n    /// Only \"vanilla\" erc20 token balances are supported as treasury assets.\n    /// I.e. if the balance is changing such as due to a rebasing token or\n    /// other mechanism then the WRONG token amounts will be redeemed. The\n    /// redemption calculation is very simple and naive in that it takes the\n    /// current balance of this contract of the assets being claimed via\n    /// redemption to calculate the \"prorata\" entitlement. If the contract's\n    /// balance of the claimed token is changing between redemptions (other\n    /// than due to the redemption itself) then each redemption will send\n    /// incorrect amounts.\n    /// @param treasuryAssets_ The list of assets to redeem.\n    /// @param redeemAmount_ The amount of redeemable token to burn.\n    function _redeem(\n        IERC20[] memory treasuryAssets_,\n        uint256 redeemAmount_\n    ) internal {\n        uint256 assetsLength_ = treasuryAssets_.length;\n\n        // Calculate everything before any balances change.\n        uint256[] memory amounts_ = new uint256[](assetsLength_);\n\n        // The fraction of the assets we release is the fraction of the\n        // outstanding total supply of the redeemable being burned.\n        // Every treasury asset is released in the same proportion.\n        // Guard against no asset redemptions and log all events before we\n        // change any contract state or call external contracts.\n        require(assetsLength_ > 0, \"EMPTY_ASSETS\");\n        uint256 supply_ = IERC20(address(this)).totalSupply();\n        uint256 amount_ = 0;\n        for (uint256 i_ = 0; i_ < assetsLength_; i_++) {\n            amount_ = treasuryAssets_[i_].balanceOf(address(this)).mulDiv(\n                redeemAmount_,\n                supply_\n            );\n            require(amount_ > 0, \"ZERO_AMOUNT\");\n            emit Redeem(\n                msg.sender,\n                address(treasuryAssets_[i_]),\n                redeemAmount_,\n                amount_\n            );\n            amounts_[i_] = amount_;\n        }\n\n        // Burn FIRST (reentrancy safety).\n        _burn(msg.sender, redeemAmount_);\n\n        // THEN send all assets.\n        for (uint256 i_ = 0; i_ < assetsLength_; i_++) {\n            treasuryAssets_[i_].safeTransfer(msg.sender, amounts_[i_]);\n        }\n    }\n}\n"
    },
    "contracts/escrow/RedeemableERC20ClaimEscrow.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {RedeemableERC20} from \"../redeemableERC20/RedeemableERC20.sol\";\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./SaleEscrow.sol\";\n\n/// Escrow contract for ERC20 tokens to be deposited and withdrawn against\n/// redeemableERC20 tokens from a specific `Sale`.\n///\n/// When some token is deposited the running total of that token against the\n/// trust is incremented by the deposited amount. When some `redeemableERC20`\n/// token holder calls `withdraw` they are sent the full balance they have not\n/// previously claimed, multiplied by their fraction of the redeemable token\n/// supply that they currently hold. As redeemable tokens are frozen after\n/// distribution there are no issues with holders manipulating withdrawals by\n/// transferring tokens to claim multiple times.\n///\n/// As redeemable tokens can be burned it is possible for the total supply to\n/// decrease over time, which naively would result in claims being larger\n/// retroactively (prorata increases beyond what can be paid).\n///\n/// For example:\n/// - Alice and Bob hold 50 rTKN each, 100 total supply\n/// - 100 TKN is deposited\n/// - Alice withdraws 50% of 100 TKN => alice holds 50 TKN escrow holds 50 TKN\n/// - Alice burns her 50 rTKN\n/// - Bob attempts to withdraw his 50 rTKN which is now 100% of supply\n/// - Escrow tries to pay 100% of 100 TKN deposited and fails as the escrow\n///   only holds 50 TKN (alice + bob = 150%).\n///\n/// To avoid the escrow allowing more withdrawals than deposits we include the\n/// total rTKN supply in the key of each deposit mapping, and include it in the\n/// emmitted event. Alice and Bob must read the events offchain and make a\n/// withdrawal relative to the rTKN supply as it was at deposit time. Many\n/// deposits can be made under a single rTKN supply and will all combine to a\n/// single withdrawal but deposits made across different supplies will require\n/// multiple withdrawals.\n///\n/// Alice or Bob could burn their tokens before withdrawing and would simply\n/// withdraw zero or only some of the deposited TKN. This hurts them\n/// individually, so they SHOULD check their indexer for claimable assets in\n/// the escrow before considering a burn. But neither of them can cause the\n/// other to be able to withdraw more or less relative to the supply as it was\n/// at the time of TKN being deposited, or to trick the escrow into overpaying\n/// more TKN than was deposited under a given `Sale`.\n///\n/// A griefer could attempt to flood the escrow with many dust deposits under\n/// many different supplies in an attempt to confuse alice/bob. They are free\n/// to filter out events in their indexer that come from an unknown depositor\n/// or fall below some dust value threshold.\n///\n/// Tokens may also exit the escrow as an `undeposit` call where the depositor\n/// receives back the tokens they deposited. As above the depositor must\n/// provide the rTKN supply from `deposit` time in order to `undeposit`.\n///\n/// As `withdraw` and `undeposit` both represent claims on the same tokens they\n/// are mutually exclusive outcomes, hence the need for an escrow. The escrow\n/// will process `withdraw` only if the `Sale` is reporting a complete and\n/// successful raise. Similarly `undeposit` will only return tokens after the\n/// `Sale` completes and reports failure. While the `Sale` is in active\n/// distribution neither `withdraw` or `undeposit` will move tokens. This is\n/// necessary in part because it is only safe to calculate entitlements once\n/// the redeemable tokens are fully distributed and frozen.\n///\n/// Because much of the redeemable token supply will never be sold, and then\n/// burned, `depositPending` MUST be called rather than `deposit` while the\n/// raise is active. When the raise completes anon can call `sweepPending`\n/// which will calculate and emit a `Deposit` event for a useful `supply`.\n///\n/// Any supported ERC20 token can be deposited at any time BUT ONLY under a\n/// `Sale` contract that is the child of the `TrustFactory` that the escrow\n/// is deployed for. `TrustEscrow` is used to prevent a `Sale` from changing\n/// the pass/fail outcome once it is known due to a bug/attempt to double\n/// spend escrow funds.\n///\n/// This mechanism is very similar to the native burn mechanism on\n/// `redeemableERC20` itself under `redeem` but without requiring any tokens to\n/// be burned in the process. Users can claim the same token many times safely,\n/// simply receiving 0 tokens if there is nothing left to claim.\n///\n/// This does NOT support rebase/elastic token _balance_ mechanisms on the\n/// escrowed token as the escrow has no way to track deposits/withdrawals other\n/// than 1:1 conservation of input/output. For example, if 100 tokens are\n/// deposited under two different trusts and then that token rebases all\n/// balances to half, there will be 50 tokens in the escrow but the escrow will\n/// attempt transfers up to 100 tokens between the two trusts. Essentially the\n/// first 50 tokens will send and the next 50 tokens will fail because the\n/// trust literally doesn't have 100 tokens at that point.\n///\n/// Elastic _supply_ tokens are supported as every token to be withdrawn must\n/// be first deposited, with the caveat that if some mechanism can\n/// mint/burn/transfer tokens out from under the escrow contract directly, this\n/// will break internal accounting much like the rebase situation.\n///\n/// Using a real-world example, stETH from LIDO would be NOT be supported as\n/// the balance changes every day to reflect incoming ETH from validators, but\n/// wstETH IS supported as balances remain static while the underlying assets\n/// per unit of wstETH increase each day. This is of course exactly why wstETH\n/// was created in the first place.\n///\n/// Every escrowed token has a separate space in the deposited/withdrawn\n/// mappings so that some broken/malicious/hacked token that leads to incorrect\n/// token movement in/out of the escrow cannot impact other tokens, even for\n/// the same trust and redeemable.\ncontract RedeemableERC20ClaimEscrow is SaleEscrow {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    /// Emitted for every successful pending deposit.\n    /// @param sender Anon `msg.sender` depositing the token.\n    /// @param sale `ISale` contract deposit is under.\n    /// @param redeemable Redeemable token that can claim this deposit.\n    /// Implicitly snapshots the redeemable so malicious `Trust` cannot\n    /// redirect funds later.\n    /// @param token `IERC20` token being deposited.\n    /// @param amount Amount of token deposited.\n    event PendingDeposit(\n        address sender,\n        address sale,\n        address redeemable,\n        address token,\n        uint256 amount\n    );\n\n    /// Emitted every time a pending deposit is swept to a full deposit.\n    /// @param sender Anon `msg.sender` sweeping the deposit.\n    /// @param depositor Anon `msg.sender` who originally deposited the token.\n    /// @param sale `ISale` contract deposit is under.\n    /// @param redeemable Redeemable token first reported by the trust.\n    /// @param token `IERC20` token being swept into a deposit.\n    /// @param amount Amount of token being swept into a deposit.\n    event Sweep(\n        address sender,\n        address depositor,\n        address sale,\n        address redeemable,\n        address token,\n        uint256 amount\n    );\n\n    /// Emitted for every successful deposit.\n    /// @param sender Anon `msg.sender` triggering the deposit.\n    /// MAY NOT be the `depositor` in the case of a pending sweep.\n    /// @param depositor Anon `msg.sender` who originally deposited the token.\n    /// MAY NOT be the current `msg.sender` in the case of a pending sweep.\n    /// @param sale `ISale` contract deposit is under.\n    /// @param redeemable Redeemable token that can claim this deposit.\n    /// @param token `IERC20` token being deposited.\n    /// @param supply rTKN supply at moment of deposit.\n    /// @param amount Amount of token deposited.\n    event Deposit(\n        address sender,\n        address depositor,\n        address sale,\n        address redeemable,\n        address token,\n        uint256 supply,\n        uint256 amount\n    );\n\n    /// Emitted for every successful undeposit.\n    /// @param sender Anon `msg.sender` undepositing the token.\n    /// @param sale `ISale` contract undeposit is from.\n    /// @param redeemable Redeemable token that is being undeposited against.\n    /// @param token `IERC20` token being undeposited.\n    /// @param supply rTKN supply at moment of deposit.\n    /// @param amount Amount of token undeposited.\n    event Undeposit(\n        address sender,\n        address sale,\n        address redeemable,\n        address token,\n        uint256 supply,\n        uint256 amount\n    );\n\n    /// Emitted for every successful withdrawal.\n    /// @param withdrawer Anon `msg.sender` withdrawing the token.\n    /// @param sale `ISale` contract withdrawal is from.\n    /// @param redeemable Redeemable token used to withdraw.\n    /// @param token `IERC20` token being withdrawn.\n    /// @param supply rTKN supply at moment of deposit.\n    /// @param amount Amount of token withdrawn.\n    event Withdraw(\n        address withdrawer,\n        address sale,\n        address redeemable,\n        address token,\n        uint256 supply,\n        uint256 amount\n    );\n\n    /// Every time an address calls `withdraw` their withdrawals increases to\n    /// match the current `totalDeposits` for that trust/token combination.\n    /// The token amount they actually receive is only their prorata share of\n    /// that deposited balance. The prorata scaling calculation happens inline\n    /// within the `withdraw` function.\n    /// trust => withdrawn token =>  rTKN supply => withdrawer => amount\n    mapping(address => mapping(address => mapping(uint256 => mapping(address => uint256))))\n        internal withdrawals;\n\n    /// Deposits during an active raise are desirable to trustlessly prove to\n    /// raise participants that they will in fact be able to access the TKN\n    /// after the raise succeeds. Deposits during the pending stage are set\n    /// aside with no rTKN supply mapping, to be swept into a real deposit by\n    /// anon once the raise completes.\n    mapping(address => mapping(address => mapping(address => uint256)))\n        internal pendingDeposits;\n\n    /// Every time an address calls `deposit` their deposited trust/token\n    /// combination is increased. If they call `undeposit` when the raise has\n    /// failed they will receive the full amount they deposited back. Every\n    /// depositor must call `undeposit` for themselves.\n    /// trust => deposited token => depositor => rTKN supply => amount\n    mapping(address => mapping(address => mapping(address => mapping(uint256 => uint256))))\n        internal deposits;\n\n    /// Every time an address calls `deposit` the amount is added to that\n    /// trust/token/supply combination. This increase becomes the\n    /// \"high water mark\" that withdrawals move up to with each `withdraw`\n    /// call.\n    /// trust => deposited token => rTKN supply => amount\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\n        internal totalDeposits;\n\n    /// Redundant tracking of deposits withdrawn.\n    /// Counts aggregate deposits down as users withdraw, while their own\n    /// individual withdrawal counters count up.\n    /// Guards against buggy/malicious redeemable tokens that don't correctly\n    /// freeze their balances, hence opening up double spends.\n    /// trust => deposited token => rTKN supply => amount\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\n        internal remainingDeposits;\n\n    /// Depositor can set aside tokens during pending raise status to be swept\n    /// into a real deposit later.\n    /// The problem with doing a normal deposit while the raise is still active\n    /// is that the `Sale` will burn all unsold tokens when the raise ends. If\n    /// we captured the token supply mid-raise then many deposited TKN would\n    /// be allocated to unsold rTKN. Instead we set aside TKN so that raise\n    /// participants can be sure that they will be claimable upon raise success\n    /// but they remain unbound to any rTKN supply until `sweepPending` is\n    /// called.\n    /// `depositPending` is a one-way function, there is no way to `undeposit`\n    /// until after the raise fails. Strongly recommended that depositors do\n    /// NOT call `depositPending` until raise starts, so they know it will also\n    /// end.\n    /// @param sale_ The `Sale` to assign this deposit to.\n    /// @param token_ The `IERC20` token to deposit to the escrow.\n    /// @param amount_ The amount of token to despoit. Requires depositor has\n    /// approved at least this amount to succeed.\n    function depositPending(\n        address sale_,\n        address token_,\n        uint256 amount_\n    ) external {\n        require(amount_ > 0, \"ZERO_DEPOSIT\");\n        require(escrowStatus(sale_) == EscrowStatus.Pending, \"NOT_PENDING\");\n        pendingDeposits[sale_][token_][msg.sender] += amount_;\n        // Important to snapshot the token from the trust here so it can't be\n        // changed later by the trust.\n        address redeemable_ = token(sale_);\n\n        emit PendingDeposit(msg.sender, sale_, redeemable_, token_, amount_);\n\n        IERC20(token_).safeTransferFrom(msg.sender, address(this), amount_);\n    }\n\n    /// Internal accounting for a deposit.\n    /// Identical for both a direct deposit and sweeping a pending deposit.\n    /// @param sale_ The sale to register a deposit under.\n    /// @param token_ The token being deposited.\n    /// @param depositor_ The depositor address to register the deposit under.\n    /// @param amount_ The size of the deposit denominated in `token_`.\n    function registerDeposit(\n        address sale_,\n        address token_,\n        address depositor_,\n        uint256 amount_\n    ) private {\n        require(escrowStatus(sale_) > EscrowStatus.Pending, \"PENDING\");\n        require(amount_ > 0, \"ZERO_DEPOSIT\");\n\n        address redeemable_ = token(sale_);\n        uint256 supply_ = IERC20(redeemable_).totalSupply();\n        // Zero supply means the escrow is at best useless (no recipients) and\n        // at worst dangerous (tokens trapped behind a divide by zero).\n        require(supply_ > 0, \"ZERO_SUPPLY\");\n\n        deposits[sale_][token_][depositor_][supply_] += amount_;\n        totalDeposits[sale_][token_][supply_] += amount_;\n        remainingDeposits[sale_][token_][supply_] += amount_;\n\n        emit Deposit(\n            msg.sender,\n            depositor_,\n            sale_,\n            redeemable_,\n            token_,\n            supply_,\n            amount_\n        );\n    }\n\n    /// Anon can convert any existing pending deposit to a deposit with known\n    /// rTKN supply once the escrow has moved out of pending status.\n    /// As `sweepPending` is anon callable, raise participants know that the\n    /// depositor cannot later prevent a sweep, and depositor knows that raise\n    /// participants cannot prevent a sweep. As per normal deposits, the output\n    /// of swept tokens depends on success/fail state allowing `undeposit` or\n    /// `withdraw` to be called subsequently.\n    /// Partial sweeps are NOT supported, to avoid griefers splitting a deposit\n    /// across many different `supply_` values.\n    /// @param sale_ The sale to sweep all pending deposits for.\n    /// @param token_ The token to sweep into registered deposits.\n    /// @param depositor_ The depositor to sweep registered deposits under.\n    function sweepPending(\n        address sale_,\n        address token_,\n        address depositor_\n    ) external {\n        uint256 amount_ = pendingDeposits[sale_][token_][depositor_];\n        delete pendingDeposits[sale_][token_][depositor_];\n        emit Sweep(\n            msg.sender,\n            depositor_,\n            sale_,\n            token(sale_),\n            token_,\n            amount_\n        );\n        registerDeposit(sale_, token_, depositor_, amount_);\n    }\n\n    /// Any address can deposit any amount of its own `IERC20` under a `Sale`.\n    /// The `Sale` MUST be a child of the trusted factory.\n    /// The deposit will be accounted for under both the depositor individually\n    /// and the trust in aggregate. The aggregate value is used by `withdraw`\n    /// and the individual value by `undeposit`.\n    /// The depositor is responsible for approving the token for this contract.\n    /// `deposit` is still enabled after the distribution ends; `undeposit` is\n    /// always allowed in case of a fail and disabled on success. Multiple\n    /// `deposit` calls before and after a success result are supported. If a\n    /// depositor deposits when a raise has failed they will need to undeposit\n    /// it again manually.\n    /// Delegated `deposit` is not supported. Every depositor is directly\n    /// responsible for every `deposit`.\n    /// WARNING: As `undeposit` can only be called when the `Sale` reports\n    /// failure, `deposit` should only be called when the caller is sure the\n    /// `Sale` will reach a clear success/fail status. For example, when a\n    /// `Sale` has not yet been seeded it may never even start the raise so\n    /// depositing at this point is dangerous. If the `Sale` never starts the\n    /// raise it will never fail the raise either.\n    /// @param sale_ The `Sale` to assign this deposit to.\n    /// @param token_ The `IERC20` token to deposit to the escrow.\n    /// @param amount_ The amount of token to deposit. Requires depositor has\n    /// approved at least this amount to succeed.\n    function deposit(address sale_, address token_, uint256 amount_) external {\n        registerDeposit(sale_, token_, msg.sender, amount_);\n        IERC20(token_).safeTransferFrom(msg.sender, address(this), amount_);\n    }\n\n    /// The inverse of `deposit`.\n    /// In the case of a failed distribution the depositors can claim back any\n    /// tokens they deposited in the escrow.\n    /// Ideally the distribution is a success and this does not need to be\n    /// called but it is important that we can walk back deposits and try again\n    /// for some future raise if needed.\n    /// Delegated `undeposit` is not supported, only the depositor can wind\n    /// back their original deposit.\n    /// `amount_` must be non-zero.\n    /// If several tokens have been deposited against a given trust for the\n    /// depositor then each token must be individually undeposited. There is\n    /// no onchain tracking or bulk processing for the depositor, they are\n    /// expected to know what they have previously deposited and if/when to\n    /// process an `undeposit`.\n    /// @param sale_ The `Sale` to undeposit from.\n    /// @param token_ The token to undeposit.\n    /// @param supply_ The total supply of the sale token associated with the\n    /// deposit being undeposited.\n    /// @param amount_ The amount to undeposit.\n    function undeposit(\n        address sale_,\n        address token_,\n        uint256 supply_,\n        uint256 amount_\n    ) external {\n        // Can only undeposit when the `Trust` reports failure.\n        require(escrowStatus(sale_) == EscrowStatus.Fail, \"NOT_FAIL\");\n        require(amount_ > 0, \"ZERO_AMOUNT\");\n\n        deposits[sale_][token_][msg.sender][supply_] -= amount_;\n        // Guard against outputs exceeding inputs.\n        // Last undeposit gets a gas refund.\n        totalDeposits[sale_][token_][supply_] -= amount_;\n        remainingDeposits[sale_][token_][supply_] -= amount_;\n\n        emit Undeposit(\n            msg.sender,\n            sale_,\n            // Include this in the event so that indexer consumers see a\n            // consistent world view even if the trust_ changes its answer\n            // about the redeemable.\n            token(sale_),\n            token_,\n            supply_,\n            amount_\n        );\n\n        IERC20(token_).safeTransfer(msg.sender, amount_);\n    }\n\n    /// The successful handover of a `deposit` to a recipient.\n    /// When a redeemable token distribution is successful the redeemable token\n    /// holders are automatically and immediately eligible to `withdraw` any\n    /// and all tokens previously deposited against the relevant `Sale`.\n    /// The `withdraw` can only happen if/when the relevant `Sale` reaches the\n    /// success distribution status.\n    /// Delegated `withdraw` is NOT supported. Every redeemable token holder is\n    /// directly responsible for being aware of and calling `withdraw`.\n    /// If a redeemable token holder calls `redeem` they also burn their claim\n    /// on any tokens held in escrow so they MUST first call `withdraw` THEN\n    /// `redeem`.\n    /// It is expected that the redeemable token holder knows about the tokens\n    /// that they will be withdrawing. This information is NOT tracked onchain\n    /// or exposed for bulk processing.\n    /// Partial `withdraw` is not supported, all tokens allocated to the caller\n    /// are withdrawn`. 0 amount withdrawal is an error, if the prorata share\n    /// of the token being claimed is small enough to round down to 0 then the\n    /// withdraw will revert.\n    /// Multiple withdrawals across multiple deposits is supported and is\n    /// equivalent to a single withdraw after all relevant deposits.\n    /// @param sale_ The trust to `withdraw` against.\n    /// @param token_ The token to `withdraw`.\n    /// @param supply_ The total supply of the sale token at time of deposit\n    /// to process this withdrawal against.\n    function withdraw(address sale_, address token_, uint256 supply_) external {\n        // Can only withdraw when the `Trust` reports success.\n        require(escrowStatus(sale_) == EscrowStatus.Success, \"NOT_SUCCESS\");\n\n        uint256 totalDeposited_ = totalDeposits[sale_][token_][supply_];\n        uint256 withdrawn_ = withdrawals[sale_][token_][supply_][msg.sender];\n        withdrawals[sale_][token_][supply_][msg.sender] = totalDeposited_;\n\n        RedeemableERC20 redeemable_ = RedeemableERC20(token(sale_));\n\n        uint256 amount_ = (totalDeposited_ - withdrawn_).mulDiv( // dust, for example. // receive less, so 0/33/33 from 100 with 34 TKN as escrow // for example. If someone burns before withdrawing they will // 3 ways will be 33 tokens each, leaving 1 TKN as escrow dust, // all get a share rounded down by integer division. 100 split // as at the time deposit was made. If nobody burns they will // prorata share of `msg.sender`'s current balance vs. supply // Underflow MUST error here (should not be possible).\n            redeemable_.balanceOf(msg.sender),\n            supply_\n        );\n\n        // Guard against outputs exceeding inputs.\n        // For example a malicious `Trust` could report a `redeemable_` token\n        // that does NOT freeze balances. In this case token holders can double\n        // spend their withdrawals by simply shuffling the same token around\n        // between accounts.\n        remainingDeposits[sale_][token_][supply_] -= amount_;\n\n        require(amount_ > 0, \"ZERO_WITHDRAW\");\n        emit Withdraw(\n            msg.sender,\n            sale_,\n            address(redeemable_),\n            token_,\n            supply_,\n            amount_\n        );\n        IERC20(token_).safeTransfer(msg.sender, amount_);\n    }\n}\n"
    },
    "contracts/escrow/SaleEscrow.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"../sale/ISaleV2.sol\";\n\n/// Represents the 3 possible statuses an escrow could care about.\n/// Either the escrow takes no action or consistently allows a success/fail\n/// action.\nenum EscrowStatus {\n    /// The underlying `Sale` has not reached a definitive pass/fail state.\n    /// Important this is the first item in the enum as inequality is used to\n    /// check pending vs. pass/fail in security sensitive code.\n    Pending,\n    /// The underlying `Sale` distribution failed.\n    Fail,\n    /// The underlying `Sale` distribution succeeded.\n    Success\n}\n\n/// @title SaleEscrow\n/// An escrow that is designed to work with untrusted `Sale` bytecode.\n/// `escrowStatus` wraps `Sale` functions to guarantee that results do not\n/// change. Reserve and token addresses never change for a given `Sale` and\n/// a pass/fail result is one-way. Even if some bug in the `Sale` causes the\n/// pass/fail status to flip, this will not result in the escrow double\n/// spending or otherwise changing the direction that it sends funds.\ncontract SaleEscrow {\n    /// ISale address => reserve address.\n    mapping(address => address) internal reserves;\n    /// ISale address => token address.\n    mapping(address => address) internal tokens;\n    /// ISale address => status.\n    mapping(address => EscrowStatus) internal escrowStatuses;\n\n    /// Immutable wrapper around `ISale.reserve`.\n    /// Once a `Sale` reports a reserve address the `SaleEscrow` never asks\n    /// again. Prevents a malicious `Sale` from changing the reserve at some\n    /// point to break internal escrow accounting.\n    /// @param sale_ The ISale to fetch reserve for.\n    function reserve(address sale_) internal returns (address) {\n        address reserve_ = reserves[sale_];\n        if (reserve_ == address(0)) {\n            address saleReserve_ = address(ISaleV2(sale_).reserve());\n            require(saleReserve_ != address(0), \"0_RESERVE\");\n            reserves[sale_] = saleReserve_;\n            reserve_ = saleReserve_;\n        }\n        return reserve_;\n    }\n\n    /// Immutable wrapper around `ISale.token`.\n    /// Once a `Sale` reports a token address the `SaleEscrow` never asks\n    /// again. Prevents a malicious `Sale` from changing the token at some\n    /// point to divert escrow payments after assets have already been set\n    /// aside.\n    /// @param sale_ The ISale to fetch token for.\n    function token(address sale_) internal returns (address) {\n        address token_ = tokens[sale_];\n        if (token_ == address(0)) {\n            address saleToken_ = address(ISaleV2(sale_).token());\n            require(saleToken_ != address(0), \"0_TOKEN\");\n            tokens[sale_] = saleToken_;\n            token_ = saleToken_;\n        }\n        return token_;\n    }\n\n    /// Read the one-way, one-time transition from pending to success/fail.\n    /// We never change our opinion of a success/fail outcome.\n    /// If a buggy/malicious `ISale` somehow changes success/fail state then\n    /// that is obviously bad as the escrow will release funds in the wrong\n    /// direction. But if we were to change our opinion that would be worse as\n    /// claims/refunds could potentially be \"double spent\" somehow.\n    /// @param sale_ The sale to get the escrow status for.\n    function escrowStatus(address sale_) internal returns (EscrowStatus) {\n        EscrowStatus escrowStatus_ = escrowStatuses[sale_];\n        // Short circuit and ignore the `ISale` if we previously saved a value.\n        if (escrowStatus_ > EscrowStatus.Pending) {\n            return escrowStatus_;\n        }\n        // We have never seen a success/fail outcome so need to ask the `ISale`\n        // for the distribution status.\n        else {\n            SaleStatus saleStatus_ = ISaleV2(sale_).saleStatus();\n            // Success maps to success.\n            if (saleStatus_ == SaleStatus.Success) {\n                escrowStatuses[sale_] = EscrowStatus.Success;\n                return EscrowStatus.Success;\n            }\n            // Fail maps to fail.\n            else if (saleStatus_ == SaleStatus.Fail) {\n                escrowStatuses[sale_] = EscrowStatus.Fail;\n                return EscrowStatus.Fail;\n            }\n            // Everything else is still pending.\n            else {\n                return EscrowStatus.Pending;\n            }\n        }\n    }\n}\n"
    },
    "contracts/factory/Factory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {IFactory} from \"./IFactory.sol\";\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n/// Thrown when a new factory deployment creates a child that was already created\n/// by a previous deployment. This should never happen without some kind of\n/// precompute such as CREATE2 and is generally unsupported at this time.\nerror DuplicateChild(address child);\n\n/// @title Factory\n/// @notice Base contract for deploying and registering child contracts.\nabstract contract Factory is IFactory, ReentrancyGuard {\n    /// @dev state to track each deployed contract address. A `Factory` will\n    /// never lie about deploying a child, unless `isChild` is overridden to do\n    /// so.\n    mapping(address => bool) private contracts;\n\n    constructor() {\n        // Technically `ReentrancyGuard` is initializable but allowing it to be\n        // initialized is a foot-gun as the status will be set to _NOT_ENTERED.\n        // This would allow re-entrant behaviour upon initialization of the\n        // `Factory` and is unnecessary as the reentrancy guard always restores\n        // _NOT_ENTERED after every call anyway.\n        _disableInitializers();\n    }\n\n    /// Implements `IFactory`.\n    ///\n    /// `_createChild` hook must be overridden to actually create child\n    /// contract.\n    ///\n    /// Implementers may want to overload this function with a typed equivalent\n    /// to expose domain specific structs etc. to the compiled ABI consumed by\n    /// tooling and other scripts. To minimise gas costs for deployment it is\n    /// expected that the tooling will consume the typed ABI, then encode the\n    /// arguments and pass them to this function directly.\n    ///\n    /// @param data_ ABI encoded data to pass to child contract constructor.\n    function _createChild(\n        bytes memory data_\n    ) internal virtual returns (address);\n\n    /// Implements `IFactory`.\n    ///\n    /// Calls the `_createChild` hook that inheriting contracts must override.\n    /// Registers child contract address such that `isChild` is `true`.\n    /// Emits `NewChild` event.\n    ///\n    /// @param data_ Encoded data to pass down to child contract constructor.\n    /// @return New child contract address.\n    function createChild(\n        bytes memory data_\n    ) public virtual override nonReentrant returns (address) {\n        // Create child contract using hook.\n        address child_ = _createChild(data_);\n\n        // Ensure the child at this address has not previously been deployed.\n        if (contracts[child_]) {\n            revert DuplicateChild(child_);\n        }\n\n        // Register child contract address to `contracts` mapping.\n        contracts[child_] = true;\n        // Emit `NewChild` event with child contract address.\n        emit IFactory.NewChild(msg.sender, child_);\n        return child_;\n    }\n\n    /// Implements `IFactory`.\n    ///\n    /// Checks if address is registered as a child contract of this factory.\n    ///\n    /// @param maybeChild_ Address of child contract to look up.\n    /// @return Returns `true` if address is a contract created by this\n    /// contract factory, otherwise `false`.\n    function isChild(\n        address maybeChild_\n    ) external view virtual override returns (bool) {\n        return contracts[maybeChild_];\n    }\n}\n"
    },
    "contracts/factory/IFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\ninterface IFactory {\n    /// Whenever a new child contract is deployed, a `NewChild` event\n    /// containing the new child contract address MUST be emitted.\n    /// @param sender `msg.sender` that deployed the contract (factory).\n    /// @param child address of the newly deployed child.\n    event NewChild(address sender, address child);\n\n    /// Factories that clone a template contract MUST emit an event any time\n    /// they set the implementation being cloned. Factories that deploy new\n    /// contracts without cloning do NOT need to emit this.\n    /// @param sender `msg.sender` that deployed the implementation (factory).\n    /// @param implementation address of the implementation contract that will\n    /// be used for future clones if relevant.\n    event Implementation(address sender, address implementation);\n\n    /// Creates a new child contract.\n    ///\n    /// @param data_ Domain specific data for the child contract constructor.\n    /// @return New child contract address.\n    function createChild(bytes calldata data_) external returns (address);\n\n    /// Checks if address is registered as a child contract of this factory.\n    ///\n    /// Addresses that were not deployed by `createChild` MUST NOT return\n    /// `true` from `isChild`. This is CRITICAL to the security guarantees for\n    /// any contract implementing `IFactory`.\n    ///\n    /// @param maybeChild_ Address to check registration for.\n    /// @return `true` if address was deployed by this contract factory,\n    /// otherwise `false`.\n    function isChild(address maybeChild_) external view returns (bool);\n}\n"
    },
    "contracts/flow/basic/Flow.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"../FlowCommon.sol\";\nimport \"../libraries/LibFlow.sol\";\nimport \"../../array/LibUint256Array.sol\";\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nstruct FlowConfig {\n    StateConfig stateConfig;\n    FlowCommonConfig flowConfig;\n}\n\ncontract Flow is ReentrancyGuard, FlowCommon {\n    using LibInterpreterState for InterpreterState;\n    using LibUint256Array for uint256[];\n\n    event Initialize(address sender, FlowConfig config);\n\n    /// @param config_ allowed flows set at initialization.\n    function initialize(FlowConfig calldata config_) external initializer {\n        __FlowCommon_init(config_.flowConfig, MIN_FLOW_SENTINELS);\n        emit Initialize(msg.sender, config_);\n    }\n\n    function _previewFlow(\n        EncodedDispatch dispatch_,\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) internal view returns (FlowTransfer memory, uint256[] memory) {\n        (\n            StackPointer stackBottom_,\n            StackPointer stackTop_,\n            uint256[] memory stateChanges_\n        ) = flowStack(dispatch_, callerContext_, signedContexts_);\n        return (LibFlow.stackToFlow(stackBottom_, stackTop_), stateChanges_);\n    }\n\n    function previewFlow(\n        EncodedDispatch dispatch_,\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) external view virtual returns (FlowTransfer memory) {\n        (FlowTransfer memory flowTransfer_, ) = _previewFlow(\n            dispatch_,\n            callerContext_,\n            signedContexts_\n        );\n        return flowTransfer_;\n    }\n\n    function flow(\n        EncodedDispatch dispatch_,\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) external payable virtual nonReentrant {\n        (\n            FlowTransfer memory flowTransfer_,\n            uint256[] memory stateChanges_\n        ) = _previewFlow(dispatch_, callerContext_, signedContexts_);\n        LibFlow.flow(flowTransfer_, _interpreter, stateChanges_);\n    }\n}\n"
    },
    "contracts/flow/basic/FlowFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {Factory} from \"../../factory/Factory.sol\";\nimport {Flow, FlowConfig} from \"./Flow.sol\";\nimport {ClonesUpgradeable as Clones} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\nimport {LibInterpreterState} from \"../../interpreter/run/LibInterpreterState.sol\";\n\n/// @title FlowFactory\n/// @notice Factory for deploying and registering `Flow` contracts.\ncontract FlowFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new Flow());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(\n        bytes memory data_\n    ) internal virtual override returns (address) {\n        FlowConfig memory config_ = abi.decode(data_, (FlowConfig));\n        address clone_ = Clones.clone(implementation);\n        Flow(payable(clone_)).initialize(config_);\n        return clone_;\n    }\n\n    /// Allows calling `createChild` with `StateConfig` struct.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `Flow` constructor configuration.\n    /// @return New `Flow` child contract address.\n    function createChildTyped(\n        FlowConfig memory config_\n    ) external returns (Flow) {\n        return Flow(payable(createChild(abi.encode(config_))));\n    }\n}\n"
    },
    "contracts/flow/erc1155/FlowERC1155.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"../../sentinel/LibSentinel.sol\";\nimport \"../libraries/LibFlow.sol\";\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../FlowCommon.sol\";\nimport {ERC1155Upgradeable as ERC1155} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport {ERC1155ReceiverUpgradeable as ERC1155Receiver} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol\";\nimport \"../../interpreter/run/LibEncodedDispatch.sol\";\n\nuint256 constant RAIN_FLOW_ERC1155_SENTINEL = uint256(\n    keccak256(bytes(\"RAIN_FLOW_ERC1155_SENTINEL\")) | SENTINEL_HIGH_BITS\n);\n\nstruct FlowERC1155Config {\n    string uri;\n    StateConfig stateConfig;\n    FlowCommonConfig flowConfig;\n}\n\nstruct ERC1155SupplyChange {\n    address account;\n    uint256 id;\n    uint256 amount;\n}\n\nstruct FlowERC1155IO {\n    ERC1155SupplyChange[] mints;\n    ERC1155SupplyChange[] burns;\n    FlowTransfer flow;\n}\n\nSourceIndex constant CAN_TRANSFER_ENTRYPOINT = SourceIndex.wrap(0);\nuint256 constant CAN_TRANSFER_MIN_OUTPUTS = 1;\nuint256 constant CAN_TRANSFER_MAX_OUTPUTS = 1;\n\nuint256 constant FLOW_ERC1155_MIN_OUTPUTS = MIN_FLOW_SENTINELS + 2;\n\ncontract FlowERC1155 is ReentrancyGuard, FlowCommon, ERC1155 {\n    using LibStackPointer for StackPointer;\n    using LibStackPointer for uint256[];\n    using LibUint256Array for uint256;\n    using LibUint256Array for uint256[];\n\n    event Initialize(address sender, FlowERC1155Config config);\n\n    EncodedDispatch internal _dispatch;\n\n    function initialize(\n        FlowERC1155Config calldata config_\n    ) external initializer {\n        emit Initialize(msg.sender, config_);\n        __ReentrancyGuard_init();\n        __ERC1155_init(config_.uri);\n        // Ignoring context scratch here as we never use it, all context is\n        // provided unconditionally.\n        address expression_ = IExpressionDeployerV1(\n            config_.flowConfig.expressionDeployer\n        ).deployExpression(\n                config_.stateConfig,\n                LibUint256Array.arrayFrom(CAN_TRANSFER_MIN_OUTPUTS)\n            );\n\n        _dispatch = LibEncodedDispatch.encode(\n            expression_,\n            CAN_TRANSFER_ENTRYPOINT,\n            CAN_TRANSFER_MAX_OUTPUTS\n        );\n        __FlowCommon_init(config_.flowConfig, FLOW_ERC1155_MIN_OUTPUTS);\n    }\n\n    /// Needed here to fix Open Zeppelin implementing `supportsInterface` on\n    /// multiple base contracts.\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC1155, ERC1155Receiver) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc ERC1155\n    function _afterTokenTransfer(\n        address operator_,\n        address from_,\n        address to_,\n        uint256[] memory ids_,\n        uint256[] memory amounts_,\n        bytes memory data_\n    ) internal virtual override {\n        unchecked {\n            super._afterTokenTransfer(\n                operator_,\n                from_,\n                to_,\n                ids_,\n                amounts_,\n                data_\n            );\n            // Mint and burn access MUST be handled by flow.\n            // CAN_TRANSFER will only restrict subsequent transfers.\n            if (!(from_ == address(0) || to_ == address(0))) {\n                IInterpreterV1 interpreter_ = _interpreter;\n                EncodedDispatch dispatch_ = _dispatch;\n\n                for (uint256 i_ = 0; i_ < ids_.length; i_++) {\n                    uint256[][] memory context_ = LibUint256Array\n                        .arrayFrom(\n                            uint(uint160(msg.sender)),\n                            uint(uint160(operator_)),\n                            uint256(uint160(from_)),\n                            uint256(uint160(to_)),\n                            ids_[i_],\n                            amounts_[i_]\n                        )\n                        .matrixFrom();\n                    (\n                        uint256[] memory stack_,\n                        uint256[] memory stateChanges_\n                    ) = interpreter_.eval(dispatch_, context_);\n                    require(\n                        stack_.asStackPointerAfter().peek() > 0,\n                        \"INVALID_TRANSFER\"\n                    );\n                    if (stateChanges_.length > 0) {\n                        interpreter_.stateChanges(stateChanges_);\n                    }\n                }\n            }\n        }\n    }\n\n    function _previewFlow(\n        EncodedDispatch dispatch_,\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) internal view returns (FlowERC1155IO memory, uint256[] memory) {\n        uint256[] memory refs_;\n        FlowERC1155IO memory flowIO_;\n        (\n            StackPointer stackBottom_,\n            StackPointer stackTop_,\n            uint256[] memory stateChanges_\n        ) = flowStack(dispatch_, callerContext_, signedContexts_);\n        (stackTop_, refs_) = stackTop_.consumeStructs(\n            stackBottom_,\n            RAIN_FLOW_ERC1155_SENTINEL,\n            3\n        );\n        assembly (\"memory-safe\") {\n            mstore(flowIO_, refs_)\n        }\n        (stackTop_, refs_) = stackTop_.consumeStructs(\n            stackBottom_,\n            RAIN_FLOW_ERC1155_SENTINEL,\n            3\n        );\n        assembly (\"memory-safe\") {\n            mstore(add(flowIO_, 0x20), refs_)\n        }\n        flowIO_.flow = LibFlow.stackToFlow(stackBottom_, stackTop_);\n        return (flowIO_, stateChanges_);\n    }\n\n    function _flow(\n        EncodedDispatch dispatch_,\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) internal virtual nonReentrant returns (FlowERC1155IO memory) {\n        unchecked {\n            (\n                FlowERC1155IO memory flowIO_,\n                uint256[] memory stateChanges_\n            ) = _previewFlow(dispatch_, callerContext_, signedContexts_);\n            for (uint256 i_ = 0; i_ < flowIO_.mints.length; i_++) {\n                // @todo support data somehow.\n                _mint(\n                    flowIO_.mints[i_].account,\n                    flowIO_.mints[i_].id,\n                    flowIO_.mints[i_].amount,\n                    \"\"\n                );\n            }\n            for (uint256 i_ = 0; i_ < flowIO_.burns.length; i_++) {\n                _burn(\n                    flowIO_.burns[i_].account,\n                    flowIO_.burns[i_].id,\n                    flowIO_.burns[i_].amount\n                );\n            }\n            LibFlow.flow(flowIO_.flow, _interpreter, stateChanges_);\n            return flowIO_;\n        }\n    }\n\n    function previewFlow(\n        EncodedDispatch dispatch_,\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) external view virtual returns (FlowERC1155IO memory) {\n        (FlowERC1155IO memory flowERC1155IO_, ) = _previewFlow(\n            dispatch_,\n            callerContext_,\n            signedContexts_\n        );\n        return flowERC1155IO_;\n    }\n\n    function flow(\n        EncodedDispatch dispatch_,\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) external payable virtual returns (FlowERC1155IO memory) {\n        return _flow(dispatch_, callerContext_, signedContexts_);\n    }\n}\n"
    },
    "contracts/flow/erc1155/FlowERC1155Factory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {Factory} from \"../../factory/Factory.sol\";\nimport {FlowERC1155, FlowERC1155Config} from \"./FlowERC1155.sol\";\nimport {ClonesUpgradeable as Clones} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\n/// @title EmissionsERC1155Factory\n/// @notice Factory for deploying and registering `FlowERC1155` contracts.\ncontract FlowERC1155Factory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new FlowERC1155());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(\n        bytes memory data_\n    ) internal virtual override returns (address) {\n        FlowERC1155Config memory config_ = abi.decode(\n            data_,\n            (FlowERC1155Config)\n        );\n        address clone_ = Clones.clone(implementation);\n        FlowERC1155(payable(clone_)).initialize(config_);\n        return clone_;\n    }\n\n    /// Allows calling `createChild` with `FlowERC1155Config` struct.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `FlowERC1155` constructor configuration.\n    /// @return New `FlowERC1155` child contract address.\n    function createChildTyped(\n        FlowERC1155Config memory config_\n    ) external returns (FlowERC1155) {\n        return FlowERC1155(payable(createChild(abi.encode(config_))));\n    }\n}\n"
    },
    "contracts/flow/erc20/FlowERC20.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"../../interpreter/deploy/IExpressionDeployerV1.sol\";\nimport {AllStandardOps} from \"../../interpreter/ops/AllStandardOps.sol\";\nimport {ERC20Upgradeable as ERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"../../array/LibUint256Array.sol\";\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../libraries/LibFlow.sol\";\nimport \"../../math/FixedPointMath.sol\";\nimport \"../FlowCommon.sol\";\nimport \"../../interpreter/run/LibEncodedDispatch.sol\";\n\nuint256 constant RAIN_FLOW_ERC20_SENTINEL = uint256(\n    keccak256(bytes(\"RAIN_FLOW_ERC20_SENTINEL\")) | SENTINEL_HIGH_BITS\n);\n\n/// Constructor config.\n/// @param Constructor config for the ERC20 token minted according to flow\n/// schedule in `flow`.\n/// @param Constructor config for the `ImmutableSource` that defines the\n/// emissions schedule for claiming.\nstruct FlowERC20Config {\n    string name;\n    string symbol;\n    StateConfig stateConfig;\n    FlowCommonConfig flowConfig;\n}\n\nstruct ERC20SupplyChange {\n    address account;\n    uint256 amount;\n}\n\nstruct FlowERC20IO {\n    ERC20SupplyChange[] mints;\n    ERC20SupplyChange[] burns;\n    FlowTransfer flow;\n}\n\nSourceIndex constant CAN_TRANSFER_ENTRYPOINT = SourceIndex.wrap(0);\nuint256 constant CAN_TRANSFER_MIN_OUTPUTS = 1;\nuint256 constant CAN_TRANSFER_MAX_OUTPUTS = 1;\n\n/// @title FlowERC20\n/// @notice Mints itself according to some predefined schedule. The schedule is\n/// expressed as an expression and the `claim` function is world-callable.\n/// Intended behaviour is to avoid sybils infinitely minting by putting the\n/// claim functionality behind a `TierV2` contract. The flow contract\n/// itself implements `ReadOnlyTier` and every time a claim is processed it\n/// logs the block number of the claim against every tier claimed. So the block\n/// numbers in the tier report for `FlowERC20` are the last time that tier\n/// was claimed against this contract. The simplest way to make use of this\n/// information is to take the max block for the underlying tier and the last\n/// claim and then diff it against the current block number.\n/// See `test/Claim/FlowERC20.sol.ts` for examples, including providing\n/// staggered rewards where more tokens are minted for higher tier accounts.\ncontract FlowERC20 is ReentrancyGuard, FlowCommon, ERC20 {\n    using LibStackPointer for uint256[];\n    using LibStackPointer for StackPointer;\n    using LibUint256Array for uint256;\n    using LibUint256Array for uint256[];\n    using LibInterpreterState for InterpreterState;\n    using FixedPointMath for uint256;\n\n    /// Contract has initialized.\n    /// @param sender `msg.sender` initializing the contract (factory).\n    /// @param config All initialized config.\n    event Initialize(address sender, FlowERC20Config config);\n\n    EncodedDispatch internal _dispatch;\n\n    /// @param config_ source and token config. Also controls delegated claims.\n    function initialize(FlowERC20Config memory config_) external initializer {\n        emit Initialize(msg.sender, config_);\n        __ReentrancyGuard_init();\n        __ERC20_init(config_.name, config_.symbol);\n        address expression_ = IExpressionDeployerV1(\n            config_.flowConfig.expressionDeployer\n        ).deployExpression(\n                config_.stateConfig,\n                LibUint256Array.arrayFrom(CAN_TRANSFER_MIN_OUTPUTS)\n            );\n        _dispatch = LibEncodedDispatch.encode(\n            expression_,\n            CAN_TRANSFER_ENTRYPOINT,\n            CAN_TRANSFER_MAX_OUTPUTS\n        );\n        __FlowCommon_init(config_.flowConfig, MIN_FLOW_SENTINELS + 2);\n    }\n\n    /// @inheritdoc ERC20\n    function _afterTokenTransfer(\n        address from_,\n        address to_,\n        uint256 amount_\n    ) internal virtual override {\n        super._afterTokenTransfer(from_, to_, amount_);\n        // Mint and burn access MUST be handled by flow.\n        // CAN_TRANSFER will only restrict subsequent transfers.\n        if (!(from_ == address(0) || to_ == address(0))) {\n            uint256[][] memory context_ = LibUint256Array\n                .arrayFrom(\n                    uint(uint160(msg.sender)),\n                    uint256(uint160(from_)),\n                    uint256(uint160(to_)),\n                    amount_\n                )\n                .matrixFrom();\n            EncodedDispatch dispatch_ = _dispatch;\n            (\n                uint256[] memory stack_,\n                uint256[] memory stateChanges_\n            ) = _interpreter.eval(dispatch_, context_);\n            require(\n                stack_.asStackPointerAfter().peek() > 0,\n                \"INVALID_TRANSFER\"\n            );\n            if (stateChanges_.length > 0) {\n                _interpreter.stateChanges(stateChanges_);\n            }\n        }\n    }\n\n    function _previewFlow(\n        EncodedDispatch dispatch_,\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) internal view virtual returns (FlowERC20IO memory, uint256[] memory) {\n        uint256[] memory refs_;\n        FlowERC20IO memory flowIO_;\n        (\n            StackPointer stackBottom_,\n            StackPointer stackTop_,\n            uint256[] memory stateChanges_\n        ) = flowStack(dispatch_, callerContext_, signedContexts_);\n        (stackTop_, refs_) = stackTop_.consumeStructs(\n            stackBottom_,\n            RAIN_FLOW_ERC20_SENTINEL,\n            2\n        );\n        assembly (\"memory-safe\") {\n            mstore(flowIO_, refs_)\n        }\n        (stackTop_, refs_) = stackTop_.consumeStructs(\n            stackBottom_,\n            RAIN_FLOW_ERC20_SENTINEL,\n            2\n        );\n        assembly (\"memory-safe\") {\n            mstore(add(flowIO_, 0x20), refs_)\n        }\n        flowIO_.flow = LibFlow.stackToFlow(stackBottom_, stackTop_);\n\n        return (flowIO_, stateChanges_);\n    }\n\n    function _flow(\n        EncodedDispatch dispatch_,\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) internal virtual nonReentrant returns (FlowERC20IO memory) {\n        (\n            FlowERC20IO memory flowIO_,\n            uint256[] memory stateChanges_\n        ) = _previewFlow(dispatch_, callerContext_, signedContexts_);\n        for (uint256 i_ = 0; i_ < flowIO_.mints.length; i_++) {\n            _mint(flowIO_.mints[i_].account, flowIO_.mints[i_].amount);\n        }\n        for (uint256 i_ = 0; i_ < flowIO_.burns.length; i_++) {\n            _burn(flowIO_.burns[i_].account, flowIO_.burns[i_].amount);\n        }\n        LibFlow.flow(flowIO_.flow, _interpreter, stateChanges_);\n        return flowIO_;\n    }\n\n    function previewFlow(\n        EncodedDispatch dispatch_,\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) external view virtual returns (FlowERC20IO memory) {\n        (FlowERC20IO memory flowERC20IO_, ) = _previewFlow(\n            dispatch_,\n            callerContext_,\n            signedContexts_\n        );\n        return flowERC20IO_;\n    }\n\n    function flow(\n        EncodedDispatch dispatch_,\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) external payable virtual returns (FlowERC20IO memory) {\n        return _flow(dispatch_, callerContext_, signedContexts_);\n    }\n}\n"
    },
    "contracts/flow/erc20/FlowERC20Factory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {Factory} from \"../../factory/Factory.sol\";\nimport {FlowERC20, FlowERC20Config} from \"../erc20/FlowERC20.sol\";\nimport {ClonesUpgradeable as Clones} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\n/// @title EmissionsERC20Factory\n/// @notice Factory for deploying and registering `FlowERC20` contracts.\ncontract FlowERC20Factory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new FlowERC20());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(\n        bytes memory data_\n    ) internal virtual override returns (address) {\n        FlowERC20Config memory config_ = abi.decode(data_, (FlowERC20Config));\n        address clone_ = Clones.clone(implementation);\n        FlowERC20(payable(clone_)).initialize(config_);\n        return clone_;\n    }\n\n    /// Allows calling `createChild` with `FlowERC20Config` struct.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `FlowERC20` constructor configuration.\n    /// @return New `FlowERC20` child contract address.\n    function createChildTyped(\n        FlowERC20Config memory config_\n    ) external returns (FlowERC20) {\n        return FlowERC20(payable(createChild(abi.encode(config_))));\n    }\n}\n"
    },
    "contracts/flow/erc721/FlowERC721.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"../../interpreter/deploy/IExpressionDeployerV1.sol\";\nimport {AllStandardOps} from \"../../interpreter/ops/AllStandardOps.sol\";\nimport {ERC721Upgradeable as ERC721} from \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\nimport \"../../array/LibUint256Array.sol\";\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../libraries/LibFlow.sol\";\nimport \"../../math/FixedPointMath.sol\";\nimport \"../FlowCommon.sol\";\nimport \"../../sentinel/LibSentinel.sol\";\nimport {ERC1155ReceiverUpgradeable as ERC1155Receiver} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol\";\nimport \"../../interpreter/run/LibEncodedDispatch.sol\";\n\nuint256 constant RAIN_FLOW_ERC721_SENTINEL = uint256(\n    keccak256(bytes(\"RAIN_FLOW_ERC721_SENTINEL\")) | SENTINEL_HIGH_BITS\n);\n\n/// Constructor config.\n/// @param Constructor config for the ERC721 token minted according to flow\n/// schedule in `flow`.\n/// @param Constructor config for the `ImmutableSource` that defines the\n/// emissions schedule for claiming.\nstruct FlowERC721Config {\n    string name;\n    string symbol;\n    StateConfig stateConfig;\n    FlowCommonConfig flowConfig;\n}\n\nstruct ERC721SupplyChange {\n    address account;\n    uint256 id;\n}\n\nstruct FlowERC721IO {\n    ERC721SupplyChange[] mints;\n    ERC721SupplyChange[] burns;\n    FlowTransfer flow;\n}\n\nSourceIndex constant CAN_TRANSFER_ENTRYPOINT = SourceIndex.wrap(0);\nuint256 constant CAN_TRANSFER_MIN_OUTPUTS = 1;\nuint256 constant CAN_TRANSFER_MAX_OUTPUTS = 1;\n\n/// @title FlowERC721\ncontract FlowERC721 is ReentrancyGuard, FlowCommon, ERC721 {\n    using LibStackPointer for uint256[];\n    using LibStackPointer for StackPointer;\n    using LibUint256Array for uint256;\n    using LibUint256Array for uint256[];\n    using LibInterpreterState for InterpreterState;\n    using FixedPointMath for uint256;\n\n    /// Contract has initialized.\n    /// @param sender `msg.sender` initializing the contract (factory).\n    /// @param config All initialized config.\n    event Initialize(address sender, FlowERC721Config config);\n\n    EncodedDispatch internal _dispatch;\n\n    /// @param config_ source and token config. Also controls delegated claims.\n    function initialize(\n        FlowERC721Config calldata config_\n    ) external initializer {\n        emit Initialize(msg.sender, config_);\n        __ReentrancyGuard_init();\n        __ERC721_init(config_.name, config_.symbol);\n        address expression_ = IExpressionDeployerV1(\n            config_.flowConfig.expressionDeployer\n        ).deployExpression(\n                config_.stateConfig,\n                LibUint256Array.arrayFrom(CAN_TRANSFER_MIN_OUTPUTS)\n            );\n        _dispatch = LibEncodedDispatch.encode(\n            expression_,\n            CAN_TRANSFER_ENTRYPOINT,\n            CAN_TRANSFER_MAX_OUTPUTS\n        );\n        __FlowCommon_init(config_.flowConfig, MIN_FLOW_SENTINELS + 2);\n    }\n\n    /// Needed here to fix Open Zeppelin implementing `supportsInterface` on\n    /// multiple base contracts.\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(ERC721, ERC1155Receiver) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /// @inheritdoc ERC721\n    function _afterTokenTransfer(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 batchSize_\n    ) internal virtual override {\n        super._afterTokenTransfer(from_, to_, tokenId_, batchSize_);\n        // Mint and burn access MUST be handled by CAN_FLOW.\n        // CAN_TRANSFER will only restrict subsequent transfers.\n        if (!(from_ == address(0) || to_ == address(0))) {\n            uint256[] memory callerContext_ = LibUint256Array.arrayFrom(\n                uint256(uint160(from_)),\n                uint256(uint160(to_)),\n                tokenId_,\n                batchSize_\n            );\n            EncodedDispatch dispatch_ = _dispatch;\n            (\n                uint256[] memory stack_,\n                uint256[] memory stateChanges_\n            ) = _interpreter.eval(\n                    dispatch_,\n                    LibContext.build(\n                        new uint256[][](0),\n                        callerContext_,\n                        new SignedContext[](0)\n                    )\n                );\n            require(\n                stack_.asStackPointerAfter().peek() > 0,\n                \"INVALID_TRANSFER\"\n            );\n            if (stateChanges_.length > 0) {\n                _interpreter.stateChanges(stateChanges_);\n            }\n        }\n    }\n\n    function _previewFlow(\n        EncodedDispatch dispatch_,\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) internal view returns (FlowERC721IO memory, uint256[] memory) {\n        uint256[] memory refs_;\n        FlowERC721IO memory flowIO_;\n        (\n            StackPointer stackBottom_,\n            StackPointer stackTop_,\n            uint256[] memory stateChanges_\n        ) = flowStack(dispatch_, callerContext_, signedContexts_);\n        // mints\n        (stackTop_, refs_) = stackTop_.consumeStructs(\n            stackBottom_,\n            RAIN_FLOW_ERC721_SENTINEL,\n            2\n        );\n        assembly (\"memory-safe\") {\n            mstore(flowIO_, refs_)\n        }\n        // burns\n        (stackTop_, refs_) = stackTop_.consumeStructs(\n            stackBottom_,\n            RAIN_FLOW_ERC721_SENTINEL,\n            2\n        );\n        assembly (\"memory-safe\") {\n            mstore(add(flowIO_, 0x20), refs_)\n        }\n        flowIO_.flow = LibFlow.stackToFlow(stackBottom_, stackTop_);\n        return (flowIO_, stateChanges_);\n    }\n\n    function _flow(\n        EncodedDispatch dispatch_,\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) internal virtual nonReentrant returns (FlowERC721IO memory) {\n        unchecked {\n            (\n                FlowERC721IO memory flowIO_,\n                uint256[] memory stateChanges_\n            ) = _previewFlow(dispatch_, callerContext_, signedContexts_);\n            for (uint256 i_ = 0; i_ < flowIO_.mints.length; i_++) {\n                _safeMint(flowIO_.mints[i_].account, flowIO_.mints[i_].id);\n            }\n            for (uint256 i_ = 0; i_ < flowIO_.burns.length; i_++) {\n                uint256 burnId_ = flowIO_.burns[i_].id;\n                require(\n                    ERC721.ownerOf(burnId_) == flowIO_.burns[i_].account,\n                    \"NOT_OWNER\"\n                );\n                _burn(burnId_);\n            }\n            LibFlow.flow(flowIO_.flow, _interpreter, stateChanges_);\n            return flowIO_;\n        }\n    }\n\n    function previewFlow(\n        EncodedDispatch dispatch_,\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) external view virtual returns (FlowERC721IO memory) {\n        (FlowERC721IO memory flowERC721IO_, ) = _previewFlow(\n            dispatch_,\n            callerContext_,\n            signedContexts_\n        );\n        return flowERC721IO_;\n    }\n\n    function flow(\n        EncodedDispatch dispatch_,\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) external payable virtual returns (FlowERC721IO memory) {\n        return _flow(dispatch_, callerContext_, signedContexts_);\n    }\n}\n"
    },
    "contracts/flow/erc721/FlowERC721Factory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {Factory} from \"../../factory/Factory.sol\";\nimport {FlowERC721, FlowERC721Config} from \"./FlowERC721.sol\";\nimport {ClonesUpgradeable as Clones} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\n/// @title EmissionsERC721Factory\n/// @notice Factory for deploying and registering `FlowERC721` contracts.\ncontract FlowERC721Factory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new FlowERC721());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(\n        bytes memory data_\n    ) internal virtual override returns (address) {\n        FlowERC721Config memory config_ = abi.decode(data_, (FlowERC721Config));\n        address clone_ = Clones.clone(implementation);\n        FlowERC721(payable(clone_)).initialize(config_);\n        return clone_;\n    }\n\n    /// Allows calling `createChild` with `FlowERC721Config` struct.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `FlowERC721` constructor configuration.\n    /// @return New `FlowERC721` child contract address.\n    function createChildTyped(\n        FlowERC721Config memory config_\n    ) external returns (FlowERC721) {\n        return FlowERC721(payable(createChild(abi.encode(config_))));\n    }\n}\n"
    },
    "contracts/flow/FlowCommon.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"./libraries/LibFlow.sol\";\nimport \"../interpreter/deploy/IExpressionDeployerV1.sol\";\nimport \"../interpreter/run/IInterpreterV1.sol\";\nimport \"../interpreter/run/LibEncodedDispatch.sol\";\nimport \"../interpreter/run/LibContext.sol\";\nimport \"../interpreter/run/LibInterpreterState.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {MulticallUpgradeable as Multicall} from \"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\";\nimport {ERC721HolderUpgradeable as ERC721Holder} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport {ERC1155HolderUpgradeable as ERC1155Holder} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155HolderUpgradeable.sol\";\n\nuint256 constant FLAG_COLUMN_FLOW_ID = 0;\nuint256 constant FLAG_ROW_FLOW_ID = 0;\nuint256 constant FLAG_COLUMN_FLOW_TIME = 0;\nuint256 constant FLAG_ROW_FLOW_TIME = 2;\n\nuint256 constant MIN_FLOW_SENTINELS = 4;\n\nSourceIndex constant FLOW_ENTRYPOINT = SourceIndex.wrap(0);\nuint256 constant FLOW_MAX_OUTPUTS = type(uint16).max;\n\nstruct FlowCommonConfig {\n    address expressionDeployer;\n    address interpreter;\n    StateConfig[] flows;\n}\n\ncontract FlowCommon is ERC721Holder, ERC1155Holder, Multicall {\n    using LibInterpreterState for InterpreterState;\n    using LibStackPointer for StackPointer;\n    using LibStackPointer for uint256[];\n    using LibUint256Array for uint256;\n    using LibUint256Array for uint256[];\n\n    IInterpreterV1 internal _interpreter;\n\n    /// flow expression pointer => is registered\n    mapping(EncodedDispatch => uint256) internal _flows;\n\n    event FlowInitialized(\n        address sender,\n        address interpreter,\n        EncodedDispatch dispatch\n    );\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function __FlowCommon_init(\n        FlowCommonConfig memory config_,\n        uint256 flowMinOutputs_\n    ) internal onlyInitializing {\n        __ERC721Holder_init();\n        __ERC1155Holder_init();\n        __Multicall_init();\n        require(flowMinOutputs_ >= MIN_FLOW_SENTINELS, \"BAD MIN STACKS LENGTH\");\n        _interpreter = IInterpreterV1(config_.interpreter);\n        for (uint256 i_ = 0; i_ < config_.flows.length; i_++) {\n            address expression_ = IExpressionDeployerV1(\n                config_.expressionDeployer\n            ).deployExpression(\n                    config_.flows[i_],\n                    LibUint256Array.arrayFrom(flowMinOutputs_)\n                );\n            EncodedDispatch dispatch_ = LibEncodedDispatch.encode(\n                expression_,\n                FLOW_ENTRYPOINT,\n                FLOW_MAX_OUTPUTS\n            );\n            _flows[dispatch_] = 1;\n            emit FlowInitialized(msg.sender, config_.interpreter, dispatch_);\n        }\n    }\n\n    modifier onlyRegisteredDispatch(EncodedDispatch dispatch_) {\n        require(_flows[dispatch_] > 0, \"UNREGISTERED_FLOW\");\n        _;\n    }\n\n    function flowStack(\n        EncodedDispatch dispatch_,\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    )\n        internal\n        view\n        onlyRegisteredDispatch(dispatch_)\n        returns (StackPointer, StackPointer, uint256[] memory)\n    {\n        (uint256[] memory stack_, uint256[] memory stateChanges_) = _interpreter\n            .eval(\n                dispatch_,\n                LibContext.build(\n                    new uint256[][](0),\n                    callerContext_,\n                    signedContexts_\n                )\n            );\n        return (\n            stack_.asStackPointerUp(),\n            stack_.asStackPointerAfter(),\n            stateChanges_\n        );\n    }\n\n    receive() external payable virtual {}\n}\n"
    },
    "contracts/flow/libraries/LibFlow.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../interpreter/run/LibStackPointer.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {IERC721Upgradeable as IERC721} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport {IERC1155Upgradeable as IERC1155} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport {AddressUpgradeable as Address} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"../../sentinel/LibSentinel.sol\";\nimport {SafeCastUpgradeable as SafeCast} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\n/// @dev We want a sentinel with the following properties:\n/// - Won't collide with token amounts (| with very large number)\n/// - Won't collide with token addresses\n/// - Won't collide with common values like `type(uint256).max` and\n///   `type(uint256).min`\n/// - Won't collide with other sentinels from unrelated contexts\nuint256 constant RAIN_FLOW_SENTINEL = uint256(\n    keccak256(bytes(\"RAIN_FLOW_SENTINEL\")) | SENTINEL_HIGH_BITS\n);\n\nstruct NativeTransfer {\n    address from;\n    address to;\n    uint256 amount;\n}\n\nstruct ERC20Transfer {\n    address token;\n    address from;\n    address to;\n    uint256 amount;\n}\n\nstruct ERC721Transfer {\n    address token;\n    address from;\n    address to;\n    uint256 id;\n}\n\nstruct ERC1155Transfer {\n    address token;\n    address from;\n    address to;\n    uint256 id;\n    uint256 amount;\n}\n\nstruct FlowTransfer {\n    NativeTransfer[] native;\n    ERC20Transfer[] erc20;\n    ERC721Transfer[] erc721;\n    ERC1155Transfer[] erc1155;\n}\n\nlibrary LibFlow {\n    using Address for address payable;\n    using SafeERC20 for IERC20;\n    using LibStackPointer for StackPointer;\n    using SafeCast for uint256;\n    using LibFlow for FlowTransfer;\n    using LibUint256Array for uint256[];\n\n    function stackToFlow(\n        StackPointer stackBottom_,\n        StackPointer stackTop_\n    ) internal pure returns (FlowTransfer memory) {\n        unchecked {\n            FlowTransfer memory transfer_;\n            uint256[] memory refs_;\n            // native\n            (stackTop_, refs_) = stackTop_.consumeStructs(\n                stackBottom_,\n                RAIN_FLOW_SENTINEL,\n                3\n            );\n            assembly (\"memory-safe\") {\n                mstore(transfer_, refs_)\n            }\n            // erc20\n            (stackTop_, refs_) = stackTop_.consumeStructs(\n                stackBottom_,\n                RAIN_FLOW_SENTINEL,\n                4\n            );\n            assembly (\"memory-safe\") {\n                mstore(add(transfer_, 0x20), refs_)\n            }\n            // erc721\n            (stackTop_, refs_) = stackTop_.consumeStructs(\n                stackBottom_,\n                RAIN_FLOW_SENTINEL,\n                4\n            );\n            assembly (\"memory-safe\") {\n                mstore(add(transfer_, 0x40), refs_)\n            }\n            // erc1155\n            (stackTop_, refs_) = stackTop_.consumeStructs(\n                stackBottom_,\n                RAIN_FLOW_SENTINEL,\n                5\n            );\n            assembly (\"memory-safe\") {\n                mstore(add(transfer_, 0x60), refs_)\n            }\n            return transfer_;\n        }\n    }\n\n    function flowNative(FlowTransfer memory flowTransfer_) internal {\n        unchecked {\n            uint256 youToMe_ = 0;\n            uint256 meToYou_ = 0;\n            NativeTransfer memory transfer_;\n            for (uint256 i_ = 0; i_ < flowTransfer_.native.length; i_++) {\n                transfer_ = flowTransfer_.native[i_];\n                if (transfer_.from == msg.sender) {\n                    require(\n                        transfer_.to == address(this),\n                        \"UNSUPPORTED_NATIVE_FLOW\"\n                    );\n                    youToMe_ += transfer_.amount;\n                } else {\n                    require(\n                        transfer_.from == address(this),\n                        \"UNSUPPORTED_NATIVE_FLOW\"\n                    );\n                    if (transfer_.to == msg.sender) {\n                        meToYou_ += transfer_.amount;\n                    } else {\n                        payable(transfer_.to).sendValue(transfer_.amount);\n                    }\n                }\n            }\n\n            if (youToMe_ > 0) {\n                // This will overflow if the msg.value is less than youToMe_.\n                // Will refund any excess incoming value.\n                meToYou_ += msg.value - youToMe_;\n            }\n            if (meToYou_ > 0) {\n                payable(msg.sender).sendValue(meToYou_);\n            }\n        }\n    }\n\n    function flowERC20(FlowTransfer memory flowTransfer_) internal {\n        unchecked {\n            ERC20Transfer memory transfer_;\n            for (uint256 i_ = 0; i_ < flowTransfer_.erc20.length; i_++) {\n                transfer_ = flowTransfer_.erc20[i_];\n                if (transfer_.from == msg.sender) {\n                    IERC20(transfer_.token).safeTransferFrom(\n                        msg.sender,\n                        transfer_.to,\n                        transfer_.amount\n                    );\n                } else if (transfer_.from == address(this)) {\n                    IERC20(transfer_.token).safeTransfer(\n                        transfer_.to,\n                        transfer_.amount\n                    );\n                } else {\n                    // We don't support `from` as anyone other than `you` or `me`\n                    // as this would allow for all kinds of issues re: approvals.\n                    revert(\"UNSUPPORTED_ERC20_FLOW\");\n                }\n            }\n        }\n    }\n\n    function flowERC721(FlowTransfer memory flowTransfer_) internal {\n        unchecked {\n            ERC721Transfer memory transfer_;\n            for (uint256 i_ = 0; i_ < flowTransfer_.erc721.length; i_++) {\n                transfer_ = flowTransfer_.erc721[i_];\n                require(\n                    transfer_.from == msg.sender ||\n                        transfer_.from == address(this),\n                    \"UNSUPPORTED_ERC721_FLOW\"\n                );\n                IERC721(transfer_.token).safeTransferFrom(\n                    transfer_.from,\n                    transfer_.to,\n                    transfer_.id\n                );\n            }\n        }\n    }\n\n    function flowERC1155(FlowTransfer memory flowTransfer_) internal {\n        unchecked {\n            ERC1155Transfer memory transfer_;\n            for (uint256 i_ = 0; i_ < flowTransfer_.erc1155.length; i_++) {\n                transfer_ = flowTransfer_.erc1155[i_];\n                require(\n                    transfer_.from == msg.sender ||\n                        transfer_.from == address(this),\n                    \"UNSUPPORTED_ERC1155_FLOW\"\n                );\n                // @todo safeBatchTransferFrom support.\n                // @todo data support.\n                IERC1155(transfer_.token).safeTransferFrom(\n                    transfer_.from,\n                    transfer_.to,\n                    transfer_.id,\n                    transfer_.amount,\n                    \"\"\n                );\n            }\n        }\n    }\n\n    function flow(\n        FlowTransfer memory flowTransfer_,\n        IInterpreterV1 interpreter_,\n        uint256[] memory stateChanges_\n    ) internal {\n        if (stateChanges_.length > 0) {\n            interpreter_.stateChanges(stateChanges_);\n        }\n        flowTransfer_.flowNative();\n        flowTransfer_.flowERC20();\n        flowTransfer_.flowERC721();\n        flowTransfer_.flowERC1155();\n    }\n}\n"
    },
    "contracts/ierc3156/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: CC0\n// Alberto Cuesta Cañada, Fiona Kobayashi, fubuloubu, Austin Williams, \"EIP-3156: Flash Loans,\" Ethereum Improvement Proposals, no. 3156, November 2020. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-3156.\npragma solidity ^0.8.0;\n\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "contracts/ierc3156/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: CC0\n// Alberto Cuesta Cañada, Fiona Kobayashi, fubuloubu, Austin Williams, \"EIP-3156: Flash Loans,\" Ethereum Improvement Proposals, no. 3156, November 2020. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-3156.\npragma solidity ^0.8.0;\nimport \"./IERC3156FlashBorrower.sol\";\n\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lent.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(\n        address token,\n        uint256 amount\n    ) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "contracts/interpreter/deploy/IExpressionDeployerV1.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\n/// Config required to build a new `State`.\n/// @param sources Sources verbatim. These sources MUST be provided in their\n/// sequential/index opcode form as the deployment process will need to index\n/// into BOTH the integrity check and the final runtime function pointers.\n/// This will be emitted in an event for offchain processing to use the indexed\n/// opcode sources. The first N sources are considered entrypoints and will be\n/// integrity checked by the expression deployer against a starting stack height\n/// of 0. Non-entrypoint sources MAY be provided for internal use such as the\n/// `call` opcode but will NOT be integrity checked UNLESS entered by an opcode\n/// in an entrypoint.\n/// @param constants Constants verbatim. Constants are provided alongside sources\n/// rather than inline as it allows us to avoid variable length opcodes and can\n/// be more memory efficient if the same constant is referenced several times\n/// from the sources.\nstruct StateConfig {\n    bytes[] sources;\n    uint256[] constants;\n}\n\n/// @title IExpressionDeployerV1\n/// @notice Companion to `IInterpreterV1` responsible for onchain static code\n/// analysis and deploying expressions. Each `IExpressionDeployerV1` is tightly\n/// coupled at the bytecode level to some interpreter that it knows how to\n/// analyse and deploy expressions for. The expression deployer can perform an\n/// integrity check \"dry run\" of candidate source code for the intepreter. The\n/// critical analysis/transformation includes:\n///\n/// - Enforcement of no out of bounds memory reads/writes\n/// - Calculation of memory required to eval the stack with a single allocation\n/// - Replacing index based opcodes with absolute interpreter function pointers\n/// - Enforcement that all opcodes and operands used exist and are valid\n///\n/// This analysis is highly sensitive to the specific implementation and position\n/// of all opcodes and function pointers as compiled into the interpreter. This\n/// is what makes the coupling between an interpreter and expression deployer\n/// so tight. Ideally all responsibilities would be handled by a single contract\n/// but this introduces code size issues quickly by roughly doubling the compiled\n/// logic of each opcode (half for the integrity check and half for evaluation).\n///\n/// Interpreters MUST assume that expression deployers are malicious and fail\n/// gracefully if the integrity check is corrupt/bypassed and/or function\n/// pointers are incorrect, etc. i.e. the interpreter MUST always return a stack\n/// from `eval` in a read only way or error. I.e. it is the expression deployer's\n/// responsibility to do everything it can to prevent undefined behaviour in the\n/// interpreter, and the interpreter's responsibility to handle the expression\n/// deployer completely failing to do so.\ninterface IExpressionDeployerV1 {\n    /// Expressions are expected to be deployed onchain as immutable contract\n    /// code with a first class address like any other contract or account.\n    /// Technically this is optional in the sense that all the tools required to\n    /// eval some expression and define all its opcodes are available as libraries.\n    ///\n    /// In practise there are enough advantages to deploying the sources directly\n    /// onchain as contract data and loading them from the interpreter at eval time:\n    ///\n    /// - Loading and storing binary data is gas efficient as immutable contract data\n    /// - Expressions need to be immutable between their deploy time integrity check\n    ///   and runtime evaluation\n    /// - Passing the address of an expression through calldata to an interpreter is\n    ///   cheaper than passing an entire expression through calldata\n    /// - Conceptually a very simple approach, even if implementations like SSTORE2\n    ///   are subtle under the hood\n    ///\n    /// The expression deployer MUST perform an integrity check of the source code\n    /// before it puts the expression onchain at a known address. The integrity check\n    /// MUST at a minimum (it is free to do additional static analysis) calculate the\n    /// memory required to be allocated for the stack in total, and that no out of\n    /// bounds memory reads/writes occur within this stack. A simple example of an\n    /// invalid source would be one that pushes one value to the stack then attempts\n    /// to pops two values, clearly we cannot remove more values than we added. The\n    /// `IExpressionDeployerV1` MUST revert in the case of any integrity failure, all\n    /// integrity checks MUST pass in order for the deployment to complete.\n    ///\n    /// Once the integrity check is complete the `IExpressionDeployerV1` MUST do any\n    /// additional processing required by its paired interpreter. For example, the\n    /// `IExpressionDeployerV1` MAY NEED to replace the indexed opcodes in the\n    /// `StateConfig` sources with real function pointers from the corresponding\n    /// interpreter.\n    ///\n    /// @param config All the state config associated with an expression.\n    /// @param minOutputs The first N sources on the state config are entrypoints to\n    /// the expression where N is the length of the `minOutputs` array. Each item in\n    /// the `minOutputs` array specifies the number of outputs that MUST be present\n    /// on the final stack for an evaluation of each entrypoint. The minimum output\n    /// for some entrypoint MAY be zero if the expectation is that the expression\n    /// only applies checks and error logic. Non-entrypoint sources MUST NOT have a\n    /// minimum outputs length specified.\n    /// @return expression The onchain address of the deployed expression.\n    function deployExpression(\n        StateConfig memory config,\n        uint256[] memory minOutputs\n    ) external returns (address expression);\n}\n"
    },
    "contracts/interpreter/deploy/LibIntegrityCheck.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../run/LibStackPointer.sol\";\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\nimport \"./IExpressionDeployerV1.sol\";\nimport \"../run/IInterpreterV1.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @dev The virtual stack pointers are never read or written so don't need to\n/// point to a real location in memory. We only care that the stack never moves\n/// below its starting point at the stack bottom. For the virtual stack used by\n/// the integrity check we can start it in the middle of the `uint256` range and\n/// achieve something analogous to signed integers with unsigned integer types.\nStackPointer constant INITIAL_STACK_BOTTOM = StackPointer.wrap(\n    type(uint256).max / 2\n);\n\n/// It is a misconfiguration to set the initial stack bottom to zero or some\n/// small value as this trivially exposes the integrity check to potential\n/// underflow issues that are gas intensive to repeatedly guard against on every\n/// pop. The initial stack bottom for an `IntegrityCheckState` should be\n/// `INITIAL_STACK_BOTTOM` to safely avoid the need for underflow checks due to\n/// pops and pushes.\nerror MinStackBottom();\n\n/// The virtual stack top has underflowed the stack highwater (or zero) during an\n/// integrity check. The highwater will initially be the stack bottom but MAY\n/// move higher due to certain operations such as placing multiple outputs on the\n/// stack or copying from a stack position. The highwater prevents subsequent\n/// popping of values that are considered immutable.\n/// @param stackHighwaterIndex Index of the stack highwater at the moment of\n/// underflow.\n/// @param stackTopIndex Index of the stack top at the moment of underflow.\nerror StackPopUnderflow(uint256 stackHighwaterIndex, uint256 stackTopIndex);\n\n/// The final stack produced by some source did not hit the minimum required for\n/// its calling context.\n/// @param minStackOutputs The required minimum stack height.\n/// @param actualStackOutputs The final stack height after evaluating a source.\n/// Will be less than the min stack outputs if this error is thrown.\nerror MinFinalStack(uint256 minStackOutputs, uint256 actualStackOutputs);\n\n/// Running an integrity check is a stateful operation. As well as the basic\n/// configuration of what is being checked such as the sources and size of the\n/// constants, the current and maximum stack height is being recomputed on every\n/// checked opcode. The stack is virtual during the integrity check so whatever\n/// the `StackPointer` values are during the check, it's always undefined\n/// behaviour to actually try to read/write to them.\n///\n/// @param sources All the sources of the expression are provided to the\n/// integrity check as any entrypoint and non-entrypoint can `call` into some\n/// other source at any time, provided the overall inputs and outputs to the\n/// stack are valid.\n/// @param constantsLength The integrity check assumes the existence of some\n/// opcode that will read from a predefined list of constants. Technically this\n/// opcode MAY NOT exist in some interpreter but it seems highly likely to be\n/// included in most setups. The integrity check only needs the length of the\n/// constants array to check for out of bounds reads, which allows runtime\n/// behaviour to read without additional gas for OOB index checks.\n/// @param stackBottom Pointer to the bottom of the virtual stack that the\n/// integrity check uses to simulate a real eval.\n/// @param stackMaxTop Pointer to the maximum height the virtual stack has\n/// reached during the integrity check. The current virtual stack height will\n/// be handled separately to the state during the check.\n/// @param integrityFunctionPointers We pass an array of all the function\n/// pointers to per-opcode integrity checks around with the state to facilitate\n/// simple recursive integrity checking.\nstruct IntegrityCheckState {\n    // Sources in zeroth position as we read from it in assembly without paying\n    // gas to calculate offsets.\n    bytes[] sources;\n    uint256 constantsLength;\n    StackPointer stackBottom;\n    StackPointer stackHighwater;\n    StackPointer stackMaxTop;\n    function(IntegrityCheckState memory, Operand, StackPointer)\n        view\n        returns (StackPointer)[] integrityFunctionPointers;\n}\n\n/// @title LibIntegrityCheck\n/// @notice \"Dry run\" versions of the key logic from `LibStackPointer` that\n/// allows us to simulate a virtual stack based on the Solidity type system\n/// itself. The core loop of an integrity check is to dispatch an integrity-only\n/// version of a runtime opcode that then uses `LibIntegrityCheck` to apply a\n/// function that simulates a stack movement. The simulated stack movement will\n/// move a pointer to memory in the same way as a real pop/push would at runtime\n/// but without any associated logic or even allocating and writing data in\n/// memory on the other side of the pointer. Every pop is checked for out of\n/// bounds reads, even if it is an intermediate pop within the logic of a single\n/// opcode. The _gross_ stack movement is just as important as the net movement.\n/// For example, consider a simple ERC20 total supply read. The _net_ movement\n/// of a total supply read is 0, it pops the token address then pushes the total\n/// supply. However the _gross_ movement is first -1 then +1, so we have to guard\n/// against the -1 underflowing while reading the token address _during_ the\n/// simulated opcode dispatch. In general this can be subtle, complex and error\n/// prone, which is why `LibIntegrityCheck` and `LibStackPointer` take function\n/// signatures as arguments, so that the overloading mechanism in Solidity itself\n/// enforces correct pop/push calculations for every opcode.\nlibrary LibIntegrityCheck {\n    using LibIntegrityCheck for IntegrityCheckState;\n    using LibStackPointer for StackPointer;\n    using Math for uint256;\n\n    function newState(\n        StateConfig memory config_,\n        function(IntegrityCheckState memory, Operand, StackPointer)\n            view\n            returns (StackPointer)[]\n            memory integrityFns_\n    ) internal pure returns (IntegrityCheckState memory) {\n        return\n            IntegrityCheckState(\n                config_.sources,\n                config_.constants.length,\n                INITIAL_STACK_BOTTOM,\n                // Highwater starts underneath stack bottom as it errors on an\n                // greater than _or equal to_ check.\n                INITIAL_STACK_BOTTOM.down(),\n                INITIAL_STACK_BOTTOM,\n                integrityFns_\n            );\n    }\n\n    /// If the given stack pointer is above the current state of the max stack\n    /// top, the max stack top will be moved to the stack pointer.\n    /// i.e. this works like `stackMaxTop = stackMaxTop.max(stackPointer_)` but\n    /// with the type unwrapping boilerplate included for convenience.\n    /// @param integrityCheckState_ The state of the current integrity check\n    /// including the current max stack top.\n    /// @param stackPointer_ The stack pointer to compare and potentially swap\n    /// the max stack top for.\n    function syncStackMaxTop(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackPointer_\n    ) internal pure {\n        if (\n            StackPointer.unwrap(stackPointer_) >\n            StackPointer.unwrap(integrityCheckState_.stackMaxTop)\n        ) {\n            integrityCheckState_.stackMaxTop = stackPointer_;\n        }\n    }\n\n    /// The main integrity check loop. Designed so that it can be called\n    /// recursively by the dispatched integrity opcodes to support arbitrary\n    /// nesting of sources and substacks, loops, etc.\n    /// If ANY of the integrity checks for ANY opcode fails the entire integrity\n    /// check will revert.\n    /// @param integrityCheckState_ Current state of the integrity check passed\n    /// by reference to allow for recursive/nested integrity checking.\n    /// @param sourceIndex_ The source to check the integrity of which can be\n    /// either an entrypoint or a non-entrypoint source if this is a recursive\n    /// call to `ensureIntegrity`.\n    /// @param stackTop_ The current top of the virtual stack as a pointer. This\n    /// can be manipulated to create effective substacks/scoped/immutable\n    /// runtime values by restricting how the `stackTop_` can move at deploy\n    /// time.\n    /// @param minStackOutputs_ The minimum stack height required by the end of\n    /// this integrity check. The caller MUST ensure that it sets this value high\n    /// enough so that it can safely read enough values from the final stack\n    /// without out of bounds reads. The external interface to the expression\n    /// deployer accepts an array of minimum stack heights against entrypoints,\n    /// but the internal checks can be recursive against non-entrypoints and each\n    /// opcode such as `call` can build scoped stacks, etc. so here we just put\n    /// defining the requirements back on the caller.\n    function ensureIntegrity(\n        IntegrityCheckState memory integrityCheckState_,\n        SourceIndex sourceIndex_,\n        StackPointer stackTop_,\n        uint256 minStackOutputs_\n    ) internal view returns (StackPointer) {\n        unchecked {\n            // It's generally more efficient to ensure the stack bottom has\n            // plenty of headroom to make underflows from pops impossible rather\n            // than guard every single pop against underflow.\n            if (\n                StackPointer.unwrap(integrityCheckState_.stackBottom) <\n                StackPointer.unwrap(INITIAL_STACK_BOTTOM)\n            ) {\n                revert MinStackBottom();\n            }\n            uint256 cursor_;\n            uint256 end_;\n            assembly (\"memory-safe\") {\n                cursor_ := mload(\n                    add(\n                        mload(integrityCheckState_),\n                        add(0x20, mul(0x20, sourceIndex_))\n                    )\n                )\n                end_ := add(cursor_, mload(cursor_))\n            }\n\n            // Loop until complete.\n            while (cursor_ < end_) {\n                uint256 opcode_;\n                Operand operand_;\n                cursor_ += 4;\n                assembly (\"memory-safe\") {\n                    let op_ := mload(cursor_)\n                    operand_ := and(op_, 0xFFFF)\n                    opcode_ := and(shr(16, op_), 0xFFFF)\n                }\n                // We index into the function pointers here to ensure that any\n                // opcodes that we don't have a pointer for will error.\n                stackTop_ = integrityCheckState_.integrityFunctionPointers[\n                    opcode_\n                ](integrityCheckState_, operand_, stackTop_);\n            }\n            uint256 finalStackOutputs_ = integrityCheckState_\n                .stackBottom\n                .toIndex(stackTop_);\n            if (minStackOutputs_ > finalStackOutputs_) {\n                revert MinFinalStack(minStackOutputs_, finalStackOutputs_);\n            }\n            return stackTop_;\n        }\n    }\n\n    /// Push a single virtual item onto the virtual stack.\n    /// Simply moves the stack top up one and syncs the interpreter max stack\n    /// height with it if needed.\n    /// @param integrityCheckState_ The state of the current integrity check.\n    /// @param stackTop_ The pointer to the virtual stack top for the current\n    /// integrity check.\n    /// @return The stack top after it has pushed an item.\n    function push(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_\n    ) internal pure returns (StackPointer) {\n        stackTop_ = stackTop_.up();\n        integrityCheckState_.syncStackMaxTop(stackTop_);\n        return stackTop_;\n    }\n\n    /// Overloaded `push` to support `n_` pushes in a single movement.\n    /// `n_` MAY be 0 and this is a virtual noop stack movement.\n    /// @param integrityCheckState_ as per `push`.\n    /// @param stackTop_ as per `push`.\n    /// @param n_ The number of items to push to the virtual stack.\n    function push(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_,\n        uint256 n_\n    ) internal pure returns (StackPointer) {\n        stackTop_ = stackTop_.up(n_);\n        // Any time we push more than 1 item to the stack we move the highwater\n        // _past_ it as nested multioutput is disallowed.\n        if (\n            n_ > 1 &&\n            StackPointer.unwrap(stackTop_) >\n            StackPointer.unwrap(integrityCheckState_.stackHighwater)\n        ) {\n            integrityCheckState_.stackHighwater = stackTop_;\n        }\n        integrityCheckState_.syncStackMaxTop(stackTop_);\n        return stackTop_;\n    }\n\n    /// As push for 0+ values. Does NOT move the highwater. This may be useful if\n    /// the highwater is already calculated somehow by the caller.\n    function pushIgnoreHighwater(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_,\n        uint256 n_\n    ) internal pure returns (StackPointer) {\n        stackTop_ = stackTop_.up(n_);\n        integrityCheckState_.syncStackMaxTop(stackTop_);\n        return stackTop_;\n    }\n\n    /// Move the stock top down one item then check that it hasn't underflowed\n    /// the stack bottom. If all virtual stack movements are defined in terms\n    /// of pops and pushes this will enforce that the gross stack movements do\n    /// not underflow, which would lead to out of bounds stack reads at runtime.\n    /// @param integrityCheckState_ The state of the current integrity check.\n    /// @param stackTop_ The virtual stack top before an item is popped.\n    /// @return The virtual stack top after the pop.\n    function pop(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        stackTop_ = stackTop_.down();\n        integrityCheckState_.popUnderflowCheck(stackTop_);\n        return stackTop_;\n    }\n\n    /// Overloaded `pop` to support `n_` pops in a single movement.\n    /// `n_` MAY be 0 and this is a virtual noop stack movement.\n    /// @param integrityCheckState_ as per `pop`.\n    /// @param stackTop_ as per `pop`.\n    /// @param n_ The number of items to pop off the virtual stack.\n    function pop(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_,\n        uint256 n_\n    ) internal view returns (StackPointer) {\n        console.log(\"pop\", n_, StackPointer.unwrap(stackTop_));\n        if (n_ > 0) {\n            stackTop_ = stackTop_.down(n_);\n            integrityCheckState_.popUnderflowCheck(stackTop_);\n        }\n        return stackTop_;\n    }\n\n    /// Ensures that pops have not underflowed the stack, i.e. that the stack\n    /// top is not below the stack bottom. We set a large stack bottom that is\n    /// impossible to underflow within gas limits with realistic pops so that\n    /// we don't have to deal with a numeric underflow of the stack top.\n    /// @param integrityCheckState_ As per `pop`.\n    /// @param stackTop_ as per `pop`.\n    function popUnderflowCheck(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_\n    ) internal view {\n        console.log(\"puc\", StackPointer.unwrap(stackTop_), StackPointer.unwrap(integrityCheckState_.stackHighwater));\n        if (\n            StackPointer.unwrap(stackTop_) <=\n            StackPointer.unwrap(integrityCheckState_.stackHighwater)\n        ) {\n            revert StackPopUnderflow(\n                integrityCheckState_.stackBottom.toIndex(\n                    integrityCheckState_.stackHighwater\n                ),\n                integrityCheckState_.stackBottom.toIndex(stackTop_)\n            );\n        }\n    }\n\n    /// Maps `function(uint256, uint256) internal view returns (uint256)` to pops\n    /// and pushes repeatedly N times. The function itself is irrelevant we only\n    /// care about the signature to know how many items are popped/pushed.\n    /// @param integrityCheckState_ as per `pop` and `push`.\n    /// @param stackTop_ as per `pop` and `push`.\n    /// @param n_ The number of times the function is applied to the stack.\n    /// @return The stack top after the function has been applied n times.\n    function applyFnN(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_,\n        function(uint256, uint256) internal view returns (uint256),\n        uint256 n_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, n_));\n    }\n\n    /// Maps `function(uint256) internal view` to pops and pushes repeatedly N\n    /// times. The function itself is irrelevant we only care about the\n    /// signature to know how many items are popped/pushed.\n    /// @param integrityCheckState_ as per `pop` and `push`.\n    /// @param stackTop_ as per `pop` and `push`.\n    /// @param n_ The number of times the function is applied to the stack.\n    /// @return The stack top after the function has been applied n times.\n    function applyFnN(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_,\n        function(uint256) internal view,\n        uint256 n_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.pop(stackTop_, n_);\n    }\n\n    /// Maps `function(uint256) internal view returns (uint256)` to pops and\n    /// pushes once. The function itself is irrelevant we only care about the\n    /// signature to know how many items are popped/pushed.\n    /// @param integrityCheckState_ as per `pop` and `push`.\n    /// @param stackTop_ as per `pop` and `push`.\n    /// @return The stack top after the function has been applied once.\n    function applyFn(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_,\n        function(uint256) internal view returns (uint256)\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.push(integrityCheckState_.pop(stackTop_));\n    }\n\n    /// Maps `function(uint256, uint256) internal view` to pops and pushes once.\n    /// The function itself is irrelevant we only care about the signature to\n    /// know how many items are popped/pushed.\n    /// @param integrityCheckState_ as per `pop` and `push`.\n    /// @param stackTop_ as per `pop` and `push`.\n    /// @return The stack top after the function has been applied once.\n    function applyFn(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_,\n        function(uint256, uint256) internal view\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.pop(stackTop_, 2);\n    }\n\n    /// Maps `function(uint256, uint256) internal view returns (uint256)` to\n    /// pops and pushes once. The function itself is irrelevant we only care\n    /// about the signature to know how many items are popped/pushed.\n    /// @param integrityCheckState_ as per `pop` and `push`.\n    /// @param stackTop_ as per `pop` and `push`.\n    /// @return The stack top after the function has been applied once.\n    function applyFn(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_,\n        function(uint256, uint256) internal view returns (uint256)\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, 2));\n    }\n\n    /// Maps\n    /// `function(uint256, uint256, uint256) internal view returns (uint256)` to\n    /// pops and pushes once. The function itself is irrelevant we only care\n    /// about the signature to know how many items are popped/pushed.\n    /// @param integrityCheckState_ as per `pop` and `push`.\n    /// @param stackTop_ as per `pop` and `push`.\n    /// @return The stack top after the function has been applied once.\n    function applyFn(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_,\n        function(uint256, uint256, uint256) internal view returns (uint256)\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, 3));\n    }\n\n    /// Maps\n    /// ```\n    /// function(uint256, uint256, uint256, uint256)\n    ///     internal\n    ///     view\n    ///     returns (uint256)\n    /// ```\n    /// to pops and pushes once. The function itself is irrelevant we only care\n    /// about the signature to know how many items are popped/pushed.\n    /// @param integrityCheckState_ as per `pop` and `push`.\n    /// @param stackTop_ as per `pop` and `push`.\n    /// @return The stack top after the function has been applied once.\n    function applyFn(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_,\n        function(uint256, uint256, uint256, uint256)\n            internal\n            view\n            returns (uint256)\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, 4));\n    }\n\n    /// Maps `function(uint256[] memory) internal view returns (uint256)` to\n    /// pops and pushes once given that we know the length of the dynamic array\n    /// at deploy time. The function itself is irrelevant we only care about the\n    /// signature to know how many items are popped/pushed.\n    /// @param integrityCheckState_ as per `pop` and `push`.\n    /// @param stackTop_ as per `pop` and `push`.\n    /// @param length_ The length of the dynamic input array.\n    /// @return The stack top after the function has been applied once.\n    function applyFn(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_,\n        function(uint256[] memory) internal view returns (uint256),\n        uint256 length_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.push(\n                integrityCheckState_.pop(stackTop_, length_)\n            );\n    }\n\n    /// Maps\n    /// ```\n    /// function(uint256, uint256, uint256[] memory)\n    ///     internal\n    ///     view\n    ///     returns (uint256)\n    /// ```\n    /// to pops and pushes once given that we know the length of the dynamic\n    /// array at deploy time. The function itself is irrelevant we only care\n    /// about the signature to know how many items are popped/pushed.\n    /// @param integrityCheckState_ as per `pop` and `push`.\n    /// @param stackTop_ as per `pop` and `push`.\n    /// @param length_ The length of the dynamic input array.\n    /// @return The stack top after the function has been applied once.\n    function applyFn(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_,\n        function(uint256, uint256, uint256[] memory)\n            internal\n            view\n            returns (uint256),\n        uint256 length_\n    ) internal view returns (StackPointer) {\n        unchecked {\n            return\n                integrityCheckState_.push(\n                    integrityCheckState_.pop(stackTop_, length_ + 2)\n                );\n        }\n    }\n\n    /// Maps\n    /// ```\n    /// function(uint256, uint256, uint256, uint256[] memory)\n    ///     internal\n    ///     view\n    ///     returns (uint256)\n    /// ```\n    /// to pops and pushes once given that we know the length of the dynamic\n    /// array at deploy time. The function itself is irrelevant we only care\n    /// about the signature to know how many items are popped/pushed.\n    /// @param integrityCheckState_ as per `pop` and `push`.\n    /// @param stackTop_ as per `pop` and `push`.\n    /// @param length_ The length of the dynamic input array.\n    /// @return The stack top after the function has been applied once.\n    function applyFn(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_,\n        function(uint256, uint256, uint256, uint256[] memory)\n            internal\n            view\n            returns (uint256),\n        uint256 length_\n    ) internal view returns (StackPointer) {\n        unchecked {\n            return\n                integrityCheckState_.push(\n                    integrityCheckState_.pop(stackTop_, length_ + 3)\n                );\n        }\n    }\n\n    /// Maps\n    /// ```\n    /// function(uint256, uint256[] memory, uint256[] memory)\n    ///     internal\n    ///     view\n    ///     returns (uint256[] memory)\n    /// ```\n    /// to pops and pushes once given that we know the length of the dynamic\n    /// array at deploy time. The function itself is irrelevant we only care\n    /// about the signature to know how many items are popped/pushed.\n    /// @param integrityCheckState_ as per `pop` and `push`.\n    /// @param stackTop_ as per `pop` and `push`.\n    /// @param length_ The length of the dynamic input array.\n    /// @return The stack top after the function has been applied once.\n    function applyFn(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_,\n        function(uint256, uint256[] memory, uint256[] memory)\n            internal\n            view\n            returns (uint256[] memory),\n        uint256 length_\n    ) internal view returns (StackPointer) {\n        unchecked {\n            return\n                integrityCheckState_.push(\n                    integrityCheckState_.pop(stackTop_, length_ * 2 + 1),\n                    length_\n                );\n        }\n    }\n\n    /// Maps `function(Operand, uint256) internal view returns (uint256)` to\n    /// pops and pushes once. The function itself is irrelevant we only care\n    /// about the signature to know how many items are popped/pushed.\n    ///\n    /// The operand MUST NOT influence the stack movements if this application\n    /// is to be valid.\n    ///\n    /// @param integrityCheckState_ as per `pop` and `push`.\n    /// @param stackTop_ as per `pop` and `push`.\n    /// @return The stack top after the function has been applied once.\n    function applyFn(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_,\n        function(Operand, uint256) internal view returns (uint256)\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.push(integrityCheckState_.pop(stackTop_));\n    }\n\n    /// Maps\n    /// `function(Operand, uint256, uint256) internal view returns (uint256)` to\n    /// pops and pushes once. The function itself is irrelevant we only care\n    /// about the signature to know how many items are popped/pushed.\n    ///\n    /// The operand MUST NOT influence the stack movements if this application\n    /// is to be valid.\n    ///\n    /// @param integrityCheckState_ as per `pop` and `push`.\n    /// @param stackTop_ as per `pop` and `push`.\n    /// @return The stack top after the function has been applied once.\n    function applyFn(\n        IntegrityCheckState memory integrityCheckState_,\n        StackPointer stackTop_,\n        function(Operand, uint256, uint256) internal view returns (uint256)\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_, 2));\n    }\n}\n"
    },
    "contracts/interpreter/deploy/LibIntegrityState.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../run/LibStackTop.sol\";\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\nimport \"../run/IInterpreterV1.sol\";\n\nstruct IntegrityState {\n    // Sources first as we read it in assembly.\n    bytes[] sources;\n    uint256 constantsLength;\n    StackTop stackBottom;\n    StackTop stackMaxTop;\n    function(IntegrityState memory, Operand, StackTop)\n        view\n        returns (StackTop)[] integrityFunctionPointers;\n}\n\nlibrary LibIntegrityState {\n    using LibIntegrityState for IntegrityState;\n    using LibStackTop for StackTop;\n    using Math for uint256;\n\n    function syncStackMaxTop(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_\n    ) internal pure {\n        if (\n            StackTop.unwrap(stackTop_) >\n            StackTop.unwrap(integrityState_.stackMaxTop)\n        ) {\n            integrityState_.stackMaxTop = stackTop_;\n        }\n    }\n\n    function ensureIntegrity(\n        IntegrityState memory integrityState_,\n        SourceIndex sourceIndex_,\n        StackTop stackTop_,\n        uint minStackOutputs_\n    ) internal view returns (StackTop) {\n        unchecked {\n            uint256 cursor_;\n            uint256 end_;\n            assembly (\"memory-safe\") {\n                cursor_ := mload(\n                    add(\n                        mload(integrityState_),\n                        add(0x20, mul(0x20, sourceIndex_))\n                    )\n                )\n                end_ := add(cursor_, mload(cursor_))\n            }\n\n            // Loop until complete.\n            while (cursor_ < end_) {\n                uint256 opcode_;\n                Operand operand_;\n                cursor_ += 4;\n                assembly (\"memory-safe\") {\n                    let op_ := mload(cursor_)\n                    operand_ := and(op_, 0xFFFF)\n                    opcode_ := and(shr(16, op_), 0xFFFF)\n                }\n                // We index into the function pointers here to ensure that any\n                // opcodes that we don't have a pointer for will error.\n                stackTop_ = integrityState_.integrityFunctionPointers[opcode_](\n                    integrityState_,\n                    operand_,\n                    stackTop_\n                );\n            }\n            require(\n                minStackOutputs_ <=\n                    integrityState_.stackBottom.toIndex(stackTop_),\n                \"MIN_FINAL_STACK\"\n            );\n            return stackTop_;\n        }\n    }\n\n    function push(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop stackTopAfter_) {\n        stackTopAfter_ = stackTop_.up();\n        integrityState_.syncStackMaxTop(stackTopAfter_);\n    }\n\n    function push(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        uint256 n_\n    ) internal pure returns (StackTop stackTopAfter_) {\n        stackTopAfter_ = stackTop_.up(n_);\n        integrityState_.syncStackMaxTop(stackTopAfter_);\n    }\n\n    function popUnderflowCheck(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_\n    ) internal pure {\n        require(\n            // Stack bottom may be non-zero so check we are above it.\n            (StackTop.unwrap(stackTop_) >=\n                StackTop.unwrap(integrityState_.stackBottom)) &&\n                // If we underflowed zero then we will be above the stack max\n                // top. Assumes that at least 1 item was popped so we can do a\n                // strict inequality check here.\n                (StackTop.unwrap(stackTop_) <\n                    StackTop.unwrap(integrityState_.stackMaxTop)),\n            \"STACK_UNDERFLOW\"\n        );\n    }\n\n    function pop(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_\n    ) internal pure returns (StackTop stackTopAfter_) {\n        stackTopAfter_ = stackTop_.down();\n        integrityState_.popUnderflowCheck(stackTopAfter_);\n    }\n\n    function pop(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        uint256 n_\n    ) internal pure returns (StackTop) {\n        if (n_ > 0) {\n            stackTop_ = stackTop_.down(n_);\n            integrityState_.popUnderflowCheck(stackTop_);\n        }\n        return stackTop_;\n    }\n\n    function applyFnN(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256, uint256) internal view returns (uint256),\n        uint256 n_\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(integrityState_.pop(stackTop_, n_));\n    }\n\n    function applyFnN(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256) internal view,\n        uint256 n_\n    ) internal pure returns (StackTop) {\n        return integrityState_.pop(stackTop_, n_);\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256) internal view returns (uint256)\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(integrityState_.pop(stackTop_));\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(Operand, uint256) internal view returns (uint256)\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(integrityState_.pop(stackTop_));\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256, uint256) internal view\n    ) internal pure returns (StackTop) {\n        return integrityState_.pop(stackTop_, 2);\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256, uint256) internal view returns (uint256)\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(integrityState_.pop(stackTop_, 2));\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(Operand, uint256, uint256) internal view returns (uint256)\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(integrityState_.pop(stackTop_, 2));\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256, uint256, uint256) internal view returns (uint256)\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(integrityState_.pop(stackTop_, 3));\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256, uint256, uint256, uint)\n            internal\n            view\n            returns (uint256)\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(integrityState_.pop(stackTop_, 4));\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256[] memory) internal view returns (uint256),\n        uint256 length_\n    ) internal pure returns (StackTop) {\n        return integrityState_.push(integrityState_.pop(stackTop_, length_));\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256, uint256, uint256[] memory)\n            internal\n            view\n            returns (uint256),\n        uint256 length_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            return\n                integrityState_.push(\n                    integrityState_.pop(stackTop_, length_ + 2)\n                );\n        }\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256, uint256, uint256, uint256[] memory)\n            internal\n            view\n            returns (uint256),\n        uint256 length_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            return\n                integrityState_.push(\n                    integrityState_.pop(stackTop_, length_ + 3)\n                );\n        }\n    }\n\n    function applyFn(\n        IntegrityState memory integrityState_,\n        StackTop stackTop_,\n        function(uint256, uint256[] memory, uint256[] memory)\n            internal\n            view\n            returns (uint256[] memory),\n        uint256 length_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            return\n                integrityState_.push(\n                    integrityState_.pop(stackTop_, length_ * 2 + 1),\n                    length_\n                );\n        }\n    }\n}\n"
    },
    "contracts/interpreter/ops/AllStandardOps.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"../../type/LibCast.sol\";\nimport \"../../type/LibConvert.sol\";\nimport \"../../array/LibUint256Array.sol\";\nimport \"./chainlink/OpChainlinkOraclePrice.sol\";\nimport \"./core/OpCall.sol\";\nimport \"./core/OpSet.sol\";\nimport \"./core/OpContext.sol\";\nimport \"./core/OpContextRow.sol\";\nimport \"./core/OpDebug.sol\";\nimport \"./core/OpDoWhile.sol\";\nimport \"./core/OpFoldContext.sol\";\nimport \"./core/OpLoopN.sol\";\nimport \"./core/OpReadMemory.sol\";\nimport \"./crypto/OpHash.sol\";\nimport \"./erc20/OpERC20BalanceOf.sol\";\nimport \"./erc20/OpERC20TotalSupply.sol\";\nimport \"./erc20/snapshot/OpERC20SnapshotBalanceOfAt.sol\";\nimport \"./erc20/snapshot/OpERC20SnapshotTotalSupplyAt.sol\";\nimport \"./erc721/OpERC721BalanceOf.sol\";\nimport \"./erc721/OpERC721OwnerOf.sol\";\nimport \"./erc1155/OpERC1155BalanceOf.sol\";\nimport \"./erc1155/OpERC1155BalanceOfBatch.sol\";\nimport \"./error/OpEnsure.sol\";\nimport \"./evm/OpBlockNumber.sol\";\nimport \"./evm/OpTimestamp.sol\";\nimport \"./list/OpExplode32.sol\";\nimport \"./math/fixedPoint/OpFixedPointScale18.sol\";\nimport \"./math/fixedPoint/OpFixedPointScale18Div.sol\";\nimport \"./math/fixedPoint/OpFixedPointScale18Mul.sol\";\nimport \"./math/fixedPoint/OpFixedPointScaleBy.sol\";\nimport \"./math/fixedPoint/OpFixedPointScaleN.sol\";\nimport \"./math/logic/OpAny.sol\";\nimport \"./math/logic/OpEagerIf.sol\";\nimport \"./math/logic/OpEqualTo.sol\";\nimport \"./math/logic/OpEvery.sol\";\nimport \"./math/logic/OpGreaterThan.sol\";\nimport \"./math/logic/OpIsZero.sol\";\nimport \"./math/logic/OpLessThan.sol\";\nimport \"./math/saturating/OpSaturatingAdd.sol\";\nimport \"./math/saturating/OpSaturatingMul.sol\";\nimport \"./math/saturating/OpSaturatingSub.sol\";\nimport \"./math/OpAdd.sol\";\nimport \"./math/OpDiv.sol\";\nimport \"./math/OpExp.sol\";\nimport \"./math/OpMax.sol\";\nimport \"./math/OpMin.sol\";\nimport \"./math/OpMod.sol\";\nimport \"./math/OpMul.sol\";\nimport \"./math/OpSub.sol\";\nimport \"./rain/IOrderBookV1/OpIOrderBookV1VaultBalance.sol\";\nimport \"./rain/ISaleV2/OpISaleV2RemainingTokenInventory.sol\";\nimport \"./rain/ISaleV2/OpISaleV2Reserve.sol\";\nimport \"./rain/ISaleV2/OpISaleV2SaleStatus.sol\";\nimport \"./rain/ISaleV2/OpISaleV2Token.sol\";\nimport \"./rain/ISaleV2/OpISaleV2TotalReserveReceived.sol\";\nimport \"./rain/IVerifyV1/OpIVerifyV1AccountStatusAtTime.sol\";\nimport \"./tier/OpITierV2Report.sol\";\nimport \"./tier/OpITierV2ReportTimeForTier.sol\";\nimport \"./tier/OpSaturatingDiff.sol\";\nimport \"./tier/OpSelectLte.sol\";\nimport \"./tier/OpUpdateTimesForTierRange.sol\";\n\n/// Thrown when a dynamic length array is NOT 1 more than a fixed length array.\n/// Should never happen outside a major breaking change to memory layouts.\nerror BadDynamicLength(uint256 dynamicLength, uint256 standardOpsLength);\n\n/// @dev Number of ops currently provided by `AllStandardOps`.\nuint256 constant ALL_STANDARD_OPS_LENGTH = 58;\n\n/// @title AllStandardOps\n/// @notice Every opcode available from the core repository laid out as a single\n/// array to easily build function pointers for `IInterpreterV1`.\nlibrary AllStandardOps {\n    using LibCast for uint256;\n    using LibCast for function(uint256) pure returns (uint256);\n    using LibCast for function(InterpreterState memory, uint256, StackPointer)\n        view\n        returns (StackPointer);\n    using LibCast for function(InterpreterState memory, uint256, StackPointer)\n        pure\n        returns (StackPointer);\n    using LibCast for function(InterpreterState memory, uint256, StackPointer)\n        view\n        returns (StackPointer)[];\n\n    using AllStandardOps for function(\n        IntegrityCheckState memory,\n        Operand,\n        StackPointer\n    ) view returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1];\n    using AllStandardOps for function(\n        InterpreterState memory,\n        Operand,\n        StackPointer\n    ) view returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1];\n\n    using AllStandardOps for uint256[ALL_STANDARD_OPS_LENGTH + 1];\n\n    using LibUint256Array for uint256[];\n    using LibConvert for uint256[];\n    using LibCast for uint256[];\n    using LibCast for function(\n        IntegrityCheckState memory,\n        Operand,\n        StackPointer\n    ) view returns (StackPointer);\n    using LibCast for function(\n        IntegrityCheckState memory,\n        Operand,\n        StackPointer\n    ) pure returns (StackPointer);\n    using LibCast for function(\n        IntegrityCheckState memory,\n        Operand,\n        StackPointer\n    ) view returns (StackPointer)[];\n    using LibCast for function(InterpreterState memory, Operand, StackPointer)\n        view\n        returns (StackPointer)[];\n\n    /// An oddly specific length conversion between a fixed and dynamic `uint256`\n    /// array. This is useful for the purpose of building metadata for bounds\n    /// checks and dispatch of all the standard ops provided by `Rainterpreter`.\n    /// The cast will fail if the length of the dynamic array doesn't match the\n    /// first item of the fixed array; it relies on differences in memory\n    /// layout in Solidity that MAY change in the future. The rollback guards\n    /// against changes in Solidity memory layout silently breaking this cast.\n    /// @param fixed_ The fixed size `uint256` array to cast to a dynamic\n    /// `uint256` array. Specifically the size is fixed to match the number of\n    /// standard ops.\n    /// @param dynamic_ The dynamic `uint256` array with length of the standard\n    /// ops.\n    function asUint256Array(\n        function(IntegrityCheckState memory, Operand, StackPointer)\n            view\n            returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1]\n            memory fixed_\n    ) internal pure returns (uint256[] memory dynamic_) {\n        assembly (\"memory-safe\") {\n            dynamic_ := fixed_\n        }\n        if (dynamic_.length != ALL_STANDARD_OPS_LENGTH) {\n            revert BadDynamicLength(dynamic_.length, ALL_STANDARD_OPS_LENGTH);\n        }\n    }\n\n    /// An oddly specific conversion between a fixed and dynamic `uint256` array.\n    /// This is useful for the purpose of building function pointers for the\n    /// runtime dispatch of all the standard ops provided by `Rainterpreter`.\n    /// The cast will fail if the length of the dynamic array doesn't match the\n    /// first item of the fixed array; it relies on differences in memory\n    /// layout in Solidity that MAY change in the future. The rollback guards\n    /// against changes in Solidity memory layout silently breaking this cast.\n    /// @param fixed_ The fixed size `uint256` array to cast to a dynamic\n    /// `uint256` array. Specifically the size is fixed to match the number of\n    /// standard ops.\n    /// @param dynamic_ The dynamic `uint256` array with length of the standard\n    /// ops.\n    function asUint256Array(\n        function(InterpreterState memory, Operand, StackPointer)\n            view\n            returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1]\n            memory fixed_\n    ) internal pure returns (uint256[] memory dynamic_) {\n        assembly (\"memory-safe\") {\n            dynamic_ := fixed_\n        }\n        if (dynamic_.length != ALL_STANDARD_OPS_LENGTH) {\n            revert BadDynamicLength(dynamic_.length, ALL_STANDARD_OPS_LENGTH);\n        }\n    }\n\n    function integrityFunctionPointers(\n        function(IntegrityCheckState memory, Operand, StackPointer)\n            view\n            returns (StackPointer)[]\n            memory locals_\n    )\n        internal\n        pure\n        returns (\n            function(IntegrityCheckState memory, Operand, StackPointer)\n                view\n                returns (StackPointer)[]\n                memory\n        )\n    {\n        unchecked {\n            function(IntegrityCheckState memory, Operand, StackPointer)\n                view\n                returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1]\n                memory pointersFixed_ = [\n                    ALL_STANDARD_OPS_LENGTH.asIntegrityFunctionPointer(),\n                    OpChainlinkOraclePrice.integrity,\n                    OpCall.integrity,\n                    OpContext.integrity,\n                    OpContextRow.integrity,\n                    OpDebug.integrity,\n                    OpDoWhile.integrity,\n                    OpFoldContext.integrity,\n                    OpLoopN.integrity,\n                    OpReadMemory.integrity,\n                    OpSet.integrity,\n                    OpHash.integrity,\n                    OpERC20BalanceOf.integrity,\n                    OpERC20TotalSupply.integrity,\n                    OpERC20SnapshotBalanceOfAt.integrity,\n                    OpERC20SnapshotTotalSupplyAt.integrity,\n                    OpERC721BalanceOf.integrity,\n                    OpERC721OwnerOf.integrity,\n                    OpERC1155BalanceOf.integrity,\n                    OpERC1155BalanceOfBatch.integrity,\n                    OpEnsure.integrity,\n                    OpBlockNumber.integrity,\n                    OpTimestamp.integrity,\n                    OpExplode32.integrity,\n                    OpFixedPointScale18.integrity,\n                    OpFixedPointScale18Div.integrity,\n                    OpFixedPointScale18Mul.integrity,\n                    OpFixedPointScaleBy.integrity,\n                    OpFixedPointScaleN.integrity,\n                    OpAny.integrity,\n                    OpEagerIf.integrity,\n                    OpEqualTo.integrity,\n                    OpEvery.integrity,\n                    OpGreaterThan.integrity,\n                    OpIsZero.integrity,\n                    OpLessThan.integrity,\n                    OpSaturatingAdd.integrity,\n                    OpSaturatingMul.integrity,\n                    OpSaturatingSub.integrity,\n                    OpAdd.integrity,\n                    OpDiv.integrity,\n                    OpExp.integrity,\n                    OpMax.integrity,\n                    OpMin.integrity,\n                    OpMod.integrity,\n                    OpMul.integrity,\n                    OpSub.integrity,\n                    OpIOrderBookV1VaultBalance.integrity,\n                    OpISaleV2RemainingTokenInventory.integrity,\n                    OpISaleV2Reserve.integrity,\n                    OpISaleV2SaleStatus.integrity,\n                    OpISaleV2Token.integrity,\n                    OpISaleV2TotalReserveReceived.integrity,\n                    OpIVerifyV1AccountStatusAtTime.integrity,\n                    OpITierV2Report.integrity,\n                    OpITierV2ReportTimeForTier.integrity,\n                    OpSaturatingDiff.integrity,\n                    OpSelectLte.integrity,\n                    OpUpdateTimesForTierRange.integrity\n                ];\n            uint256[] memory pointers_ = pointersFixed_.asUint256Array();\n            pointers_.extend(locals_.asUint256Array());\n            return pointers_.asIntegrityPointers();\n        }\n    }\n\n    function opcodeFunctionPointers(\n        function(InterpreterState memory, Operand, StackPointer)\n            view\n            returns (StackPointer)[]\n            memory locals_\n    )\n        internal\n        pure\n        returns (\n            function(InterpreterState memory, Operand, StackPointer)\n                view\n                returns (StackPointer)[]\n                memory opcodeFunctionPointers_\n        )\n    {\n        unchecked {\n            function(InterpreterState memory, Operand, StackPointer)\n                view\n                returns (StackPointer)[ALL_STANDARD_OPS_LENGTH + 1]\n                memory pointersFixed_ = [\n                    ALL_STANDARD_OPS_LENGTH.asOpFunctionPointer(),\n                    OpChainlinkOraclePrice.run,\n                    OpCall.run,\n                    OpContext.run,\n                    OpContextRow.run,\n                    OpDebug.run,\n                    OpDoWhile.run,\n                    OpFoldContext.run,\n                    OpLoopN.run,\n                    OpReadMemory.run,\n                    OpSet.run,\n                    OpHash.run,\n                    OpERC20BalanceOf.run,\n                    OpERC20TotalSupply.run,\n                    OpERC20SnapshotBalanceOfAt.run,\n                    OpERC20SnapshotTotalSupplyAt.run,\n                    OpERC721BalanceOf.run,\n                    OpERC721OwnerOf.run,\n                    OpERC1155BalanceOf.run,\n                    OpERC1155BalanceOfBatch.run,\n                    OpEnsure.run,\n                    OpBlockNumber.run,\n                    OpTimestamp.run,\n                    OpExplode32.run,\n                    OpFixedPointScale18.run,\n                    OpFixedPointScale18Div.run,\n                    OpFixedPointScale18Mul.run,\n                    OpFixedPointScaleBy.run,\n                    OpFixedPointScaleN.run,\n                    OpAny.run,\n                    OpEagerIf.run,\n                    OpEqualTo.run,\n                    OpEvery.run,\n                    OpGreaterThan.run,\n                    OpIsZero.run,\n                    OpLessThan.run,\n                    OpSaturatingAdd.run,\n                    OpSaturatingMul.run,\n                    OpSaturatingSub.run,\n                    OpAdd.run,\n                    OpDiv.run,\n                    OpExp.run,\n                    OpMax.run,\n                    OpMin.run,\n                    OpMod.run,\n                    OpMul.run,\n                    OpSub.run,\n                    OpIOrderBookV1VaultBalance.run,\n                    OpISaleV2RemainingTokenInventory.run,\n                    OpISaleV2Reserve.run,\n                    OpISaleV2SaleStatus.run,\n                    OpISaleV2Token.run,\n                    OpISaleV2TotalReserveReceived.run,\n                    OpIVerifyV1AccountStatusAtTime.run,\n                    OpITierV2Report.run,\n                    OpITierV2ReportTimeForTier.run,\n                    OpSaturatingDiff.run,\n                    OpSelectLte.run,\n                    OpUpdateTimesForTierRange.run\n                ];\n            uint256[] memory pointers_ = pointersFixed_.asUint256Array();\n            pointers_.extend(locals_.asUint256Array());\n            opcodeFunctionPointers_ = pointers_.asOpcodeFunctionPointers();\n        }\n    }\n}\n"
    },
    "contracts/interpreter/ops/chainlink/OpChainlinkOraclePrice.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {LibChainlink} from \"../../../chainlink/LibChainlink.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpChainlinkOraclePrice\n/// @notice Opcode for chainlink oracle prices.\nlibrary OpChainlinkOraclePrice {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(\n        uint256 feed_,\n        uint256 staleAfter_\n    ) internal view returns (uint256) {\n        return LibChainlink.price(address(uint160(feed_)), staleAfter_);\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpCall.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../../array/LibUint256Array.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\nimport \"../../../math/Binary.sol\";\n\n/// @title OpCall\n/// @notice Opcode for calling eval with a new scope. The construction of this\n/// scope is split across integrity and runtime responsibilities. When the\n/// integrity checks are done the expression being called has all its integrity\n/// logic run, recursively if needed. The integrity checks are run against the\n/// integrity state as it is but with the stack bottom set below the inputs to\n/// the called source. This ensures that the sub-integrity checks do not\n/// underflow what they perceive as a fresh stack, and it ensures that we set the\n/// stack length long enough to cover all sub-executions as a single array in\n/// memory. At runtime we trust the integrity checks have allocated enough runway\n/// in the stack for all our recursive sub-calls so we simply move the stack\n/// bottom in the state below the inputs during the call and move it back to\n/// where it was after the call. Notably this means that reading from the stack\n/// in the called source will 0 index from the first input, NOT the bottom of\n/// the calling stack.\nlibrary OpCall {\n    using LibIntegrityCheck for IntegrityCheckState;\n    using LibStackPointer for StackPointer;\n    using LibInterpreterState for InterpreterState;\n    using LibUint256Array for uint256;\n\n    /// Interpreter integrity logic.\n    /// The basic movements on the outer stack are to pop the inputs and push the\n    /// outputs, but the called source doesn't have access to a separately\n    /// allocated region of memory. There's only a single shared memory\n    /// allocation for all executions and sub-executions, so we recursively run\n    /// integrity checks on the called source relative to the current stack\n    /// position.\n    /// @param integrityCheckState_ The state of the current integrity check.\n    /// @param operand_ The operand associated with this call.\n    /// @param stackTop_ The current stack top within the integrity check.\n    /// @return stackTopAfter_ The stack top after the call movements are applied.\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer stackTopAfter_) {\n        // Unpack the operand to get IO and the source to be called.\n        uint256 inputs_ = Operand.unwrap(operand_) & MASK_4BIT;\n        uint256 outputs_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\n        SourceIndex callSourceIndex_ = SourceIndex.wrap(\n            Operand.unwrap(operand_) >> 8\n        );\n\n        // Remember the outer stack bottom and highwater.\n        StackPointer stackBottom_ = integrityCheckState_.stackBottom;\n        StackPointer stackHighwater_ = integrityCheckState_.stackHighwater;\n\n        // Set the inner stack bottom to below the inputs and highwater to\n        // protect the inputs from being popped internally.\n        integrityCheckState_.stackBottom = integrityCheckState_.pop(\n            stackTop_,\n            inputs_\n        );\n        integrityCheckState_.stackHighwater = stackTop_.down();\n\n        // Ensure the integrity of the inner source on the current state using\n        // the stack top above the inputs as the starting stack top.\n        // Contraints namespace is irrelevant here.\n        integrityCheckState_.ensureIntegrity(\n            callSourceIndex_,\n            stackTop_,\n            outputs_\n        );\n\n        // Reinstate the original highwater before handling outputs as single\n        // outputs can be nested but multioutput will move the highwater.\n        integrityCheckState_.stackHighwater = stackHighwater_;\n\n        // The outer stack top will move above the outputs relative to the inner\n        // stack bottom. At runtime any values that are not outputs will be\n        // removed so they do not need to be accounted for here.\n        stackTopAfter_ = integrityCheckState_.push(\n            integrityCheckState_.stackBottom,\n            outputs_\n        );\n\n        // Reinstate the outer stack bottom.\n        integrityCheckState_.stackBottom = stackBottom_;\n    }\n\n    /// Call eval with a new scope.\n    /// @param state_ The state of the current evaluation.\n    /// @param operand_ The operand associated with this call.\n    /// @param stackTop_ The current stack top within the evaluation.\n    /// @return stackTopAfter_ The stack top after the call is evaluated.\n    function run(\n        InterpreterState memory state_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer stackTopAfter_) {\n        // Unpack the operand to get IO and the source to be called.\n        uint256 inputs_ = Operand.unwrap(operand_) & MASK_4BIT;\n        uint256 outputs_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\n        SourceIndex callSourceIndex_ = SourceIndex.wrap(\n            Operand.unwrap(operand_) >> 8\n        );\n\n        // Remember the outer stack bottom.\n        StackPointer stackBottom_ = state_.stackBottom;\n\n        // Set the inner stack bottom to below the inputs.\n        state_.stackBottom = stackTop_.down(inputs_);\n\n        // Eval the source from the operand on the current state using the stack\n        // top above the inputs as the starting stack top. The final stack top\n        // is where we will read outputs from below.\n        StackPointer stackTopEval_ = state_.eval(callSourceIndex_, stackTop_);\n        // Normalize the inner final stack so that it contains only the outputs\n        // starting from the inner stack bottom.\n        LibUint256Array.unsafeCopyValuesTo(\n            StackPointer.unwrap(stackTopEval_.down(outputs_)),\n            StackPointer.unwrap(state_.stackBottom),\n            outputs_\n        );\n\n        // The outer stack top should now point above the outputs.\n        stackTopAfter_ = state_.stackBottom.up(outputs_);\n\n        // The outer stack bottom needs to be reinstated as it was before eval.\n        state_.stackBottom = stackBottom_;\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpContext.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\nimport \"../../../math/Binary.sol\";\n\n/// @title OpContext\n/// @notice Opcode for stacking from the context. Context requires slightly\n/// different handling to other memory reads as it is working with data that\n/// is provided at runtime from the calling contract on a per-eval basis so\n/// cannot be predicted at deploy time.\nlibrary OpContext {\n    using LibStackPointer for StackPointer;\n    using LibInterpreterState for InterpreterState;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    /// Interpreter integrity logic.\n    /// Context pushes a single value to the stack from the context array.\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal pure returns (StackPointer) {\n        // Note that a expression with context can error at runtime due to OOB\n        // reads that we don't know about here.\n        return integrityCheckState_.push(stackTop_);\n    }\n\n    /// Stack a value from the context WITH OOB checks from solidity.\n    /// The bounds checks are done at runtime because context MAY be provided\n    /// by the end user with arbitrary length.\n    function run(\n        InterpreterState memory state_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal pure returns (StackPointer) {\n        // The indexing syntax here enforces OOB checks at runtime.\n        return\n            stackTop_.push(\n                state_.context[Operand.unwrap(operand_) >> 8][\n                    Operand.unwrap(operand_) & MASK_8BIT\n                ]\n            );\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpContextRow.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\nimport \"../../../math/Binary.sol\";\n\n/// @title OpContextRow\n/// @notice Opcode for stacking a dynamic row from the context. Context requires\n/// slightly different handling to other memory reads as it is working with data\n/// that is provided at runtime. `OpContextRow` works exactly like `OpContext`\n/// but the row is provided from the stack instead of the operand. We rely on\n/// Solidity OOB checks at runtime to enforce that the index from the stack is\n/// within bounds at runtime. As we do NOT know statically which row will be read\n/// the context reads is set to the entire column.\nlibrary OpContextRow {\n    using LibStackPointer for StackPointer;\n    using LibInterpreterState for InterpreterState;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    /// Interpreter integrity logic.\n    /// Context pushes a single value to the stack from memory.\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        // Note that a expression with context can error at runtime due to OOB\n        // reads that we don't know about here.\n        function(uint256) internal pure returns (uint256) fn_;\n        return integrityCheckState_.applyFn(stackTop_, fn_);\n    }\n\n    /// Stack a value from the context WITH OOB checks from solidity.\n    /// The bounds checks are done at runtime because context MAY be provided\n    /// by the end user with arbitrary length.\n    function run(\n        InterpreterState memory state_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal pure returns (StackPointer) {\n        // The indexing syntax here enforces OOB checks at runtime.\n        (StackPointer location_, uint256 row_) = stackTop_.pop();\n        location_.set(state_.context[Operand.unwrap(operand_)][row_]);\n        return stackTop_;\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpDebug.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpDebug\n/// @notice Opcode for debugging state. Uses the standard debugging logic from\n/// InterpreterState.debug.\nlibrary OpDebug {\n    using LibStackPointer for StackPointer;\n    using LibInterpreterState for InterpreterState;\n\n    /// Interpreter integrity for debug.\n    /// Debug doesn't modify the stack.\n    function integrity(\n        IntegrityCheckState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal pure returns (StackPointer) {\n        // Try to build a debug style from the operand to ensure we can enumerate\n        // it.\n        DebugStyle(Operand.unwrap(operand_));\n        return stackTop_;\n    }\n\n    /// Debug the current state.\n    function run(\n        InterpreterState memory state_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        DebugStyle debugStyle_ = DebugStyle(Operand.unwrap(operand_));\n\n        state_.debug(stackTop_, debugStyle_);\n\n        return stackTop_;\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpDoWhile.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\nimport \"./OpCall.sol\";\n\n/// More inputs were encoded in the operand than can be dispatched internally by\n/// a do-while loop.\nerror DoWhileMaxInputs(uint256 inputs);\n\n/// @title OpDoWhile\n/// @notice Opcode for looping while the stack top is nonzero. As we pre-allocate\n/// all the memory for execution during integrity checks we have an apparent\n/// contradiction here. If we do not know how many times the loop will run then\n/// we cannot calculate the final stack height or intermediate pops and pushes.\n/// To solve this we simply wrap `OpCall` which already has fixed inputs and\n/// outputs and enforce that the outputs of each iteration is 1 more than the\n/// inputs. We then consume the extra output as the condition for the decision\n/// to loop again, thus the outputs = inputs for every iteration. If the stack\n/// height does not change between iterations we do not care how many times we\n/// loop (although the user paying gas might).\nlibrary OpDoWhile {\n    using LibIntegrityCheck for IntegrityCheckState;\n    using LibStackPointer for StackPointer;\n    using LibInterpreterState for InterpreterState;\n\n    /// Interpreter integrity for do while.\n    /// The loop itself pops a single value from the stack to determine whether\n    /// it should run another iteration of the loop. The source called by the\n    /// loop must then put a value back on the stack in the same position to\n    /// either continue or break the loop.\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        unchecked {\n            uint256 inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\n            /// We need outputs to be _larger than_ inputs so inputs must be\n            /// _strictly less than_ the max value possible in 4 bits or outputs\n            /// will overflow.\n            if (inputs_ >= MASK_4BIT) {\n                revert DoWhileMaxInputs(inputs_);\n            }\n            uint256 outputs_ = inputs_ + 1;\n            Operand callOperand_ = Operand.wrap(\n                Operand.unwrap(operand_) | (outputs_ << 4)\n            );\n            // Stack height changes are deterministic so if we call once we've\n            // called a thousand times. Also we pop one output off the result of\n            // the call to check the while condition.\n            return\n                integrityCheckState_.pop(\n                    OpCall.integrity(\n                        integrityCheckState_,\n                        callOperand_,\n                        stackTop_\n                    )\n                );\n        }\n    }\n\n    /// Loop the stack while the stack top is true.\n    function run(\n        InterpreterState memory state_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        unchecked {\n            uint256 inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\n            uint256 outputs_ = inputs_ + 1;\n            Operand callOperand_ = Operand.wrap(\n                Operand.unwrap(operand_) | (outputs_ << 4)\n            );\n            uint256 do_;\n            (stackTop_, do_) = stackTop_.pop();\n            while (do_ > 0) {\n                stackTop_ = OpCall.run(state_, callOperand_, stackTop_);\n                (stackTop_, do_) = stackTop_.pop();\n            }\n            return stackTop_;\n        }\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpFoldContext.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\nimport \"./OpCall.sol\";\n\n/// @title OpFoldContext\n/// Folds over columns of context from their start to end. Expressions do not\n/// have a good way of handling dynamic lengths of things, and that is\n/// intentional to avoid end users having to write out looping constructs of the\n/// form `i = 0; i < length; i++` is is so tedious and error prone in software\n/// development generally. It is very easy to implement \"off by one\" errors in\n/// this form, and requires sourcing a length from somewhere. This opcode exposes\n/// a pretty typical fold as found elsewhere in functional programming. A start\n/// column and width of columns can be specified, the rows will be iterated and\n/// pushed to the stack on top of any additional inputs specified by the\n/// expression. The additional inputs are the accumulators and so the number of\n/// outputs in the called source needs to match the number of accumulator inputs.\nlibrary OpFoldContext {\n    using LibIntegrityCheck for IntegrityCheckState;\n    using LibStackPointer for StackPointer;\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        unchecked {\n            uint256 sourceIndex_ = Operand.unwrap(operand_) & MASK_4BIT;\n            // We don't use the column for anything in the integrity check.\n            // uint256 column_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\n            uint256 width_ = (Operand.unwrap(operand_) >> 8) & MASK_4BIT;\n            uint256 inputs_ = Operand.unwrap(operand_) >> 12;\n            uint256 callInputs_ = width_ + inputs_;\n\n            // Outputs for call is the same as the inputs.\n            Operand callOperand_ = Operand.wrap(\n                (sourceIndex_ << 8) | (inputs_ << 4) | callInputs_\n            );\n\n            // First the width of the context columns being folded is pushed to\n            // the stack. Ignore the highwater here as `OpCall.integrity` has its\n            // own internal highwater handling over all its inputs and outputs.\n            stackTop_ = integrityCheckState_.pushIgnoreHighwater(\n                stackTop_,\n                width_\n            );\n            // Then we loop over call taking the width and extra inputs, then\n            // returning the same number of outputs as non-width inputs.\n            return\n                OpCall.integrity(integrityCheckState_, callOperand_, stackTop_);\n        }\n    }\n\n    function run(\n        InterpreterState memory state_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        unchecked {\n            uint256 sourceIndex_ = Operand.unwrap(operand_) & MASK_4BIT;\n            uint256 column_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\n            uint256 width_ = (Operand.unwrap(operand_) >> 8) & MASK_4BIT;\n            uint256 inputs_ = Operand.unwrap(operand_) >> 12;\n            // Call will take the width of the context rows being copied and the\n            // base inputs that will be the accumulators of the fold.\n            uint256 callInputs_ = width_ + inputs_;\n\n            // Fold over the entire context. This will error with an OOB index\n            // if the context columns are not of the same length.\n            for (uint256 i_ = 0; i_ < state_.context[column_].length; i_++) {\n                // Push the width of the context columns onto the stack as rows.\n                for (uint256 j_ = 0; j_ < width_; j_++) {\n                    stackTop_ = stackTop_.push(\n                        state_.context[column_ + j_][i_]\n                    );\n                }\n                // The outputs of call are the same as the base inputs, this is\n                // similar to `OpDoWhile` so that we don't have to care how many\n                // iterations there are in order to calculate the stack.\n                Operand callOperand_ = Operand.wrap(\n                    (sourceIndex_ << 8) | (inputs_ << 4) | callInputs_\n                );\n                stackTop_ = OpCall.run(state_, callOperand_, stackTop_);\n            }\n\n            return stackTop_;\n        }\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpGet.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpGet\n/// @notice Opcode for reading from storage.\nlibrary OpGet {\n    using LibStackPointer for StackPointer;\n    using LibInterpreterState for InterpreterState;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        unchecked {\n            // Pop key\n            // Stack value\n            function(uint256) internal pure returns (uint256) fn_;\n            return integrityCheckState_.applyFn(stackTop_, fn_);\n        }\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer\n    ) internal pure returns (StackPointer) {\n        // This must be implemented on the interpreter itself so that storage\n        // reads can happen.\n        revert(\"UNIMPLEMENTED\");\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpLoopN.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\nimport \"./OpCall.sol\";\n\n/// @title OpLoopN\n/// @notice Opcode for looping a static number of times. A thin wrapper around\n/// `OpCall` with the 4 high bits as a number of times to loop. Each iteration\n/// will use the outputs of the previous iteration as its inputs so the inputs\n/// to call must be greater or equal to the outputs. If the outputs exceed the\n/// inputs then each subsequent call will take as many inputs as it needs from\n/// the top of the intermediate stack. The net outputs to the stack will include\n/// all the intermediate excess outputs as:\n/// `outputs + (inputs - outputs) * n`\nlibrary OpLoopN {\n    using LibStackPointer for StackPointer;\n    using LibInterpreterState for InterpreterState;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        unchecked {\n            uint256 n_ = Operand.unwrap(operand_) >> 12;\n            uint256 inputs_ = Operand.unwrap(operand_) & MASK_4BIT;\n            uint256 outputs_ = (Operand.unwrap(operand_) >> 4) & MASK_4BIT;\n            require(inputs_ >= outputs_, \"LOOP_N_INPUTS\");\n            Operand callOperand_ = Operand.wrap(\n                Operand.unwrap(operand_) & MASK_12BIT\n            );\n            for (uint256 i_ = 0; i_ < n_; i_++) {\n                stackTop_ = OpCall.integrity(\n                    integrityCheckState_,\n                    callOperand_,\n                    stackTop_\n                );\n            }\n            return stackTop_;\n        }\n    }\n\n    function run(\n        InterpreterState memory state_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        uint256 n_ = Operand.unwrap(operand_) >> 12;\n        Operand callOperand_ = Operand.wrap(\n            Operand.unwrap(operand_) & MASK_12BIT\n        );\n        for (uint256 i_ = 0; i_ < n_; i_++) {\n            stackTop_ = OpCall.run(state_, callOperand_, stackTop_);\n        }\n        return stackTop_;\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpReadMemory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\nimport \"../../../math/Binary.sol\";\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// Thrown when a stack read index is outside the current stack top.\nerror OutOfBoundsStackRead(uint256 stackTopIndex, uint256 stackRead);\n\n/// Thrown when a constant read index is outside the constants array.\nerror OutOfBoundsConstantsRead(uint256 constantsLength, uint256 constantsRead);\n\nuint256 constant OPCODE_MEMORY_TYPE_STACK = 0;\nuint256 constant OPCODE_MEMORY_TYPE_CONSTANT = 1;\n\n/// @title OpReadMemory\n/// @notice Opcode for stacking from the interpreter state in memory. This can\n/// either be copying values from anywhere in the stack or from the constants\n/// array by index.\nlibrary OpReadMemory {\n    using LibStackPointer for StackPointer;\n    using LibInterpreterState for InterpreterState;\n    using LibIntegrityCheck for IntegrityCheckState;\n    using Math for uint256;\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        uint256 type_ = Operand.unwrap(operand_) & MASK_1BIT;\n        uint256 offset_ = Operand.unwrap(operand_) >> 1;\n        if (type_ == OPCODE_MEMORY_TYPE_STACK) {\n            uint256 stackTopIndex_ = integrityCheckState_.stackBottom.toIndex(\n                stackTop_\n            );\n            if (offset_ >= stackTopIndex_) {\n                revert OutOfBoundsStackRead(stackTopIndex_, offset_);\n            }\n\n            console.log(\n                \"before\",\n                StackPointer.unwrap(integrityCheckState_.stackBottom),\n                StackPointer.unwrap(integrityCheckState_.stackHighwater)\n            );\n            // Ensure that highwater is moved past any stack item that we\n            // read so that copied values cannot later be consumed.\n            integrityCheckState_.stackHighwater = StackPointer.wrap(\n                StackPointer.unwrap(integrityCheckState_.stackHighwater).max(\n                    StackPointer.unwrap(\n                        integrityCheckState_.stackBottom.up(offset_)\n                    )\n                )\n            );\n            console.log(\n                \"after\",\n                StackPointer.unwrap(integrityCheckState_.stackBottom),\n                StackPointer.unwrap(integrityCheckState_.stackHighwater)\n            );\n        } else {\n            if (offset_ >= integrityCheckState_.constantsLength) {\n                revert OutOfBoundsConstantsRead(\n                    integrityCheckState_.constantsLength,\n                    offset_\n                );\n            }\n        }\n        return integrityCheckState_.push(stackTop_);\n    }\n\n    function run(\n        InterpreterState memory state_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal pure returns (StackPointer) {\n        unchecked {\n            uint256 type_ = Operand.unwrap(operand_) & MASK_1BIT;\n            uint256 offset_ = Operand.unwrap(operand_) >> 1;\n            assembly (\"memory-safe\") {\n                mstore(\n                    stackTop_,\n                    mload(\n                        add(\n                            mload(add(state_, mul(0x20, type_))),\n                            mul(0x20, offset_)\n                        )\n                    )\n                )\n            }\n            return StackPointer.wrap(StackPointer.unwrap(stackTop_) + 0x20);\n        }\n    }\n}\n"
    },
    "contracts/interpreter/ops/core/OpSet.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\nimport \"../../../kv/LibMemoryKV.sol\";\n\n/// @title OpSet\n/// @notice Opcode for recording k/v state changes to be set in storage.\nlibrary OpSet {\n    using LibStackPointer for StackPointer;\n    using LibInterpreterState for InterpreterState;\n    using LibIntegrityCheck for IntegrityCheckState;\n    using LibMemoryKV for MemoryKV;\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        unchecked {\n            function(uint256, uint256) internal pure fn_;\n            return integrityCheckState_.applyFn(stackTop_, fn_);\n        }\n    }\n\n    function run(\n        InterpreterState memory state_,\n        Operand,\n        StackPointer stackTop_\n    ) internal pure returns (StackPointer) {\n        unchecked {\n            uint256 k_;\n            uint256 v_;\n            (stackTop_, v_) = stackTop_.pop();\n            (stackTop_, k_) = stackTop_.pop();\n            state_.stateKV = state_.stateKV.setVal(\n                MemoryKVKey.wrap(k_),\n                MemoryKVVal.wrap(v_)\n            );\n            return stackTop_;\n        }\n    }\n}\n"
    },
    "contracts/interpreter/ops/crypto/OpHash.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../../array/LibUint256Array.sol\";\nimport \"../../../type/LibCast.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpHash\n/// @notice Opcode for hashing a list of values.\nlibrary OpHash {\n    using LibStackPointer for StackPointer;\n    using LibCast for uint256[];\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(uint256[] memory values_) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(values_)));\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFn(\n                stackTop_,\n                f,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    // Stack the return of `balanceOfBatch`.\n    // Operand will be the length\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/erc1155/OpERC1155BalanceOf.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC1155Upgradeable as IERC1155} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpERC1155BalanceOf\n/// @notice Opcode for getting the current erc1155 balance of an account.\nlibrary OpERC1155BalanceOf {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(\n        uint256 token_,\n        uint256 account_,\n        uint256 id_\n    ) internal view returns (uint256) {\n        return\n            IERC1155(address(uint160(token_))).balanceOf(\n                address(uint160(account_)),\n                id_\n            );\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/erc1155/OpERC1155BalanceOfBatch.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC1155Upgradeable as IERC1155} from \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../../array/LibUint256Array.sol\";\nimport \"../../../type/LibCast.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpERC1155BalanceOfBatch\n/// @notice Opcode for getting the current erc1155 balance of an accounts batch.\nlibrary OpERC1155BalanceOfBatch {\n    using LibStackPointer for StackPointer;\n    using LibCast for uint256[];\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(\n        uint256 token_,\n        uint256[] memory accounts_,\n        uint256[] memory ids_\n    ) internal view returns (uint256[] memory) {\n        return\n            IERC1155(address(uint160(token_))).balanceOfBatch(\n                accounts_.asAddresses(),\n                ids_\n            );\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFn(\n                stackTop_,\n                f,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    // Operand will be the length\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/erc20/OpERC20BalanceOf.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpERC20BalanceOf\n/// @notice Opcode for ERC20 `balanceOf`.\nlibrary OpERC20BalanceOf {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(\n        uint256 token_,\n        uint256 account_\n    ) internal view returns (uint256) {\n        return\n            IERC20(address(uint160(token_))).balanceOf(\n                address(uint160(account_))\n            );\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/erc20/OpERC20TotalSupply.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpERC20TotalSupply\n/// @notice Opcode for ERC20 `totalSupply`.\nlibrary OpERC20TotalSupply {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(uint256 token_) internal view returns (uint256) {\n        return IERC20(address(uint160(token_))).totalSupply();\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/erc20/snapshot/OpERC20SnapshotBalanceOfAt.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {ERC20SnapshotUpgradeable as ERC20Snapshot} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\";\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpERC20SnapshotBalanceOfAt\n/// @notice Opcode for Open Zeppelin `ERC20Snapshot.balanceOfAt`.\n/// https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20Snapshot\nlibrary OpERC20SnapshotBalanceOfAt {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(\n        uint256 token_,\n        uint256 account_,\n        uint256 snapshotId_\n    ) internal view returns (uint256) {\n        return\n            ERC20Snapshot(address(uint160(token_))).balanceOfAt(\n                address(uint160(account_)),\n                snapshotId_\n            );\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/erc20/snapshot/OpERC20SnapshotTotalSupplyAt.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {ERC20SnapshotUpgradeable as ERC20Snapshot} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\";\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpERC20SnapshotTotalSupplyAt\n/// @notice Opcode for Open Zeppelin `ERC20Snapshot.totalSupplyAt`.\n/// https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#ERC20Snapshot\nlibrary OpERC20SnapshotTotalSupplyAt {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(\n        uint256 token_,\n        uint256 snapshotId_\n    ) internal view returns (uint256) {\n        return\n            ERC20Snapshot(address(uint160(token_))).totalSupplyAt(snapshotId_);\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/erc721/OpERC721BalanceOf.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC721Upgradeable as IERC721} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpERC721BalanceOf\n/// @notice Opcode for getting the current erc721 balance of an account.\nlibrary OpERC721BalanceOf {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(\n        uint256 token_,\n        uint256 account_\n    ) internal view returns (uint256) {\n        return\n            IERC721(address(uint160(token_))).balanceOf(\n                address(uint160(account_))\n            );\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/erc721/OpERC721OwnerOf.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {IERC721Upgradeable as IERC721} from \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpERC721OwnerOf\n/// @notice Opcode for getting the current erc721 owner of an account.\nlibrary OpERC721OwnerOf {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(\n        uint256 token_,\n        uint256 id_\n    ) internal view returns (uint256) {\n        return uint256(uint160(IERC721(address(uint160(token_))).ownerOf(id_)));\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/error/OpEnsure.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../../array/LibUint256Array.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpEnsure\n/// @notice Opcode for requiring some truthy values.\nlibrary OpEnsure {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(uint256 a_) internal pure {\n        assembly (\"memory-safe\") {\n            if iszero(a_) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFnN(\n                stackTop_,\n                f,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFnN(f, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/evm/OpBlockNumber.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpBlockNumber\n/// @notice Opcode for getting the current block number.\nlibrary OpBlockNumber {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal pure returns (StackPointer) {\n        return integrityCheckState_.push(stackTop_);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.push(block.number);\n    }\n}\n"
    },
    "contracts/interpreter/ops/evm/OpTimestamp.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpTimestamp\n/// @notice Opcode for getting the current timestamp.\nlibrary OpTimestamp {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal pure returns (StackPointer) {\n        return integrityCheckState_.push(stackTop_);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.push(block.timestamp);\n    }\n}\n"
    },
    "contracts/interpreter/ops/list/OpExplode32.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../../array/LibUint256Array.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpExplode\n/// @notice Opcode for exploding a single value into 8x 32 bit integers.\nlibrary OpExplode32 {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.push(integrityCheckState_.pop(stackTop_), 8);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal pure returns (StackPointer) {\n        (StackPointer location_, uint256 i_) = stackTop_.pop();\n        uint256 mask_ = uint256(type(uint32).max);\n        return\n            location_.push(\n                i_ & mask_,\n                (i_ >> 0x20) & mask_,\n                (i_ >> 0x40) & mask_,\n                (i_ >> 0x60) & mask_,\n                (i_ >> 0x80) & mask_,\n                (i_ >> 0xA0) & mask_,\n                (i_ >> 0xC0) & mask_,\n                (i_ >> 0xE0) & mask_\n            );\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/fixedPoint/OpFixedPointScale18.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../math/FixedPointMath.sol\";\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpFixedPointScale18\n/// @notice Opcode for scaling a number to 18 fixed point.\nlibrary OpFixedPointScale18 {\n    using FixedPointMath for uint256;\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(\n        Operand operand_,\n        uint256 a_\n    ) internal pure returns (uint256) {\n        return a_.scale18(Operand.unwrap(operand_));\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f, operand_);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/fixedPoint/OpFixedPointScale18Div.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../math/FixedPointMath.sol\";\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpFixedPointScale18Div\n/// @notice Opcode for performing scale 18 fixed point division.\nlibrary OpFixedPointScale18Div {\n    using FixedPointMath for uint256;\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(\n        Operand operand_,\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        return a_.scale18(Operand.unwrap(operand_)).fixedPointDiv(b_);\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f, operand_);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/fixedPoint/OpFixedPointScale18Mul.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../math/FixedPointMath.sol\";\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpFixedPointScale18Mul\n/// @notice Opcode for performing scale 18 fixed point multiplication.\nlibrary OpFixedPointScale18Mul {\n    using FixedPointMath for uint256;\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(\n        Operand operand_,\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        return a_.scale18(Operand.unwrap(operand_)).fixedPointMul(b_);\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f, operand_);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/fixedPoint/OpFixedPointScaleBy.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../math/FixedPointMath.sol\";\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpFixedPointScaleBy\n/// @notice Opcode for scaling a number by some OOMs.\nlibrary OpFixedPointScaleBy {\n    using FixedPointMath for uint256;\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(\n        Operand operand_,\n        uint256 a_\n    ) internal pure returns (uint256) {\n        return a_.scaleBy(int8(uint8(Operand.unwrap(operand_))));\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f, operand_);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/fixedPoint/OpFixedPointScaleN.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../math/FixedPointMath.sol\";\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpFixedPointScaleN\n/// @notice Opcode for scaling a number to N fixed point.\nlibrary OpFixedPointScaleN {\n    using FixedPointMath for uint256;\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(\n        Operand operand_,\n        uint256 a_\n    ) internal pure returns (uint256) {\n        return a_.scaleN(Operand.unwrap(operand_));\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f, operand_);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/logic/OpAny.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpAny\n/// @notice Opcode to compare the top N stack values.\nlibrary OpAny {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        function(uint256[] memory) internal view returns (uint256) fn_;\n        return\n            integrityCheckState_.applyFn(\n                stackTop_,\n                fn_,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    // ANY\n    // ANY is the first nonzero item, else 0.\n    // operand_ id the length of items to check.\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal pure returns (StackPointer) {\n        StackPointer bottom_ = stackTop_.down(Operand.unwrap(operand_));\n        for (\n            StackPointer i_ = bottom_;\n            StackPointer.unwrap(i_) < StackPointer.unwrap(stackTop_);\n            i_ = i_.up()\n        ) {\n            uint256 item_ = i_.peekUp();\n            if (item_ > 0) {\n                return bottom_.push(item_);\n            }\n        }\n        return bottom_.up();\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/logic/OpEagerIf.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpEagerIf\n/// @notice Opcode for selecting a value based on a condition.\nlibrary OpEagerIf {\n    using LibIntegrityCheck for IntegrityCheckState;\n    using LibStackPointer for StackPointer;\n\n    function _eagerIf(\n        uint256 a_,\n        uint256[] memory bs_,\n        uint256[] memory cs_\n    ) internal pure returns (uint256[] memory) {\n        return a_ > 0 ? bs_ : cs_;\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFn(\n                stackTop_,\n                _eagerIf,\n                Operand.unwrap(operand_) + 1\n            );\n    }\n\n    /// Eager because BOTH x_ and y_ must be eagerly evaluated\n    /// before EAGER_IF will select one of them. If both x_ and y_\n    /// are cheap (e.g. constant values) then this may also be the\n    /// simplest and cheapest way to select one of them.\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        unchecked {\n            return stackTop_.applyFn(_eagerIf, Operand.unwrap(operand_) + 1);\n        }\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/logic/OpEqualTo.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../../type/LibCast.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpEqualTo\n/// @notice Opcode to compare the top two stack values.\nlibrary OpEqualTo {\n    using LibCast for bool;\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function _equalTo(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256 c_) {\n        // Perhaps surprisingly it seems to require assembly to efficiently get\n        // a `uint256` from boolean equality.\n        assembly (\"memory-safe\") {\n            c_ := eq(a_, b_)\n        }\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, _equalTo);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(_equalTo);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/logic/OpEvery.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpEvery\n/// @notice Opcode to compare the top N stack values.\nlibrary OpEvery {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        function(uint256[] memory) internal view returns (uint256) fn_;\n        return\n            integrityCheckState_.applyFn(\n                stackTop_,\n                fn_,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    // EVERY\n    // EVERY is either the first item if every item is nonzero, else 0.\n    // operand_ is the length of items to check.\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal pure returns (StackPointer) {\n        StackPointer bottom_ = stackTop_.down(Operand.unwrap(operand_));\n        for (\n            StackPointer i_ = bottom_;\n            StackPointer.unwrap(i_) < StackPointer.unwrap(stackTop_);\n            i_ = i_.up()\n        ) {\n            if (i_.peekUp() == 0) {\n                return bottom_.push(0);\n            }\n        }\n        return bottom_.up();\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/logic/OpGreaterThan.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../../type/LibCast.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpGreaterThan\n/// @notice Opcode to compare the top two stack values.\nlibrary OpGreaterThan {\n    using LibCast for bool;\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function _greaterThan(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256 c_) {\n        assembly (\"memory-safe\") {\n            c_ := gt(a_, b_)\n        }\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, _greaterThan);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(_greaterThan);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/logic/OpIsZero.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../../type/LibCast.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpIsZero\n/// @notice Opcode for checking if the stack top is zero.\nlibrary OpIsZero {\n    using LibCast for bool;\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(uint256 a_) internal pure returns (uint256 b_) {\n        assembly (\"memory-safe\") {\n            b_ := iszero(a_)\n        }\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/logic/OpLessThan.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../../type/LibCast.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpLessThan\n/// @notice Opcode to compare the top two stack values.\nlibrary OpLessThan {\n    using LibStackPointer for StackPointer;\n    using LibCast for bool;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function _lessThan(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256 c_) {\n        assembly (\"memory-safe\") {\n            c_ := lt(a_, b_)\n        }\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, _lessThan);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(_lessThan);\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/OpAdd.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../../array/LibUint256Array.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpAdd\n/// @notice Opcode for adding N numbers with error on overflow.\nlibrary OpAdd {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    /// Addition with implied overflow checks from the Solidity 0.8.x compiler.\n    function f(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return a_ + b_;\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFnN(\n                stackTop_,\n                f,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFnN(f, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/OpDiv.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpDiv\n/// @notice Opcode for dividing N numbers.\nlibrary OpDiv {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function _div(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return a_ / b_;\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFnN(\n                stackTop_,\n                _div,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer stackTopAfter_) {\n        return stackTop_.applyFnN(_div, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/OpExp.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpExp\n/// @notice Opcode to exponentiate N numbers.\nlibrary OpExp {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function _exp(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return a_ ** b_;\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFnN(\n                stackTop_,\n                _exp,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer stackTopAfter_) {\n        return stackTop_.applyFnN(_exp, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/OpMax.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpMax\n/// @notice Opcode to stack the maximum of N numbers.\nlibrary OpMax {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function _max(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return a_ > b_ ? a_ : b_;\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFnN(\n                stackTop_,\n                _max,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer stackTopAfter_) {\n        return stackTop_.applyFnN(_max, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/OpMin.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpMin\n/// @notice Opcode to stack the minimum of N numbers.\nlibrary OpMin {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function _min(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return a_ < b_ ? a_ : b_;\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFnN(\n                stackTop_,\n                _min,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer stackTopAfter_) {\n        return stackTop_.applyFnN(_min, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/OpMod.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpMod\n/// @notice Opcode to mod N numbers.\nlibrary OpMod {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function _mod(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return a_ % b_;\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFnN(\n                stackTop_,\n                _mod,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer stackTopAfter_) {\n        return stackTop_.applyFnN(_mod, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/OpMul.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpMul\n/// @notice Opcode for multiplying N numbers.\nlibrary OpMul {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function _mul(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return a_ * b_;\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFnN(\n                stackTop_,\n                _mul,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer stackTopAfter_) {\n        return stackTop_.applyFnN(_mul, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/OpSub.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpSub\n/// @notice Opcode for subtracting N numbers.\nlibrary OpSub {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function _sub(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return a_ - b_;\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFnN(\n                stackTop_,\n                _sub,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer stackTopAfter_) {\n        return stackTop_.applyFnN(_sub, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/saturating/OpSaturatingAdd.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../math/SaturatingMath.sol\";\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpSaturatingAdd\n/// @notice Opcode for adding N numbers with saturating addition.\nlibrary OpSaturatingAdd {\n    using SaturatingMath for uint256;\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFnN(\n                stackTop_,\n                SaturatingMath.saturatingAdd,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer stackTopAfter_) {\n        return\n            stackTop_.applyFnN(\n                SaturatingMath.saturatingAdd,\n                Operand.unwrap(operand_)\n            );\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/saturating/OpSaturatingMul.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../math/SaturatingMath.sol\";\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpSaturatingMul\n/// @notice Opcode for multiplying N numbers with saturating multiplication.\nlibrary OpSaturatingMul {\n    using SaturatingMath for uint256;\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFnN(\n                stackTop_,\n                SaturatingMath.saturatingMul,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer stackTopAfter_) {\n        return\n            stackTop_.applyFnN(\n                SaturatingMath.saturatingMul,\n                Operand.unwrap(operand_)\n            );\n    }\n}\n"
    },
    "contracts/interpreter/ops/math/saturating/OpSaturatingSub.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../math/SaturatingMath.sol\";\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpSaturatingSub\n/// @notice Opcode for subtracting N numbers with saturating subtraction.\nlibrary OpSaturatingSub {\n    using SaturatingMath for uint256;\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFnN(\n                stackTop_,\n                SaturatingMath.saturatingSub,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer stackTopAfter_) {\n        return\n            stackTop_.applyFnN(\n                SaturatingMath.saturatingSub,\n                Operand.unwrap(operand_)\n            );\n    }\n}\n"
    },
    "contracts/interpreter/ops/rain/IOrderBookV1/OpIOrderBookV1VaultBalance.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../orderbook/IOrderBookV1.sol\";\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpIOrderBookV1VaultBalance\n/// @notice Opcode for IOrderBookV1 `vaultBalance`.\nlibrary OpIOrderBookV1VaultBalance {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(\n        uint256 orderbook_,\n        uint256 owner_,\n        uint256 token_,\n        uint256 id_\n    ) internal view returns (uint256) {\n        return\n            uint256(\n                uint160(\n                    IOrderBookV1(address(uint160(orderbook_))).vaultBalance(\n                        address(uint160(owner_)),\n                        address(uint160(token_)),\n                        id_\n                    )\n                )\n            );\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/rain/ISaleV2/OpISaleV2RemainingTokenInventory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../sale/ISaleV2.sol\";\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpISaleV2RemainingTokenInventory\n/// @notice Opcode for ISaleV2 `remainingTokenInventory`.\nlibrary OpISaleV2RemainingTokenInventory {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(uint256 sale_) internal view returns (uint256) {\n        return ISaleV2(address(uint160(sale_))).remainingTokenInventory();\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    /// Stack `remainingTokenInventory`.\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/rain/ISaleV2/OpISaleV2Reserve.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../sale/ISaleV2.sol\";\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpISaleV2Reserve\n/// @notice Opcode for ISaleV2 `reserve`.\nlibrary OpISaleV2Reserve {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(uint256 sale_) internal view returns (uint256) {\n        return uint256(uint160(ISaleV2(address(uint160(sale_))).reserve()));\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    /// Stack `reserve`.\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/rain/ISaleV2/OpISaleV2SaleStatus.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../sale/ISaleV2.sol\";\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpISaleV2SaleStatus\n/// @notice Opcode for ISaleV2 `saleStatus`.\nlibrary OpISaleV2SaleStatus {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(uint256 sale_) internal view returns (uint256) {\n        return uint(ISaleV2(address(uint160(sale_))).saleStatus());\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    /// Stack `saleStatus`.\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/rain/ISaleV2/OpISaleV2Token.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../sale/ISaleV2.sol\";\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpISaleV2Token\n/// @notice Opcode for ISaleV2 `token`.\nlibrary OpISaleV2Token {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(uint256 sale_) internal view returns (uint256) {\n        return uint256(uint160(ISaleV2(address(uint160(sale_))).token()));\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    /// Stack `token`.\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/rain/ISaleV2/OpISaleV2TotalReserveReceived.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../sale/ISaleV2.sol\";\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpISaleV2TotalReserveReceived\n/// @notice Opcode for ISaleV2 `totalReserveReceived`.\nlibrary OpISaleV2TotalReserveReceived {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(uint256 sale_) internal view returns (uint256) {\n        return ISaleV2(address(uint160(sale_))).totalReserveReceived();\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    /// Stack `totalReserveReceived`.\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/rain/IVerifyV1/OpIVerifyV1AccountStatusAtTime.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../verify/IVerifyV1.sol\";\nimport \"../../../run/LibStackPointer.sol\";\nimport \"../../../run/LibInterpreterState.sol\";\nimport \"../../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpIVerifyV1AccountStatusAtTime\n/// @notice Opcode for IVerifyV1 `accountStatusAtTime`.\nlibrary OpIVerifyV1AccountStatusAtTime {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(\n        uint256 contract_,\n        uint256 account_,\n        uint256 timestamp_\n    ) internal view returns (uint256) {\n        return\n            VerifyStatus.unwrap(\n                IVerifyV1(address(uint160(contract_))).accountStatusAtTime(\n                    address(uint160(account_)),\n                    timestamp_\n                )\n            );\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    /// Stack `token`.\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f);\n    }\n}\n"
    },
    "contracts/interpreter/ops/tier/OpITierV2Report.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../tier/ITierV2.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpITierV2Report\n/// @notice Exposes `ITierV2.report` as an opcode.\nlibrary OpITierV2Report {\n    using LibStackPointer for StackPointer;\n    using LibStackPointer for uint256[];\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function _report(\n        uint256 tierContract_,\n        uint256 account_,\n        uint256[] memory context_\n    ) internal view returns (uint256) {\n        return\n            ITierV2(address(uint160(tierContract_))).report(\n                address(uint160(account_)),\n                context_\n            );\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFn(\n                stackTop_,\n                _report,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    // Stack the `report` returned by an `ITierV2` contract.\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer stackTopAfter_) {\n        return stackTop_.applyFn(_report, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/tier/OpITierV2ReportTimeForTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../tier/ITierV2.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\n/// @title OpITierV2Report\n/// @notice Exposes `ITierV2.reportTimeForTier` as an opcode.\nlibrary OpITierV2ReportTimeForTier {\n    using LibStackPointer for StackPointer;\n    using LibStackPointer for uint256[];\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function _reportTimeForTier(\n        uint256 tierContract_,\n        uint256 account_,\n        uint256 tier_,\n        uint256[] memory context_\n    ) internal view returns (uint256) {\n        return\n            ITierV2(address(uint160(tierContract_))).reportTimeForTier(\n                address(uint160(account_)),\n                tier_,\n                context_\n            );\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFn(\n                stackTop_,\n                _reportTimeForTier,\n                Operand.unwrap(operand_)\n            );\n    }\n\n    // Stack the `reportTimeForTier` returned by an `ITierV2` contract.\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(_reportTimeForTier, Operand.unwrap(operand_));\n    }\n}\n"
    },
    "contracts/interpreter/ops/tier/OpSaturatingDiff.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../tier/libraries/TierwiseCombine.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\nlibrary OpSaturatingDiff {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFn(\n                stackTop_,\n                TierwiseCombine.saturatingSub\n            );\n    }\n\n    // Stack the tierwise saturating subtraction of two reports.\n    // If the older report is newer than newer report the result will\n    // be `0`, else a tierwise diff in blocks will be obtained.\n    // The older and newer report are taken from the stack.\n    function run(\n        InterpreterState memory,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(TierwiseCombine.saturatingSub);\n    }\n}\n"
    },
    "contracts/interpreter/ops/tier/OpSelectLte.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../tier/libraries/TierwiseCombine.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\nimport \"../../../math/Binary.sol\";\n\n/// Zero inputs to select lte is NOT supported.\nerror ZeroInputs();\n\n/// @title OpSelectLte\n/// @notice Exposes `TierwiseCombine.selectLte` as an opcode.\nlibrary OpSelectLte {\n    using LibStackPointer for StackPointer;\n    using LibStackPointer for uint256[];\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        unchecked {\n            uint256 inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\n            if (inputs_ == 0) {\n                revert ZeroInputs();\n            }\n\n            return\n                integrityCheckState_.push(\n                    integrityCheckState_.pop(stackTop_, inputs_)\n                );\n        }\n    }\n\n    // Stacks the result of a `selectLte` combinator.\n    // All `selectLte` share the same stack and argument handling.\n    // Takes the `logic_` and `mode_` from the `operand_` high bits.\n    // `logic_` is the highest bit.\n    // `mode_` is the 2 highest bits after `logic_`.\n    // The other bits specify how many values to take from the stack\n    // as reports to compare against each other and the block number.\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal pure returns (StackPointer) {\n        unchecked {\n            uint256 inputs_ = Operand.unwrap(operand_) & MASK_8BIT;\n            uint256 mode_ = (Operand.unwrap(operand_) >> 8) & MASK_2BIT;\n            uint256 logic_ = Operand.unwrap(operand_) >> 10;\n            (uint256 time_, uint256[] memory reports_) = stackTop_.list(\n                inputs_\n            );\n            return\n                reports_.asStackPointer().push(\n                    TierwiseCombine.selectLte(logic_, mode_, time_, reports_)\n                );\n        }\n    }\n}\n"
    },
    "contracts/interpreter/ops/tier/OpUpdateTimesForTierRange.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../tier/libraries/TierReport.sol\";\nimport \"../../run/LibStackPointer.sol\";\nimport \"../../run/LibInterpreterState.sol\";\nimport \"../../deploy/LibIntegrityCheck.sol\";\n\nlibrary OpUpdateTimesForTierRange {\n    using LibStackPointer for StackPointer;\n    using LibIntegrityCheck for IntegrityCheckState;\n\n    function f(\n        Operand operand_,\n        uint256 report_,\n        uint256 timestamp_\n    ) internal pure returns (uint256) {\n        return\n            TierReport.updateTimesForTierRange(\n                report_,\n                // start tier.\n                // 4 low bits.\n                Operand.unwrap(operand_) & 0x0f,\n                // end tier.\n                // 4 high bits.\n                (Operand.unwrap(operand_) >> 4) & 0x0f,\n                timestamp_\n            );\n    }\n\n    function integrity(\n        IntegrityCheckState memory integrityCheckState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return\n            integrityCheckState_.applyFn(stackTop_, f);\n    }\n\n    // Stacks a report with updated times over tier range.\n    // The start and end tier are taken from the low and high bits of\n    // the `operand_` respectively.\n    // The report to update and timestamp to update to are both\n    // taken from the stack.\n    function run(\n        InterpreterState memory,\n        Operand operand_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        return stackTop_.applyFn(f, operand_);\n    }\n}\n"
    },
    "contracts/interpreter/run/IInterpreterV1.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// @dev The index of a source within a deployed expression that can be evaluated\n/// by an `IInterpreterV1`. MAY be an entrypoint or the index of a source called\n/// internally such as by the `call` opcode.\ntype SourceIndex is uint256;\n/// @dev Encoded information about a specific evaluation including the expression\n/// address onchain, entrypoint and expected return values.\ntype EncodedDispatch is uint256;\n/// @dev The namespace for state changes as requested by the calling contract.\n/// The interpreter MUST apply this namespace IN ADDITION to namespacing by\n/// caller etc.\ntype StateNamespace is uint256;\n/// @dev Additional bytes that can be used to configure a single opcode dispatch.\n/// Commonly used to specify the number of inputs to a variadic function such\n/// as addition or multiplication.\ntype Operand is uint256;\n\n/// @title IInterpreterV1\n/// Interface into a standard interpreter that supports:\n///\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\n///   to the evaluated logic\n/// - handling subsequent state changes in bulk in response to evaluated logic\n/// - namespacing state changes according to the caller's preferences to avoid\n///   unwanted key collisions\n/// - exposing its internal function pointers to support external precompilation\n///   of logic for more gas efficient runtime evaluation by the interpreter\n///\n/// The interface is designed to be stable across many versions and\n/// implementations of an interpreter, balancing minimalism with features\n/// required for a general purpose onchain interpreted compute environment.\n///\n/// The security model of an interpreter is that it MUST be resilient to\n/// malicious expressions even if they dispatch arbitrary internal function\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\n/// undefined behaviour or error during an eval, _provided that no state changes\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\n/// malicious expression can be negatively impacted by the result. In turn, the\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\n/// return values from any interpreter that it requests an expression from. And\n/// so on and so forth up to the externally owned account (EOA) who signs the\n/// transaction and agrees to a specific combination of contracts, expressions\n/// and interpreters, who can presumably make an informed decision about which\n/// ones to trust to get the job done.\n///\n/// The state changes for an interpreter are expected to be produces by an `eval`\n/// and passed back to the interpreter as-is by the caller, after the caller has\n/// had an opportunity to apply their own intermediate logic such as reentrancy\n/// defenses against malicious interpreters. The interpreter is free to structure\n/// the state changes however it wants but MUST guard against the calling\n/// contract corrupting the changes between `eval` and `stateChanges`. For\n/// example an interpreter could sandbox storage writes per-caller so that a\n/// malicious caller can only damage their own state changes, while honest\n/// callers respect, benefit from and are protected by the interpreter's state\n/// change handling.\n///\n/// The two step eval-state model allows eval to be read-only which provides\n/// security guarantees for the caller such as no stateful reentrancy, either\n/// from the interpreter or some contract interface used by some word, while\n/// still allowing for storage writes. As the storage writes happen on the\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\n/// need to trust the interpreter, which allows for permissionless selection of\n/// interpreters by end users. Delegate call always implies an admin key on the\n/// caller because the delegatee contract can write arbitrarily to the state of\n/// the delegator, which severely limits the generality of contract composition.\ninterface IInterpreterV1 {\n    /// Exposes the function pointers as `uint16` values packed into a single\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\n    ///\n    /// `IExpressionDeployerV1` contracts use these function pointers to\n    /// \"compile\" the expression into something that an interpreter can dispatch\n    /// directly without paying gas to lookup the same at runtime. As the\n    /// validity of any integrity check and subsequent dispatch is highly\n    /// sensitive to both the function pointers and overall bytecode of the\n    /// interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\n    /// against accidentally being deployed onchain paired against an unknown\n    /// interpreter. It is very easy for an apparent compatible pairing to be\n    /// subtly and critically incompatible due to addition/removal/reordering of\n    /// opcodes and compiler optimisations on the interpreter bytecode.\n    ///\n    /// This MAY return different values during construction vs. all other times\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\n    /// on function pointers reported during contract construction.\n    function functionPointers() external view returns (bytes memory);\n\n    /// The raison d'etre for an interpreter. Given some expression and per-call\n    /// additional contextual data, produce a stack of results and a set of state\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\n    /// call to `stateChanges`.\n    /// @param dispatch All the information required for the interpreter to load\n    /// an expression, select an entrypoint and return the values expected by the\n    /// caller. The interpreter MAY encode dispatches differently to\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\n    /// calling contracts that hardcode the encoding logic.\n    /// @param context A 2-dimensional array of data that can be indexed into at\n    /// runtime by the interpreter. The calling contract is responsible for\n    /// ensuring the authenticity and completeness of context data. The\n    /// interpreter MUST revert at runtime if an expression attempts to index\n    /// into some context value that is not provided by the caller. This implies\n    /// that context reads cannot be checked for out of bounds reads at deploy\n    /// time, as the runtime context MAY be provided in a different shape to what\n    /// the expression is expecting.\n    function eval(\n        EncodedDispatch dispatch,\n        uint256[][] calldata context\n    )\n        external\n        view\n        returns (uint256[] memory stack, uint256[] memory stateChanges);\n\n    /// Applies state changes from a prior eval to the storage of the\n    /// interpreter. The interpreter is responsible for ensuring that applying\n    /// these state changes is safe from key collisions, both with any internal\n    /// state the interpreter needs for itself and with calls to `stateChanges`\n    /// from different `msg.sender` callers. I.e. it MUST NOT be possible for\n    /// a caller to modify the state changes associated with some other caller.\n    ///\n    /// The interpreter defines the shape of its own state changes, which is\n    /// opaque to the calling contract. For example, some interpreter may treat\n    /// the list of state changes as a pairwise key/value set, and some other\n    /// interpreter may treat it as a literal list to be stored as-is.\n    ///\n    /// The interpreter MUST assume the state changes have been corrupted by the\n    /// calling contract due to bugs or malicious intent, and enforce state\n    /// isolation between callers despite arbitrarily invalid state changes. The\n    /// interpreter MUST revert if it can detect invalid state changes, such\n    /// as a key/value list having an odd number of items, but this MAY NOT be\n    /// possible if the corruption is undetectable.\n    ///\n    /// @param stateChanges The list of changes to apply to the interpreter's\n    /// internal state.\n    function stateChanges(uint256[] calldata stateChanges) external;\n\n    /// Same as `eval` but allowing the caller to specify a namespace under which\n    /// the state changes will be applied. The interpeter MUST ensure that keys\n    /// will never collide across namespaces, even if, for example:\n    ///\n    /// - The calling contract is malicious and attempts to craft a collision\n    ///   with state changes from another contract\n    /// - The expression is malicious and attempts to craft a collision with\n    ///   other expressions evaluated by the same calling contract\n    ///\n    /// A malicious entity MAY have access to significant offchain resources to\n    /// attempt to precompute key collisions through brute force. The collision\n    /// resistance of namespaces should be comparable or equivalent to the\n    /// collision resistance of the hashing algorithms employed by the blockchain\n    /// itself, such as the design of `mapping` in Solidity that hashes each\n    /// nested key to produce a collision resistant compound key.\n    ///\n    /// Calls to `eval` without a namespace are implied to be under namespace `0`\n    /// so an interpreter MAY implement `eval` in terms of `evalWithNamespace` if\n    /// this simplifies the implementation.\n    ///\n    /// @param namespace The namespace specified by the calling contract.\n    /// @param dispatch As per `eval`.\n    /// @param context As per `eval`.\n    /// @return stack As per `eval`.\n    /// @return stateChanges As per `eval`.\n    function evalWithNamespace(\n        StateNamespace namespace,\n        EncodedDispatch dispatch,\n        uint256[][] calldata context\n    )\n        external\n        view\n        returns (uint256[] memory stack, uint256[] memory stateChanges);\n\n    /// Same as `stateChanges` but following `evalWithNamespace`. The caller MUST\n    /// use the same namespace for both `evalWithNamespace` and\n    /// `stateChangesWithNamespace` for a given expression evaluation.\n    /// @param namespace As per `evalWithNamespace`.\n    /// @param stateChanges as per `stateChanges`.\n    function stateChangesWithNamespace(\n        StateNamespace namespace,\n        uint256[] calldata stateChanges\n    ) external;\n}\n"
    },
    "contracts/interpreter/run/LibContext.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"../../array/LibUint256Array.sol\";\n\nimport {SignatureCheckerUpgradeable as SignatureChecker} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/SignatureCheckerUpgradeable.sol\";\nimport {ECDSAUpgradeable as ECDSA} from \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\n\n/// Thrown when the ith signature from a list of signed contexts is invalid.\nerror InvalidSignature(uint256 i);\n\n/// Typed embodiment of some context data with associated signer and signature.\n/// The signature MUST be over the packed encoded bytes of the context array,\n/// i.e. the context array concatenated as bytes without the length prefix, then\n/// hashed, then handled as per EIP-191 to produce a final hash to be signed.\n///\n/// The calling contract (likely with the help of `LibContext`) is responsible\n/// for ensuring the authenticity of the signature, but not authorizing _who_ can\n/// sign. IN ADDITION to authorisation of the signer to known-good entities the\n/// expression is also responsible for:\n///\n/// - Enforcing the context is the expected data (e.g. with a domain separator)\n/// - Tracking and enforcing nonces if signed contexts are only usable one time\n/// - Tracking and enforcing uniqueness of signed data if relevant\n/// - Checking and enforcing expiry times if present and relevant in the context\n/// - Many other potential constraints that expressions may want to enforce\n///\n/// EIP-1271 smart contract signatures are supported in addition to EOA\n/// signatures via. the Open Zeppelin `SignatureChecker` library, which is\n/// wrapped by `LibContext.build`. As smart contract signatures are checked\n/// onchain they CAN BE REVOKED AT ANY MOMENT as the smart contract can simply\n/// return `false` when it previously returned `true`.\n///\n/// @param signer The account that produced the signature for `context`. The\n/// calling contract MUST authenticate that the signer produced the signature.\n/// @param signature The cryptographic signature for `context`. The calling\n/// contract MUST authenticate that the signature is valid for the `signer` and\n/// `context`.\n/// @param context The signed data in a format that can be merged into a\n/// 2-dimensional context matrix as-is.\nstruct SignedContext {\n    address signer;\n    bytes signature;\n    uint256[] context;\n}\n\n/// @title LibContext\n/// @notice Conventions for working with context as a calling contract. All of\n/// this functionality is OPTIONAL but probably useful for the majority of use\n/// cases. By building and authenticating onchain, caller provided and signed\n/// contexts all in a standard way the overall usability of context is greatly\n/// improved for expression authors and readers. Any calling contract that can\n/// match the context expectations of an existing expression is one large step\n/// closer to compatibility and portability, inheriting network effects of what\n/// has already been authored elsewhere.\nlibrary LibContext {\n    using LibUint256Array for uint256[];\n\n    /// The base context is the `msg.sender` and address of the calling contract.\n    /// As the interpreter itself is called via an external interface and may be\n    /// statically calling itself, it MAY NOT have any ability to inspect either\n    /// of these values. Even if this were not the case the calling contract\n    /// cannot assume the existence of some opcode(s) in the interpreter that\n    /// inspect the caller, so providing these two values as context is\n    /// sufficient to decouple the calling contract from the interpreter. It is\n    /// STRONGLY RECOMMENDED that even if the calling contract has \"no context\"\n    /// that it still provides this base to every `eval`.\n    ///\n    /// Calling contracts DO NOT need to call this directly. It is built and\n    /// merged automatically into the standard context built by `build`.\n    ///\n    /// @return The `msg.sender` and address of the calling contract using this\n    /// library, as a context-compatible array.\n    function base() internal view returns (uint256[] memory) {\n        return\n            LibUint256Array.arrayFrom(\n                uint(uint160(msg.sender)),\n                uint(uint160(address(this)))\n            );\n    }\n\n    /// Standard hashing process over a list of signed contexts. Situationally\n    /// useful if the calling contract wants to record that it has seen a set of\n    /// signed data then later compare it against some input (e.g. to ensure that\n    /// many calls of some function all share the same input values). Note that\n    /// unlike the internals of `build`, this hashes over the signer and the\n    /// signature, to ensure that some data cannot be re-signed and used under\n    /// a different provenance later.\n    /// @param signedContexts_ The list of signed contexts to hash over.\n    /// @return The hash of the signed contexts.\n    function hash(\n        SignedContext[] memory signedContexts_\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(signedContexts_));\n    }\n\n    /// Builds a standard 2-dimensional context array from base, calling and\n    /// signed contexts. Note that \"columns\" of a context array refer to each\n    /// `uint256[]` and each item within a `uint256[]` is a \"row\".\n    ///\n    /// @param baseContext_ Anything the calling contract can provide without\n    /// input from the `msg.sender`. More strictly the `msg.sender` MUST NOT be\n    /// able to directly modify any of these values, although the values MAY be\n    /// derived from user activity broadly, such as current vault balances after\n    /// a series of deposits and withdrawals. The default base context from\n    /// `LibContext.base()` DOES NOT need to be provided by the caller, this\n    /// matrix MAY be empty and will be simply merged into the final context. The\n    /// base context matrix MUST contain a consistent number of columns from the\n    /// calling contract so that the expression can always predict how many\n    /// columns there will be when it runs.\n    /// @param callingContext_ Calling context is provided by the `msg.sender`\n    /// and so should be treated as self-signed data. As an attestation/proof of\n    /// some external event or state it is highly suspect, but as an indicator\n    /// of the intent of `msg.sender` it may be treated as gospel. Calling\n    /// context MAY be empty but a zero length column will still be reserved in\n    /// the final built context. This ensures that expressions can always\n    /// predict how many columns there will be when they run.\n    /// @param signedContexts_ Signed contexts are provided by the `msg.sender`\n    /// but signed by a third party. The expression (author) defines _who_ may\n    /// sign and the calling contract authenticates the signature over the\n    /// signed data. Technically `build` handles all the authentication inline\n    /// for the calling contract so if some context builds it can be treated as\n    /// authentic. The builder WILL REVERT if any of the signatures are invalid.\n    /// Note two things about the structure of the final built context re: signed\n    /// contexts:\n    /// - The first column is a list of the signers in order of what they signed\n    /// - The `msg.sender` can provide an arbitrary number of signed contexts so\n    ///   expressions DO NOT know exactly how many columns there are.\n    /// The expression is responsible for defining e.g. a domain separator in a\n    /// position that would force signed context to be provided in the \"correct\"\n    /// order, rather than relying on the `msg.sender` to honestly present data\n    /// in any particular structure/order.\n    function build(\n        uint256[][] memory baseContext_,\n        uint256[] memory callingContext_,\n        SignedContext[] memory signedContexts_\n    ) internal view returns (uint256[][] memory) {\n        unchecked {\n            uint256[] memory signers_ = new uint256[](signedContexts_.length);\n\n            // - LibContext.base() + whatever we are provided.\n            // - calling context always even if empty\n            // - signed contexts + signers if they exist else nothing.\n            uint256 contextLength_ = 1 +\n                baseContext_.length +\n                1 +\n                (signedContexts_.length > 0 ? signedContexts_.length + 1 : 0);\n\n            uint256[][] memory context_ = new uint256[][](contextLength_);\n            uint256 offset_ = 0;\n            context_[offset_] = LibContext.base();\n\n            for (uint256 i_ = 0; i_ < baseContext_.length; i_++) {\n                offset_++;\n                context_[offset_] = baseContext_[i_];\n            }\n\n            // Calling context is added unconditionally so that a 0 length array\n            // is simply an empty column. We don't want callers to be able to\n            // manipulate the overall structure of context columns that the\n            // expression indexes into.\n            offset_++;\n            context_[offset_] = callingContext_;\n\n            if (signedContexts_.length > 0) {\n                offset_++;\n                context_[offset_] = signers_;\n\n                for (uint256 i_ = 0; i_ < signedContexts_.length; i_++) {\n                    if (\n                        !SignatureChecker.isValidSignatureNow(\n                            signedContexts_[i_].signer,\n                            ECDSA.toEthSignedMessageHash(\n                                // Unlike `LibContext.hash` we can only hash over\n                                // the context as it's impossible for a signature\n                                // to sign itself.\n                                keccak256(\n                                    abi.encodePacked(\n                                        signedContexts_[i_].context\n                                    )\n                                )\n                            ),\n                            signedContexts_[i_].signature\n                        )\n                    ) {\n                        revert InvalidSignature(i_);\n                    }\n\n                    signers_[i_] = uint256(uint160(signedContexts_[i_].signer));\n                    offset_++;\n                    context_[offset_] = signedContexts_[i_].context;\n                }\n            }\n\n            return context_;\n        }\n    }\n}\n"
    },
    "contracts/interpreter/run/LibEncodedDispatch.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"./IInterpreterV1.sol\";\n\n/// @title LibEncodedDispatch\n/// @notice Establishes and implements a convention for encoding an interpreter\n/// dispatch. Handles encoding of several things required for efficient dispatch.\nlibrary LibEncodedDispatch {\n    /// Builds an `EncodedDispatch` from its constituent parts.\n    /// @param expression_ The onchain address of the expression to run.\n    /// @param sourceIndex_ The index of the source to run within the expression\n    /// as an entrypoint.\n    /// @param maxOutputs_ The maximum outputs the caller can meaningfully use.\n    /// If the interpreter returns a larger stack than this it is merely wasting\n    /// gas across the external call boundary.\n    /// @return The encoded dispatch.\n    function encode(\n        address expression_,\n        SourceIndex sourceIndex_,\n        uint256 maxOutputs_\n    ) internal pure returns (EncodedDispatch) {\n        return\n            EncodedDispatch.wrap(\n                (uint256(uint160(expression_)) << 32) |\n                    (SourceIndex.unwrap(sourceIndex_) << 16) |\n                    maxOutputs_\n            );\n    }\n\n    /// Decodes an `EncodedDispatch` to its constituent parts.\n    /// @param dispatch_ The `EncodedDispatch` to decode.\n    /// @return The expression, source index, and max outputs as per `encode`.\n    function decode(\n        EncodedDispatch dispatch_\n    ) internal pure returns (address, SourceIndex, uint256) {\n        return (\n            address(uint160(EncodedDispatch.unwrap(dispatch_) >> 32)),\n            SourceIndex.wrap((EncodedDispatch.unwrap(dispatch_) >> 16) & 0xFF),\n            EncodedDispatch.unwrap(dispatch_) & 0xFF\n        );\n    }\n}\n"
    },
    "contracts/interpreter/run/LibInterpreterState.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../run/IInterpreterV1.sol\";\nimport \"../deploy/IExpressionDeployerV1.sol\";\nimport \"./LibStackPointer.sol\";\nimport \"../../type/LibCast.sol\";\nimport \"../../type/LibConvert.sol\";\nimport \"../../array/LibUint256Array.sol\";\nimport \"../../memory/LibMemorySize.sol\";\nimport {SafeCastUpgradeable as SafeCast} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport \"../../kv/LibMemoryKV.sol\";\nimport \"hardhat/console.sol\";\n\n/// Debugging options for a standard console log over the interpreter state.\n/// - Stack: Log the entire stack, respects the current stack top, i.e. DOES NOT\n///   log every value of the underlying `uint256[]` unless the stack top points\n///   to the end of the array.\n/// - Constant: Log every constant available to the current expression.\n/// - Context: Log every column/row of context available to the current eval.\n/// - Source: Log all the raw bytes of the compiled sources being evaluated.\nenum DebugStyle {\n    Stack,\n    Constant,\n    Context,\n    Source\n}\n\n/// A fully qualified namespace includes the interpreter's own namespacing logic\n/// IN ADDITION to the calling contract's requested `StateNamespace`. Typically\n/// this involves hashing the `msg.sender` into the `StateNamespace` so that each\n/// caller operates within its own disjoint state universe. Intepreters MUST NOT\n/// allow either the caller nor any expression/word to modify this directly on\n/// pain of potential key collisions on writes to the interpreter's own storage.\ntype FullyQualifiedNamespace is uint256;\n\n/// The standard in-memory representation of an interpreter that facilitates\n/// decoupled coordination between opcodes. Opcodes MAY:\n///\n/// - push and pop values to the shared stack\n/// - read per-expression constants\n/// - write to the final state changes set within the fully qualified namespace\n/// - read per-eval context values\n/// - recursively evaluate any compiled source associated with the expression\n///\n/// As the interpreter defines the opcodes it is its responsibility to ensure the\n/// opcodes are incapable of doing anything to undermine security or correctness.\n/// For example, a hypothetical opcode could modify the current namespace from\n/// the stack, but this would be a very bad idea as it would allow expressions\n/// to hijack storage values associated with other callers, fundamentally\n/// breaking the state sandbox model.\n///\n/// The iterpreter MAY skip any runtime integrity checks that can be reasonably\n/// assumed to have been performed by a competent expression deployer, such as\n/// guarding against stack underflow. A competent expression deployer MAY NOT\n/// have deployed the currently evaluating expression, so the interpreter MUST\n/// avoid state changes during evaluation, but MAY return garbage data if the\n/// calling contract fails to leverage an appropriate expression deployer.\n///\n/// @param stackBottom Opcodes write to the stack starting at the stack bottom,\n/// ideally using `LibStackPointer` to normalise push and pop behaviours. A\n/// competent expression deployer will calculate a memory preallocation that\n/// pushes and pops above the stack bottom effectively allocate and deallocate\n/// memory within.\n/// @param constantsBottom Opcodes read constants starting at the pointer to\n/// the bottom of the constants array. As the name implies the interpreter MUST\n/// NOT write to the constants, it is read only.\n/// @param stateKV The in memory key/value store that tracks reads/writes over\n/// the underlying interpreter storage for the duration of a single expression\n/// evaluation.\n/// @param namespace The fully qualified namespace that all state reads and\n/// writes MUST be performed under.\n/// @param context A 2-dimensional array of per-eval data provided by the calling\n/// contract. Opaque to the interpreter but presumably meaningful to the\n/// expression.\n/// @param compiledSources A list of sources that can be directly evaluated by\n/// the interpreter, either as a top level entrypoint or nested e.g. under a\n/// dispatch by `call`.\nstruct InterpreterState {\n    StackPointer stackBottom;\n    StackPointer constantsBottom;\n    MemoryKV stateKV;\n    FullyQualifiedNamespace namespace;\n    uint256[][] context;\n    bytes[] compiledSources;\n}\n\n/// @dev squiggly lines to make the debug output easier to read. Intentionlly\n/// short to keep compiled code size down.\nstring constant DEBUG_DELIMETER = \"~~~\";\n\n/// @title LibInterpreterState\n/// @notice Main workhorse for `InterpeterState` including:\n///\n/// - the standard `eval` loop\n/// - source compilation from opcodes\n/// - state (de)serialization (more gas efficient than abi encoding)\n/// - low level debugging utility\n///\n/// Interpreters are designed to be highly moddable behind the `IInterpreterV1`\n/// interface, but pretty much any interpreter that uses `InterpreterState` will\n/// need these low level facilities verbatim. Further, these facilities\n/// (with possible exception of debugging logic), while relatively short in terms\n/// of lines of code, are surprisingly fragile to maintain in a gas efficient way\n/// so we don't recommend reinventing this wheel.\nlibrary LibInterpreterState {\n    using SafeCast for uint256;\n    using LibMemorySize for uint256;\n    using LibMemorySize for uint256[];\n    using LibMemorySize for bytes;\n    using LibUint256Array for uint256[];\n    using LibUint256Array for uint256;\n    using LibInterpreterState for StackPointer;\n    using LibStackPointer for uint256[];\n    using LibStackPointer for StackPointer;\n    using LibStackPointer for bytes;\n    using LibCast for uint256;\n    using LibCast for function(\n        InterpreterState memory,\n        SourceIndex,\n        StackPointer\n    ) view returns (StackPointer);\n    using LibCast for function(InterpreterState memory, Operand, StackPointer)\n        view\n        returns (StackPointer)[];\n    using LibConvert for uint256[];\n\n    /// Thin wrapper around hardhat's `console.log` that loops over any array\n    /// and logs each value delimited by `DEBUG_DELIMITER`.\n    /// @param array_ The array to debug.\n    function debugArray(uint256[] memory array_) internal view {\n        console.log(DEBUG_DELIMETER);\n        for (uint256 i_ = 0; i_ < array_.length; i_++) {\n            console.log(i_, array_[i_]);\n        }\n        console.log(DEBUG_DELIMETER);\n    }\n\n    /// Copies the stack to a new array then debugs it. Definitely NOT gas\n    /// efficient, but affords simple and effective debugging.\n    /// @param stackBottom_ Pointer to the bottom of the stack.\n    /// @param stackTop_ Pointer to the top of the stack.\n    function debugStack(\n        StackPointer stackBottom_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        uint256 length_ = stackBottom_.toIndex(stackTop_);\n        debugArray(\n            StackPointer.unwrap(stackTop_.down(length_)).copyToNewUint256Array(\n                length_\n            )\n        );\n        return stackTop_;\n    }\n\n    /// Console log various aspects of the Interpreter state. Gas intensive and\n    /// relies on hardhat console so not intended for production but great for\n    /// debugging expressions. MAY be exposed as an opcode so expression authors\n    /// can debug the expressions directly onchain.\n    /// @param state_ The interpreter state to debug the internals of.\n    /// @param stackTop_ Pointer to the current stack top.\n    /// @param debugStyle_ Enum variant defining what should be debugged from the\n    /// interpreter state.\n    function debug(\n        InterpreterState memory state_,\n        StackPointer stackTop_,\n        DebugStyle debugStyle_\n    ) internal view returns (StackPointer) {\n        if (debugStyle_ == DebugStyle.Source) {\n            for (uint256 i_ = 0; i_ < state_.compiledSources.length; i_++) {\n                console.logBytes(state_.compiledSources[i_]);\n            }\n        } else {\n            if (debugStyle_ == DebugStyle.Stack) {\n                state_.stackBottom.debugStack(stackTop_);\n            } else if (debugStyle_ == DebugStyle.Constant) {\n                debugArray(state_.constantsBottom.down().asUint256Array());\n            } else {\n                for (uint256 i_ = 0; i_ < state_.context.length; i_++) {\n                    debugArray(state_.context[i_]);\n                }\n            }\n        }\n        return stackTop_;\n    }\n\n    /// Efficiently serializes some `IInterpreterV1` state config into bytes that\n    /// can be deserialized to an `InterpreterState` without memory allocation or\n    /// copying of data on the return trip. This is achieved by mutating data in\n    /// place for both serialization and deserialization so it is much more gas\n    /// efficient than abi encode/decode but is NOT SAFE to use the `StateConfig`\n    /// after it has been serialized. Notably the index based opcodes in the\n    /// sources in `StateConfig` will be replaced by function pointer based\n    /// opcodes in place, so are no longer usable in a portable format.\n    /// @param config_ State config as per `IInterpreterV1`.\n    /// @param stackLength_ Stack length calculated by `IExpressionDeployerV1`\n    /// that will be used to allocate memory for the stack upon deserialization.\n    /// @param opcodeFunctionPointers_ As per `IInterpreterV1.functionPointers`,\n    /// bytes to be compiled into the final `InterpreterState.compiledSources`.\n    function serialize(\n        StateConfig memory config_,\n        uint256 stackLength_,\n        bytes memory opcodeFunctionPointers_\n    ) internal pure returns (bytes memory) {\n        unchecked {\n            uint256 size_ = 0;\n            size_ += stackLength_.size();\n            size_ += config_.constants.size();\n            for (uint256 i_ = 0; i_ < config_.sources.length; i_++) {\n                size_ += config_.sources[i_].size();\n            }\n            bytes memory serialized_ = new bytes(size_);\n            StackPointer cursor_ = serialized_.asStackPointer().up();\n\n            // Copy stack length.\n            cursor_ = cursor_.push(stackLength_);\n\n            // Then the constants.\n            cursor_ = cursor_.pushWithLength(config_.constants);\n\n            // Last the sources.\n            bytes memory source_;\n            for (uint256 i_ = 0; i_ < config_.sources.length; i_++) {\n                source_ = config_.sources[i_];\n                compile(source_, opcodeFunctionPointers_);\n                cursor_ = cursor_.unalignedPushWithLength(source_);\n            }\n            return serialized_;\n        }\n    }\n\n    /// Return trip from `serialize` but targets an `InterpreterState` NOT a\n    /// `StateConfig`. Allows serialized bytes to be written directly into\n    /// contract code on the other side of an expression address, then loaded\n    /// directly into an eval-able memory layout. The only allocation required\n    /// is to initialise the stack for eval, there is no copying in memory from\n    /// the serialized data as the deserialization merely calculates Solidity\n    /// compatible pointers to positions in the raw serialized data. This is much\n    /// more gas efficient than an equivalent abi.decode call which would involve\n    /// more processing, copying and allocating.\n    ///\n    /// Note that per-eval data such as namespace and context is NOT initialised\n    /// by the deserialization process and so will need to be handled by the\n    /// interpreter as part of `eval`.\n    ///\n    /// @param serialized_ Bytes previously serialized by\n    /// `LibInterpreterState.serialize`.\n    /// @return An eval-able interpreter state with initialized stack.\n    function deserialize(\n        bytes memory serialized_\n    ) internal pure returns (InterpreterState memory) {\n        unchecked {\n            InterpreterState memory state_;\n\n            // Context will probably be overridden by the caller according to the\n            // context scratch that we deserialize so best to just set it empty\n            // here.\n            state_.context = new uint256[][](0);\n\n            StackPointer cursor_ = serialized_.asStackPointer().up();\n            // The end of processing is the end of the state bytes.\n            StackPointer end_ = cursor_.upBytes(cursor_.peek());\n\n            // Read the stack length and build a stack.\n            cursor_ = cursor_.up();\n            uint256 stackLength_ = cursor_.peek();\n\n            // The stack is never stored in stack bytes so we allocate a new\n            // array for it with length as per the indexes and point the state\n            // at it.\n            uint256[] memory stack_ = new uint256[](stackLength_);\n            state_.stackBottom = stack_.asStackPointerUp();\n\n            // Reference the constants array and move cursor past it.\n            cursor_ = cursor_.up();\n            state_.constantsBottom = cursor_;\n            cursor_ = cursor_.up(cursor_.peek());\n\n            // Rebuild the sources array.\n            uint256 i_ = 0;\n            StackPointer lengthCursor_ = cursor_;\n            uint256 sourcesLength_ = 0;\n            while (\n                StackPointer.unwrap(lengthCursor_) < StackPointer.unwrap(end_)\n            ) {\n                lengthCursor_ = lengthCursor_\n                    .upBytes(lengthCursor_.peekUp())\n                    .up();\n                sourcesLength_++;\n            }\n            state_.compiledSources = new bytes[](sourcesLength_);\n            while (StackPointer.unwrap(cursor_) < StackPointer.unwrap(end_)) {\n                state_.compiledSources[i_] = cursor_.asBytes();\n                cursor_ = cursor_.upBytes(cursor_.peekUp()).up();\n                i_++;\n            }\n            return state_;\n        }\n    }\n\n    /// Given a source in opcodes compile to an equivalent source with real\n    /// function pointers for a given Interpreter contract. The \"compilation\"\n    /// involves simply replacing the opcode with the pointer at the index of\n    /// the opcode. i.e. opcode 4 will be replaced with `pointers_[4]`.\n    /// Relies heavily on the integrity checks ensuring opcodes used are not OOB\n    /// and that the pointers provided are valid and in the correct order. As the\n    /// expression deployer is typically handling compilation during\n    /// serialization, NOT the interpreter, the interpreter MUST guard against\n    /// the compilation being garbage or outright hostile during `eval` by\n    /// pointing to arbitrary internal functions of the interpreter.\n    /// @param source_ The input source as index based opcodes.\n    /// @param pointers_ The function pointers ordered by index to replace the\n    /// index based opcodes with.\n    function compile(\n        bytes memory source_,\n        bytes memory pointers_\n    ) internal pure {\n        assembly (\"memory-safe\") {\n            for {\n                let replaceMask_ := 0xFFFF\n                let preserveMask_ := not(replaceMask_)\n                let sourceLength_ := mload(source_)\n                let pointersBottom_ := add(pointers_, 2)\n                let cursor_ := add(source_, 2)\n                let end_ := add(source_, sourceLength_)\n            } lt(cursor_, end_) {\n                cursor_ := add(cursor_, 4)\n            } {\n                let data_ := mload(cursor_)\n                let pointer_ := and(\n                    replaceMask_,\n                    mload(\n                        add(pointersBottom_, mul(2, and(data_, replaceMask_)))\n                    )\n                )\n                mstore(cursor_, or(and(data_, preserveMask_), pointer_))\n            }\n        }\n    }\n\n    /// The main eval loop. Does as little as possible as it is an extremely hot\n    /// performance and critical security path. Loads opcode/operand pairs from\n    /// a precompiled source in the interpreter state and calls the function\n    /// that the opcode points to. This function is in turn responsible for\n    /// actually pushing/popping from the stack, etc. As `eval` receives the\n    /// source index and stack top alongside its state, it supports recursive\n    /// calls via. opcodes that can manage scoped substacks, etc. without `eval`\n    /// needing to house that complexity itself.\n    /// @param state_ The interpreter state to evaluate a source over.\n    /// @param sourceIndex_ The index of the source to evaluate. MAY be an\n    /// entrypoint or a nested call.\n    /// @param stackTop_ The current stack top, MUST be equal to the stack bottom\n    /// on the intepreter state if the current eval is for an entrypoint.\n    function eval(\n        InterpreterState memory state_,\n        SourceIndex sourceIndex_,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        unchecked {\n            uint256 cursor_;\n            uint256 end_;\n            assembly (\"memory-safe\") {\n                cursor_ := mload(\n                    add(\n                        mload(add(state_, 0xA0)),\n                        add(0x20, mul(0x20, sourceIndex_))\n                    )\n                )\n                end_ := add(cursor_, mload(cursor_))\n            }\n\n            // Loop until complete.\n            while (cursor_ < end_) {\n                function(InterpreterState memory, Operand, StackPointer)\n                    internal\n                    view\n                    returns (StackPointer) fn_;\n                Operand operand_;\n                cursor_ += 4;\n                {\n                    uint256 op_;\n                    assembly (\"memory-safe\") {\n                        op_ := mload(cursor_)\n                        operand_ := and(op_, 0xFFFF)\n                        fn_ := and(shr(16, op_), 0xFFFF)\n                    }\n                }\n                stackTop_ = fn_(state_, operand_, stackTop_);\n            }\n            return stackTop_;\n        }\n    }\n\n    /// Standard way to elevate a caller-provided state namespace to a universal\n    /// namespace that is disjoint from all other caller-provided namespaces.\n    /// Essentially just hashes the `msg.sender` into the state namespace as-is.\n    ///\n    /// This is deterministic such that the same combination of state namespace\n    /// and caller will produce the same fully qualified namespace, even across\n    /// multiple transactions/blocks.\n    ///\n    /// @param stateNamespace_ The state namespace as specified by the caller.\n    /// @return A fully qualified namespace that cannot collide with any other\n    /// state namespace specified by any other caller.\n    function qualifyNamespace(\n        StateNamespace stateNamespace_\n    ) internal view returns (FullyQualifiedNamespace) {\n        return\n            FullyQualifiedNamespace.wrap(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            msg.sender,\n                            StateNamespace.unwrap(stateNamespace_)\n                        )\n                    )\n                )\n            );\n    }\n}\n"
    },
    "contracts/interpreter/run/LibStackPointer.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"./IInterpreterV1.sol\";\nimport \"../../array/LibUint256Array.sol\";\nimport \"../../bytes/LibBytes.sol\";\n\n/// Thrown when the length of an array as the result of an applied function does\n/// not match expectations.\nerror UnexpectedResultLength(uint256 expectedLength, uint256 actualLength);\n\n/// Custom type to point to memory ostensibly in a stack.\ntype StackPointer is uint256;\n\n/// @title LibStackPointer\n/// @notice A `StackPointer` is just a pointer to some memory. Ostensibly it is\n/// pointing at a stack item in memory used by the `RainInterpreter` so that\n/// means it can move \"up\" and \"down\" (increment and decrement) by `uint256`\n/// (32 bytes) increments. Structurally a stack is a `uint256[]` but we can save\n/// a lot of gas vs. default Solidity handling of array indexes by using assembly\n/// to bypass runtime bounds checks on every read and write. Of course, this\n/// means we have to introduce some mechanism that gives us equivalent guarantees\n/// and we do, in the form of the `IExpressionDeployerV1` integrity check.\n///\n/// The pointer to the bottom of a stack points at the 0th item, NOT the length\n/// of the implied `uint256[]` and the top of a stack points AFTER the last item.\n/// e.g. consider a `uint256[]` in memory with values `3 A B C` and assume this\n/// starts at position `0` in memory, i.e. `0` points to value `3` for the\n/// array length. In this case the stack bottom would be\n/// `StackPointer.wrap(0x20)` (32 bytes above 0, past the length) and the stack\n/// top would be `StackPointer.wrap(0x80)` (96 bytes above the stack bottom).\n///\n/// Most of the functions in this library are equivalent to each other via\n/// composition, i.e. everything could be achieved with just `up`, `down`,\n/// `pop`, `push`, `peek`. The reason there is so much overloaded/duplicated\n/// logic is that the Solidity compiler seems to fail at inlining equivalent\n/// logic quite a lot. Perhaps once the IR compilation of Solidity is better\n/// supported by tooling etc. we could remove a lot of this duplication as the\n/// compiler itself would handle the optimisations.\nlibrary LibStackPointer {\n    using LibStackPointer for StackPointer;\n    using LibStackPointer for uint256[];\n    using LibStackPointer for bytes;\n    using LibUint256Array for uint256[];\n    using LibBytes for uint256;\n\n    /// Reads the value above the stack pointer. If the stack pointer is the\n    /// current stack top this is an out of bounds read! The caller MUST ensure\n    /// that this is not the case and that the stack pointer being read is within\n    /// the stack and not after it.\n    /// @param stackPointer_ Position to read past/above.\n    function peekUp(\n        StackPointer stackPointer_\n    ) internal pure returns (uint256) {\n        uint256 a_;\n        assembly (\"memory-safe\") {\n            a_ := mload(stackPointer_)\n        }\n        return a_;\n    }\n\n    /// Read the value immediately below the given stack pointer. Equivalent to\n    /// calling `pop` and discarding the `stackPointerAfter_` value, so may be\n    /// less gas than setting and discarding a value.\n    /// @param stackPointer_ The stack pointer to read below.\n    /// @return a_ The value that was read.\n    function peek(StackPointer stackPointer_) internal pure returns (uint256) {\n        uint256 a_;\n        assembly (\"memory-safe\") {\n            a_ := mload(sub(stackPointer_, 0x20))\n        }\n        return a_;\n    }\n\n    /// Reads 2 values below the given stack pointer.\n    /// The following statements are equivalent but A may use gas if the\n    /// compiler fails to inline some function calls.\n    /// A:\n    /// ```\n    /// (uint256 a_, uint256 b_) = stackPointer_.peek2();\n    /// ```\n    /// B:\n    /// ```\n    /// uint256 b_;\n    /// (stackPointer_, b_) = stackPointer_.pop();\n    /// uint256 a_ = stackPointer_.peek();\n    /// ```\n    /// @param stackPointer_ The stack top to peek below.\n    function peek2(\n        StackPointer stackPointer_\n    ) internal pure returns (uint256, uint256) {\n        uint256 a_;\n        uint256 b_;\n        assembly (\"memory-safe\") {\n            a_ := mload(sub(stackPointer_, 0x40))\n            b_ := mload(sub(stackPointer_, 0x20))\n        }\n        return (a_, b_);\n    }\n\n    /// Read the value immediately below the given stack pointer and return the\n    /// stack pointer that points to the value that was read alongside the value.\n    /// The following are equivalent but A may be cheaper if the compiler\n    /// fails to inline some function calls:\n    /// A:\n    /// ```\n    /// uint256 a_;\n    /// (stackPointer_, a_) = stackPointer_.pop();\n    /// ```\n    /// B:\n    /// ```\n    /// stackPointer_ = stackPointer_.down();\n    /// uint256 a_ = stackPointer_.peekUp();\n    /// ```\n    /// @param stackPointer_ The stack pointer to read below.\n    /// @return stackPointerAfter_ Points to the value that was read.\n    /// @return a_ The value that was read.\n    function pop(\n        StackPointer stackPointer_\n    ) internal pure returns (StackPointer, uint256) {\n        StackPointer stackPointerAfter_;\n        uint256 a_;\n        assembly (\"memory-safe\") {\n            stackPointerAfter_ := sub(stackPointer_, 0x20)\n            a_ := mload(stackPointerAfter_)\n        }\n        return (stackPointerAfter_, a_);\n    }\n\n    /// Given two stack pointers that bound a stack build an array of all values\n    /// above the given sentinel value. The sentinel will be _replaced_ by the\n    /// length of the array, allowing for efficient construction of a valid\n    /// `uint256[]` without additional allocation or copying in memory. As the\n    /// returned value is a `uint256[]` it can be treated as a substack and the\n    /// same (or different) sentinel can be consumed many times to build many\n    /// arrays from the main stack.\n    ///\n    /// As the sentinel is mutated in place into a length it is NOT safe to call\n    /// this in a context where the stack is expected to be immutable.\n    ///\n    /// The sentinel MUST be chosen to have a negligible chance of colliding with\n    /// a real value in the array, otherwise an intended array item will be\n    /// interpreted as a sentinel and the array will be split into two slices.\n    ///\n    /// If the sentinel is absent in the stack this WILL REVERT. The intent is\n    /// to represent dynamic length arrays without forcing expression authors to\n    /// calculate lengths on the stack. If the expression author wants to model\n    /// an empty/optional/absent value they MAY provided a sentinel for a zero\n    /// length array and the calling contract SHOULD handle this.\n    ///\n    /// @param stackTop_ Pointer to the top of the stack.\n    /// @param stackBottom_ Pointer to the bottom of the stack.\n    /// @param sentinel_ The value to expect as the sentinel. MUST be present in\n    /// the stack or `consumeSentinel` will revert. MUST NOT collide with valid\n    /// stack items (or be cryptographically improbable to do so).\n    /// @param stepSize_ Number of items to move over in the array per loop\n    /// iteration. If the array has a known multiple of items it can be more\n    /// efficient to find a sentinel moving in N-item increments rather than\n    /// reading every item individually.\n    function consumeSentinel(\n        StackPointer stackTop_,\n        StackPointer stackBottom_,\n        uint256 sentinel_,\n        uint256 stepSize_\n    ) internal pure returns (StackPointer, uint256[] memory) {\n        uint256[] memory array_;\n        assembly (\"memory-safe\") {\n            // Underflow is not allowed and pointing at position 0 in memory is\n            // corrupt behaviour anyway.\n            if iszero(stackBottom_) {\n                revert(0, 0)\n            }\n            let sentinelLocation_ := 0\n            let length_ := 0\n            let step_ := mul(stepSize_, 0x20)\n            for {\n                stackTop_ := sub(stackTop_, 0x20)\n                let end_ := sub(stackBottom_, 0x20)\n            } gt(stackTop_, end_) {\n                stackTop_ := sub(stackTop_, step_)\n                length_ := add(length_, stepSize_)\n            } {\n                if eq(sentinel_, mload(stackTop_)) {\n                    sentinelLocation_ := stackTop_\n                    break\n                }\n            }\n            // Sentinel MUST exist in the stack if consumer expects it to there.\n            if iszero(sentinelLocation_) {\n                revert(0, 0)\n            }\n            mstore(sentinelLocation_, length_)\n            array_ := sentinelLocation_\n        }\n        return (stackTop_, array_);\n    }\n\n    /// Abstraction over `consumeSentinel` to build an array of solidity structs.\n    /// Solidity won't exactly allow this due to its type system not supporting\n    /// generics, so instead we return an array of references to struct data that\n    /// can be assigned/cast to an array of structs easily with assembly. This\n    /// is NOT intended to be a general purpose workhorse for this task, only\n    /// structs of pointers to `uint256[]` values are supported.\n    ///\n    /// ```\n    /// struct Foo {\n    ///   uint256[] a;\n    ///   uint256[] b;\n    /// }\n    ///\n    /// (StackPointer stackPointer_, uint256[] memory refs_) = consumeStructs(...);\n    /// Foo[] memory foo_;\n    /// assembly (\"memory-safe\") {\n    ///   mstore(foo_, refs_)\n    /// }\n    /// ```\n    ///\n    /// @param stackTop_ The top of the stack as per `consumeSentinel`.\n    /// @param stackBottom_ The bottom of the stack as per `consumeSentinel`.\n    /// @param sentinel_ The sentinel as per `consumeSentinel`.\n    /// @param structSize_ The number of `uint256[]` fields on the struct.\n    function consumeStructs(\n        StackPointer stackTop_,\n        StackPointer stackBottom_,\n        uint256 sentinel_,\n        uint256 structSize_\n    ) internal pure returns (StackPointer, uint256[] memory) {\n        (StackPointer stackTopAfter_, uint256[] memory tempArray_) = stackTop_\n            .consumeSentinel(stackBottom_, sentinel_, structSize_);\n        uint256 structsLength_ = tempArray_.length / structSize_;\n        uint256[] memory refs_ = new uint256[](structsLength_);\n        assembly (\"memory-safe\") {\n            for {\n                let refCursor_ := add(refs_, 0x20)\n                let refEnd_ := add(refCursor_, mul(structsLength_, 0x20))\n                let tempCursor_ := add(tempArray_, 0x20)\n                let tempStepSize_ := mul(structSize_, 0x20)\n            } lt(refCursor_, refEnd_) {\n                refCursor_ := add(refCursor_, 0x20)\n                tempCursor_ := add(tempCursor_, tempStepSize_)\n            } {\n                mstore(refCursor_, tempCursor_)\n            }\n        }\n        return (stackTopAfter_, refs_);\n    }\n\n    /// Write a value at the stack pointer. Typically only useful as intermediate\n    /// logic within some opcode etc. as the value will be treated as an out of\n    /// bounds for future reads unless the stack top after the opcode logic is\n    /// above the pointer.\n    /// @param stackPointer_ The stack top to write the value at.\n    /// @param a_ The value to write.\n    function set(StackPointer stackPointer_, uint256 a_) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(stackPointer_, a_)\n        }\n    }\n\n    /// Store a `uint256` at the stack pointer and return the stack pointer\n    /// above the written value. The following statements are equivalent in\n    /// functionality but A may be less gas if the compiler fails to inline\n    /// some function calls.\n    /// A:\n    /// ```\n    /// stackPointer_ = stackPointer_.push(a_);\n    /// ```\n    /// B:\n    /// ```\n    /// stackPointer_.set(a_);\n    /// stackPointer_ = stackPointer_.up();\n    /// ```\n    /// @param stackPointer_ The stack pointer to write at.\n    /// @param a_ The value to write.\n    /// @return The stack pointer above where `a_` was written to.\n    function push(\n        StackPointer stackPointer_,\n        uint256 a_\n    ) internal pure returns (StackPointer) {\n        assembly (\"memory-safe\") {\n            mstore(stackPointer_, a_)\n            stackPointer_ := add(stackPointer_, 0x20)\n        }\n        return stackPointer_;\n    }\n\n    /// Store a `uint256[]` at the stack pointer and return the stack pointer\n    /// above the written values. The length of the array is NOT written to the\n    /// stack, ONLY the array values are copied to the stack. The following\n    /// statements are equivalent in functionality but A may be less gas if the\n    /// compiler fails to inline some function calls.\n    /// A:\n    /// ```\n    /// stackPointer_ = stackPointer_.push(array_);\n    /// ```\n    /// B:\n    /// ```\n    /// unchecked {\n    ///   for (uint256 i_ = 0; i_ < array_.length; i_++) {\n    ///     stackPointer_ = stackPointer_.push(array_[i_]);\n    ///   }\n    /// }\n    /// ```\n    /// @param stackPointer_ The stack pointer to write at.\n    /// @param array_ The array of values to write.\n    /// @return The stack pointer above the array.\n    function push(\n        StackPointer stackPointer_,\n        uint256[] memory array_\n    ) internal pure returns (StackPointer) {\n        array_.unsafeCopyValuesTo(StackPointer.unwrap(stackPointer_));\n        return stackPointer_.up(array_.length);\n    }\n\n    /// Store a `uint256[]` at the stack pointer and return the stack pointer\n    /// above the written values. The length of the array IS written to the\n    /// stack.\n    /// @param stackPointer_ The stack pointer to write at.\n    /// @param array_ The array of values and length to write.\n    /// @return The stack pointer above the array.\n    function pushWithLength(\n        StackPointer stackPointer_,\n        uint256[] memory array_\n    ) internal pure returns (StackPointer) {\n        return stackPointer_.push(array_.length).push(array_);\n    }\n\n    /// Store `bytes` at the stack pointer and return the stack pointer above\n    /// the written bytes. The length of the bytes is NOT written to the stack,\n    /// ONLY the bytes are written. As `bytes` may be of arbitrary length, i.e.\n    /// it MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\n    /// ensure that this is safe in context of subsequent reads and writes.\n    /// @param stackPointer_ The stack top to write at.\n    /// @param bytes_ The bytes to write at the stack top.\n    /// @return The stack top above the written bytes.\n    function unalignedPush(\n        StackPointer stackPointer_,\n        bytes memory bytes_\n    ) internal pure returns (StackPointer) {\n        StackPointer.unwrap(bytes_.asStackPointer().up()).unsafeCopyBytesTo(\n            StackPointer.unwrap(stackPointer_),\n            bytes_.length\n        );\n        return stackPointer_.upBytes(bytes_.length);\n    }\n\n    /// Store `bytes` at the stack pointer and return the stack top above the\n    /// written bytes. The length of the bytes IS written to the stack in\n    /// addition to the bytes. As `bytes` may be of arbitrary length, i.e. it\n    /// MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\n    /// ensure that this is safe in context of subsequent reads and writes.\n    /// @param stackPointer_ The stack pointer to write at.\n    /// @param bytes_ The bytes to write with their length at the stack pointer.\n    /// @return The stack pointer above the written bytes.\n    function unalignedPushWithLength(\n        StackPointer stackPointer_,\n        bytes memory bytes_\n    ) internal pure returns (StackPointer) {\n        return stackPointer_.push(bytes_.length).unalignedPush(bytes_);\n    }\n\n    /// Store 8x `uint256` at the stack pointer and return the stack pointer\n    /// above the written value. The following statements are equivalent in\n    /// functionality but A may be cheaper if the compiler fails to\n    /// inline some function calls.\n    /// A:\n    /// ```\n    /// stackPointer_ = stackPointer_.push(a_, b_, c_, d_, e_, f_, g_, h_);\n    /// ```\n    /// B:\n    /// ```\n    /// stackPointer_ = stackPointer_\n    ///   .push(a_)\n    ///   .push(b_)\n    ///   .push(c_)\n    ///   .push(d_)\n    ///   .push(e_)\n    ///   .push(f_)\n    ///   .push(g_)\n    ///   .push(h_);\n    /// @param stackPointer_ The stack pointer to write at.\n    /// @param a_ The first value to write.\n    /// @param b_ The second value to write.\n    /// @param c_ The third value to write.\n    /// @param d_ The fourth value to write.\n    /// @param e_ The fifth value to write.\n    /// @param f_ The sixth value to write.\n    /// @param g_ The seventh value to write.\n    /// @param h_ The eighth value to write.\n    /// @return The stack pointer above where `h_` was written.\n    function push(\n        StackPointer stackPointer_,\n        uint256 a_,\n        uint256 b_,\n        uint256 c_,\n        uint256 d_,\n        uint256 e_,\n        uint256 f_,\n        uint256 g_,\n        uint256 h_\n    ) internal pure returns (StackPointer) {\n        assembly (\"memory-safe\") {\n            mstore(stackPointer_, a_)\n            mstore(add(stackPointer_, 0x20), b_)\n            mstore(add(stackPointer_, 0x40), c_)\n            mstore(add(stackPointer_, 0x60), d_)\n            mstore(add(stackPointer_, 0x80), e_)\n            mstore(add(stackPointer_, 0xA0), f_)\n            mstore(add(stackPointer_, 0xC0), g_)\n            mstore(add(stackPointer_, 0xE0), h_)\n            stackPointer_ := add(stackPointer_, 0x100)\n        }\n        return stackPointer_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackPointer stackTop_,\n        function(uint256) internal view returns (uint256) fn_\n    ) internal view returns (StackPointer) {\n        uint256 a_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n        }\n        a_ = fn_(a_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackPointer stackTop_,\n        function(Operand, uint256) internal view returns (uint256) fn_,\n        Operand operand_\n    ) internal view returns (StackPointer) {\n        uint256 a_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n        }\n        a_ = fn_(operand_, a_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackPointer stackTop_,\n        function(uint256, uint256) internal view returns (uint256) fn_\n    ) internal view returns (StackPointer) {\n        uint256 a_;\n        uint256 b_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            stackTop_ := sub(stackTop_, 0x20)\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n            b_ := mload(stackTop_)\n        }\n        a_ = fn_(a_, b_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    /// Reduce a function N times, reading and writing inputs and the accumulated\n    /// result on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @param n_ The number of times to apply fn_ to accumulate a final result.\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\n    function applyFnN(\n        StackPointer stackTop_,\n        function(uint256, uint256) internal view returns (uint256) fn_,\n        uint256 n_\n    ) internal view returns (StackPointer) {\n        unchecked {\n            uint256 bottom_;\n            uint256 cursor_;\n            uint256 a_;\n            uint256 b_;\n            StackPointer stackTopAfter_;\n            assembly (\"memory-safe\") {\n                bottom_ := sub(stackTop_, mul(n_, 0x20))\n                a_ := mload(bottom_)\n                stackTopAfter_ := add(bottom_, 0x20)\n                cursor_ := stackTopAfter_\n            }\n            while (cursor_ < StackPointer.unwrap(stackTop_)) {\n                assembly (\"memory-safe\") {\n                    b_ := mload(cursor_)\n                }\n                a_ = fn_(a_, b_);\n                cursor_ += 0x20;\n            }\n            assembly (\"memory-safe\") {\n                mstore(bottom_, a_)\n            }\n            return stackTopAfter_;\n        }\n    }\n\n    /// Reduce a function N times, reading and writing inputs and the accumulated\n    /// result on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @param n_ The number of times to apply fn_ to accumulate a final result.\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\n    function applyFnN(\n        StackPointer stackTop_,\n        function(uint256) internal view fn_,\n        uint256 n_\n    ) internal view returns (StackPointer) {\n        uint256 cursor_;\n        uint256 a_;\n        StackPointer stackTopAfter_;\n        assembly (\"memory-safe\") {\n            stackTopAfter_ := sub(stackTop_, mul(n_, 0x20))\n            cursor_ := stackTopAfter_\n        }\n        while (cursor_ < StackPointer.unwrap(stackTop_)) {\n            assembly (\"memory-safe\") {\n                a_ := mload(cursor_)\n                cursor_ := add(cursor_, 0x20)\n            }\n            fn_(a_);\n        }\n        return stackTopAfter_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackPointer stackTop_,\n        function(uint256, uint256, uint256) internal view returns (uint256) fn_\n    ) internal view returns (StackPointer) {\n        uint256 a_;\n        uint256 b_;\n        uint256 c_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            stackTop_ := sub(stackTop_, 0x40)\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n            b_ := mload(stackTop_)\n            c_ := mload(add(stackTop_, 0x20))\n        }\n        a_ = fn_(a_, b_, c_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackPointer stackTop_,\n        function(uint256, uint256, uint256, uint256)\n            internal\n            view\n            returns (uint256) fn_\n    ) internal view returns (StackPointer) {\n        uint256 a_;\n        uint256 b_;\n        uint256 c_;\n        uint256 d_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            stackTop_ := sub(stackTop_, 0x60)\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n            b_ := mload(stackTop_)\n            c_ := mload(add(stackTop_, 0x20))\n            d_ := mload(add(stackTop_, 0x40))\n        }\n        a_ = fn_(a_, b_, c_, d_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @param operand_ Operand is passed from the source instead of the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackPointer stackTop_,\n        function(Operand, uint256, uint256) internal view returns (uint256) fn_,\n        Operand operand_\n    ) internal view returns (StackPointer) {\n        uint256 a_;\n        uint256 b_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            stackTop_ := sub(stackTop_, 0x20)\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n            b_ := mload(stackTop_)\n        }\n        a_ = fn_(operand_, a_, b_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @param length_ The length of the array to pass to fn_ from the stack.\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\n    function applyFn(\n        StackPointer stackTop_,\n        function(uint256[] memory) internal view returns (uint256) fn_,\n        uint256 length_\n    ) internal view returns (StackPointer) {\n        (uint256 a_, uint256[] memory tail_) = stackTop_.list(length_);\n        uint256 b_ = fn_(tail_);\n        return tail_.asStackPointer().push(a_).push(b_);\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @param length_ The length of the array to pass to fn_ from the stack.\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\n    function applyFn(\n        StackPointer stackTop_,\n        function(uint256, uint256, uint256[] memory)\n            internal\n            view\n            returns (uint256) fn_,\n        uint256 length_\n    ) internal view returns (StackPointer) {\n        (uint256 b_, uint256[] memory tail_) = stackTop_.list(length_);\n        StackPointer stackTopAfter_ = tail_.asStackPointer();\n        (StackPointer location_, uint256 a_) = stackTopAfter_.pop();\n        location_.set(fn_(a_, b_, tail_));\n        return stackTopAfter_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @param length_ The length of the array to pass to fn_ from the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackPointer stackTop_,\n        function(uint256, uint256, uint256, uint256[] memory)\n            internal\n            view\n            returns (uint256) fn_,\n        uint256 length_\n    ) internal view returns (StackPointer) {\n        (uint256 c_, uint256[] memory tail_) = stackTop_.list(length_);\n        (StackPointer stackTopAfter_, uint256 b_) = tail_\n            .asStackPointer()\n            .pop();\n        uint256 a_ = stackTopAfter_.peek();\n        stackTopAfter_.down().set(fn_(a_, b_, c_, tail_));\n        return stackTopAfter_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @param length_ The length of the arrays to pass to fn_ from the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackPointer stackTop_,\n        function(uint256, uint256[] memory, uint256[] memory)\n            internal\n            view\n            returns (uint256[] memory) fn_,\n        uint256 length_\n    ) internal view returns (StackPointer) {\n        StackPointer csStart_ = stackTop_.down(length_);\n        uint256[] memory cs_ = LibUint256Array.copyToNewUint256Array(\n            StackPointer.unwrap(csStart_),\n            length_\n        );\n        (uint256 a_, uint256[] memory bs_) = csStart_.list(length_);\n\n        uint256[] memory results_ = fn_(a_, bs_, cs_);\n        if (results_.length != length_) {\n            revert UnexpectedResultLength(length_, results_.length);\n        }\n\n        StackPointer bottom_ = bs_.asStackPointer();\n        LibUint256Array.unsafeCopyValuesTo(\n            results_,\n            StackPointer.unwrap(bottom_)\n        );\n        return bottom_.up(length_);\n    }\n\n    /// Returns `length_` values from the stack as an array without allocating\n    /// new memory. As arrays always start with their length, this requires\n    /// writing the length value to the stack below the array values. The value\n    /// that is overwritten in the process is also returned so that data is not\n    /// lost. For example, imagine a stack `[ A B C D ]` and we list 2 values.\n    /// This will write the stack to look like `[ A 2 C D ]` and return both `B`\n    /// and a pointer to `2` represented as a `uint256[]`.\n    /// The returned array is ONLY valid for as long as the stack DOES NOT move\n    /// back into its memory. As soon as the stack moves up again and writes into\n    /// the array it will be corrupt. The caller MUST ensure that it does not\n    /// read from the returned array after it has been corrupted by subsequent\n    /// stack writes.\n    /// @param stackPointer_ The stack pointer to read the values below into an\n    /// array.\n    /// @param length_ The number of values to include in the returned array.\n    /// @return head_ The value that was overwritten with the length.\n    /// @return tail_ The array constructed from the stack memory.\n    function list(\n        StackPointer stackPointer_,\n        uint256 length_\n    ) internal pure returns (uint256, uint256[] memory) {\n        uint256 head_;\n        uint256[] memory tail_;\n        assembly (\"memory-safe\") {\n            tail_ := sub(stackPointer_, add(0x20, mul(length_, 0x20)))\n            head_ := mload(tail_)\n            mstore(tail_, length_)\n        }\n        return (head_, tail_);\n    }\n\n    /// Cast a `uint256[]` array to a stack pointer. The stack pointer will\n    /// point to the length of the array, NOT its first value.\n    /// @param array_ The array to cast to a stack pointer.\n    /// @return stackPointer_ The stack pointer that points to the length of the\n    /// array.\n    function asStackPointer(\n        uint256[] memory array_\n    ) internal pure returns (StackPointer) {\n        StackPointer stackPointer_;\n        assembly (\"memory-safe\") {\n            stackPointer_ := array_\n        }\n        return stackPointer_;\n    }\n\n    /// Cast a stack pointer to an array. The value immediately above the stack\n    /// pointer will be treated as the length of the array, so the proceeding\n    /// length values will be the items of the array. The caller MUST ensure the\n    /// values above the stack position constitute a valid array. The returned\n    /// array will be corrupt if/when the stack subsequently moves into it and\n    /// writes to those memory locations. The caller MUST ensure that it does\n    /// NOT read from the returned array after the stack writes over it.\n    /// @param stackPointer_ The stack pointer that will be cast to an array.\n    /// @return array_ The array above the stack pointer.\n    function asUint256Array(\n        StackPointer stackPointer_\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory array_;\n        assembly (\"memory-safe\") {\n            array_ := stackPointer_\n        }\n        return array_;\n    }\n\n    /// Cast a stack position to bytes. The value immediately above the stack\n    /// position will be treated as the length of the `bytes`, so the proceeding\n    /// length bytes will be the data of the `bytes`. The caller MUST ensure the\n    /// length and bytes above the stack top constitute valid `bytes` data. The\n    /// returned `bytes` will be corrupt if/when the stack subsequently moves\n    /// into it and writes to those memory locations. The caller MUST ensure\n    // that it does NOT read from the returned bytes after the stack writes over\n    /// it.\n    /// @param stackPointer_ The stack pointer that will be cast to bytes.\n    /// @return bytes_ The bytes above the stack top.\n    function asBytes(\n        StackPointer stackPointer_\n    ) internal pure returns (bytes memory) {\n        bytes memory bytes_;\n        assembly (\"memory-safe\") {\n            bytes_ := stackPointer_\n        }\n        return bytes_;\n    }\n\n    /// Cast a `uint256[]` array to a stack pointer after its length. The stack\n    /// pointer will point to the first item of the array, NOT its length.\n    /// @param array_ The array to cast to a stack pointer.\n    /// @return stackPointer_ The stack pointer that points to the first item of\n    /// the array.\n    function asStackPointerUp(\n        uint256[] memory array_\n    ) internal pure returns (StackPointer) {\n        StackPointer stackPointer_;\n        assembly (\"memory-safe\") {\n            stackPointer_ := add(array_, 0x20)\n        }\n        return stackPointer_;\n    }\n\n    /// Cast a `uint256[]` array to a stack pointer after its items. The stack\n    /// pointer will point after the last item of the array. It is out of bounds\n    /// to read above the returned pointer. This can be interpreted as the stack\n    /// top assuming the entire given array is a valid stack.\n    /// @param array_ The array to cast to a stack pointer.\n    /// @return stackPointer_ The stack pointer that points after the last item\n    /// of the array.\n    function asStackPointerAfter(\n        uint256[] memory array_\n    ) internal pure returns (StackPointer) {\n        StackPointer stackPointer_;\n        assembly (\"memory-safe\") {\n            stackPointer_ := add(array_, add(0x20, mul(mload(array_), 0x20)))\n        }\n        return stackPointer_;\n    }\n\n    /// Cast `bytes` to a stack pointer. The stack pointer will point to the\n    /// length of the `bytes`, NOT the first byte.\n    /// @param bytes_ The `bytes` to cast to a stack pointer.\n    /// @return stackPointer_ The stack top that points to the length of the\n    /// bytes.\n    function asStackPointer(\n        bytes memory bytes_\n    ) internal pure returns (StackPointer) {\n        StackPointer stackPointer_;\n        assembly (\"memory-safe\") {\n            stackPointer_ := bytes_\n        }\n        return stackPointer_;\n    }\n\n    /// Returns the stack pointer 32 bytes above/past the given stack pointer.\n    /// @param stackPointer_ The stack pointer at the starting position.\n    /// @return The stack pointer 32 bytes above the input stack pointer.\n    function up(\n        StackPointer stackPointer_\n    ) internal pure returns (StackPointer) {\n        unchecked {\n            return StackPointer.wrap(StackPointer.unwrap(stackPointer_) + 0x20);\n        }\n    }\n\n    /// Returns the stack pointer `n_ * 32` bytes above/past the given stack\n    /// pointer.\n    /// @param stackPointer_ The stack pointer at the starting position.\n    /// @param n_ The multiplier on the stack movement. MAY be zero.\n    /// @return The stack pointer `n_ * 32` bytes above/past the input stack\n    /// pointer.\n    function up(\n        StackPointer stackPointer_,\n        uint256 n_\n    ) internal pure returns (StackPointer) {\n        unchecked {\n            return\n                StackPointer.wrap(\n                    StackPointer.unwrap(stackPointer_) + 0x20 * n_\n                );\n        }\n    }\n\n    /// Returns the stack pointer `n_` bytes above/past the given stack pointer.\n    /// The returned stack pointer MAY NOT be aligned with the given stack\n    /// pointer for subsequent 32 byte reads and writes. The caller MUST ensure\n    /// that it is safe to read and write data relative to the returned stack\n    /// pointer.\n    /// @param stackPointer_ The stack pointer at the starting position.\n    /// @param n_ The number of bytes to move.\n    /// @return The stack pointer `n_` bytes above/past the given stack pointer.\n    function upBytes(\n        StackPointer stackPointer_,\n        uint256 n_\n    ) internal pure returns (StackPointer) {\n        unchecked {\n            return StackPointer.wrap(StackPointer.unwrap(stackPointer_) + n_);\n        }\n    }\n\n    /// Returns the stack pointer 32 bytes below/before the given stack pointer.\n    /// @param stackPointer_ The stack pointer at the starting position.\n    /// @return The stack pointer 32 bytes below/before the given stack pointer.\n    function down(\n        StackPointer stackPointer_\n    ) internal pure returns (StackPointer) {\n        unchecked {\n            return StackPointer.wrap(StackPointer.unwrap(stackPointer_) - 0x20);\n        }\n    }\n\n    /// Returns the stack pointer `n_ * 32` bytes below/before the given stack\n    /// pointer.\n    /// @param stackPointer_ The stack pointer at the starting position.\n    /// @param n_ The multiplier on the movement.\n    /// @return The stack pointer `n_ * 32` bytes below/before the given stack\n    /// pointer.\n    function down(\n        StackPointer stackPointer_,\n        uint256 n_\n    ) internal pure returns (StackPointer) {\n        unchecked {\n            return\n                StackPointer.wrap(\n                    StackPointer.unwrap(stackPointer_) - 0x20 * n_\n                );\n        }\n    }\n\n    /// Convert two stack pointer values to a single stack index. A stack index\n    /// is the distance in 32 byte increments between two stack pointers. The\n    /// calculations assumes the two stack pointers are aligned. The caller MUST\n    /// ensure the alignment of both values. The calculation is unchecked and MAY\n    /// underflow. The caller MUST ensure that the stack top is always above the\n    /// stack bottom.\n    /// @param stackBottom_ The lower of the two values.\n    /// @param stackTop_ The higher of the two values.\n    /// @return The stack index as 32 byte distance between the top and bottom.\n    function toIndex(\n        StackPointer stackBottom_,\n        StackPointer stackTop_\n    ) internal pure returns (uint256) {\n        unchecked {\n            return\n                (StackPointer.unwrap(stackTop_) -\n                    StackPointer.unwrap(stackBottom_)) / 0x20;\n        }\n    }\n}\n"
    },
    "contracts/interpreter/run/LibStackTop.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"./IInterpreterV1.sol\";\nimport \"../../array/LibUint256Array.sol\";\nimport \"../../bytes/LibBytes.sol\";\n\n/// Custom type to point to memory ostensibly in a stack.\ntype StackTop is uint256;\n\n/// @title LibStackTop\n/// @notice A `StackTop` is just a pointer to some memory. Ostensibly it is the\n/// top of some stack used by the `RainInterpreter` so that means it can move \"up\" and\n/// \"down\" (increment and decrement) by `uint256` (32 bytes) increments. In\n/// general we're abusing that concept a bit to extend to things like the bottom\n/// of a stack or a hypothetical maximum stack or even treating an arbitrary\n/// `uint256[]` array as \"a stack\". In the future it's likely this lib and\n/// concept will be renamed to reflect that it is used much more generally than\n/// simply the top of some stack.\n/// All the functions in `LibStackTop` operate on memory to read/write what is\n/// referenced but the pointers and values themselves are typically input/output\n/// of the functions. I.e. the stack top itself is not being mutated in-place,\n/// typically the caller would have both the input stack top and the output\n/// stack top in scope after calling library functions.\n/// Most of the functions in this library are equivalent to each other via\n/// composition, i.e. everything could be achieved with just `up`, `down`,\n/// `pop`, `push`, `peek`. The reason there is so much duplication of logic is\n/// that the Solidity compiler seems to fail at inlining equivalent logic quite\n/// a lot sadly. There appears to be effort upstream towards improving the\n/// function inlining by the optimizer so we should expect a lot of this library\n/// to become redundant or even counterproductive in the future.\nlibrary LibStackTop {\n    using LibStackTop for StackTop;\n    using LibStackTop for uint256[];\n    using LibStackTop for bytes;\n    using LibUint256Array for uint256[];\n    using LibBytes for uint256;\n\n    /// Reads the value above the stack top. If the stack top is the current\n    /// true stack top this is an out of bounds read. This is only useful if\n    /// the stack was first moved down and the value it moved past needs to be\n    /// read as part of the current operation.\n    /// @param stackTop_ Position to read past/above.\n    function peekUp(StackTop stackTop_) internal pure returns (uint256 a_) {\n        assembly (\"memory-safe\") {\n            a_ := mload(stackTop_)\n        }\n    }\n\n    /// Read the value immediately below the given stack top. Equivalent to\n    /// calling `pop` and discarding the `stackTopAfter_` value, so may be\n    /// less gas than setting and discarding a value.\n    /// @param stackTop_ The stack top to read below.\n    /// @return a_ The value that was read.\n    function peek(StackTop stackTop_) internal pure returns (uint256 a_) {\n        assembly (\"memory-safe\") {\n            a_ := mload(sub(stackTop_, 0x20))\n        }\n    }\n\n    /// Reads 2 values below the given stack top.\n    /// The following statements are equivalent but A may use gas if the\n    /// compiler fails to inline some function calls.\n    /// A:\n    /// ```\n    /// (uint a_, uint b_) = stackTop_.peek2();\n    /// ```\n    /// B:\n    /// ```\n    /// uint b_;\n    /// (stackTop_, b_) = stackTop_.pop();\n    /// uint a_ = stackTop_.peek();\n    /// ```\n    /// @param stackTop_ The stack top to peek below.\n    function peek2(\n        StackTop stackTop_\n    ) internal pure returns (uint256 a_, uint256 b_) {\n        assembly (\"memory-safe\") {\n            a_ := mload(sub(stackTop_, 0x40))\n            b_ := mload(sub(stackTop_, 0x20))\n        }\n    }\n\n    /// Read the value immediately below the given stack top and return the\n    /// stack top that points to the value that was read alongside the value.\n    /// The following are equivalent but A may be cheaper if the compiler\n    /// fails to inline some function calls:\n    /// A:\n    /// ```\n    /// uint a_;\n    /// (stackTop_, a_) = stackTop_.pop();\n    /// ```\n    /// B:\n    /// ```\n    /// stackTop_ = stackTop_.down();\n    /// uint a_ = stackTop_.peekUp();\n    /// ```\n    /// @param stackTop_ The stack top to read below.\n    /// @return stackTopAfter_ The stack top that points to the value that was\n    /// read.\n    /// @return a_ The value that was read.\n    function pop(\n        StackTop stackTop_\n    ) internal pure returns (StackTop stackTopAfter_, uint256 a_) {\n        assembly (\"memory-safe\") {\n            stackTopAfter_ := sub(stackTop_, 0x20)\n            a_ := mload(stackTopAfter_)\n        }\n    }\n\n    function consumeSentinel(\n        StackTop stackTop_,\n        StackTop stackBottom_,\n        uint256 sentinel_,\n        uint256 stepSize_\n    ) internal pure returns (StackTop, uint256[] memory) {\n        uint256[] memory array_;\n        assembly (\"memory-safe\") {\n            // Underflow is not allowed and pointing at position 0 in memory is\n            // corrupt behaviour anyway.\n            if iszero(stackBottom_) {\n                revert(0, 0)\n            }\n            let sentinelLocation_ := 0\n            let length_ := 0\n            let step_ := mul(stepSize_, 0x20)\n            for {\n                stackTop_ := sub(stackTop_, 0x20)\n                let end_ := sub(stackBottom_, 0x20)\n            } gt(stackTop_, end_) {\n                stackTop_ := sub(stackTop_, step_)\n                length_ := add(length_, stepSize_)\n            } {\n                if eq(sentinel_, mload(stackTop_)) {\n                    sentinelLocation_ := stackTop_\n                    break\n                }\n            }\n            // Sentinel MUST exist in the stack if consumer expects it to there.\n            if iszero(sentinelLocation_) {\n                revert(0, 0)\n            }\n            mstore(sentinelLocation_, length_)\n            array_ := sentinelLocation_\n        }\n        return (stackTop_, array_);\n    }\n\n    function consumeStructs(\n        StackTop stackTop_,\n        StackTop stackBottom_,\n        uint256 sentinel_,\n        uint256 structSize_\n    ) internal pure returns (StackTop, uint256[] memory) {\n        uint256[] memory tempArray_;\n        (stackTop_, tempArray_) = stackTop_.consumeSentinel(\n            stackBottom_,\n            sentinel_,\n            structSize_\n        );\n        uint256 structsLength_ = tempArray_.length / structSize_;\n        uint256[] memory refs_ = new uint256[](structsLength_);\n        assembly (\"memory-safe\") {\n            for {\n                let refCursor_ := add(refs_, 0x20)\n                let refEnd_ := add(refCursor_, mul(structsLength_, 0x20))\n                let tempCursor_ := add(tempArray_, 0x20)\n                let tempStepSize_ := mul(structSize_, 0x20)\n            } lt(refCursor_, refEnd_) {\n                refCursor_ := add(refCursor_, 0x20)\n                tempCursor_ := add(tempCursor_, tempStepSize_)\n            } {\n                mstore(refCursor_, tempCursor_)\n            }\n        }\n        return (stackTop_, refs_);\n    }\n\n    /// Write a value at the stack top location. Typically not useful if the\n    /// given stack top is not subsequently moved past the written value , or\n    /// if the given stack top is actually located somewhere below the \"true\"\n    /// stack top.\n    /// @param stackTop_ The stack top to write the value at.\n    /// @param a_ The value to write.\n    function set(StackTop stackTop_, uint256 a_) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(stackTop_, a_)\n        }\n    }\n\n    /// Store a `uint256` at the stack top position and return the stack top\n    /// above the written value. The following statements are equivalent in\n    /// functionality but A may be less gas if the compiler fails to inline\n    /// some function calls.\n    /// A:\n    /// ```\n    /// stackTop_ = stackTop_.push(a_);\n    /// ```\n    /// B:\n    /// ```\n    /// stackTop_.set(a_);\n    /// stackTop_ = stackTop_.up();\n    /// ```\n    /// @param stackTop_ The stack top to write at.\n    /// @param a_ The value to write.\n    /// @return The stack top above where `a_` was written to.\n    function push(\n        StackTop stackTop_,\n        uint256 a_\n    ) internal pure returns (StackTop) {\n        assembly (\"memory-safe\") {\n            mstore(stackTop_, a_)\n            stackTop_ := add(stackTop_, 0x20)\n        }\n        return stackTop_;\n    }\n\n    /// Store a `uint256[]` at the stack top position and return the stack top\n    /// above the written values. The length of the array is NOT written to the\n    /// stack, ONLY the array values are copied to the stack. The following\n    /// statements are equivalent in functionality but A may be less gas if the\n    /// compiler fails to inline some function calls.\n    /// A:\n    /// ```\n    /// stackTop_ = stackTop_.push(array_);\n    /// ```\n    /// B:\n    /// ```\n    /// unchecked {\n    ///   for (uint i_ = 0; i_ < array_.length; i_++) {\n    ///     stackTop_ = stackTop_.push(array_[i_]);\n    ///   }\n    /// }\n    /// ```\n    /// @param stackTop_ The stack top to write at.\n    /// @param array_ The array of values to write.\n    /// @return The stack top above the array.\n    function push(\n        StackTop stackTop_,\n        uint256[] memory array_\n    ) internal pure returns (StackTop) {\n        array_.unsafeCopyValuesTo(StackTop.unwrap(stackTop_));\n        return stackTop_.up(array_.length);\n    }\n\n    /// Store a `uint256[]` at the stack top position and return the stack top\n    /// above the written values. The length of the array IS written to the\n    /// stack.\n    /// @param stackTop_ The stack top to write at.\n    /// @param array_ The array of values and length to write.\n    /// @return The stack top above the array.\n    function pushWithLength(\n        StackTop stackTop_,\n        uint256[] memory array_\n    ) internal pure returns (StackTop) {\n        return stackTop_.push(array_.length).push(array_);\n    }\n\n    /// Store `bytes` at the stack top position and return the stack top above\n    /// the written bytes. The length of the bytes is NOT written to the stack,\n    /// ONLY the bytes are written. As `bytes` may be of arbitrary length, i.e.\n    /// it MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\n    /// ensure that this is safe in context of subsequent reads and writes.\n    /// @param stackTop_ The stack top to write at.\n    /// @param bytes_ The bytes to write at the stack top.\n    /// @return The stack top above the written bytes.\n    function unalignedPush(\n        StackTop stackTop_,\n        bytes memory bytes_\n    ) internal pure returns (StackTop) {\n        StackTop.unwrap(bytes_.asStackTop().up()).unsafeCopyBytesTo(\n            StackTop.unwrap(stackTop_),\n            bytes_.length\n        );\n        return stackTop_.upBytes(bytes_.length);\n    }\n\n    /// Store `bytes` at the stack top position and return the stack top above\n    /// the written bytes. The length of the bytes IS written to the stack in\n    /// addition to the bytes. As `bytes` may be of arbitrary length, i.e. it\n    /// MAY NOT be a multiple of 32, the push is unaligned. The caller MUST\n    /// ensure that this is safe in context of subsequent reads and writes.\n    /// @param stackTop_ The stack top to write at.\n    /// @param bytes_ The bytes to write with their length at the stack top.\n    /// @return The stack top above the written bytes.\n    function unalignedPushWithLength(\n        StackTop stackTop_,\n        bytes memory bytes_\n    ) internal pure returns (StackTop) {\n        return stackTop_.push(bytes_.length).unalignedPush(bytes_);\n    }\n\n    /// Store 8x `uint256` at the stack top position and return the stack top\n    /// above the written value. The following statements are equivalent in\n    /// functionality but A may be cheaper if the compiler fails to\n    /// inline some function calls.\n    /// A:\n    /// ```\n    /// stackTop_ = stackTop_.push(a_, b_, c_, d_, e_, f_, g_, h_);\n    /// ```\n    /// B:\n    /// ```\n    /// stackTop_ = stackTop_\n    ///   .push(a_)\n    ///   .push(b_)\n    ///   .push(c_)\n    ///   .push(d_)\n    ///   .push(e_)\n    ///   .push(f_)\n    ///   .push(g_)\n    ///   .push(h_);\n    /// @param stackTop_ The stack top to write at.\n    /// @param a_ The first value to write.\n    /// @param b_ The second value to write.\n    /// @param c_ The third value to write.\n    /// @param d_ The fourth value to write.\n    /// @param e_ The fifth value to write.\n    /// @param f_ The sixth value to write.\n    /// @param g_ The seventh value to write.\n    /// @param h_ The eighth value to write.\n    /// @return The stack top above where `h_` was written.\n    function push(\n        StackTop stackTop_,\n        uint256 a_,\n        uint256 b_,\n        uint256 c_,\n        uint256 d_,\n        uint256 e_,\n        uint256 f_,\n        uint256 g_,\n        uint256 h_\n    ) internal pure returns (StackTop) {\n        assembly (\"memory-safe\") {\n            mstore(stackTop_, a_)\n            mstore(add(stackTop_, 0x20), b_)\n            mstore(add(stackTop_, 0x40), c_)\n            mstore(add(stackTop_, 0x60), d_)\n            mstore(add(stackTop_, 0x80), e_)\n            mstore(add(stackTop_, 0xA0), f_)\n            mstore(add(stackTop_, 0xC0), g_)\n            mstore(add(stackTop_, 0xE0), h_)\n            stackTop_ := add(stackTop_, 0x100)\n        }\n        return stackTop_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(uint256) internal view returns (uint256) fn_\n    ) internal view returns (StackTop) {\n        uint256 a_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n        }\n        a_ = fn_(a_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(Operand, uint256) internal view returns (uint256) fn_,\n        Operand operand_\n    ) internal view returns (StackTop) {\n        uint256 a_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n        }\n        a_ = fn_(operand_, a_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(uint256, uint256) internal view returns (uint256) fn_\n    ) internal view returns (StackTop) {\n        uint256 a_;\n        uint256 b_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            stackTop_ := sub(stackTop_, 0x20)\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n            b_ := mload(stackTop_)\n        }\n        a_ = fn_(a_, b_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    /// Reduce a function N times, reading and writing inputs and the accumulated\n    /// result on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @param n_ The number of times to apply fn_ to accumulate a final result.\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\n    function applyFnN(\n        StackTop stackTop_,\n        function(uint256, uint256) internal view returns (uint256) fn_,\n        uint256 n_\n    ) internal view returns (StackTop stackTopAfter_) {\n        unchecked {\n            uint256 bottom_;\n            uint256 cursor_;\n            uint256 a_;\n            uint256 b_;\n            assembly (\"memory-safe\") {\n                bottom_ := sub(stackTop_, mul(n_, 0x20))\n                a_ := mload(bottom_)\n                stackTopAfter_ := add(bottom_, 0x20)\n                cursor_ := stackTopAfter_\n            }\n            while (cursor_ < StackTop.unwrap(stackTop_)) {\n                assembly (\"memory-safe\") {\n                    b_ := mload(cursor_)\n                }\n                a_ = fn_(a_, b_);\n                cursor_ += 0x20;\n            }\n            assembly (\"memory-safe\") {\n                mstore(bottom_, a_)\n            }\n        }\n    }\n\n    function applyFnN(\n        StackTop stackTop_,\n        function(uint256) internal view fn_,\n        uint256 n_\n    ) internal view returns (StackTop stackTopAfter_) {\n        uint256 cursor_;\n        uint256 a_;\n        assembly (\"memory-safe\") {\n            stackTopAfter_ := sub(stackTop_, mul(n_, 0x20))\n            cursor_ := stackTopAfter_\n        }\n        while (cursor_ < StackTop.unwrap(stackTop_)) {\n            assembly (\"memory-safe\") {\n                a_ := mload(cursor_)\n                cursor_ := add(cursor_, 0x20)\n            }\n            fn_(a_);\n        }\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(uint256, uint256, uint256) internal view returns (uint256) fn_\n    ) internal view returns (StackTop) {\n        uint256 a_;\n        uint256 b_;\n        uint256 c_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            stackTop_ := sub(stackTop_, 0x40)\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n            b_ := mload(stackTop_)\n            c_ := mload(add(stackTop_, 0x20))\n        }\n        a_ = fn_(a_, b_, c_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(uint256, uint256, uint256, uint)\n            internal\n            view\n            returns (uint256) fn_\n    ) internal view returns (StackTop) {\n        uint256 a_;\n        uint256 b_;\n        uint256 c_;\n        uint d_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            stackTop_ := sub(stackTop_, 0x60)\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n            b_ := mload(stackTop_)\n            c_ := mload(add(stackTop_, 0x20))\n            d_ := mload(add(stackTop_, 0x40))\n        }\n        a_ = fn_(a_, b_, c_, d_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @param operand_ Operand is passed from the source instead of the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(Operand, uint256, uint256) internal view returns (uint256) fn_,\n        Operand operand_\n    ) internal view returns (StackTop) {\n        uint256 a_;\n        uint256 b_;\n        uint256 location_;\n        assembly (\"memory-safe\") {\n            stackTop_ := sub(stackTop_, 0x20)\n            location_ := sub(stackTop_, 0x20)\n            a_ := mload(location_)\n            b_ := mload(stackTop_)\n        }\n        a_ = fn_(operand_, a_, b_);\n        assembly (\"memory-safe\") {\n            mstore(location_, a_)\n        }\n        return stackTop_;\n    }\n\n    function applyFn(\n        StackTop stackTop_,\n        function(uint256[] memory) internal view returns (uint256) fn_,\n        uint256 length_\n    ) internal view returns (StackTop stackTopAfter_) {\n        (uint256 a_, uint256[] memory tail_) = stackTop_.list(length_);\n        uint256 b_ = fn_(tail_);\n        return tail_.asStackTop().push(a_).push(b_);\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @param length_ The length of the array to pass to fn_ from the stack.\n    /// @return stackTopAfter_ The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(uint256, uint256, uint256[] memory)\n            internal\n            view\n            returns (uint256) fn_,\n        uint256 length_\n    ) internal view returns (StackTop stackTopAfter_) {\n        (uint256 b_, uint256[] memory tail_) = stackTop_.list(length_);\n        stackTopAfter_ = tail_.asStackTop();\n        (StackTop location_, uint256 a_) = stackTopAfter_.pop();\n        location_.set(fn_(a_, b_, tail_));\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @param length_ The length of the array to pass to fn_ from the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(uint256, uint256, uint256, uint256[] memory)\n            internal\n            view\n            returns (uint256) fn_,\n        uint256 length_\n    ) internal view returns (StackTop) {\n        (uint256 c_, uint256[] memory tail_) = stackTop_.list(length_);\n        (StackTop stackTopAfter_, uint256 b_) = tail_.asStackTop().pop();\n        uint256 a_ = stackTopAfter_.peek();\n        stackTopAfter_.down().set(fn_(a_, b_, c_, tail_));\n        return stackTopAfter_;\n    }\n\n    /// Execute a function, reading and writing inputs and outputs on the stack.\n    /// The caller MUST ensure this does not result in unsafe reads and writes.\n    /// @param stackTop_ The stack top to read and write to.\n    /// @param fn_ The function to run on the stack.\n    /// @param length_ The length of the arrays to pass to fn_ from the stack.\n    /// @return The new stack top above the outputs of fn_.\n    function applyFn(\n        StackTop stackTop_,\n        function(uint256, uint256[] memory, uint256[] memory)\n            internal\n            view\n            returns (uint256[] memory) fn_,\n        uint256 length_\n    ) internal view returns (StackTop) {\n        StackTop csStart_ = stackTop_.down(length_);\n        uint256[] memory cs_ = LibUint256Array.copyToNewUint256Array(\n            StackTop.unwrap(csStart_),\n            length_\n        );\n        (uint256 a_, uint256[] memory bs_) = csStart_.list(length_);\n\n        uint256[] memory results_ = fn_(a_, bs_, cs_);\n        require(results_.length == length_, \"BAD_RESULT_LENGTH\");\n        StackTop bottom_ = bs_.asStackTop();\n        LibUint256Array.unsafeCopyValuesTo(results_, StackTop.unwrap(bottom_));\n        return bottom_.up(length_);\n    }\n\n    /// Returns `length_` values from the stack as an array without allocating\n    /// new memory. As arrays always start with their length, this requires\n    /// writing the length value to the stack below the array values. The value\n    /// that is overwritten in the process is also returned so that data is not\n    /// lost. For example, imagine a stack `[ A B C D ]` and we list 2 values.\n    /// This will write the stack to look like `[ A 2 C D ]` and return both `B`\n    /// and a pointer to `2` represented as a `uint256[]`.\n    /// The returned array is ONLY valid for as long as the stack DOES NOT move\n    /// back into its memory. As soon as the stack moves up again and writes into\n    /// the array it will be corrupt. The caller MUST ensure that it does not\n    /// read from the returned array after it has been corrupted by subsequent\n    /// stack writes.\n    /// @param stackTop_ The stack top to read the values below into an array.\n    /// @param length_ The number of values to include in the returned array.\n    /// @return head_ The value that was overwritten with the length.\n    /// @return tail_ The array constructed from the stack memory.\n    function list(\n        StackTop stackTop_,\n        uint256 length_\n    ) internal pure returns (uint256 head_, uint256[] memory tail_) {\n        assembly (\"memory-safe\") {\n            tail_ := sub(stackTop_, add(0x20, mul(length_, 0x20)))\n            head_ := mload(tail_)\n            mstore(tail_, length_)\n        }\n    }\n\n    /// Cast a `uint256[]` array to a stack top. The stack top will point to the\n    /// length of the array, NOT its first value.\n    /// @param array_ The array to cast to a stack top.\n    /// @return stackTop_ The stack top that points to the length of the array.\n    function asStackTop(\n        uint256[] memory array_\n    ) internal pure returns (StackTop stackTop_) {\n        assembly (\"memory-safe\") {\n            stackTop_ := array_\n        }\n    }\n\n    /// Cast a stack top to an array. The value immediately above the stack top\n    /// will be treated as the length of the array, so the proceeding length\n    /// values will be the items of the array. The caller MUST ensure the values\n    /// above the stack top constitute a valid array. The retured array will be\n    /// corrupt if/when the stack subsequently moves into it and writes to those\n    /// memory locations. The caller MUST ensure that it does NOT read from the\n    /// returned array after the stack writes over it.\n    /// @param stackTop_ The stack top that will be cast to an array.\n    /// @return array_ The array above the stack top.\n    function asUint256Array(\n        StackTop stackTop_\n    ) internal pure returns (uint256[] memory array_) {\n        assembly (\"memory-safe\") {\n            array_ := stackTop_\n        }\n    }\n\n    /// Cast a stack top to bytes. The value immediately above the stack top will\n    /// be treated as the length of the `bytes`, so the proceeding length bytes\n    /// will be the data of the `bytes`. The caller MUST ensure the length and\n    /// bytes above the stack top constitute valid `bytes` data. The returned\n    /// `bytes` will be corrupt if/when the stack subsequently moves into it and\n    /// writes to those memory locations. The caller MUST ensure that it does\n    /// NOT read from the returned bytes after the stack writes over it.\n    /// @param stackTop_ The stack top that will be cast to bytes.\n    /// @return bytes_ The bytes above the stack top.\n    function asBytes(\n        StackTop stackTop_\n    ) internal pure returns (bytes memory bytes_) {\n        assembly (\"memory-safe\") {\n            bytes_ := stackTop_\n        }\n    }\n\n    /// Cast a `uint256[]` array to a stack top after its length. The stack top\n    /// will point to the first item of the array, NOT its length.\n    /// @param array_ The array to cast to a stack top.\n    /// @return stackTop_ The stack top that points to the first item of the array.\n    function asStackTopUp(\n        uint256[] memory array_\n    ) internal pure returns (StackTop stackTop_) {\n        assembly (\"memory-safe\") {\n            stackTop_ := add(array_, 0x20)\n        }\n    }\n\n    function asStackTopAfter(\n        uint256[] memory array_\n    ) internal pure returns (StackTop stackTop_) {\n        assembly (\"memory-safe\") {\n            stackTop_ := add(array_, add(0x20, mul(mload(array_), 0x20)))\n        }\n    }\n\n    /// Cast `bytes` to a stack top. The stack top will point to the length of\n    /// the `bytes`, NOT the first byte.\n    /// @param bytes_ The `bytes` to cast to a stack top.\n    /// @return stackTop_ The stack top that points to the length of the bytes.\n    function asStackTop(\n        bytes memory bytes_\n    ) internal pure returns (StackTop stackTop_) {\n        assembly (\"memory-safe\") {\n            stackTop_ := bytes_\n        }\n    }\n\n    /// Returns the stack top 32 bytes above/past the passed stack top.\n    /// @param stackTop_ The stack top at the starting position.\n    /// @return The stack top 32 bytes above the passed stack top.\n    function up(StackTop stackTop_) internal pure returns (StackTop) {\n        unchecked {\n            return StackTop.wrap(StackTop.unwrap(stackTop_) + 0x20);\n        }\n    }\n\n    /// Returns the stack top `n_ * 32` bytes above/past the passed stack top.\n    /// @param stackTop_ The stack top at the starting position.\n    /// @param n_ The multiplier on the stack movement. MAY be zero.\n    /// @return The stack top `n_ * 32` bytes above/past the passed stack top.\n    function up(\n        StackTop stackTop_,\n        uint256 n_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            return StackTop.wrap(StackTop.unwrap(stackTop_) + 0x20 * n_);\n        }\n    }\n\n    /// Returns the stack top `n_` bytes above/past the passed stack top.\n    /// The returned stack top MAY NOT be aligned with the passed stack top for\n    /// subsequent 32 byte reads and writes. The caller MUST ensure that it is\n    /// safe to read and write data relative to the returned stack top.\n    /// @param stackTop_ The stack top at the starting position.\n    /// @param n_ The number of bytes to move.\n    /// @return The stack top `n_` bytes above/past the passed stack top.\n    function upBytes(\n        StackTop stackTop_,\n        uint256 n_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            return StackTop.wrap(StackTop.unwrap(stackTop_) + n_);\n        }\n    }\n\n    /// Returns the stack top 32 bytes below/before the passed stack top.\n    /// @param stackTop_ The stack top at the starting position.\n    /// @return The stack top 32 bytes below/before the passed stack top.\n    function down(StackTop stackTop_) internal pure returns (StackTop) {\n        unchecked {\n            return StackTop.wrap(StackTop.unwrap(stackTop_) - 0x20);\n        }\n    }\n\n    /// Returns the stack top `n_ * 32` bytes below/before the passed stack top.\n    /// @param stackTop_ The stack top at the starting position.\n    /// @param n_ The multiplier on the movement.\n    /// @return The stack top `n_ * 32` bytes below/before the passed stack top.\n    function down(\n        StackTop stackTop_,\n        uint256 n_\n    ) internal pure returns (StackTop) {\n        unchecked {\n            return StackTop.wrap(StackTop.unwrap(stackTop_) - 0x20 * n_);\n        }\n    }\n\n    /// Convert two stack top values to a single stack index. A stack index is\n    /// the distance in 32 byte increments between two stack positions. The\n    /// calculations assumes the two stack positions are aligned. The caller MUST\n    /// ensure the alignment of both values. The calculation is unchecked and MAY\n    /// underflow. The caller MUST ensure that the stack top is always above the\n    /// stack bottom.\n    /// @param stackBottom_ The lower of the two values.\n    /// @param stackTop_ The higher of the two values.\n    /// @return The stack index as 32 byte distance between the two stack\n    /// positions.\n    function toIndex(\n        StackTop stackBottom_,\n        StackTop stackTop_\n    ) internal pure returns (uint256) {\n        unchecked {\n            return\n                (StackTop.unwrap(stackTop_) - StackTop.unwrap(stackBottom_)) /\n                0x20;\n        }\n    }\n}\n"
    },
    "contracts/interpreter/shared/Rainterpreter.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../ops/AllStandardOps.sol\";\nimport \"../run/LibEncodedDispatch.sol\";\nimport \"../ops/core/OpGet.sol\";\nimport \"../../kv/LibMemoryKV.sol\";\nimport \"../../sstore2/SSTORE2.sol\";\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\n/// Thrown when the caller of a self static call is not self.\nerror SelfStaticCaller(address caller);\n\n/// @title Rainterpreter\n/// @notice Minimal binding of the `IIinterpreterV1` interface to the\n/// `LibInterpreterState` library, including every opcode in `AllStandardOps`.\n/// This is the default implementation of \"an interpreter\" but is designed such\n/// that other interpreters can easily be developed alongside. Alterpreters can\n/// either be built by inheriting and overriding the functions on this contract,\n/// or using the relevant libraries to construct an alternative binding to the\n/// same interface.\ncontract Rainterpreter is IInterpreterV1 {\n    using LibStackPointer for StackPointer;\n    using LibInterpreterState for bytes;\n    using LibInterpreterState for InterpreterState;\n    using LibInterpreterState for StateNamespace;\n    using LibCast for function(InterpreterState memory, Operand, StackPointer)\n        view\n        returns (StackPointer)[];\n    using LibConvert for uint256[];\n    using Math for uint256;\n    using LibMemoryKV for MemoryKV;\n    using LibMemoryKV for MemoryKVPtr;\n\n    /// State is several tiers of sandbox.\n    ///\n    /// 0. address is msg.sender so that callers cannot attack each other\n    /// 1. StateNamespace is caller-provided namespace so that expressions cannot\n    ///    attack each other\n    /// 2. uint256 is expression-provided key\n    /// 3. uint256 is expression-provided value\n    ///\n    /// tiers 0 and 1 are both embodied in the `FullyQualifiedNamespace`.\n    mapping(FullyQualifiedNamespace => mapping(uint256 => uint256))\n        internal state;\n\n    /// Guards against `msg.sender` calling `eval` in a non-static way and\n    /// providing function pointers in the eval to attempt to manipulate state.\n    /// For example, perhaps there is some way an attacker could carefully craft\n    /// function pointers such that `stateChanges` is executed within an `eval`.\n    /// This function can only be called externally by the interpreter itself and\n    /// guards all code paths that dispatch logic by direct function pointer. The\n    /// interpreter will only ever call itself statically according to\n    /// `external view` so restricting callers to self is enough to restrict all\n    /// calls to static over untrusted function pointers.\n    /// @param namespace_ The fully qualified namespace can be provided directly\n    /// here as this function can only be called by self.\n    /// @param dispatch_ As per `eval`.\n    /// @param context_ As per `eval`.\n    function selfStaticEval(\n        FullyQualifiedNamespace namespace_,\n        EncodedDispatch dispatch_,\n        uint256[][] memory context_\n    ) external view returns (uint256[] memory, uint256[] memory) {\n        if (msg.sender != address(this)) {\n            revert SelfStaticCaller(msg.sender);\n        }\n        // Decode the dispatch.\n        (\n            address expression_,\n            SourceIndex sourceIndex_,\n            uint256 maxOutputs_\n        ) = LibEncodedDispatch.decode(dispatch_);\n\n        // Build the interpreter state from the onchain expression.\n        InterpreterState memory state_ = SSTORE2\n            .read(expression_)\n            .deserialize();\n        state_.namespace = namespace_;\n        state_.context = context_;\n\n        // Eval the expression and return up to maxOutputs_ from the final stack.\n        StackPointer stackTop_ = state_.eval(sourceIndex_, state_.stackBottom);\n        uint256 stackLength_ = state_.stackBottom.toIndex(stackTop_);\n        (, uint256[] memory tail_) = stackTop_.list(\n            stackLength_.min(maxOutputs_)\n        );\n        return (tail_, state_.stateKV.toUint256Array());\n    }\n\n    /// @inheritdoc IInterpreterV1\n    function evalWithNamespace(\n        StateNamespace namespace_,\n        EncodedDispatch dispatch_,\n        uint256[][] calldata context_\n    ) public view returns (uint256[] memory, uint256[] memory) {\n        return\n            this.selfStaticEval(\n                namespace_.qualifyNamespace(),\n                dispatch_,\n                context_\n            );\n    }\n\n    /// @inheritdoc IInterpreterV1\n    function eval(\n        EncodedDispatch dispatch_,\n        uint256[][] calldata context_\n    ) external view returns (uint256[] memory, uint256[] memory) {\n        return evalWithNamespace(StateNamespace.wrap(0), dispatch_, context_);\n    }\n\n    /// @inheritdoc IInterpreterV1\n    function stateChangesWithNamespace(\n        StateNamespace namespace_,\n        uint256[] calldata stateChanges_\n    ) public {\n        FullyQualifiedNamespace fullyQualifiedNamespace_ = namespace_\n            .qualifyNamespace();\n        unchecked {\n            for (uint256 i_ = 0; i_ < stateChanges_.length; i_ += 2) {\n                state[fullyQualifiedNamespace_][\n                    stateChanges_[i_]\n                ] = stateChanges_[i_ + 1];\n            }\n        }\n    }\n\n    /// @inheritdoc IInterpreterV1\n    function stateChanges(uint256[] calldata stateChanges_) external {\n        stateChangesWithNamespace(StateNamespace.wrap(0), stateChanges_);\n    }\n\n    /// @inheritdoc IInterpreterV1\n    function functionPointers() external view virtual returns (bytes memory) {\n        function(InterpreterState memory, Operand, StackPointer)\n            view\n            returns (StackPointer)[]\n            memory localPtrs_ = new function(\n                InterpreterState memory,\n                Operand,\n                StackPointer\n            ) view returns (StackPointer)[](1);\n        localPtrs_[0] = opGet;\n        return\n            AllStandardOps\n                .opcodeFunctionPointers(localPtrs_)\n                .asUint256Array()\n                .unsafeTo16BitBytes();\n    }\n\n    /// Implements runtime behaviour of the `get` opcode. Attempts to lookup the\n    /// key in the memory key/value store then falls back to the interpreter's\n    /// storage mapping of state changes. If the key is not found in either the\n    /// value will fallback to `0` as per default Solidity/EVM behaviour.\n    /// @param interpreterState_ The interpreter state of the current eval.\n    /// @param stackTop_ Pointer to the current stack top.\n    function opGet(\n        InterpreterState memory interpreterState_,\n        Operand,\n        StackPointer stackTop_\n    ) internal view returns (StackPointer) {\n        uint256 k_;\n        (stackTop_, k_) = stackTop_.pop();\n        MemoryKVPtr kvPtr_ = interpreterState_.stateKV.getPtr(\n            MemoryKVKey.wrap(k_)\n        );\n        uint256 v_ = 0;\n        if (MemoryKVPtr.unwrap(kvPtr_) > 0) {\n            v_ = MemoryKVVal.unwrap(kvPtr_.readPtrVal());\n        } else {\n            v_ = state[interpreterState_.namespace][k_];\n        }\n        return stackTop_.push(v_);\n    }\n}\n"
    },
    "contracts/interpreter/shared/RainterpreterExpressionDeployer.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../deploy/IExpressionDeployerV1.sol\";\nimport \"../ops/AllStandardOps.sol\";\nimport \"../ops/core/OpGet.sol\";\nimport \"../../sstore2/SSTORE2.sol\";\n\n/// @dev Thrown when the pointers known to the expression deployer DO NOT match\n/// the interpreter it is constructed for. This WILL cause undefined expression\n/// behaviour so MUST REVERT.\nerror UnexpectedPointers(bytes actualPointers);\n\n/// @dev Thrown when the bytecode hash known to the expression deployer DOES NOT\n/// match the interpreter it is constructed for. This WILL cause undefined\n/// expression behaviour so MUST REVERT.\nerror UnexpectedInterpreterBytecodeHash(bytes32 actualBytecodeHash);\n\n/// @dev There are more entrypoints defined by the minimum stack outputs than\n/// there are provided sources. This means the calling contract WILL attempt to\n/// eval a dangling reference to a non-existent source at some point, so this\n/// MUST REVERT.\nerror MissingEntrypoint(uint256 expectedEntrypoints, uint256 actualEntrypoints);\n\n/// @dev The function pointers known to the expression deployer. These are\n/// immutable for any given interpreter so once the expression deployer is\n/// constructed and has verified that this matches what the interpreter reports,\n/// it can use this constant value to compile and serialize expressions.\nbytes constant OPCODE_FUNCTION_POINTERS = hex\"0cb50cc30d190d6b0de90e150eae0f780fad0fcb105310621070107e108c1062109a10a810b610c510d410e210f0116811771186119511a411b311fc120e121c124e125c126a12781287129612a512b412c312d212e112f012ff130e131d132b13391347135513631371137f138e139d13ab13f507e5\";\n\n/// @dev The interpreter bytecode hash known to the expression deployer. Checking\n/// this guarantees that the code on the other side of the function pointers is\n/// what the expression deployer expects it to be, giving significantly higher\n/// confidence that the integrity checks are valid.\nbytes32 constant INTERPRETER_BYTECODE_HASH = bytes32(\n    0xda914e60d06a83d8099b6562ac80dd60acbac7c35f0fcee9bffa8e160b377f63\n);\n\n/// @title RainterpreterExpressionDeployer\n/// @notice Minimal binding of the `IExpressionDeployerV1` interface to the\n/// `LibIntegrityCheck.ensureIntegrity` loop and `AllStandardOps`.\ncontract RainterpreterExpressionDeployer is IExpressionDeployerV1 {\n    using LibInterpreterState for StateConfig;\n    using LibStackPointer for StackPointer;\n\n    /// The interpreter passed in construction is valid. The only valid\n    /// interpreter has the exact bytecode hash known to the expression deployer.\n    /// @param sender The account that constructed the expression deployer.\n    /// @param interpreter The address of the interpreter that the expression\n    /// deployer agrees to perform integrity checks for. Note that the pairing\n    /// between interpreter and expression deployer needs to be checked and\n    /// enforced elsewhere offchain and/or onchain.\n    event ValidInterpreter(address sender, address interpreter);\n\n    /// The config of the deployed expression including uncompiled sources. Will\n    /// only be emitted after the config passes the integrity check.\n    /// @param sender The caller of `deployExpression`.\n    /// @param config The config for the deployed expression.\n    event ExpressionConfig(address sender, StateConfig config);\n\n    /// The address of the deployed expression. Will only be emitted once the\n    /// expression can be loaded and deserialized into an evaluable interpreter\n    /// state.\n    /// @param sender The caller of `deployExpression`.\n    /// @param expression The address of the deployed expression.\n    event ExpressionDeployed(address sender, address expression);\n\n    /// THIS IS NOT A SECURITY CHECK. IT IS AN INTEGRITY CHECK TO PREVENT HONEST\n    /// MISTAKES. IT CANNOT PREVENT EITHER A MALICIOUS INTERPRETER OR DEPLOYER\n    /// FROM BEING EXECUTED.\n    constructor(address interpreter_) {\n        // Guard against serializing incorrect function pointers, which would\n        // cause undefined runtime behaviour for corrupted opcodes.\n        bytes memory functionPointers_ = IInterpreterV1(interpreter_)\n            .functionPointers();\n        if (\n            keccak256(functionPointers_) != keccak256(OPCODE_FUNCTION_POINTERS)\n        ) {\n            revert UnexpectedPointers(functionPointers_);\n        }\n\n        // Guard against an interpreter with unknown/untrusted bytecode that\n        // could run arbitrary logic even if the function pointers are identical\n        // to the known/trusted interpreter.\n        bytes32 interpreterHash_;\n        assembly (\"memory-safe\") {\n            interpreterHash_ := extcodehash(interpreter_)\n        }\n        if (interpreterHash_ != INTERPRETER_BYTECODE_HASH) {\n            revert UnexpectedInterpreterBytecodeHash(interpreterHash_);\n        }\n\n        emit ValidInterpreter(msg.sender, interpreter_);\n    }\n\n    /// Defines all the function pointers to integrity checks. This is the\n    /// expression deployer's equivalent of the opcode function pointers and\n    /// follows a near identical dispatch process. These are never compiled into\n    /// source and are instead indexed into directly by the integrity check. The\n    /// indexing into integrity pointers (which has an out of bounds check) is a\n    /// proxy for enforcing that all opcode pointers exist at runtime, so the\n    /// length of the integrity pointers MUST match the length of opcode function\n    /// pointers. This function is `virtual` so that it can be overridden\n    /// pairwise with overrides to `functionPointers` on `Rainterpreter`.\n    /// @return The list of integrity function pointers.\n    function integrityFunctionPointers()\n        internal\n        view\n        virtual\n        returns (\n            function(IntegrityCheckState memory, Operand, StackPointer)\n                view\n                returns (StackPointer)[]\n                memory\n        )\n    {\n        function(IntegrityCheckState memory, Operand, StackPointer)\n            view\n            returns (StackPointer)[]\n            memory localFnPtrs_ = new function(\n                IntegrityCheckState memory,\n                Operand,\n                StackPointer\n            ) view returns (StackPointer)[](1);\n        localFnPtrs_[0] = OpGet.integrity;\n        return AllStandardOps.integrityFunctionPointers(localFnPtrs_);\n    }\n\n    /// @inheritdoc IExpressionDeployerV1\n    function deployExpression(\n        StateConfig memory config_,\n        uint256[] memory minStackOutputs_\n    ) external returns (address) {\n        // Ensure that we are not missing any entrypoints expected by the calling\n        // contract.\n        if (minStackOutputs_.length > config_.sources.length) {\n            revert MissingEntrypoint(\n                minStackOutputs_.length,\n                config_.sources.length\n            );\n        }\n\n        // Build the initial state of the integrity check.\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(config_, integrityFunctionPointers());\n        // Loop over each possible entrypoint as defined by the calling contract\n        // and check the integrity of each. At the least we need to be sure that\n        // there are no out of bounds stack reads/writes and to know the total\n        // memory to allocate when later deserializing an associated interpreter\n        // state for evaluation.\n        StackPointer initialStackBottom_ = integrityCheckState_.stackBottom;\n        StackPointer initialStackHighwater_ = integrityCheckState_.stackHighwater;\n        for (uint256 i_ = 0; i_ < minStackOutputs_.length; i_++) {\n            // Reset the top, bottom and highwater between each entrypoint as\n            // every external eval MUST have a fresh stack, but retain the max\n            // stack height as the latter is used for unconditional memory\n            // allocation so MUST be the max height across all possible\n            // entrypoints.\n            integrityCheckState_.stackBottom = initialStackBottom_;\n            integrityCheckState_.stackHighwater = initialStackHighwater_;\n            LibIntegrityCheck.ensureIntegrity(\n                integrityCheckState_,\n                SourceIndex.wrap(i_),\n                INITIAL_STACK_BOTTOM,\n                minStackOutputs_[i_]\n            );\n        }\n        uint256 stackLength_ = integrityCheckState_.stackBottom.toIndex(\n            integrityCheckState_.stackMaxTop\n        );\n\n        // Emit the config of the expression _before_ we serialize it, as the\n        // serialization process itself is destructive of the config in memory.\n        emit ExpressionConfig(msg.sender, config_);\n\n        // Serialize the state config into bytes that can be deserialized later\n        // by the interpreter. This will compile the sources according to the\n        // provided function pointers.\n        bytes memory stateBytes_ = config_.serialize(\n            stackLength_,\n            OPCODE_FUNCTION_POINTERS\n        );\n\n        // Deploy the serialized expression onchain.\n        address expression_ = SSTORE2.write(stateBytes_);\n\n        // Emit and return the address of the deployed expression.\n        emit ExpressionDeployed(msg.sender, expression_);\n\n        return expression_;\n    }\n}\n"
    },
    "contracts/kv/LibMemoryKV.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../math/Binary.sol\";\n\n/// Thrown when attempting to read a value from the other side of a zero pointer.\nerror InvalidPtr(MemoryKVPtr ptr);\n\n/// Entrypoint into the key/value store. Is a mutable pointer to the head of the\n/// linked list. Initially points to `0` for an empty list. The total length of\n/// the linked list is also encoded alongside the pointer to allow efficient O(1)\n/// memory allocation for a `uint256[]` in the case of a final snapshot/export.\ntype MemoryKV is uint256;\n/// The key associated with the value for each item in the linked list.\ntype MemoryKVKey is uint256;\n/// The pointer to the next item in the list. `0` signifies the end of the list.\ntype MemoryKVPtr is uint256;\n/// The value associated with the key for each item in the linked list.\ntype MemoryKVVal is uint256;\n\n/// @title LibMemoryKV\n/// @notice Implements an in-memory key/value store in terms of a linked list\n/// that can be snapshotted/exported to a `uint256[]` of pairwise keys/values as\n/// its items. Ostensibly supports reading/writing to storage within a read only\n/// context in an interpreter `eval` by tracking changes requested by an\n/// expression in memory as a cache-like structure over the underlying storage.\n///\n/// A linked list is required because unlike stack movements we do NOT have any\n/// way to precalculate how many items will be included in the final set at\n/// deploy time. Any two writes may share the same key known only at runtime, so\n/// any two writes may result in either 2 or 1 insertions (and 0 or 1 updates).\n/// We could attempt to solve this by allowing duplicate keys and simply append\n/// values for each write, so two writes will always insert 2 values, but then\n/// looping constructs such as `OpDoWhile` and `OpFoldContext` with net 0 stack\n/// movements (i.e. predictably deallocateable memory) can still cause\n/// unbounded/unknown inserts for our state changes. The linked list allows us\n/// to both dedupe same-key writes and also safely handle an unknown\n/// (at deploy time) number of upserts. New items are inserted at the head of\n/// the list and a pointer to `0` is the sentinel that defines the end of the\n/// list. It is an error to dereference the `0` pointer.\n///\n/// Currently implemented as O(n) where n is likely relatively small, in future\n/// could be reimplemented as 8 linked lists over a single `MemoryKV` by packing\n/// many `MemoryKVPtr` and using `%` to distribute keys between lists. The\n/// extremely high gas cost of writing to storage itself should be a natural\n/// disincentive for n getting large enough to cause the linked list traversal\n/// to be a significant gas cost itself.\n///\n/// Currently implemented in terms of raw `uint256` custom types that represent\n/// keys, values and pointers. Could be reimplemented in terms of an equivalent\n/// struct with key, value and pointer fields.\nlibrary LibMemoryKV {\n    /// Reads the `MemoryKVVal` that some `MemoryKVPtr` is pointing to. It is an\n    /// error to call this if `ptr_` is `0`.\n    /// @param ptr_ The pointer to read the value\n    function readPtrVal(\n        MemoryKVPtr ptr_\n    ) internal pure returns (MemoryKVVal v_) {\n        // This is ALWAYS a bug. It means the caller did not check if the ptr is\n        // nonzero before trying to read from it.\n        if (MemoryKVPtr.unwrap(ptr_) == 0) {\n            revert InvalidPtr(ptr_);\n        }\n\n        assembly (\"memory-safe\") {\n            v_ := mload(add(ptr_, 0x20))\n        }\n    }\n\n    /// Finds the pointer to the item that holds the value associated with the\n    /// given key. Walks the linked list from the entrypoint into the key/value\n    /// store until it finds the specified key. As the last pointer in the list\n    /// is always `0`, `0` is what will be returned if the key is not found. Any\n    /// non-zero pointer implies the value it points to is for the provided key.\n    /// @param kv_ The entrypoint to the key/value store.\n    /// @param k_ The key to lookup a pointer for.\n    /// @return ptr_ The _pointer_ to the value for the key, if it exists, else\n    /// a pointer to `0`. If the pointer is non-zero the associated value can be\n    /// read to a `MemoryKVVal` with `LibMemoryKV.readPtrVal`.\n    function getPtr(\n        MemoryKV kv_,\n        MemoryKVKey k_\n    ) internal pure returns (MemoryKVPtr ptr_) {\n        uint256 mask_ = MASK_16BIT;\n        assembly (\"memory-safe\") {\n            // loop until k found or give up if ptr is zero\n            for {\n                ptr_ := and(kv_, mask_)\n            } iszero(iszero(ptr_)) {\n                ptr_ := mload(add(ptr_, 0x40))\n            } {\n                if eq(k_, mload(ptr_)) {\n                    break\n                }\n            }\n        }\n    }\n\n    /// Upserts a value in the set by its key. I.e. if the key exists then the\n    /// associated value will be mutated in place, else a new key/value pair will\n    /// be inserted. The key/value store pointer will be mutated and returned as\n    /// it MAY point to a new list item in memory.\n    /// @param kv_ The key/value store pointer to modify.\n    /// @param k_ The key to upsert against.\n    /// @param v_ The value to associate with the upserted key.\n    /// @return The final value of `kv_` as it MAY be modified if the upsert\n    /// resulted in an insert operation.\n    function setVal(\n        MemoryKV kv_,\n        MemoryKVKey k_,\n        MemoryKVVal v_\n    ) internal pure returns (MemoryKV) {\n        MemoryKVPtr ptr_ = getPtr(kv_, k_);\n        uint256 mask_ = MASK_16BIT;\n        // update\n        if (MemoryKVPtr.unwrap(ptr_) > 0) {\n            assembly (\"memory-safe\") {\n                mstore(add(ptr_, 0x20), v_)\n            }\n        }\n        // insert\n        else {\n            assembly (\"memory-safe\") {\n                // allocate new memory\n                ptr_ := mload(0x40)\n                mstore(0x40, add(ptr_, 0x60))\n                // set k/v/ptr\n                mstore(ptr_, k_)\n                mstore(add(ptr_, 0x20), v_)\n                mstore(add(ptr_, 0x40), and(kv_, mask_))\n                // kv must point to new insertion and update array len\n                kv_ := or(\n                    // inc len by 2\n                    shl(16, add(shr(16, kv_), 2)),\n                    // set ptr\n                    ptr_\n                )\n            }\n        }\n        return kv_;\n    }\n\n    /// Export/snapshot the underlying linked list of the key/value store into\n    /// a standard `uint256[]`. Reads the total length to preallocate the\n    /// `uint256[]` then walks the entire linked list, copying every key and\n    /// value into the array, until it reaches a pointer to `0`. Note this is a\n    /// one time export, if the key/value store is subsequently mutated the built\n    /// array will not reflect these mutations.\n    /// @param kv_ The entrypoint into the key/value store.\n    /// @return All the keys and values copied pairwise into a `uint256[]`.\n    function toUint256Array(\n        MemoryKV kv_\n    ) internal pure returns (uint256[] memory) {\n        unchecked {\n            uint256 ptr_ = MemoryKV.unwrap(kv_) & MASK_16BIT;\n            uint256 length_ = MemoryKV.unwrap(kv_) >> 16;\n            uint256[] memory arr_ = new uint256[](length_);\n            assembly (\"memory-safe\") {\n                for {\n                    let cursor_ := add(arr_, 0x20)\n                    let end_ := add(cursor_, mul(mload(arr_), 0x20))\n                } lt(cursor_, end_) {\n                    cursor_ := add(cursor_, 0x20)\n                    ptr_ := mload(add(ptr_, 0x40))\n                } {\n                    // key\n                    mstore(cursor_, mload(ptr_))\n                    cursor_ := add(cursor_, 0x20)\n                    // value\n                    mstore(cursor_, mload(add(ptr_, 0x20)))\n                }\n            }\n            return arr_;\n        }\n    }\n}\n"
    },
    "contracts/lobby/Lobby.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"../array/LibUint256Array.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../interpreter/deploy/IExpressionDeployerV1.sol\";\nimport \"../interpreter/run/IInterpreterV1.sol\";\nimport \"../interpreter/run/LibEncodedDispatch.sol\";\nimport \"../interpreter/run/LibStackPointer.sol\";\nimport \"../interpreter/run/LibContext.sol\";\nimport \"../math/SaturatingMath.sol\";\nimport \"../math/FixedPointMath.sol\";\n\nimport \"../phased/Phased.sol\";\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\n/// Configuration for a `Lobby` to initialize.\n/// @param refMustAgree If `true` the ref must agree to be the ref before ANY\n/// players can join. This guards against the ref being entirely unaware of the\n/// lobby and therefore unlikely to sign any data beyond generic results. This\n/// MAY be `false` if the outcome of the `Lobby` can be inferred by entirely\n/// generic data that the ref is likely to publish regardless of the `Lobby`,\n/// such as a winner list that can be produced upon demand from some API.\n/// @param ref The ref is some address that is expected to provide signatures of\n/// the results that allow the `Lobby` to complete or move to invalid.\nstruct LobbyConfig {\n    bool refMustAgree;\n    address ref;\n    address expressionDeployer;\n    address interpreter;\n    address token;\n    StateConfig stateConfig;\n    // ipfs hash or similar of description and rules etc. that can be in json\n    // for GUI.\n    bytes description;\n    // timeout the whole lobby after this many seconds.\n    uint256 timeoutDuration;\n}\n\n/// @dev A player is attempting to join.\n/// This expression is responsible for:\n/// - Any access gating using `ensure` to error ineligible players\n/// - Calculating an amount of the token buyin\n/// - Starting the event by returning 0 or 1+ as truthy value\n/// Future versions could support multi-token buyins\nSourceIndex constant ENTRYPOINT_JOIN = SourceIndex.wrap(0);\n\n/// @dev A player is attempting to leave.\n/// This expression is responsible for:\n/// - Enforcing cooldowns and other reasons a player cannot leave\n/// - Calculating an amount to refund (will be capped by Lobby to their initial deposit)\n/// Expression has access to the player's initial deposit in context so can use it\n/// for\nSourceIndex constant ENTRYPOINT_LEAVE = SourceIndex.wrap(1);\n\n/// @dev A claim is being processed.\n/// This expression is responsible for:\n/// - Calculating pro rata shares of the caller, can include ref fees etc.\n/// - Ensuring the sanity of the results provided by the ref as claim will be\n///   called as the event is completing.\n/// The expression MAY revert for invalid results but should return 0 for any\n/// caller that is merely not entitled to claim tokens.\nSourceIndex constant ENTRYPOINT_CLAIM = SourceIndex.wrap(2);\n\n/// @dev The ref has declared an invalid result, or there is some other reason\n/// the `Lobby` is invalid. The expression DOES NOT have to cover the case of\n/// the ref failing to sign anything at all as this will be handled by the\n/// hardcoded timeout value.\nSourceIndex constant ENTRYPOINT_INVALID = SourceIndex.wrap(3);\n\n// Need an amount (can be 0) for join deposits and a truthy value to start the event.\nuint256 constant JOIN_MIN_OUTPUTS = 2;\nuint256 constant JOIN_MAX_OUTPUTS = 2;\n\n// Only need an amount (can be 0) for leave refunds.\nuint256 constant LEAVE_MIN_OUTPUTS = 1;\nuint256 constant LEAVE_MAX_OUTPUTS = 2;\n\n// Need the share for a claim.\nuint256 constant CLAIM_MIN_OUTPUTS = 1;\nuint256 constant CLAIM_MAX_OUTPUTS = 1;\n\nuint256 constant INVALID_MIN_OUTPUTS = 1;\nuint256 constant INVALID_MAX_OUTPUTS = 1;\n\n// Event is waiting for the ref to agree to ref.\nuint256 constant PHASE_REF_PENDING = 0;\n// Event is waiting for players to join.\nuint256 constant PHASE_PLAYERS_PENDING = 1;\n// Event has started and is waiting a result from the ref.\nuint256 constant PHASE_RESULT_PENDING = 2;\n// Event is complete with a result from the ref.\nuint256 constant PHASE_COMPLETE = 3;\n// Event is invalid which entitles everyone _who did not already leave_ a 1:1\n// refund on their deposit.\nuint256 constant PHASE_INVALID = 4;\n\n// Phased is a contract in the rain repo that allows contracts to move sequentially\n// through phases and restrict logic by phase.\ncontract Lobby is Phased, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using LibUint256Array for uint256;\n    using LibUint256Array for uint256[];\n    using LibStackPointer for uint256[];\n    using LibStackPointer for StackPointer;\n    using Math for uint256;\n    using SaturatingMath for uint256;\n    using FixedPointMath for uint256;\n\n    event Initialize(address sender, LobbyConfig config);\n\n    event Deposit(address sender, address token, uint256 amount);\n\n    event Join(address sender);\n\n    event Leave(address sender, address token, uint256 deposit, uint256 amount);\n\n    event PlayersFinalised(address sender);\n\n    /// Emitted when a refund is processed for `msg.sender` MAY be less than the\n    /// original deposit if the `leave` expression reduces it. MAY NOT be greater\n    /// than the original deposit.\n    /// @param sender `msg.sender` that the refund is processed for.\n    event Refund(address sender, uint256 amount);\n\n    event Claim(address sender, uint256 share, uint256 amount);\n\n    /// Emitted when a `Lobby` is declared invalid by a ref or some other\n    /// condition such as the timeout being reached.\n    event Invalid(\n        address sender,\n        uint256[] callerContext,\n        SignedContext[] signedContext\n    );\n\n    uint256 internal immutable maxTimeoutDuration;\n    uint256 internal timeoutAt;\n\n    bytes32 internal resultHash;\n\n    address internal ref;\n    IERC20 internal token;\n    IInterpreterV1 internal interpreter;\n    address internal expression;\n\n    mapping(address => uint256) internal players;\n    mapping(address => uint256) internal deposits;\n    uint256 internal totalDeposited;\n    mapping(address => uint256) internal shares;\n    uint256 internal totalShares;\n    mapping(address => uint256) internal withdrawals;\n\n    /// A max timeout is enforced in the constructor so that all cloned proxies\n    /// share it, which prevents an initiator from setting a far future timeout\n    /// and effectively disabling it to trap funds.\n    constructor(uint256 maxTimeoutDuration_) {\n        maxTimeoutDuration = maxTimeoutDuration_;\n    }\n\n    function initialize(LobbyConfig calldata config_) external initializer {\n        // anon initializes with the passed config\n        // we initialize rather than construct as there would be some factory\n        // producing cheap clones of an implementation contract\n\n        initializePhased();\n        __ReentrancyGuard_init();\n\n        // immediately move to pending player phase if ref doesn't need to agree\n        if (!config_.refMustAgree) {\n            schedulePhase(PHASE_PLAYERS_PENDING, block.timestamp);\n        }\n\n        require(config_.timeoutDuration <= maxTimeoutDuration, \"MAX_TIMEOUT\");\n        timeoutAt = block.timestamp + config_.timeoutDuration;\n\n        // This deploys the expression data, we specify the min return values for\n        // each entrypoint by index, the deployer will dry run the expression and\n        // confirm at least the number of specified outputs will be returned.\n        address expression_ = IExpressionDeployerV1(config_.expressionDeployer)\n            .deployExpression(\n                config_.stateConfig,\n                LibUint256Array.arrayFrom(\n                    JOIN_MIN_OUTPUTS,\n                    LEAVE_MIN_OUTPUTS,\n                    CLAIM_MIN_OUTPUTS\n                )\n            );\n        expression = expression_;\n\n        ref = config_.ref;\n        token = IERC20(config_.token);\n        interpreter = IInterpreterV1(config_.interpreter);\n    }\n\n    function _joinEncodedDispatch() internal view returns (EncodedDispatch) {\n        return LibEncodedDispatch.encode(\n            expression,\n            ENTRYPOINT_JOIN,\n            JOIN_MAX_OUTPUTS\n        );\n    }\n\n    function _leaveEncodedDispatch() internal view returns (EncodedDispatch) {\n        return LibEncodedDispatch.encode(\n            expression,\n            ENTRYPOINT_LEAVE,\n            LEAVE_MAX_OUTPUTS\n        );\n    }\n\n    function _claimEncodedDispatch() internal view returns (EncodedDispatch) {\n        return LibEncodedDispatch.encode(\n            expression,\n            ENTRYPOINT_CLAIM,\n            CLAIM_MAX_OUTPUTS\n        );\n    }\n\n    function _invalidEncodedDispatch() internal view returns (EncodedDispatch) {\n        return LibEncodedDispatch.encode(\n            expression,\n            ENTRYPOINT_INVALID,\n            INVALID_MAX_OUTPUTS\n        );\n    }\n\n    /// Enforces that only the ref can call the modified function.\n    modifier onlyRef() {\n        require(msg.sender == ref, \"ONLY_REF\");\n        _;\n    }\n\n    /// Enforces that anyone other than the ref can call the modified function.\n    modifier onlyNonRef() {\n        require(msg.sender != ref, \"ONLY_NON_REF\");\n        _;\n    }\n\n    /// Enforces that only players who joined can call the modified function.\n    modifier onlyPlayer() {\n        require(players[msg.sender] > 0, \"ONLY_PLAYER\");\n        _;\n    }\n\n    /// Enforces that only non-players can call the modified function.\n    modifier onlyNonPlayer() {\n        require(players[msg.sender] == 0, \"ONLY_NON_PLAYER\");\n        _;\n    }\n\n    /// Allow the ref to agree to the lobby.\n    /// This is optionally required by the init config.\n    /// If it is required then players cannot join until this is called.\n    function refAgrees() external onlyRef onlyPhase(PHASE_REF_PENDING) {\n        schedulePhase(PHASE_PLAYERS_PENDING, block.timestamp);\n    }\n\n    function _deposit(uint256 amount_) internal {\n        deposits[msg.sender] = amount_;\n        totalDeposited += amount_;\n        token.safeTransferFrom(msg.sender, address(this), amount_);\n        emit Deposit(msg.sender, address(token), amount_);\n    }\n\n    // At any time anyone can deposit without joining or leaving.\n    // This will become available to claimants.\n    function deposit(uint256 amount_) external nonReentrant {\n        _deposit(amount_);\n    }\n\n    function join(\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    )\n        external\n        onlyPhase(PHASE_PLAYERS_PENDING)\n        onlyNonPlayer\n        onlyNonRef\n        nonReentrant\n    {\n        unchecked {\n            IInterpreterV1 interpreter_ = interpreter;\n            (\n                uint256[] memory stack_,\n                uint256[] memory stateChanges_\n            ) = interpreter_.eval(\n                    _joinEncodedDispatch(),\n                    LibContext.build(\n                        new uint256[][](0),\n                        callerContext_,\n                        signedContexts_\n                    )\n                );\n            uint256 playersFinalised_ = stack_[stack_.length - 2];\n            uint256 amount_ = stack_[stack_.length - 1];\n\n            players[msg.sender] = 1;\n            interpreter_.stateChanges(stateChanges_);\n            _deposit(amount_);\n\n            emit Join(msg.sender);\n\n            // Atomically finalise the player list with the player joining.\n            if (playersFinalised_ > 0) {\n                schedulePhase(PHASE_RESULT_PENDING, block.timestamp);\n                emit PlayersFinalised(msg.sender);\n            }\n        }\n    }\n\n    function leave(\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContext_\n    ) external onlyPhase(PHASE_PLAYERS_PENDING) onlyPlayer nonReentrant {\n        players[msg.sender] = 0;\n        uint256 deposit_ = deposits[msg.sender];\n\n        (\n            uint256[] memory stack_,\n            uint256[] memory stateChanges_\n        ) = IInterpreterV1(interpreter).eval(\n                _leaveEncodedDispatch(),\n                LibContext.build(\n                    new uint256[][](0),\n                    callerContext_,\n                    signedContext_\n                )\n            );\n        // Use the smaller of the interpreter amount and the player's original\n        // deposit as the amount they will be refunded.\n        uint256 amount_ = stack_.asStackPointerAfter().peek().min(deposit_);\n        // the calculated amount is refunded and their entire deposit forfeited\n        // from the internal ledger.\n        IERC20(token).safeTransfer(msg.sender, amount_);\n        deposits[msg.sender] = 0;\n        totalDeposited -= amount_;\n        IInterpreterV1(interpreter).stateChanges(stateChanges_);\n\n        emit Leave(msg.sender, address(token), deposit_, amount_);\n    }\n\n    function claim(\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) external onlyAtLeastPhase(PHASE_RESULT_PENDING) onlyNotPhase(PHASE_INVALID) nonReentrant {\n        bytes32 signedContextsHash_ = LibContext.hash(signedContexts_);\n\n        // The first time claim is called we move to complete and register the\n        // hash of the signed context used to phase shift.\n        if (currentPhase() == PHASE_RESULT_PENDING) {\n            require(resultHash == 0, \"HASH_SET\");\n            resultHash = signedContextsHash_;\n            schedulePhase(PHASE_COMPLETE, block.timestamp);\n        }\n\n        if (currentPhase() != PHASE_COMPLETE) {\n            revert BadPhase();\n        }\n\n        require(resultHash == signedContextsHash_, \"BAD_HASH\");\n\n        // Calculating a claimant's share is a 1 time thing. Dynamic shares aren't\n        // supported, the expression MUST ensure that each user has a stable share\n        // and that all shares add up to 1 across all claimants.\n        if (shares[msg.sender] == 0) {\n            (\n                uint256[] memory stack_,\n                uint256[] memory stateChanges_\n            ) = interpreter.eval(\n                    _claimEncodedDispatch(),\n                    LibContext.build(\n                        new uint256[][](0),\n                        callerContext_,\n                        signedContexts_\n                    )\n                );\n            // Share for this claimant is the smaller of the calculated share and\n            // 1 - shares already claimed.\n            unchecked {\n                shares[msg.sender] = stack_[stack_.length - 1].min(\n                    uint256(1e18).saturatingSub(totalShares)\n                );\n            }\n            if (stateChanges_.length > 0) {\n                interpreter.stateChanges(stateChanges_);\n            }\n        }\n\n        // Send caller their prorata share of total deposits to date and log the\n        // withdrawal so they cannot double-claim. If future deposits are made\n        // they will be eligible to claim their prorata share of the future\n        // deposits.\n        if (shares[msg.sender] > 0) {\n            uint256 amount_ = (totalDeposited - withdrawals[msg.sender])\n                .fixedPointMul(shares[msg.sender]);\n            token.safeTransfer(msg.sender, amount_);\n            withdrawals[msg.sender] = totalDeposited;\n            emit Claim(msg.sender, shares[msg.sender], amount_);\n        }\n    }\n\n    function isInvalid(\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) internal returns (bool) {\n        // Timeouts ALWAYS allow an invalid result, unless the lobby is complete.\n        // This guards against the expressions themselves being buggy and/or the\n        // ref never signing a usable result. This MUST short circuit the logic\n        // below to guard against the invalid entrypoint itself somehow breaking.\n        if (block.timestamp > timeoutAt) {\n            return true;\n        }\n\n        IInterpreterV1 interpreter_ = interpreter;\n        (uint256[] memory stack_, uint256[] memory stateChanges_) = interpreter_\n            .eval(\n                _invalidEncodedDispatch(),\n                LibContext.build(\n                    new uint256[][](0),\n                    callerContext_,\n                    signedContexts_\n                )\n            );\n\n        if (stateChanges_.length > 0) {\n            interpreter_.stateChanges(stateChanges_);\n        }\n\n        unchecked {\n            return stack_[stack_.length - 1] > 0;\n        }\n    }\n\n    function invalid(\n        uint256[] memory callerContext_,\n        SignedContext[] memory signedContexts_\n    ) external onlyNotPhase(PHASE_COMPLETE) {\n        // It is NOT possible to rollback a prior completion. Complete/invalid\n        // are mutually exclusive states because they imply incompatible token\n        // allocations for withdrawal, which would lead to a bank run and/or\n        // locked tockens in the contract.\n        // Note that the logic below will move the Lobby _through_ the complete\n        // phase to the invalid phase, but this happens atomically within this\n        // function call so there's no way that `claim` can be called before\n        // `refund` is enabled.\n        require(isInvalid(callerContext_, signedContexts_), \"NOT_INVALID\");\n\n        // Fast forward all phases to invalid.\n        while (currentPhase() < PHASE_INVALID) {\n            schedulePhase(currentPhase() + 1, block.timestamp);\n        }\n        emit Invalid(msg.sender, callerContext_, signedContexts_);\n    }\n\n    function refund() external onlyPhase(PHASE_INVALID) {\n        uint256 amount_ = deposits[msg.sender];\n        token.safeTransfer(msg.sender, amount_);\n        deposits[msg.sender] = 0;\n        emit Refund(msg.sender, amount_);\n    }\n}\n"
    },
    "contracts/lobby/LobbyFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport {ClonesUpgradeable as Clones} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\nimport \"./Lobby.sol\";\n\n/// @title LobbyFactory\n/// @notice Factory for deploying and registering `Lobby` contracts.\ncontract LobbyFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor(uint256 maxTimeoutDuration_) {\n        address implementation_ = address(new Lobby(maxTimeoutDuration_));\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(\n        bytes memory data_\n    ) internal virtual override returns (address) {\n        LobbyConfig memory config_ = abi.decode(data_, (LobbyConfig));\n        address clone_ = Clones.clone(implementation);\n        Lobby(clone_).initialize(config_);\n        return clone_;\n    }\n\n    /// Allows calling `createChild` with `LobbyConfig` struct.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `Lobby` constructor configuration.\n    /// @return New `Lobby` child contract address.\n    function createChildTyped(\n        LobbyConfig memory config_\n    ) external returns (Lobby) {\n        return Lobby(createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "contracts/math/Binary.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\n/// @dev Binary 1.\nuint256 constant B_1 = 2 ** 1 - 1;\n/// @dev Binary 11.\nuint256 constant B_11 = 2 ** 2 - 1;\n/// @dev Binary 111.\nuint256 constant B_111 = 2 ** 3 - 1;\n/// @dev Binary 1111.\nuint256 constant B_1111 = 2 ** 4 - 1;\n/// @dev Binary 11111.\nuint256 constant B_11111 = 2 ** 5 - 1;\n/// @dev Binary 111111.\nuint256 constant B_111111 = 2 ** 6 - 1;\n/// @dev Binary 1111111.\nuint256 constant B_1111111 = 2 ** 7 - 1;\n/// @dev Binary 11111111.\nuint256 constant B_11111111 = 2 ** 8 - 1;\n/// @dev Binary 111111111.\nuint256 constant B_111111111 = 2 ** 9 - 1;\n/// @dev Binary 1111111111.\nuint256 constant B_1111111111 = 2 ** 10 - 1;\n/// @dev Binary 11111111111.\nuint256 constant B_11111111111 = 2 ** 11 - 1;\n/// @dev Binary 111111111111.\nuint256 constant B_111111111111 = 2 ** 12 - 1;\n/// @dev Binary 1111111111111.\nuint256 constant B_1111111111111 = 2 ** 13 - 1;\n/// @dev Binary 11111111111111.\nuint256 constant B_11111111111111 = 2 ** 14 - 1;\n/// @dev Binary 111111111111111.\nuint256 constant B_111111111111111 = 2 ** 15 - 1;\n/// @dev Binary 1111111111111111.\nuint256 constant B_1111111111111111 = 2 ** 16 - 1;\n\n/// @dev Bitmask for 1 bit.\nuint256 constant MASK_1BIT = B_1;\n/// @dev Bitmask for 2 bits.\nuint256 constant MASK_2BIT = B_11;\n/// @dev Bitmask for 3 bits.\nuint256 constant MASK_3BIT = B_111;\n/// @dev Bitmask for 4 bits.\nuint256 constant MASK_4BIT = B_1111;\n/// @dev Bitmask for 5 bits.\nuint256 constant MASK_5BIT = B_11111;\n/// @dev Bitmask for 6 bits.\nuint256 constant MASK_6BIT = B_111111;\n/// @dev Bitmask for 7 bits.\nuint256 constant MASK_7BIT = B_1111111;\n/// @dev Bitmask for 8 bits.\nuint256 constant MASK_8BIT = B_11111111;\n/// @dev Bitmask for 9 bits.\nuint256 constant MASK_9BIT = B_111111111;\n/// @dev Bitmask for 10 bits.\nuint256 constant MASK_10BIT = B_1111111111;\n/// @dev Bitmask for 11 bits.\nuint256 constant MASK_11BIT = B_11111111111;\n/// @dev Bitmask for 12 bits.\nuint256 constant MASK_12BIT = B_111111111111;\n/// @dev Bitmask for 13 bits.\nuint256 constant MASK_13BIT = B_1111111111111;\n/// @dev Bitmask for 14 bits.\nuint256 constant MASK_14BIT = B_11111111111111;\n/// @dev Bitmask for 15 bits.\nuint256 constant MASK_15BIT = B_111111111111111;\n/// @dev Bitmask for 16 bits.\nuint256 constant MASK_16BIT = B_1111111111111111;\n"
    },
    "contracts/math/FixedPointMath.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {SafeCastUpgradeable as SafeCast} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport \"../math/SaturatingMath.sol\";\n\n/// @dev The scale of all fixed point math. This is adopting the conventions of\n/// both ETH (wei) and most ERC20 tokens, so is hopefully uncontroversial.\nuint256 constant FP_DECIMALS = 18;\n/// @dev The number `1` in the standard fixed point math scaling. Most of the\n/// differences between fixed point math and regular math is multiplying or\n/// dividing by `ONE` after the appropriate scaling has been applied.\nuint256 constant FP_ONE = 1e18;\n\n/// @title FixedPointMath\n/// @notice Sometimes we want to do math with decimal values but all we have\n/// are integers, typically uint256 integers. Floats are very complex so we\n/// don't attempt to simulate them. Instead we provide a standard definition of\n/// \"one\" as 10 ** 18 and scale everything up/down to this as fixed point math.\n///\n/// Overflows SATURATE rather than error, e.g. scaling max uint256 up will result\n/// in max uint256. The max uint256 as decimal is roughly 1e77 so scaling values\n/// comparable to 1e18 is unlikely to ever saturate in practise. For a typical\n/// use case involving tokens, the entire supply of a token rescaled up a full\n/// 18 decimals would still put it \"only\" in the region of ~1e40 which has a full\n/// 30 orders of magnitude buffer before running into saturation issues. However,\n/// there's no theoretical reason that a token or any other use case couldn't use\n/// large numbers or extremely precise decimals that would push this library to\n/// saturation point, so it MUST be treated with caution around the edge cases.\n///\n/// One case where values could come near the saturation/overflow point is phantom\n/// overflow. This is where an overflow happens during the internal logic of some\n/// operation like \"fixed point multiplication\" even though the final result fits\n/// within uint256. The fixed point multiplication and division functions are\n/// thin wrappers around Open Zeppelin's `mulDiv` function, that handles phantom\n/// overflow, reducing the problems of rescaling overflow/saturation to the input\n/// and output range rather than to the internal implementation details. For this\n/// library that gives an additional full 18 orders of magnitude for safe fixed\n/// point multiplication operations.\n///\n/// Note that scaling down ANY fixed point decimal also reduces the precision\n/// which lead to dust or in the worst case trapped funds if subsequent\n/// subtraction overflows a rounded-down number. Consider using saturating\n/// subtraction for safety against previously downscaled values, and whether\n/// trapped dust is a significant issue. If you need to retain full/arbitrary\n/// precision in the case of downscaling DO NOT use this library.\nlibrary FixedPointMath {\n    using Math for uint256;\n    using SafeCast for int256;\n    using SaturatingMath for uint256;\n\n    /// Scale a fixed point decimal of some scale factor to match `DECIMALS`.\n    /// @param a_ Some fixed point decimal value.\n    /// @param aDecimals_ The number of fixed decimals of `a_`.\n    /// @return `a_` scaled to match `DECIMALS`.\n    function scale18(\n        uint256 a_,\n        uint256 aDecimals_\n    ) internal pure returns (uint256) {\n        uint256 decimals_;\n        if (FP_DECIMALS == aDecimals_) {\n            return a_;\n        } else if (FP_DECIMALS > aDecimals_) {\n            unchecked {\n                decimals_ = FP_DECIMALS - aDecimals_;\n            }\n            return a_.saturatingMul(10 ** decimals_);\n        } else {\n            unchecked {\n                decimals_ = aDecimals_ - FP_DECIMALS;\n            }\n            return a_ / 10 ** decimals_;\n        }\n    }\n\n    /// Scale a fixed point decimals of `DECIMALS` to some other scale.\n    /// @param a_ A `DECIMALS` fixed point decimals.\n    /// @param targetDecimals_ The new scale of `a_`.\n    /// @return `a_` rescaled from `DECIMALS` to `targetDecimals_`.\n    function scaleN(\n        uint256 a_,\n        uint256 targetDecimals_\n    ) internal pure returns (uint256) {\n        uint256 decimals_;\n        if (targetDecimals_ == FP_DECIMALS) {\n            return a_;\n        } else if (FP_DECIMALS > targetDecimals_) {\n            unchecked {\n                decimals_ = FP_DECIMALS - targetDecimals_;\n            }\n            return a_ / 10 ** decimals_;\n        } else {\n            unchecked {\n                decimals_ = targetDecimals_ - FP_DECIMALS;\n            }\n            return a_.saturatingMul(10 ** decimals_);\n        }\n    }\n\n    /// Scale a fixed point decimals of `DECIMALS` that represents a ratio of\n    /// a_:b_ according to the decimals of a and b that MAY NOT be `DECIMALS`.\n    /// i.e. a subsequent call to `a_.fixedPointMul(ratio_)` would yield the value\n    /// that it would have as though `a_` and `b_` were both `DECIMALS` and we\n    /// hadn't rescaled the ratio.\n    function scaleRatio(\n        uint256 ratio_,\n        uint8 aDecimals_,\n        uint8 bDecimals_\n    ) internal pure returns (uint256) {\n        return\n            scaleBy(\n                ratio_,\n                (int256(uint(bDecimals_)) - int256(uint256(aDecimals_)))\n                    .toInt8()\n            );\n    }\n\n    /// Scale a fixed point up or down by `scaleBy_` orders of magnitude.\n    /// The caller MUST ensure the end result matches `DECIMALS` if other\n    /// functions in this library are to work correctly.\n    /// Notably `scaleBy` is a SIGNED integer so scaling down by negative OOMS\n    /// is supported.\n    /// @param a_ Some integer of any scale.\n    /// @param scaleBy_ OOMs to scale `a_` up or down by.\n    /// @return `a_` rescaled according to `scaleBy_`.\n    function scaleBy(\n        uint256 a_,\n        int8 scaleBy_\n    ) internal pure returns (uint256) {\n        if (scaleBy_ == 0) {\n            return a_;\n        } else if (scaleBy_ > 0) {\n            return a_.saturatingMul(10 ** uint8(scaleBy_));\n        } else {\n            uint256 posScaleDownBy_;\n            unchecked {\n                posScaleDownBy_ = uint8(-1 * scaleBy_);\n            }\n            return a_ / 10 ** posScaleDownBy_;\n        }\n    }\n\n    /// Fixed point multiplication in native scale decimals.\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` multiplied by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointMul(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        return a_.mulDiv(b_, FP_ONE);\n    }\n\n    /// Overloaded `fixedPointMul` that exposes underlying `mulDiv` rounding.\n    function fixedPointMul(\n        uint256 a_,\n        uint256 b_,\n        Math.Rounding rounding_\n    ) internal pure returns (uint256) {\n        return a_.mulDiv(b_, FP_ONE, rounding_);\n    }\n\n    /// Fixed point division in native scale decimals.\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` divided by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointDiv(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        return a_.mulDiv(FP_ONE, b_);\n    }\n\n    /// Overloaded `fixedPointDiv` that exposes underlying `mulDiv` rounding.\n    function fixedPointDiv(\n        uint256 a_,\n        uint256 b_,\n        Math.Rounding rounding_\n    ) internal pure returns (uint256) {\n        return a_.mulDiv(FP_ONE, b_, rounding_);\n    }\n}\n"
    },
    "contracts/math/SaturatingMath.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// @title SaturatingMath\n/// @notice Sometimes we neither want math operations to error nor wrap around\n/// on an overflow or underflow. In the case of transferring assets an error\n/// may cause assets to be locked in an irretrievable state within the erroring\n/// contract, e.g. due to a tiny rounding/calculation error. We also can't have\n/// assets underflowing and attempting to approve/transfer \"infinity\" when we\n/// wanted \"almost or exactly zero\" but some calculation bug underflowed zero.\n/// Ideally there are no calculation mistakes, but in guarding against bugs it\n/// may be safer pragmatically to saturate arithmatic at the numeric bounds.\n/// Note that saturating div is not supported because 0/0 is undefined.\nlibrary SaturatingMath {\n    /// Saturating addition.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return Minimum of a_ + b_ and max uint256.\n    function saturatingAdd(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 c_ = a_ + b_;\n            return c_ < a_ ? type(uint256).max : c_;\n        }\n    }\n\n    /// Saturating subtraction.\n    /// @param a_ Minuend.\n    /// @param b_ Subtrahend.\n    /// @return Maximum of a_ - b_ and 0.\n    function saturatingSub(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        unchecked {\n            return a_ > b_ ? a_ - b_ : 0;\n        }\n    }\n\n    /// Saturating multiplication.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return Minimum of a_ * b_ and max uint256.\n    function saturatingMul(\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being\n            // zero, but the benefit is lost if 'b' is also tested.\n            // https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a_ == 0) return 0;\n            uint256 c_ = a_ * b_;\n            return c_ / a_ != b_ ? type(uint256).max : c_;\n        }\n    }\n}\n"
    },
    "contracts/memory/LibMemorySize.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.10;\n\n/// @title LibMemorySize\n/// @notice Reports the size in bytes of type data that represents contigious\n/// regions of memory. Pointers to regions of memory that may not be congigious\n/// are not supported, e.g. fields on structs may point to dynamic data that is\n/// separate to the struct. Length slots for dynamic data are included in the\n/// size and the size is always measured in bytes.\nlibrary LibMemorySize {\n    /// Reports the size of a `uint256` in bytes. Is always 32.\n    /// @return 32.\n    function size(uint256) internal pure returns (uint256) {\n        return 0x20;\n    }\n\n    /// Reports the size of a `uint256[]` in bytes. Is the size of the length\n    /// slot (32 bytes) plus the length of the array multiplied by 32 bytes per\n    /// item.\n    /// @return The size of the array data including its length slot size.\n    function size(uint256[] memory array_) internal pure returns (uint256) {\n        unchecked {\n            return 0x20 + (array_.length * 0x20);\n        }\n    }\n\n    /// Reports the size of `bytes` data. Is the size of the length slot\n    /// (32 bytes) plus the number of bytes as per its length.\n    /// @return The size of the `bytes` data including its length slot size.\n    function size(bytes memory bytes_) internal pure returns (uint256) {\n        unchecked {\n            return 0x20 + bytes_.length;\n        }\n    }\n}\n"
    },
    "contracts/orderbook/arb/ZeroExOrderBookFlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {AddressUpgradeable as Address} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../../ierc3156/IERC3156FlashLender.sol\";\nimport \"../../ierc3156/IERC3156FlashBorrower.sol\";\nimport \"../IOrderBookV1.sol\";\n\n// input = USDT\n// output = DAI\n// maximumIORatio = 1.01\n// minimumInput = 100\n// maximumInput = infinity\n\n// flash loan amount = minimumInput = 100\n\n// - some trust has threshold 1% and 100 USDT in the associated vault\n// - 0x is offering 102 DAI per 100 USDT\n// - you flash loan 100 USDT from OB or somewhere else\n// - you sell the 100 USDT to 0x for 102 DAI\n// - give 101 DAI to the trust order and it gives you 100 USDT\n// - the trust now has 101 DAI in it and 0 USDT\n// - you have 100 USDT and 1 DAI\n// - you pay back the 100 USDT flash loan\n// - you have 1 DAI profit and the trust swapped 100 USDT for 101 DAI\n\n// i think the way to do this if the OB is the flash lender is to have it track debt:\n// - same setup as above\n// - bot floash loans 100 USDT from OB, OB records the 100 USDT debt\n// - bot sells 100 USDT to 0x for 102 DAI\n// - bot takesOrder of the trust for 101 DAI and OB _reduces the flash loan debt_ by 100USDT\n// - the trust now has 101 DAI and 0 USDT\n// - the bot has 1 DAI and 0 USDT\n// - OB considers the flash loan repaid so allows the transaction to complete\n\n/// https://github.com/0xProject/0x-api-starter-guide-code/blob/master/contracts/SimpleTokenSwap.sol\ncontract ZeroExOrderBookFlashBorrower is IERC3156FlashBorrower {\n    using Address for address;\n    using SafeERC20 for IERC20;\n\n    address public immutable orderBook;\n    address public immutable zeroExExchangeProxy;\n\n    constructor(address orderBook_, address zeroExExchangeProxy_) {\n        orderBook = orderBook_;\n        zeroExExchangeProxy = zeroExExchangeProxy_;\n    }\n\n    function onFlashLoan(\n        address initiator_,\n        address,\n        uint256,\n        uint256,\n        bytes calldata data_\n    ) external returns (bytes32) {\n        require(msg.sender == orderBook, \"FlashBorrower: Bad lender\");\n        require(initiator_ == address(this), \"FlashBorrower: Bad initiator\");\n\n        (TakeOrdersConfig memory takeOrders_, bytes memory zeroExData_) = abi\n            .decode(data_, (TakeOrdersConfig, bytes));\n\n        // Call the encoded swap function call on the contract at `swapTarget`,\n        // passing along any ETH attached to this function call to cover protocol fees.\n        zeroExExchangeProxy.functionCallWithValue(\n            zeroExData_,\n            address(this).balance\n        );\n\n        IOrderBookV1(orderBook).takeOrders(takeOrders_);\n\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n\n    function arb(\n        TakeOrdersConfig calldata takeOrders_,\n        address zeroExSpender_,\n        bytes calldata zeroExData_\n    ) external {\n        bytes memory data_ = abi.encode(takeOrders_, zeroExData_);\n        // The token we receive from taking the orders is what we will use to\n        // repay the flash loan.\n        address flashLoanToken_ = takeOrders_.input;\n        // We can't repay more than the minimum that the orders are going to\n        // give us and there's no reason to borrow less.\n        uint256 flashLoanAmount_ = takeOrders_.minimumInput;\n\n        // This is overkill to infinite approve every time.\n        // @todo make this hammer smaller.\n        IERC20(takeOrders_.output).safeApprove(orderBook, 0);\n        IERC20(takeOrders_.output).safeIncreaseAllowance(\n            orderBook,\n            type(uint256).max\n        );\n        IERC20(takeOrders_.input).safeApprove(zeroExSpender_, 0);\n        IERC20(takeOrders_.input).safeIncreaseAllowance(\n            zeroExSpender_,\n            type(uint256).max\n        );\n\n        IERC3156FlashLender(orderBook).flashLoan(\n            this,\n            flashLoanToken_,\n            flashLoanAmount_,\n            data_\n        );\n\n        // Refund any unspent 0x protocol fees to the sender.\n        payable(msg.sender).transfer(address(this).balance);\n\n        uint256 inputBalance_ = IERC20(takeOrders_.input).balanceOf(\n            address(this)\n        );\n        if (inputBalance_ > 0) {\n            IERC20(takeOrders_.input).safeTransfer(msg.sender, inputBalance_);\n        }\n        uint256 outputBalance_ = IERC20(takeOrders_.output).balanceOf(\n            address(this)\n        );\n        if (outputBalance_ > 0) {\n            IERC20(takeOrders_.output).safeTransfer(msg.sender, outputBalance_);\n        }\n    }\n}\n"
    },
    "contracts/orderbook/IOrderBookV1.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../interpreter/deploy/IExpressionDeployerV1.sol\";\nimport \"../interpreter/run/IInterpreterV1.sol\";\n\nstruct DepositConfig {\n    address token;\n    uint256 vaultId;\n    uint256 amount;\n}\n\nstruct WithdrawConfig {\n    address token;\n    uint256 vaultId;\n    uint256 amount;\n}\n\nstruct IO {\n    address token;\n    uint8 decimals;\n    uint256 vaultId;\n}\n\nstruct OrderConfig {\n    address expressionDeployer;\n    address interpreter;\n    StateConfig interpreterStateConfig;\n    IO[] validInputs;\n    IO[] validOutputs;\n    bytes data;\n}\n\nstruct Order {\n    address owner;\n    address interpreter;\n    EncodedDispatch dispatch;\n    EncodedDispatch handleIODispatch;\n    IO[] validInputs;\n    IO[] validOutputs;\n    bytes data;\n}\n\nstruct TakeOrdersConfig {\n    /// Output token from the perspective of the order taker.\n    address output;\n    /// Input token from the perspective of the order taker.\n    address input;\n    /// Minimum input from the perspective of the order taker.\n    uint256 minimumInput;\n    /// Maximum input from the perspective of the order taker.\n    uint256 maximumInput;\n    /// Maximum IO ratio as calculated by the order being taken. The input is\n    /// from the perspective of the order so higher ratio means worse deal for\n    /// the order taker.\n    uint256 maximumIORatio;\n    /// Ordered list of orders that will be taken until the limit is hit. Takers\n    /// are expected to prioritise orders that appear to be offering better\n    /// deals i.e. lower IO ratios. This prioritisation and sorting MUST happen\n    /// offchain, e.g. via. some simulator.\n    TakeOrderConfig[] orders;\n}\n\nstruct TakeOrderConfig {\n    Order order;\n    uint256 inputIOIndex;\n    uint256 outputIOIndex;\n}\n\nstruct ClearConfig {\n    uint256 aInputIOIndex;\n    uint256 aOutputIOIndex;\n    uint256 bInputIOIndex;\n    uint256 bOutputIOIndex;\n    uint256 aBountyVaultId;\n    uint256 bBountyVaultId;\n}\n\ninterface IOrderBookV1 {\n    /// depositor => token => vault id => token amount.\n    function vaultBalance(\n        address owner,\n        address token,\n        uint256 id\n    ) external view returns (uint256 balance);\n\n    function deposit(DepositConfig calldata config) external;\n\n    function withdraw(WithdrawConfig calldata config) external;\n\n    function addOrder(OrderConfig calldata config) external;\n\n    function removeOrder(Order calldata order) external;\n\n    function takeOrders(\n        TakeOrdersConfig calldata takeOrders\n    ) external returns (uint256 totalInput, uint256 totalOutput);\n\n    function clear(\n        Order memory a,\n        Order memory b,\n        ClearConfig calldata clearConfig\n    ) external;\n}\n"
    },
    "contracts/orderbook/OrderBook.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"./IOrderBookV1.sol\";\nimport \"../interpreter/run/LibStackPointer.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"../math/FixedPointMath.sol\";\nimport \"../interpreter/ops/AllStandardOps.sol\";\nimport \"./OrderBookFlashLender.sol\";\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../interpreter/run/LibEncodedDispatch.sol\";\nimport {MulticallUpgradeable as Multicall} from \"@openzeppelin/contracts-upgradeable/utils/MulticallUpgradeable.sol\";\n\nSourceIndex constant ORDER_ENTRYPOINT = SourceIndex.wrap(0);\nSourceIndex constant HANDLE_IO_ENTRYPOINT = SourceIndex.wrap(1);\n\nuint256 constant ORDER_MIN_OUTPUTS = 2;\nuint256 constant ORDER_MAX_OUTPUTS = 2;\n\nuint256 constant HANDLE_IO_MIN_OUTPUTS = 0;\nuint256 constant HANDLE_IO_MAX_OUTPUTS = type(uint16).max;\n\nuint256 constant CONTEXT_COLUMNS = 4;\nuint256 constant CONTEXT_BASE_COLUMN = 0;\nuint256 constant CONTEXT_CALCULATIONS_COLUMN = 1;\nuint256 constant CONTEXT_VAULT_INPUTS_COLUMN = 2;\nuint256 constant CONTEXT_VAULT_OUTPUTS_COLUMN = 3;\n\nuint256 constant CONTEXT_VAULT_IO_TOKEN = 0;\nuint256 constant CONTEXT_VAULT_IO_TOKEN_DECIMALS = 1;\nuint256 constant CONTEXT_VAULT_IO_VAULT_ID = 2;\nuint256 constant CONTEXT_VAULT_IO_BALANCE_BEFORE = 3;\nuint256 constant CONTEXT_VAULT_IO_BALANCE_DIFF = 4;\nuint256 constant CONTEXT_VAULT_IO_ROWS = 5;\n\nstruct ClearStateChange {\n    uint256 aOutput;\n    uint256 bOutput;\n    uint256 aInput;\n    uint256 bInput;\n}\n\nlibrary LibOrder {\n    function hash(Order memory order_) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encode(order_)));\n    }\n}\n\ncontract OrderBook is\n    IOrderBookV1,\n    ReentrancyGuard,\n    Multicall,\n    OrderBookFlashLender\n{\n    using LibInterpreterState for bytes;\n    using LibStackPointer for StackPointer;\n    using LibStackPointer for uint256[];\n    using LibUint256Array for uint256[];\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n    using FixedPointMath for uint256;\n    using LibOrder for Order;\n    using LibInterpreterState for InterpreterState;\n    using LibUint256Array for uint256;\n\n    event Deposit(address sender, DepositConfig config);\n    /// @param sender `msg.sender` withdrawing tokens.\n    /// @param config All config sent to the `withdraw` call.\n    /// @param amount The amount of tokens withdrawn, can be less than the\n    /// config amount if the vault does not have the funds available to cover\n    /// the config amount.\n    event Withdraw(address sender, WithdrawConfig config, uint256 amount);\n    event AddOrder(address sender, Order order, uint256 orderHash);\n    event RemoveOrder(address sender, Order order, uint256 orderHash);\n    event TakeOrder(\n        address sender,\n        TakeOrderConfig takeOrder,\n        uint256 input,\n        uint256 output\n    );\n    event OrderNotFound(address sender, address owner, uint256 orderHash);\n    event OrderZeroAmount(address sender, address owner, uint256 orderHash);\n    event OrderExceedsMaxRatio(\n        address sender,\n        address owner,\n        uint256 orderHash\n    );\n    event Clear(address sender, Order a, Order b, ClearConfig clearConfig);\n    event AfterClear(ClearStateChange stateChange);\n\n    // order hash => order is live\n    mapping(uint256 => uint256) private orders;\n    /// @inheritdoc IOrderBookV1\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\n        public vaultBalance;\n\n    constructor() initializer {\n        __ReentrancyGuard_init();\n        __Multicall_init();\n    }\n\n    function deposit(DepositConfig calldata config_) external nonReentrant {\n        vaultBalance[msg.sender][config_.token][config_.vaultId] += config_\n            .amount;\n        emit Deposit(msg.sender, config_);\n        IERC20(config_.token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            config_.amount\n        );\n    }\n\n    /// Allows the sender to withdraw any tokens from their own vaults.\n    /// @param config_ All config required to withdraw. Notably if the amount\n    /// is less than the current vault balance then the vault will be cleared\n    /// to 0 rather than the withdraw transaction reverting.\n    function withdraw(WithdrawConfig calldata config_) external nonReentrant {\n        uint256 vaultBalance_ = vaultBalance[msg.sender][config_.token][\n            config_.vaultId\n        ];\n        uint256 withdrawAmount_ = config_.amount.min(vaultBalance_);\n        vaultBalance[msg.sender][config_.token][config_.vaultId] =\n            vaultBalance_ -\n            withdrawAmount_;\n        emit Withdraw(msg.sender, config_, withdrawAmount_);\n        _decreaseFlashDebtThenSendToken(\n            config_.token,\n            msg.sender,\n            withdrawAmount_\n        );\n    }\n\n    function addOrder(OrderConfig calldata config_) external nonReentrant {\n        address expression_ = IExpressionDeployerV1(config_.expressionDeployer)\n            .deployExpression(\n                config_.interpreterStateConfig,\n                LibUint256Array.arrayFrom(\n                    ORDER_MIN_OUTPUTS,\n                    HANDLE_IO_MIN_OUTPUTS\n                )\n            );\n        Order memory order_ = Order(\n            msg.sender,\n            config_.interpreter,\n            LibEncodedDispatch.encode(\n                expression_,\n                ORDER_ENTRYPOINT,\n                ORDER_MAX_OUTPUTS\n            ),\n            config_\n                .interpreterStateConfig\n                .sources[SourceIndex.unwrap(HANDLE_IO_ENTRYPOINT)]\n                .length > 0\n                ? LibEncodedDispatch.encode(\n                    expression_,\n                    HANDLE_IO_ENTRYPOINT,\n                    HANDLE_IO_MAX_OUTPUTS\n                )\n                : EncodedDispatch.wrap(0),\n            config_.validInputs,\n            config_.validOutputs,\n            config_.data\n        );\n        uint256 orderHash_ = order_.hash();\n        orders[orderHash_] = 1;\n        emit AddOrder(msg.sender, order_, orderHash_);\n    }\n\n    function removeOrder(Order calldata order_) external nonReentrant {\n        require(msg.sender == order_.owner, \"OWNER\");\n        uint256 orderHash_ = order_.hash();\n        delete (orders[orderHash_]);\n        emit RemoveOrder(msg.sender, order_, orderHash_);\n    }\n\n    function _calculateOrderIO(\n        Order memory order_,\n        uint256 inputIOIndex_,\n        uint256 outputIOIndex_,\n        address counterparty_\n    )\n        internal\n        view\n        returns (\n            uint256 orderOutputMax_,\n            uint256 orderIORatio_,\n            uint256[][] memory,\n            uint256[] memory\n        )\n    {\n        uint256 orderHash_ = order_.hash();\n        uint256[][] memory context_ = new uint256[][](CONTEXT_COLUMNS);\n\n        {\n            context_[CONTEXT_BASE_COLUMN] = LibUint256Array.arrayFrom(\n                orderHash_,\n                uint256(uint160(order_.owner)),\n                uint256(uint160(counterparty_))\n            );\n\n            context_[CONTEXT_VAULT_INPUTS_COLUMN] = new uint256[](\n                CONTEXT_VAULT_IO_ROWS\n            );\n            context_[CONTEXT_VAULT_OUTPUTS_COLUMN] = new uint256[](\n                CONTEXT_VAULT_IO_ROWS\n            );\n\n            context_[CONTEXT_VAULT_INPUTS_COLUMN][\n                CONTEXT_VAULT_IO_TOKEN\n            ] = uint(uint160(order_.validInputs[inputIOIndex_].token));\n            context_[CONTEXT_VAULT_OUTPUTS_COLUMN][\n                CONTEXT_VAULT_IO_TOKEN\n            ] = uint(uint160(order_.validOutputs[outputIOIndex_].token));\n\n            context_[CONTEXT_VAULT_INPUTS_COLUMN][\n                CONTEXT_VAULT_IO_TOKEN_DECIMALS\n            ] = order_.validInputs[inputIOIndex_].decimals;\n            context_[CONTEXT_VAULT_OUTPUTS_COLUMN][\n                CONTEXT_VAULT_IO_TOKEN_DECIMALS\n            ] = order_.validOutputs[outputIOIndex_].decimals;\n\n            context_[CONTEXT_VAULT_INPUTS_COLUMN][\n                CONTEXT_VAULT_IO_VAULT_ID\n            ] = order_.validInputs[inputIOIndex_].vaultId;\n            context_[CONTEXT_VAULT_OUTPUTS_COLUMN][\n                CONTEXT_VAULT_IO_VAULT_ID\n            ] = order_.validOutputs[outputIOIndex_].vaultId;\n\n            context_[CONTEXT_VAULT_INPUTS_COLUMN][\n                CONTEXT_VAULT_IO_BALANCE_BEFORE\n            ] = vaultBalance[order_.owner][\n                order_.validInputs[inputIOIndex_].token\n            ][order_.validInputs[inputIOIndex_].vaultId];\n            context_[CONTEXT_VAULT_OUTPUTS_COLUMN][\n                CONTEXT_VAULT_IO_BALANCE_BEFORE\n            ] = vaultBalance[order_.owner][\n                order_.validOutputs[outputIOIndex_].token\n            ][order_.validOutputs[outputIOIndex_].vaultId];\n        }\n\n        // The state changes produced here are handled in _recordVaultIO so that\n        // local storage writes happen before writes on the interpreter.\n        (\n            uint256[] memory stack_,\n            uint256[] memory stateChanges_\n        ) = IInterpreterV1(order_.interpreter).evalWithNamespace(\n                StateNamespace.wrap(uint(uint160(order_.owner))),\n                order_.dispatch,\n                context_\n            );\n        (orderOutputMax_, orderIORatio_) = stack_.asStackPointerAfter().peek2();\n\n        // Rescale order output max from 18 FP to whatever decimals the output\n        // token is using.\n        orderOutputMax_ = orderOutputMax_.scaleN(\n            order_.validOutputs[outputIOIndex_].decimals\n        );\n        // Rescale the ratio from 18 FP according to the difference in decimals\n        // between input and output.\n        orderIORatio_ = orderIORatio_.scaleRatio(\n            order_.validOutputs[outputIOIndex_].decimals,\n            order_.validInputs[inputIOIndex_].decimals\n        );\n\n        uint256[] memory calculationsContext_ = new uint256[](2);\n        calculationsContext_[0] = orderOutputMax_;\n        calculationsContext_[1] = orderIORatio_;\n        context_[CONTEXT_CALCULATIONS_COLUMN] = calculationsContext_;\n\n        // The order owner can't send more than the smaller of their vault\n        // balance or their per-order limit.\n        orderOutputMax_ = orderOutputMax_.min(\n            vaultBalance[order_.owner][\n                order_.validOutputs[outputIOIndex_].token\n            ][order_.validOutputs[outputIOIndex_].vaultId]\n        );\n\n        return (orderOutputMax_, orderIORatio_, context_, stateChanges_);\n    }\n\n    function _recordVaultIO(\n        Order memory order_,\n        uint256 input_,\n        uint256 output_,\n        uint256[][] memory context_,\n        uint256[] memory stateChangesCalculate_\n    ) internal {\n        context_[CONTEXT_VAULT_INPUTS_COLUMN][\n            CONTEXT_VAULT_IO_BALANCE_DIFF\n        ] = input_;\n        context_[CONTEXT_VAULT_OUTPUTS_COLUMN][\n            CONTEXT_VAULT_IO_BALANCE_DIFF\n        ] = output_;\n\n        if (input_ > 0) {\n            // IMPORTANT! THIS MATH MUST BE CHECKED TO AVOID OVERFLOW.\n            vaultBalance[order_.owner][\n                address(\n                    uint160(\n                        context_[CONTEXT_VAULT_INPUTS_COLUMN][\n                            CONTEXT_VAULT_IO_TOKEN\n                        ]\n                    )\n                )\n            ][\n                context_[CONTEXT_VAULT_INPUTS_COLUMN][CONTEXT_VAULT_IO_VAULT_ID]\n            ] += input_;\n        }\n        if (output_ > 0) {\n            // IMPORTANT! THIS MATH MUST BE CHECKED TO AVOID UNDERFLOW.\n            vaultBalance[order_.owner][\n                address(\n                    uint160(\n                        context_[CONTEXT_VAULT_OUTPUTS_COLUMN][\n                            CONTEXT_VAULT_IO_TOKEN\n                        ]\n                    )\n                )\n            ][\n                context_[CONTEXT_VAULT_OUTPUTS_COLUMN][\n                    CONTEXT_VAULT_IO_VAULT_ID\n                ]\n            ] -= output_;\n        }\n\n        if (stateChangesCalculate_.length > 0) {\n            IInterpreterV1(order_.interpreter).stateChangesWithNamespace(\n                StateNamespace.wrap(uint(uint160(order_.owner))),\n                stateChangesCalculate_\n            );\n        }\n        if (EncodedDispatch.unwrap(order_.handleIODispatch) > 0) {\n            (, uint256[] memory stateChangesHandleIO_) = IInterpreterV1(\n                order_.interpreter\n            ).evalWithNamespace(\n                    StateNamespace.wrap(uint(uint160(order_.owner))),\n                    order_.handleIODispatch,\n                    context_\n                );\n            if (stateChangesHandleIO_.length > 0) {\n                IInterpreterV1(order_.interpreter).stateChangesWithNamespace(\n                    StateNamespace.wrap(uint(uint160(order_.owner))),\n                    stateChangesHandleIO_\n                );\n            }\n        }\n    }\n\n    function takeOrders(\n        TakeOrdersConfig calldata takeOrders_\n    )\n        external\n        nonReentrant\n        returns (uint256 totalInput_, uint256 totalOutput_)\n    {\n        uint256 i_ = 0;\n        TakeOrderConfig memory takeOrder_;\n        Order memory order_;\n        uint256 remainingInput_ = takeOrders_.maximumInput;\n        while (i_ < takeOrders_.orders.length && remainingInput_ > 0) {\n            takeOrder_ = takeOrders_.orders[i_];\n            order_ = takeOrder_.order;\n            uint256 orderHash_ = order_.hash();\n            if (orders[orderHash_] == 0) {\n                emit OrderNotFound(msg.sender, order_.owner, orderHash_);\n            } else {\n                require(\n                    order_.validInputs[takeOrder_.inputIOIndex].token ==\n                        takeOrders_.output,\n                    \"TOKEN_MISMATCH\"\n                );\n                require(\n                    order_.validOutputs[takeOrder_.outputIOIndex].token ==\n                        takeOrders_.input,\n                    \"TOKEN_MISMATCH\"\n                );\n\n                (\n                    uint256 orderOutputMax_,\n                    uint256 orderIORatio_,\n                    uint256[][] memory context_,\n                    uint256[] memory stateChangesCalculate_\n                ) = _calculateOrderIO(\n                        order_,\n                        takeOrder_.inputIOIndex,\n                        takeOrder_.outputIOIndex,\n                        msg.sender\n                    );\n\n                // Skip orders that are too expensive rather than revert as we have\n                // no way of knowing if a specific order becomes too expensive\n                // between submitting to mempool and execution, but other orders may\n                // be valid so we want to take advantage of those if possible.\n                if (orderIORatio_ > takeOrders_.maximumIORatio) {\n                    emit OrderExceedsMaxRatio(\n                        msg.sender,\n                        order_.owner,\n                        orderHash_\n                    );\n                } else if (orderOutputMax_ == 0) {\n                    emit OrderZeroAmount(msg.sender, order_.owner, orderHash_);\n                } else {\n                    uint256 input_ = remainingInput_.min(orderOutputMax_);\n                    uint256 output_ = input_.fixedPointMul(orderIORatio_);\n\n                    remainingInput_ -= input_;\n                    totalOutput_ += output_;\n\n                    _recordVaultIO(\n                        order_,\n                        output_,\n                        input_,\n                        context_,\n                        stateChangesCalculate_\n                    );\n                    emit TakeOrder(msg.sender, takeOrder_, input_, output_);\n                }\n            }\n\n            unchecked {\n                i_++;\n            }\n        }\n        totalInput_ = takeOrders_.maximumInput - remainingInput_;\n\n        require(totalInput_ >= takeOrders_.minimumInput, \"MIN_INPUT\");\n\n        IERC20(takeOrders_.output).safeTransferFrom(\n            msg.sender,\n            address(this),\n            totalOutput_\n        );\n        _decreaseFlashDebtThenSendToken(\n            takeOrders_.input,\n            msg.sender,\n            totalInput_\n        );\n    }\n\n    function clear(\n        Order memory a_,\n        Order memory b_,\n        ClearConfig calldata clearConfig_\n    ) external nonReentrant {\n        {\n            require(a_.owner != b_.owner, \"SAME_OWNER\");\n            require(\n                a_.validOutputs[clearConfig_.aOutputIOIndex].token ==\n                    b_.validInputs[clearConfig_.bInputIOIndex].token,\n                \"TOKEN_MISMATCH\"\n            );\n            require(\n                b_.validOutputs[clearConfig_.bOutputIOIndex].token ==\n                    a_.validInputs[clearConfig_.aInputIOIndex].token,\n                \"TOKEN_MISMATCH\"\n            );\n            require(orders[a_.hash()] > 0, \"A_NOT_LIVE\");\n            require(orders[b_.hash()] > 0, \"B_NOT_LIVE\");\n        }\n\n        ClearStateChange memory stateChange_;\n        uint256[][] memory aContext_;\n        uint256[] memory aStateChangesCalculate_;\n        uint256[][] memory bContext_;\n        uint256[] memory bStateChangesCalculate_;\n\n        {\n            // `IORatio` is input per output for both `a_` and `b_`.\n            uint256 aIORatio_;\n            uint256 bIORatio_;\n            // `a_` and `b_` can both set a maximum output from the Interpreter.\n            uint256 aOutputMax_;\n            uint256 bOutputMax_;\n\n            // emit the Clear event before `a_` and `b_` are mutated due to the\n            // Interpreter execution in eval.\n            emit Clear(msg.sender, a_, b_, clearConfig_);\n\n            (\n                aOutputMax_,\n                aIORatio_,\n                aContext_,\n                aStateChangesCalculate_\n            ) = _calculateOrderIO(\n                a_,\n                clearConfig_.aInputIOIndex,\n                clearConfig_.aOutputIOIndex,\n                b_.owner\n            );\n            (\n                bOutputMax_,\n                bIORatio_,\n                bContext_,\n                bStateChangesCalculate_\n            ) = _calculateOrderIO(\n                b_,\n                clearConfig_.bInputIOIndex,\n                clearConfig_.bOutputIOIndex,\n                a_.owner\n            );\n\n            stateChange_.aOutput = aOutputMax_.min(\n                bOutputMax_.fixedPointMul(bIORatio_)\n            );\n            stateChange_.bOutput = bOutputMax_.min(\n                aOutputMax_.fixedPointMul(aIORatio_)\n            );\n\n            require(\n                stateChange_.aOutput > 0 || stateChange_.bOutput > 0,\n                \"0_CLEAR\"\n            );\n\n            stateChange_.aInput = stateChange_.aOutput.fixedPointMul(aIORatio_);\n            stateChange_.bInput = stateChange_.bOutput.fixedPointMul(bIORatio_);\n        }\n\n        _recordVaultIO(\n            a_,\n            stateChange_.aInput,\n            stateChange_.aOutput,\n            aContext_,\n            aStateChangesCalculate_\n        );\n        _recordVaultIO(\n            b_,\n            stateChange_.bInput,\n            stateChange_.bOutput,\n            bContext_,\n            bStateChangesCalculate_\n        );\n\n        {\n            // At least one of these will overflow due to negative bounties if\n            // there is a spread between the orders.\n            uint256 aBounty_ = stateChange_.aOutput - stateChange_.bInput;\n            uint256 bBounty_ = stateChange_.bOutput - stateChange_.aInput;\n            if (aBounty_ > 0) {\n                vaultBalance[msg.sender][\n                    a_.validOutputs[clearConfig_.aOutputIOIndex].token\n                ][clearConfig_.aBountyVaultId] += aBounty_;\n            }\n            if (bBounty_ > 0) {\n                vaultBalance[msg.sender][\n                    b_.validOutputs[clearConfig_.bOutputIOIndex].token\n                ][clearConfig_.bBountyVaultId] += bBounty_;\n            }\n        }\n\n        emit AfterClear(stateChange_);\n    }\n}\n"
    },
    "contracts/orderbook/OrderBookFlashLender.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../ierc3156/IERC3156FlashBorrower.sol\";\nimport \"../ierc3156/IERC3156FlashLender.sol\";\n\n/**\n * @author Alberto Cuesta Cañada\n * @dev Extension of {ERC20} that allows flash lending.\n */\ncontract OrderBookFlashLender is IERC3156FlashLender {\n    bytes32 public constant CALLBACK_SUCCESS =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    using SafeERC20 for IERC20;\n\n    // token => receiver => active debt\n    mapping(address => mapping(address => uint256)) internal activeFlashDebts;\n\n    function _increaseFlashDebtThenSendToken(\n        address token_,\n        address receiver_,\n        uint256 amount_\n    ) internal {\n        activeFlashDebts[token_][receiver_] += amount_;\n        IERC20(token_).safeTransfer(receiver_, amount_);\n    }\n\n    function _decreaseFlashDebtThenSendToken(\n        address token_,\n        address receiver_,\n        uint256 amount_\n    ) internal {\n        uint256 activeFlashDebt_ = activeFlashDebts[token_][receiver_];\n        if (amount_ > activeFlashDebt_) {\n            if (activeFlashDebt_ > 0) {\n                delete activeFlashDebts[token_][receiver_];\n            }\n\n            IERC20(token_).safeTransfer(receiver_, amount_ - activeFlashDebt_);\n        } else {\n            activeFlashDebts[token_][receiver_] -= amount_;\n        }\n    }\n\n    function _finalizeDebt(address token_, address receiver_) internal {\n        uint256 activeFlashDebt_ = activeFlashDebts[token_][receiver_];\n        if (activeFlashDebt_ > 0) {\n            IERC20(token_).safeTransferFrom(\n                receiver_,\n                address(this),\n                activeFlashDebt_\n            );\n            // Once we have the tokens safely in hand decrease the debt.\n            activeFlashDebts[token_][receiver_] -= activeFlashDebt_;\n        }\n        require(activeFlashDebts[token_][receiver_] == 0, \"BAD_DEBT\");\n    }\n\n    /// @inheritdoc IERC3156FlashLender\n    function flashLoan(\n        IERC3156FlashBorrower receiver_,\n        address token_,\n        uint256 amount_,\n        bytes calldata data_\n    ) external override returns (bool) {\n        _increaseFlashDebtThenSendToken(token_, address(receiver_), amount_);\n        require(\n            receiver_.onFlashLoan(msg.sender, token_, amount_, 0, data_) ==\n                CALLBACK_SUCCESS,\n            \"FlashLender: Callback failed\"\n        );\n        _finalizeDebt(token_, address(receiver_));\n        return true;\n    }\n\n    /// @inheritdoc IERC3156FlashLender\n    function flashFee(\n        address,\n        uint256\n    ) external pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @inheritdoc IERC3156FlashLender\n    function maxFlashLoan(\n        address token_\n    ) external view override returns (uint256) {\n        return IERC20(token_).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/phased/Phased.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.4;\n\nerror BadPhase();\n\n/// @title Phased\n/// @notice `Phased` is an abstract contract that defines up to `9` phases that\n/// an implementing contract moves through.\n///\n/// Phase `0` is always the first phase and does not, and cannot, be set\n/// expicitly. Effectively it is implied that phase `0` has been active\n/// since block zero.\n///\n/// Each subsequent phase `1` through `8` must be scheduled sequentially and\n/// explicitly at a block timestamp.\n///\n/// Only the immediate next phase can be scheduled with `scheduleNextPhase`,\n/// it is not possible to schedule multiple phases ahead.\n///\n/// Multiple phases can be scheduled in a single second if each scheduled phase\n/// is scheduled for the current block OR the contract is operating on a chain\n/// with sub-second block times. I.e. if uniqueness of block timestamps is NOT\n/// enforced by a chain then phases scheduling can share a timstamp across\n/// multiple transactions. To enforce uniqueness of timestamps across\n/// transactions on subsecond blockchains, simply schedule the final phase\n/// shift of a transaction in the future.\n///\n/// Several utility functions and modifiers are provided.\n///\n/// One event `PhaseShiftScheduled` is emitted each time a phase shift is\n/// scheduled (not when the scheduled phase is reached).\n///\n/// @dev `Phased` contracts have a defined timeline with available\n/// functionality grouped into phases.\n/// Every `Phased` contract starts at `0` and moves sequentially\n/// through phases `1` to `8`.\n/// Every `Phase` other than `0` is optional, there is no requirement\n/// that all 9 phases are implemented.\n/// Phases can never be revisited, the inheriting contract always moves through\n/// each achieved phase linearly.\n/// This is enforced by only allowing `scheduleNextPhase` to be called once per\n/// phase.\n/// It is possible to call `scheduleNextPhase` several times in a single second\n/// but the `block.timestamp` for each phase must be reached each time to\n/// schedule the next phase.\n/// Importantly there are events and several modifiers and checks available to\n/// ensure that functionality is limited to the current phase.\n/// The full history of each phase shift block is recorded as a fixed size\n/// array of `uint32`.\ncontract Phased {\n    /// @dev Every phase block starts uninitialized.\n    /// Only uninitialized blocks can be set by the phase scheduler.\n    uint32 private constant UNINITIALIZED = type(uint32).max;\n    /// @dev This is how many phases can fit in a `uint256`.\n    uint256 private constant MAX_PHASE = 8;\n\n    /// `PhaseScheduled` is emitted when the next phase is scheduled.\n    /// @param sender `msg.sender` that scheduled the next phase.\n    /// @param newPhase The next phase being scheduled.\n    /// @param scheduledTime The timestamp the phase will be achieved.\n    event PhaseScheduled(\n        address sender,\n        uint256 newPhase,\n        uint256 scheduledTime\n    );\n\n    /// 8 phases each as 32 bits to fit a single 32 byte word.\n    uint32[MAX_PHASE] public phaseTimes;\n\n    /// Initialize the blocks at \"never\".\n    /// All phase blocks are initialized to `UNINITIALIZED`.\n    /// i.e. not fallback solidity value of `0`.\n    function initializePhased() internal {\n        // Reinitialization is a bug.\n        // Only need to check the first block as all times are about to be set\n        // to `UNINITIALIZED`.\n        assert(phaseTimes[0] < 1);\n        uint32[MAX_PHASE] memory phaseTimes_ = [\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED,\n            UNINITIALIZED\n        ];\n        phaseTimes = phaseTimes_;\n        // 0 is always the timestamp for implied phase 0.\n        emit PhaseScheduled(msg.sender, 0, 0);\n    }\n\n    /// Pure function to reduce an array of phase times and block timestamp to\n    /// a specific `Phase`.\n    /// The phase will be the highest attained even if several phases have the\n    /// same timestamp.\n    /// If every phase block is after the timestamp then `0` is returned.\n    /// If every phase block is before the timestamp then `MAX_PHASE` is\n    /// returned.\n    /// @param phaseTimes_ Fixed array of phase times to compare against.\n    /// @param timestamp_ Determine the relevant phase relative to this time.\n    /// @return phase_ The \"current\" phase relative to the timestamp and phase\n    /// times list.\n    function phaseAtTime(\n        uint32[MAX_PHASE] memory phaseTimes_,\n        uint256 timestamp_\n    ) public pure returns (uint256 phase_) {\n        for (phase_ = 0; phase_ < MAX_PHASE; phase_++) {\n            if (timestamp_ < phaseTimes_[phase_]) {\n                break;\n            }\n        }\n    }\n\n    /// Pure function to reduce an array of phase times and phase to a\n    /// specific timestamp.\n    /// `Phase.ZERO` will always return block `0`.\n    /// Every other phase will map to a time in `phaseTimes_`.\n    /// @param phaseTimes_ Fixed array of phase blocks to compare against.\n    /// @param phase_ Determine the relevant block number for this phase.\n    /// @return timestamp_ The timestamp for the phase according to\n    /// `phaseTimes_`.\n    function timeForPhase(\n        uint32[MAX_PHASE] memory phaseTimes_,\n        uint256 phase_\n    ) public pure returns (uint256 timestamp_) {\n        timestamp_ = phase_ > 0 ? phaseTimes_[phase_ - 1] : 0;\n    }\n\n    /// Impure read-only function to return the \"current\" phase from internal\n    /// contract state.\n    /// Simply wraps `phaseAtTime` for current values of `phaseTimes`\n    /// and `block.timestamp`.\n    function currentPhase() public view returns (uint256 phase_) {\n        phase_ = phaseAtTime(phaseTimes, block.timestamp);\n    }\n\n    /// Modifies functions to only be callable in a specific phase.\n    /// @param phase_ Modified functions can only be called during this phase.\n    modifier onlyPhase(uint256 phase_) {\n        if (currentPhase() != phase_) {\n            revert BadPhase();\n        }\n        _;\n    }\n\n    /// Modifies function to NOT be callable in a specific phase.\n    /// @param phase_ Modified functions can be called in any phase except this.\n    modifier onlyNotPhase(uint256 phase_) {\n        if (currentPhase() == phase_) {\n            revert BadPhase();\n        }\n        _;\n    }\n\n    /// Modifies functions to only be callable in a specific phase OR if the\n    /// specified phase has passed.\n    /// @param phase_ Modified function only callable during or after this\n    /// phase.\n    modifier onlyAtLeastPhase(uint256 phase_) {\n        require(currentPhase() >= phase_, \"MIN_PHASE\");\n        _;\n    }\n\n    /// Writes the timestamp for the next phase.\n    /// Only uninitialized times can be written to.\n    /// Only the immediate next phase relative to `currentPhase` can be written\n    /// to. It is still required to specify the `phase_` so that it is explicit\n    /// and clear in the calling code which phase is being moved to.\n    /// Emits `PhaseShiftScheduled` with the phase timestamp.\n    /// @param phase_ The phase being scheduled.\n    /// @param timestamp_ The timestamp for the phase.\n    function schedulePhase(uint256 phase_, uint256 timestamp_) internal {\n        require(block.timestamp <= timestamp_, \"NEXT_TIME_PAST\");\n        require(timestamp_ < UNINITIALIZED, \"NEXT_TIME_UNINITIALIZED\");\n        // Don't need to check for underflow as the index will be used as a\n        // fixed array index below. Implies that scheduling phase `0` is NOT\n        // supported.\n        uint256 index_;\n        unchecked {\n            index_ = phase_ - 1;\n        }\n        // Bit of a hack to check the current phase against the index to\n        // save calculating the subtraction twice.\n        require(currentPhase() == index_, \"NEXT_PHASE\");\n\n        require(UNINITIALIZED == phaseTimes[index_], \"NEXT_TIME_SET\");\n\n        // Cannot exceed UNINITIALIZED (see above) so don't need to check\n        // overflow on downcast.\n        unchecked {\n            phaseTimes[index_] = uint32(timestamp_);\n        }\n\n        emit PhaseScheduled(msg.sender, phase_, timestamp_);\n    }\n}\n"
    },
    "contracts/redeemableERC20/RedeemableERC20.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {ERC20Config} from \"../erc20/ERC20Config.sol\";\nimport \"../erc20/ERC20Redeem.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ITierV2} from \"../tier/ITierV2.sol\";\nimport {TierReport} from \"../tier/libraries/TierReport.sol\";\n\nimport {Phased} from \"../phased/Phased.sol\";\n\nimport {ERC165CheckerUpgradeable as ERC165Checker} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\n\n/// Everything required by the `RedeemableERC20` constructor.\n/// @param reserve Reserve token that the associated `Trust` or equivalent\n/// raise contract will be forwarding to the `RedeemableERC20` contract.\n/// @param erc20Config ERC20 config forwarded to the ERC20 constructor.\n/// @param tier Tier contract to compare statuses against on transfer.\n/// @param minimumTier Minimum tier required for transfers in `Phase.ZERO`.\n/// Can be `0`.\n/// @param distributionEndForwardingAddress Optional address to send rTKN to at\n/// the end of the distribution phase. If `0` address then all undistributed\n/// rTKN will burn itself at the end of the distribution.\nstruct RedeemableERC20Config {\n    address reserve;\n    ERC20Config erc20Config;\n    address tier;\n    uint256 minimumTier;\n    address distributionEndForwardingAddress;\n}\n\n/// @title RedeemableERC20\n/// @notice This is the ERC20 token that is minted and distributed.\n///\n/// During `Phase.ZERO` the token can be traded and so compatible with the\n/// Balancer pool mechanics.\n///\n/// During `Phase.ONE` the token is frozen and no longer able to be traded on\n/// any AMM or transferred directly.\n///\n/// The token can be redeemed during `Phase.ONE` which burns the token in\n/// exchange for pro-rata erc20 tokens held by the `RedeemableERC20` contract\n/// itself.\n///\n/// The token balances can be used indirectly for other claims, promotions and\n/// events as a proof of participation in the original distribution by token\n/// holders.\n///\n/// The token can optionally be restricted by the `ITierV2` contract to only\n/// allow receipients with a specified membership status.\n///\n/// @dev `RedeemableERC20` is an ERC20 with 2 phases.\n///\n/// `Phase.ZERO` is the distribution phase where the token can be freely\n/// transfered but not redeemed.\n/// `Phase.ONE` is the redemption phase where the token can be redeemed but no\n/// longer transferred.\n///\n/// Redeeming some amount of `RedeemableERC20` burns the token in exchange for\n/// some other tokens held by the contract. For example, if the\n/// `RedeemableERC20` token contract holds 100 000 USDC then a holder of the\n/// redeemable token can burn some of their tokens to receive a % of that USDC.\n/// If they redeemed (burned) an amount equal to 10% of the redeemable token\n/// supply then they would receive 10 000 USDC.\n///\n/// To make the treasury assets discoverable anyone can call `newTreasuryAsset`\n/// to emit an event containing the treasury asset address. As malicious and/or\n/// spam users can emit many treasury events there is a need for sensible\n/// indexing and filtering of asset events to only trusted users. This contract\n/// is agnostic to how that trust relationship is defined for each user.\n///\n/// Users must specify all the treasury assets they wish to redeem to the\n/// `redeem` function. After `redeem` is called the redeemed tokens are burned\n/// so all treasury assets must be specified and claimed in a batch atomically.\n/// Note: The same amount of `RedeemableERC20` is burned, regardless of which\n/// treasury assets were specified. Specifying fewer assets will NOT increase\n/// the proportion of each that is returned.\n///\n/// `RedeemableERC20` has several owner administrative functions:\n/// - Owner can add senders and receivers that can send/receive tokens even\n///   during `Phase.ONE`\n/// - Owner can end `Phase.ONE` during `Phase.ZERO` by specifying the address\n///   of a distributor, which will have any undistributed tokens burned.\n/// The owner should be a `Trust` not an EOA.\n///\n/// The redeem functions MUST be used to redeem and burn RedeemableERC20s\n/// (NOT regular transfers).\n///\n/// `redeem` will simply revert if called outside `Phase.ONE`.\n/// A `Redeem` event is emitted on every redemption (per treasury asset) as\n/// `(redeemer, asset, redeemAmount)`.\ncontract RedeemableERC20 is Initializable, Phased, ERC20Redeem {\n    using SafeERC20 for IERC20;\n\n    /// @dev Phase constants.\n    /// Contract is not yet initialized.\n    uint256 private constant PHASE_UNINITIALIZED = 0;\n    /// @dev Token is in the distribution phase and can be transferred freely\n    /// subject to tier requirements.\n    uint256 private constant PHASE_DISTRIBUTING = 1;\n    /// @dev Token is frozen and cannot be transferred unless the\n    /// sender/receiver is authorized as a sender/receiver.\n    uint256 private constant PHASE_FROZEN = 2;\n\n    /// @dev Bits for a receiver.\n    uint256 private constant RECEIVER = 0x1;\n    /// @dev Bits for a sender.\n    uint256 private constant SENDER = 0x2;\n\n    /// @dev To be clear, this admin is NOT intended to be an EOA.\n    /// This contract is designed assuming the admin is a `Sale` or equivalent\n    /// contract that itself does NOT have an admin key.\n    address private admin;\n    /// @dev Tracks addresses that can always send/receive regardless of phase.\n    /// sender/receiver => access bits\n    mapping(address => uint256) private access;\n\n    /// Results of initializing.\n    /// @param sender `msg.sender` of initialize.\n    /// @param config Initialization config.\n    event Initialize(address sender, RedeemableERC20Config config);\n\n    /// A new token sender has been added.\n    /// @param sender `msg.sender` that approved the token sender.\n    /// @param grantedSender address that is now a token sender.\n    event Sender(address sender, address grantedSender);\n\n    /// A new token receiver has been added.\n    /// @param sender `msg.sender` that approved the token receiver.\n    /// @param grantedReceiver address that is now a token receiver.\n    event Receiver(address sender, address grantedReceiver);\n\n    /// RedeemableERC20 uses the standard/default 18 ERC20 decimals.\n    /// The minimum supply enforced by the constructor is \"one\" token which is\n    /// `10 ** 18`.\n    /// The minimum supply does not prevent subsequent redemption/burning.\n    uint256 private constant MINIMUM_INITIAL_SUPPLY = 10 ** 18;\n\n    /// Tier contract that produces the report that `minimumTier` is checked\n    /// against.\n    /// Public so external contracts can interface with the required tier.\n    ITierV2 public tier;\n\n    /// The minimum status that a user must hold to receive transfers during\n    /// `Phase.ZERO`.\n    /// The tier contract passed to `TierByConstruction` determines if\n    /// the status is held during `_beforeTokenTransfer`.\n    /// Public so external contracts can interface with the required tier.\n    uint256 public minimumTier;\n\n    /// Optional address to send rTKN to at the end of the distribution phase.\n    /// If `0` address then all undistributed rTKN will burn itself at the end\n    /// of the distribution.\n    address private distributionEndForwardingAddress;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// Mint the full ERC20 token supply and configure basic transfer\n    /// restrictions. Initializes all base contracts.\n    /// @param config_ Initialized configuration.\n    function initialize(\n        RedeemableERC20Config calldata config_\n    ) external initializer {\n        initializePhased();\n\n        tier = ITierV2(config_.tier);\n\n        require(\n            ERC165Checker.supportsInterface(\n                config_.tier,\n                type(ITierV2).interfaceId\n            ),\n            \"ERC165_TIERV2\"\n        );\n\n        __ERC20_init(config_.erc20Config.name, config_.erc20Config.symbol);\n\n        require(\n            config_.erc20Config.initialSupply >= MINIMUM_INITIAL_SUPPLY,\n            \"MINIMUM_INITIAL_SUPPLY\"\n        );\n        minimumTier = config_.minimumTier;\n        distributionEndForwardingAddress = config_\n            .distributionEndForwardingAddress;\n\n        // Minting and burning must never fail.\n        access[address(0)] = RECEIVER | SENDER;\n\n        // Admin receives full supply.\n        access[config_.erc20Config.distributor] = RECEIVER;\n\n        // Forwarding address must be able to receive tokens.\n        if (distributionEndForwardingAddress != address(0)) {\n            access[distributionEndForwardingAddress] = RECEIVER;\n        }\n\n        admin = config_.erc20Config.distributor;\n\n        // Need to mint after assigning access.\n        _mint(\n            config_.erc20Config.distributor,\n            config_.erc20Config.initialSupply\n        );\n\n        // The reserve must always be one of the treasury assets.\n        newTreasuryAsset(config_.reserve);\n\n        emit Initialize(msg.sender, config_);\n\n        schedulePhase(PHASE_DISTRIBUTING, block.timestamp);\n    }\n\n    /// Require a function is only admin callable.\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"ONLY_ADMIN\");\n        _;\n    }\n\n    /// Check that an address is a receiver.\n    /// A sender is also a receiver.\n    /// @param maybeReceiver_ account to check.\n    /// @return True if account is a receiver.\n    function isReceiver(address maybeReceiver_) public view returns (bool) {\n        return access[maybeReceiver_] & RECEIVER > 0;\n    }\n\n    /// Admin can grant an address receiver rights.\n    /// @param newReceiver_ The account to grand receiver.\n    function grantReceiver(address newReceiver_) external onlyAdmin {\n        // Using `|` preserves sender if previously granted.\n        access[newReceiver_] |= RECEIVER;\n        emit Receiver(msg.sender, newReceiver_);\n    }\n\n    /// Check that an address is a sender.\n    /// @param maybeSender_ account to check.\n    /// @return True if account is a sender.\n    function isSender(address maybeSender_) public view returns (bool) {\n        return access[maybeSender_] & SENDER > 0;\n    }\n\n    /// Admin can grant an addres sender rights.\n    /// @param newSender_ The account to grant sender.\n    function grantSender(address newSender_) external onlyAdmin {\n        // Uinsg `|` preserves receiver if previously granted.\n        access[newSender_] |= SENDER;\n        emit Sender(msg.sender, newSender_);\n    }\n\n    /// The admin can forward or burn all tokens of a single address to end\n    /// `PHASE_DISTRIBUTING`.\n    /// The intent is that during `PHASE_DISTRIBUTING` there is some contract\n    /// responsible for distributing the tokens.\n    /// The admin specifies the distributor to end `PHASE_DISTRIBUTING` and the\n    /// forwarding address set during initialization is used. If the forwarding\n    /// address is `0` the rTKN will be burned, otherwise the entire balance of\n    /// the distributor is forwarded to the nominated address. In practical\n    /// terms the forwarding allows for escrow depositors to receive a prorata\n    /// claim on unsold rTKN if they forward it to themselves, otherwise raise\n    /// participants will receive a greater share of the final escrowed tokens\n    /// due to the burn reducing the total supply.\n    /// The distributor is NOT set during the constructor because it may not\n    /// exist at that point. For example, Balancer needs the paired erc20\n    /// tokens to exist before the trading pool can be built.\n    /// @param distributor_ The distributor according to the admin.\n    /// BURN the tokens if `address(0)`.\n    function endDistribution(\n        address distributor_\n    ) external onlyPhase(PHASE_DISTRIBUTING) onlyAdmin {\n        schedulePhase(PHASE_FROZEN, block.timestamp);\n        address forwardTo_ = distributionEndForwardingAddress;\n        uint256 distributorBalance_ = balanceOf(distributor_);\n        if (distributorBalance_ > 0) {\n            if (forwardTo_ == address(0)) {\n                _burn(distributor_, distributorBalance_);\n            } else {\n                _transfer(distributor_, forwardTo_, distributorBalance_);\n            }\n        }\n    }\n\n    /// Wraps `_redeem` from `ERC20Redeem`.\n    /// Very thin wrapper so be careful when calling!\n    /// @param treasuryAssets_ The treasury assets to redeem for. If this is\n    /// empty or incomplete then tokens will be permanently burned for no\n    /// reason by the caller and the remaining funds will be effectively\n    /// redistributed to everyone else.\n    function redeem(\n        IERC20[] calldata treasuryAssets_,\n        uint256 redeemAmount_\n    ) external onlyPhase(PHASE_FROZEN) {\n        _redeem(treasuryAssets_, redeemAmount_);\n    }\n\n    /// Apply phase sensitive transfer restrictions.\n    /// During `Phase.ZERO` only tier requirements apply.\n    /// During `Phase.ONE` all transfers except burns are prevented.\n    /// If a transfer involves either a sender or receiver with the SENDER\n    /// or RECEIVER role, respectively, it will bypass these restrictions.\n    /// @inheritdoc ERC20Upgradeable\n    function _beforeTokenTransfer(\n        address sender_,\n        address receiver_,\n        uint256 amount_\n    ) internal virtual override {\n        super._beforeTokenTransfer(sender_, receiver_, amount_);\n\n        // Sending tokens to this contract (e.g. instead of redeeming) is\n        // always an error.\n        require(receiver_ != address(this), \"TOKEN_SEND_SELF\");\n\n        // Some contracts may attempt a preflight (e.g. Balancer) of a 0 amount\n        // transfer.\n        // We don't want to accidentally cause external errors due to zero\n        // value transfers.\n        if (\n            amount_ > 0 &&\n            // The sender and receiver lists bypass all access restrictions.\n            !(isSender(sender_) || isReceiver(receiver_))\n        ) {\n            // During `PHASE_DISTRIBUTING` transfers are only restricted by the\n            // tier of the recipient. Every other phase only allows senders and\n            // receivers as above.\n            require(currentPhase() == PHASE_DISTRIBUTING, \"FROZEN\");\n\n            // Receivers act as \"hubs\" that can send to \"spokes\".\n            // i.e. any address of the minimum tier.\n            // Spokes cannot send tokens another \"hop\" e.g. to each other.\n            // Spokes can only send back to a receiver (doesn't need to be\n            // the same receiver they received from).\n            require(isReceiver(sender_), \"2SPOKE\");\n            require(\n                TierReport.tierAtTimeFromReport(\n                    tier.report(receiver_, new uint256[](0)),\n                    block.timestamp\n                ) >= minimumTier,\n                \"MIN_TIER\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/redeemableERC20/RedeemableERC20Factory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport {RedeemableERC20, RedeemableERC20Config} from \"./RedeemableERC20.sol\";\nimport {ITierV2} from \"../tier/ITierV2.sol\";\nimport {ClonesUpgradeable as Clones} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\n/// @title RedeemableERC20Factory\n/// @notice Factory for deploying and registering `RedeemableERC20` contracts.\ncontract RedeemableERC20Factory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new RedeemableERC20());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(\n        bytes memory data_\n    ) internal virtual override returns (address) {\n        RedeemableERC20Config memory config_ = abi.decode(\n            data_,\n            (RedeemableERC20Config)\n        );\n        address clone_ = Clones.clone(implementation);\n        RedeemableERC20(clone_).initialize(config_);\n        return clone_;\n    }\n\n    /// Allows calling `createChild` with `RedeemableERC20Config` struct.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `RedeemableERC20` initializer configuration.\n    /// @return New `RedeemableERC20` child contract.\n    function createChildTyped(\n        RedeemableERC20Config memory config_\n    ) external returns (RedeemableERC20) {\n        return RedeemableERC20(createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "contracts/sale/ISaleV2.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// An `ISale` can be in one of 4 possible states and a linear progression is\n/// expected from an \"in flight\" status to an immutable definitive outcome.\n/// - Pending: The sale is deployed onchain but cannot be interacted with yet.\n/// - Active: The sale can now be bought into and otherwise interacted with.\n/// - Success: The sale has ended AND reached its minimum raise target.\n/// - Fail: The sale has ended BUT NOT reached its minimum raise target.\n/// Once an `ISale` reaches `Active` it MUST NOT return `Pending` ever again.\n/// Once an `ISale` reaches `Success` or `Fail` it MUST NOT return any other\n/// status ever again.\nenum SaleStatus {\n    Pending,\n    Active,\n    Success,\n    Fail\n}\n\ninterface ISaleV2 {\n    /// Returns the address of the token being sold in the sale.\n    /// MUST NOT change during the lifecycle of the sale contract.\n    function token() external view returns (address);\n\n    function remainingTokenInventory() external view returns (uint256);\n\n    /// Returns the address of the token that sale prices are denominated in.\n    /// MUST NOT change during the lifecycle of the sale contract.\n    function reserve() external view returns (address);\n\n    /// total reserve taken in to the sale contract via. buys. Does NOT\n    /// include any reserve sent directly to the sale contract outside the\n    /// standard buy/refund loop, e.g. due to a dusting attack.\n    function totalReserveReceived() external view returns (uint256);\n\n    /// Returns the current `SaleStatus` of the sale.\n    /// Represents a linear progression of the sale through its major lifecycle\n    /// events.\n    function saleStatus() external view returns (SaleStatus);\n}\n"
    },
    "contracts/sale/Sale.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {Cooldown} from \"../cooldown/Cooldown.sol\";\n\nimport \"../math/FixedPointMath.sol\";\nimport {AllStandardOps} from \"../interpreter/ops/AllStandardOps.sol\";\nimport {ERC20Config} from \"../erc20/ERC20Config.sol\";\nimport \"./ISaleV2.sol\";\nimport {RedeemableERC20, RedeemableERC20Config} from \"../redeemableERC20/RedeemableERC20.sol\";\nimport {RedeemableERC20Factory} from \"../redeemableERC20/RedeemableERC20Factory.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../sstore2/SSTORE2.sol\";\nimport \"../interpreter/deploy/IExpressionDeployerV1.sol\";\nimport \"../interpreter/run/IInterpreterV1.sol\";\nimport \"../interpreter/run/LibStackPointer.sol\";\nimport \"../interpreter/run/LibEncodedDispatch.sol\";\nimport \"../interpreter/run/LibContext.sol\";\n\n/// Everything required to construct a Sale (not initialize).\n/// @param maximumSaleTimeout The sale timeout set in initialize cannot exceed\n/// this. Avoids downstream escrows and similar trapping funds due to sales\n/// that never end, or perhaps never even start.\n/// @param maximumCooldownDuration The cooldown duration set in initialize\n/// cannot exceed this. Avoids the \"no refunds\" situation where someone sets an\n/// infinite cooldown, then accidentally or maliciously the sale ends up in a\n/// state where it cannot end (bad \"can end\" expression), leading to trapped\n/// funds.\n/// @param redeemableERC20Factory The factory contract that creates redeemable\n/// erc20 tokens that the `Sale` can mint, sell and burn.\nstruct SaleConstructorConfig {\n    uint256 maximumSaleTimeout;\n    RedeemableERC20Factory redeemableERC20Factory;\n}\n\n/// Everything required to configure (initialize) a Sale.\n/// @param canStartStateConfig State config for the expression that allows a\n/// `Sale` to start.\n/// @param canEndStateConfig State config for the expression that allows a\n/// `Sale` to end. IMPORTANT: A Sale can always end if/when its rTKN sells out,\n/// regardless of the result of this expression.\n/// @param calculatePriceStateConfig State config for the expression that defines\n/// the current price quoted by a Sale.\n/// @param recipient The recipient of the proceeds of a Sale, if/when the Sale\n/// is successful.\n/// @param reserve The reserve token the Sale is deonominated in.\n/// @param saleTimeout The number of seconds before this sale can timeout.\n/// SHOULD be well after the expected end time as a timeout will fail an active\n/// or pending sale regardless of any funds raised.\n/// @param cooldownDuration forwarded to `Cooldown` contract initialization.\n/// @param minimumRaise defines the amount of reserve required to raise that\n/// defines success/fail of the sale. Reaching the minimum raise DOES NOT cause\n/// the raise to end early (unless the \"can end\" expression allows it of course).\n/// @param dustSize The minimum amount of rTKN that must remain in the Sale\n/// contract unless it is all purchased, clearing the raise to 0 stock and thus\n/// ending the raise.\nstruct SaleConfig {\n    address expressionDeployer;\n    address interpreter;\n    StateConfig interpreterStateConfig;\n    address recipient;\n    address reserve;\n    uint256 saleTimeout;\n    uint256 cooldownDuration;\n    uint256 minimumRaise;\n    uint256 dustSize;\n}\n\n/// Forwarded config to RedeemableERC20 initialization.\nstruct SaleRedeemableERC20Config {\n    ERC20Config erc20Config;\n    address tier;\n    uint256 minimumTier;\n    address distributionEndForwardingAddress;\n}\n\n/// Defines a request to buy rTKN from an active sale.\n/// @param feeRecipient Optional recipient to send fees to. Intended to be a\n/// \"tip\" for the front-end client that the buyer is using to fund development,\n/// infrastructure, etc.\n/// @param fee Size of the optional fee to send to the recipient. Denominated\n/// in the reserve token of the `Sale` contract.\n/// @param minimumUnits The minimum size of the buy. If the sale is close to\n/// selling out then the buyer may not fulfill their entire order, so this sets\n/// the minimum units the buyer is willing to accept for their order. MAY be 0\n/// if the buyer is willing to accept any amount of tokens.\n/// @param desiredUnits The maximum and desired size of the buy. The sale will\n/// always attempt to fulfill the buy order to the maximum rTKN amount possible\n/// according to the unsold stock on hand. Typically all the desired units will\n/// clear but as the sale runs low on stock it may not be able to.\n/// @param maximumPrice As the price quoted by the sale is a programmable curve\n/// it may change rapidly between when the buyer submitted a transaction to the\n/// mempool and when it is mined. Setting a maximum price is akin to setting\n/// slippage on a traditional AMM. The transaction will revert if the sale\n/// price exceeds the buyer's maximum.\nstruct BuyConfig {\n    address feeRecipient;\n    uint256 fee;\n    uint256 minimumUnits;\n    uint256 desiredUnits;\n    uint256 maximumPrice;\n}\n\n/// Defines the receipt for a successful buy.\n/// The receipt includes the final units and price paid for rTKN, which are\n/// known as possible ranges in `BuyConfig`.\n/// Importantly a receipt allows a buy to be reversed for as long as the sale\n/// is active, subject to buyer cooldowns as per `Cooldown`. In the case of a\n/// finalized but failed sale, all buyers can immediately process refunds for\n/// their receipts without cooldown. As the receipt is crucial to the refund\n/// process every receipt is logged so it can be indexed and never lost, and\n/// unique IDs bound to the buyer in onchain storage prevent receipts from\n/// being used in a fraudulent context. The entire receipt including the id is\n/// hashed in the storage mapping that binds it to a buyer so that a buyer\n/// cannot change the receipt offchain to claim fraudulent refunds.\n/// Front-end fees are also tracked and refunded for each receipt, to prevent\n/// front end clients from gaming/abusing sale contracts.\n/// @param id Every receipt is assigned a sequential ID to ensure uniqueness\n/// across all receipts.\n/// @param feeRecipient as per `BuyConfig`.\n/// @param fee as per `BuyConfig`.\n/// @param units number of rTKN bought and refundable.\n/// @param price price paid per unit denominated and refundable in reserve.\nstruct Receipt {\n    uint256 id;\n    address feeRecipient;\n    uint256 fee;\n    uint256 units;\n    uint256 price;\n}\n\nSourceIndex constant CAN_LIVE_ENTRYPOINT = SourceIndex.wrap(0);\nSourceIndex constant CALCULATE_BUY_ENTRYPOINT = SourceIndex.wrap(1);\nSourceIndex constant HANDLE_BUY_ENTRYPOINT = SourceIndex.wrap(2);\n\nuint256 constant CAN_LIVE_MIN_OUTPUTS = 1;\nuint256 constant CAN_LIVE_MAX_OUTPUTS = 1;\nuint256 constant CALCULATE_BUY_MIN_OUTPUTS = 2;\nuint256 constant CALCULATE_BUY_MAX_OUTPUTS = 2;\nuint256 constant HANDLE_BUY_MIN_OUTPUTS = 0;\nuint256 constant HANDLE_BUY_MAX_OUTPUTS = 0;\n\nuint256 constant CONTEXT_COLUMNS = 2;\nuint256 constant CONTEXT_CALCULATIONS_COLUMN = 1;\nuint256 constant CONTEXT_BUY_COLUMN = 2;\n\nuint256 constant CONTEXT_BUY_TOKEN_OUT_ROW = 0;\nuint256 constant CONTEXT_BUY_TOKEN_BALANCE_BEFORE_ROW = 1;\nuint256 constant CONTEXT_BUY_TOKEN_BALANCE_AFTER_ROW = 2;\nuint256 constant CONTEXT_BUY_RESERVE_FEE_ROW = 3;\nuint256 constant CONTEXT_BUY_RESERVE_COST_ROW = 4;\nuint256 constant CONTEXT_BUY_RESERVE_BALANCE_BEFORE_ROW = 5;\nuint256 constant CONTEXT_BUY_RESERVE_BALANCE_AFTER_ROW = 6;\nuint256 constant CONTEXT_BUY_ROWS = 7;\n\n// solhint-disable-next-line max-states-count\ncontract Sale is Cooldown, ISaleV2, ReentrancyGuard {\n    using Math for uint256;\n    using FixedPointMath for uint256;\n    using SafeERC20 for IERC20;\n    using LibStackPointer for uint256[];\n    using LibStackPointer for StackPointer;\n    using LibUint256Array for uint256;\n    using LibUint256Array for uint256[];\n\n    /// Contract is constructing.\n    /// @param sender `msg.sender` of the contract deployer.\n    event Construct(address sender, SaleConstructorConfig config);\n    /// Contract is initializing (being cloned by factory).\n    /// @param sender `msg.sender` of the contract initializer (cloner).\n    /// @param config All initialization config passed by the sender.\n    /// @param token The freshly deployed and minted rTKN for the sale.\n    event Initialize(address sender, SaleConfig config, address token);\n    /// Sale is started (moved to active sale state).\n    /// @param sender `msg.sender` that started the sale.\n    event Start(address sender);\n    /// Sale has ended (moved to success/fail sale state).\n    /// @param sender `msg.sender` that ended the sale.\n    /// @param saleStatus The final success/fail state of the sale.\n    event End(address sender, SaleStatus saleStatus);\n    /// Sale has failed due to a timeout (failed to even start/end).\n    /// @param sender `msg.sender` that timed out the sale.\n    event Timeout(address sender);\n    /// rTKN being bought.\n    /// Importantly includes the receipt that sender can use to apply for a\n    /// refund later if they wish.\n    /// @param sender `msg.sender` buying rTKN.\n    /// @param config All buy config passed by the sender.\n    /// @param receipt The purchase receipt, can be used to claim refunds.\n    event Buy(address sender, BuyConfig config, Receipt receipt);\n    /// rTKN being refunded.\n    /// Includes the receipt used to justify the refund.\n    event Refund(address sender, Receipt receipt);\n\n    /// @dev the saleTimeout cannot exceed this. Prevents downstream contracts\n    /// that require a finalization such as escrows from getting permanently\n    /// stuck in a pending or active status due to buggy expressions.\n    uint256 private immutable maximumSaleTimeout;\n\n    EncodedDispatch internal dispatchCanLive;\n    EncodedDispatch internal dispatchCalculateBuy;\n    EncodedDispatch internal dispatchHandleBuy;\n    IInterpreterV1 private interpreter;\n\n    /// @inheritdoc ISaleV2\n    uint256 public remainingTokenInventory;\n\n    /// @inheritdoc ISaleV2\n    uint256 public totalReserveReceived;\n\n    /// @inheritdoc ISaleV2\n    address public token;\n\n    /// @inheritdoc ISaleV2\n    address public reserve;\n\n    /// @inheritdoc ISaleV2\n    SaleStatus public saleStatus;\n\n    /// Factory responsible for minting rTKN.\n    RedeemableERC20Factory private immutable redeemableERC20Factory;\n\n    /// @dev as per `SaleConfig`.\n    address private recipient;\n    /// @dev as per `SaleConfig`.\n    uint256 private minimumRaise;\n    /// @dev as per `SaleConfig`.\n    uint256 private dustSize;\n\n    /// @dev the current sale can always end in failure at this time even if\n    /// it did not start. Provided it did not already end of course.\n    uint256 private saleTimeoutStamp;\n\n    /// @dev Binding buyers to receipt hashes to maybe a non-zero value.\n    /// A receipt will only be honoured if the mapping resolves to non-zero.\n    /// The receipt hashing ensures that receipts cannot be manipulated before\n    /// redemption. Each mapping is deleted if/when receipt is used for refund.\n    /// Buyer => keccak receipt => exists (1+ or 0).\n    mapping(address => mapping(bytes32 => uint256)) private receipts;\n    /// @dev simple incremental counter to keep all receipts unique so that\n    /// receipt hashes bound to buyers never collide.\n    uint256 private nextReceiptId;\n\n    /// @dev Tracks combined fees per recipient to be claimed if/when a sale\n    /// is successful.\n    /// Fee recipient => unclaimed fees.\n    mapping(address => uint256) private fees;\n\n    constructor(SaleConstructorConfig memory config_) {\n        _disableInitializers();\n\n        maximumSaleTimeout = config_.maximumSaleTimeout;\n\n        redeemableERC20Factory = config_.redeemableERC20Factory;\n\n        emit Construct(msg.sender, config_);\n    }\n\n    function initialize(\n        SaleConfig calldata config_,\n        SaleRedeemableERC20Config memory saleRedeemableERC20Config_\n    ) external initializer {\n        __ReentrancyGuard_init();\n        initializeCooldown(config_.cooldownDuration);\n\n        require(config_.saleTimeout <= maximumSaleTimeout, \"MAX_TIMEOUT\");\n        saleTimeoutStamp = block.timestamp + config_.saleTimeout;\n\n        // 0 minimum raise is ambiguous as to how it should be handled. It\n        // literally means \"the raise succeeds without any trades\", which\n        // doesn't have a clear way to move funds around as there are no\n        // recipients of potentially escrowed or redeemable funds. There needs\n        // to be at least 1 reserve token paid from 1 buyer in order to\n        // meaningfully process success logic.\n        require(config_.minimumRaise > 0, \"MIN_RAISE_0\");\n        minimumRaise = config_.minimumRaise;\n\n        address expression_ = IExpressionDeployerV1(config_.expressionDeployer)\n            .deployExpression(\n                config_.interpreterStateConfig,\n                LibUint256Array.arrayFrom(\n                    CAN_LIVE_MIN_OUTPUTS,\n                    CALCULATE_BUY_MIN_OUTPUTS,\n                    HANDLE_BUY_MIN_OUTPUTS\n                )\n            );\n        dispatchCanLive = LibEncodedDispatch.encode(\n            expression_,\n            CAN_LIVE_ENTRYPOINT,\n            CAN_LIVE_MAX_OUTPUTS\n        );\n        dispatchCalculateBuy = LibEncodedDispatch.encode(\n            expression_,\n            CALCULATE_BUY_ENTRYPOINT,\n            CALCULATE_BUY_MAX_OUTPUTS\n        );\n        if (\n            config_\n                .interpreterStateConfig\n                .sources[SourceIndex.unwrap(HANDLE_BUY_ENTRYPOINT)]\n                .length > 0\n        ) {\n            dispatchHandleBuy = LibEncodedDispatch.encode(\n                expression_,\n                HANDLE_BUY_ENTRYPOINT,\n                HANDLE_BUY_MAX_OUTPUTS\n            );\n        }\n        interpreter = IInterpreterV1(config_.interpreter);\n\n        recipient = config_.recipient;\n\n        dustSize = config_.dustSize;\n\n        // just making this explicit during initialization in case it ever\n        // takes a nonzero value somehow due to refactor.\n        saleStatus = SaleStatus.Pending;\n\n        reserve = config_.reserve;\n\n        // The distributor of the rTKN is always set to the sale contract.\n        // It is an error for the deployer to attempt to set the distributor.\n        require(\n            saleRedeemableERC20Config_.erc20Config.distributor == address(0),\n            \"DISTRIBUTOR_SET\"\n        );\n        saleRedeemableERC20Config_.erc20Config.distributor = address(this);\n\n        remainingTokenInventory = saleRedeemableERC20Config_\n            .erc20Config\n            .initialSupply;\n\n        address token_ = redeemableERC20Factory.createChild(\n            abi.encode(\n                RedeemableERC20Config(\n                    address(config_.reserve),\n                    saleRedeemableERC20Config_.erc20Config,\n                    saleRedeemableERC20Config_.tier,\n                    saleRedeemableERC20Config_.minimumTier,\n                    saleRedeemableERC20Config_.distributionEndForwardingAddress\n                )\n            )\n        );\n        token = token_;\n\n        emit Initialize(msg.sender, config_, address(token_));\n    }\n\n    /// Can the Sale live?\n    /// Evals the \"can live\" expression.\n    /// If a non zero value is returned then the sale can move from pending to\n    /// active, or remain active.\n    /// If a zero value is returned the sale can remain pending or move from\n    /// active to a finalised status.\n    /// An out of stock (0 remaining units) WILL ALWAYS return `false` without\n    /// evaluating the expression.\n    function _previewCanLive() internal view returns (bool, uint256[] memory) {\n        unchecked {\n            if (remainingTokenInventory < 1) {\n                return (false, new uint256[](0));\n            }\n            (\n                uint256[] memory stack_,\n                uint256[] memory interpreterStateChanges_\n            ) = interpreter.eval(\n                    dispatchCanLive,\n                    LibContext.base().matrixFrom()\n                );\n            return (\n                stack_.asStackPointerAfter().peek() > 0,\n                interpreterStateChanges_\n            );\n        }\n    }\n\n    function _start() internal {\n        saleStatus = SaleStatus.Active;\n        emit Start(msg.sender);\n    }\n\n    function _end() internal {\n        bool success_ = totalReserveReceived >= minimumRaise;\n        SaleStatus endStatus_ = success_ ? SaleStatus.Success : SaleStatus.Fail;\n\n        remainingTokenInventory = 0;\n        saleStatus = endStatus_;\n        emit End(msg.sender, endStatus_);\n        RedeemableERC20(token).endDistribution(address(this));\n\n        // Only send reserve to recipient if the raise is a success.\n        // If the raise is NOT a success then everyone can refund their reserve\n        // deposited individually.\n        if (success_) {\n            IERC20(reserve).safeTransfer(recipient, totalReserveReceived);\n        }\n    }\n\n    /// External view into whether the sale can currently be active.\n    /// Offchain users MAY call this directly or calculate the outcome\n    /// themselves.\n    function previewCanLive() external view returns (bool) {\n        (bool canLive_, ) = _previewCanLive();\n        return canLive_;\n    }\n\n    function _previewCalculateBuy(\n        uint256 targetUnits_\n    )\n        internal\n        view\n        returns (uint256, uint256, uint256[][] memory, uint256[] memory)\n    {\n        uint256[][] memory context_ = LibContext.build(\n            new uint256[][](CONTEXT_COLUMNS),\n            targetUnits_.arrayFrom(),\n            new SignedContext[](0)\n        );\n        (uint256[] memory stack_, uint256[] memory stateChanges_) = interpreter\n            .eval(dispatchCalculateBuy, context_);\n        (uint256 amount_, uint256 ratio_) = stack_\n            .asStackPointerAfter()\n            .peek2();\n        uint256[] memory calculationsContext_ = LibUint256Array.arrayFrom(\n            amount_,\n            ratio_\n        );\n        context_[CONTEXT_CALCULATIONS_COLUMN] = calculationsContext_;\n        context_[CONTEXT_BUY_COLUMN] = new uint256[](CONTEXT_BUY_ROWS);\n        return (amount_, ratio_, context_, stateChanges_);\n    }\n\n    function previewCalculateBuy(\n        uint256 targetUnits_\n    ) external view returns (uint256, uint256) {\n        (uint256 amount_, uint256 ratio_, , ) = _previewCalculateBuy(\n            targetUnits_\n        );\n        return (amount_, ratio_);\n    }\n\n    /// Start the sale (move from pending to active).\n    /// This is also done automatically inline with each `buy` call so is\n    /// optional for anon to call outside of a purchase.\n    /// `canStart` MUST return true.\n    function start() external {\n        require(saleStatus == SaleStatus.Pending, \"NOT_PENDING\");\n        (bool canLive_, uint256[] memory stateChanges_) = _previewCanLive();\n        require(canLive_, \"NOT_LIVE\");\n        if (stateChanges_.length > 0) {\n            interpreter.stateChanges(stateChanges_);\n        }\n        _start();\n    }\n\n    /// End the sale (move from active to success or fail).\n    /// This is also done automatically inline with each `buy` call so is\n    /// optional for anon to call outside of a purchase.\n    /// `canEnd` MUST return true.\n    function end() external {\n        require(saleStatus == SaleStatus.Active, \"NOT_ACTIVE\");\n        (bool canLive_, uint256[] memory stateChanges_) = _previewCanLive();\n        require(!canLive_, \"LIVE\");\n        if (stateChanges_.length > 0) {\n            interpreter.stateChanges(stateChanges_);\n        }\n        _end();\n    }\n\n    /// Timeout the sale (move from pending or active to fail).\n    /// The ONLY condition for a timeout is that the `saleTimeout` block set\n    /// during initialize is in the past. This means that regardless of what\n    /// happens re: starting, ending, buying, etc. if the sale does NOT manage\n    /// to unambiguously end by the timeout block then it can timeout to a fail\n    /// state. This means that any downstream escrows or similar can always\n    /// expect that eventually they will see a pass/fail state and so are safe\n    /// to lock funds while a Sale is active.\n    function timeout() external {\n        require(saleTimeoutStamp < block.timestamp, \"EARLY_TIMEOUT\");\n        require(\n            saleStatus == SaleStatus.Pending || saleStatus == SaleStatus.Active,\n            \"ALREADY_ENDED\"\n        );\n\n        // Mimic `end` with a failed state but `Timeout` event.\n        remainingTokenInventory = 0;\n        saleStatus = SaleStatus.Fail;\n        emit Timeout(msg.sender);\n        RedeemableERC20(token).endDistribution(address(this));\n    }\n\n    /// Main entrypoint to the sale. Sells rTKN in exchange for reserve token.\n    /// The price curve is eval'd to produce a reserve price quote. Each 1 unit\n    /// of rTKN costs `price` reserve token where BOTH the rTKN units and price\n    /// are treated as 18 decimal fixed point values. If the reserve token has\n    /// more or less precision by its own conventions (e.g. \"decimals\" method\n    /// on ERC20 tokens) then the price will need to scale accordingly.\n    /// The receipt is _logged_ rather than returned as it cannot be used in\n    /// same block for a refund anyway due to cooldowns.\n    /// @param config_ All parameters to configure the purchase.\n    function buy(\n        BuyConfig memory config_\n    ) external onlyAfterCooldown nonReentrant {\n        require(0 < config_.minimumUnits, \"0_MINIMUM\");\n        require(\n            config_.minimumUnits <= config_.desiredUnits,\n            \"MINIMUM_OVER_DESIRED\"\n        );\n        IInterpreterV1 interpreter_ = interpreter;\n\n        // Start or end the sale as required.\n        (\n            bool canLive0_,\n            uint256[] memory stateChangesCanLive0_\n        ) = _previewCanLive();\n        // Register state changes with intepreter _before_ potentially ending and\n        // returning early.\n        if (stateChangesCanLive0_.length > 0) {\n            interpreter_.stateChanges(stateChangesCanLive0_);\n        }\n        if (canLive0_) {\n            if (saleStatus == SaleStatus.Pending) {\n                _start();\n            }\n        } else {\n            if (saleStatus == SaleStatus.Active) {\n                _end();\n                // Return early so that the state change of active to ended can\n                // take effect. Otherwise it will rollback as \"NOT_ACTIVE\" below\n                // leaving the sale active even though it should have ended here.\n                return;\n            }\n        }\n\n        // Check the status AFTER possibly modifying it to ensure the potential\n        // modification is respected.\n        require(saleStatus == SaleStatus.Active, \"NOT_ACTIVE\");\n\n        uint256 targetUnits_ = config_.desiredUnits.min(\n            remainingTokenInventory\n        );\n\n        uint256 maxUnits_;\n        uint256 price_;\n        uint256[][] memory context_;\n        {\n            uint256[] memory stateChangesCalculateBuy_;\n            (\n                maxUnits_,\n                price_,\n                context_,\n                stateChangesCalculateBuy_\n            ) = _previewCalculateBuy(targetUnits_);\n            if (stateChangesCalculateBuy_.length > 0) {\n                interpreter_.stateChanges(stateChangesCalculateBuy_);\n            }\n        }\n\n        // The expression may return a larger max units than the target so we\n        // have to cap it to prevent the sale selling more than requested.\n        // Expressions SHOULD NOT exceed the target units as it may be confusing\n        // to end users but it MUST be safe from the sale's perspective to do so.\n        // Expressions MAY return max units lower than the target units to\n        // enforce per-user or other purchase limits.\n        uint256 units_ = maxUnits_.min(targetUnits_);\n        require(units_ >= config_.minimumUnits, \"INSUFFICIENT_STOCK\");\n\n        require(price_ <= config_.maximumPrice, \"MAXIMUM_PRICE\");\n        uint256 cost_ = price_.fixedPointMul(units_);\n\n        Receipt memory receipt_ = Receipt(\n            nextReceiptId,\n            config_.feeRecipient,\n            config_.fee,\n            units_,\n            price_\n        );\n\n        // Slap a code block here to avoid stack limits.\n        {\n            nextReceiptId++;\n            // There should never be more than one of the same key due to the ID\n            // counter but we can use checked math to easily cover the case of\n            // potential duplicate receipts due to some bug.\n            receipts[msg.sender][keccak256(abi.encode(receipt_))]++;\n\n            fees[config_.feeRecipient] += config_.fee;\n\n            // We ignore any rTKN or reserve that is sent to the contract directly\n            // outside of a `buy` call. This also means we don't support reserve\n            // tokens with balances that can change outside of transfers\n            // (e.g. rebase).\n            context_[CONTEXT_BUY_COLUMN][CONTEXT_BUY_TOKEN_OUT_ROW] = units_;\n            context_[CONTEXT_BUY_COLUMN][\n                CONTEXT_BUY_TOKEN_BALANCE_BEFORE_ROW\n            ] = remainingTokenInventory;\n            // IMPORTANT MUST BE CHECKED MATH TO AVOID UNDERFLOW.\n            context_[CONTEXT_BUY_COLUMN][CONTEXT_BUY_TOKEN_BALANCE_AFTER_ROW] =\n                context_[CONTEXT_BUY_COLUMN][\n                    CONTEXT_BUY_TOKEN_BALANCE_BEFORE_ROW\n                ] -\n                units_;\n            remainingTokenInventory = context_[CONTEXT_BUY_COLUMN][\n                CONTEXT_BUY_TOKEN_BALANCE_AFTER_ROW\n            ];\n\n            context_[CONTEXT_BUY_COLUMN][CONTEXT_BUY_RESERVE_FEE_ROW] = config_\n                .fee;\n            context_[CONTEXT_BUY_COLUMN][CONTEXT_BUY_RESERVE_COST_ROW] = cost_;\n            context_[CONTEXT_BUY_COLUMN][\n                CONTEXT_BUY_RESERVE_BALANCE_BEFORE_ROW\n            ] = totalReserveReceived;\n            // IMPORTANT MUST BE CHECKED MATH TO AVOID OVERFLOW.\n            context_[CONTEXT_BUY_COLUMN][\n                CONTEXT_BUY_RESERVE_BALANCE_AFTER_ROW\n            ] =\n                context_[CONTEXT_BUY_COLUMN][\n                    CONTEXT_BUY_RESERVE_BALANCE_BEFORE_ROW\n                ] +\n                cost_;\n            totalReserveReceived += context_[CONTEXT_BUY_COLUMN][\n                CONTEXT_BUY_RESERVE_BALANCE_AFTER_ROW\n            ];\n\n            EncodedDispatch dispatchHandleBuy_ = dispatchHandleBuy;\n            if (EncodedDispatch.unwrap(dispatchHandleBuy_) > 0) {\n                (, uint256[] memory stateChangesHandleBuy_) = interpreter_.eval(\n                    dispatchHandleBuy_,\n                    context_\n                );\n                if (stateChangesHandleBuy_.length > 0) {\n                    interpreter_.stateChanges(stateChangesHandleBuy_);\n                }\n            }\n        }\n\n        // This happens before `end` so that the transfer from happens before\n        // the transfer to.\n        // `end` changes state so `buy` needs to be nonReentrant.\n        IERC20(reserve).safeTransferFrom(\n            msg.sender,\n            address(this),\n            cost_ + config_.fee\n        );\n        // This happens before `end` so that the transfer happens before the\n        // distributor is burned and token is frozen.\n        IERC20(token).safeTransfer(msg.sender, units_);\n\n        emit Buy(msg.sender, config_, receipt_);\n\n        // Enforce the status of the sale after the purchase.\n        // The sale ending AFTER the purchase does NOT rollback the purchase,\n        // it simply prevents further purchases.\n        (\n            bool canLive1_,\n            uint256[] memory stateChangesCanLive1_\n        ) = _previewCanLive();\n        if (stateChangesCanLive1_.length > 0) {\n            interpreter_.stateChanges(stateChangesCanLive1_);\n        }\n        if (canLive1_) {\n            // This prevents the sale from being left with so little stock that\n            // nobody else will want to clear it out. E.g. the dust might be\n            // worth significantly less than the price of gas to call `buy`.\n            require(remainingTokenInventory >= dustSize, \"DUST\");\n        } else {\n            _end();\n        }\n    }\n\n    /// @dev This is here so we can use a modifier like a function call.\n    function refundCooldown() private onlyAfterCooldown {}\n\n    /// Rollback a buy given its receipt.\n    /// Ignoring gas (which cannot be refunded) the refund process rolls back\n    /// all state changes caused by a buy, other than the receipt id increment.\n    /// Refunds are limited by the global cooldown to mitigate rapid buy/refund\n    /// cycling that could cause volatile price curves or other unwanted side\n    /// effects for other sale participants. Cooldowns are bypassed if the sale\n    /// ends and is a failure.\n    /// @param receipt_ The receipt of the buy to rollback.\n    function refund(Receipt calldata receipt_) external {\n        require(saleStatus != SaleStatus.Success, \"REFUND_SUCCESS\");\n        // If the sale failed then cooldowns do NOT apply. Everyone should\n        // immediately refund all their receipts.\n        if (saleStatus != SaleStatus.Fail) {\n            refundCooldown();\n        }\n\n        // Checked math here will prevent consuming a receipt that doesn't\n        // exist or was already refunded as it will underflow.\n        receipts[msg.sender][keccak256(abi.encode(receipt_))]--;\n\n        uint256 cost_ = receipt_.price.fixedPointMul(receipt_.units);\n\n        totalReserveReceived -= cost_;\n        remainingTokenInventory += receipt_.units;\n        fees[receipt_.feeRecipient] -= receipt_.fee;\n\n        emit Refund(msg.sender, receipt_);\n\n        IERC20(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            receipt_.units\n        );\n        IERC20(reserve).safeTransfer(msg.sender, cost_ + receipt_.fee);\n    }\n\n    /// After a sale ends in success all fees collected for a recipient can be\n    /// cleared. If the raise is active or fails then fees cannot be claimed as\n    /// they are set aside in case of refund. A failed raise implies that all\n    /// buyers should immediately refund and zero fees claimed.\n    /// @param recipient_ The recipient to claim fees for. Does NOT need to be\n    /// the `msg.sender`.\n    function claimFees(address recipient_) external {\n        require(saleStatus == SaleStatus.Success, \"NOT_SUCCESS\");\n        uint256 amount_ = fees[recipient_];\n        if (amount_ > 0) {\n            delete fees[recipient_];\n            IERC20(reserve).safeTransfer(recipient_, amount_);\n        }\n    }\n}\n"
    },
    "contracts/sale/SaleFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport \"./Sale.sol\";\n\nimport {ClonesUpgradeable as Clones} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\n/// @title SaleFactory\n/// @notice Factory for creating and deploying `Sale` contracts.\ncontract SaleFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address private immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor(SaleConstructorConfig memory config_) {\n        address implementation_ = address(new Sale(config_));\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(\n        bytes memory data_\n    ) internal virtual override returns (address) {\n        (\n            SaleConfig memory config_,\n            SaleRedeemableERC20Config memory saleRedeemableERC20Config_\n        ) = abi.decode(data_, (SaleConfig, SaleRedeemableERC20Config));\n        address clone_ = Clones.clone(implementation);\n        Sale(clone_).initialize(config_, saleRedeemableERC20Config_);\n        return clone_;\n    }\n\n    /// Allows calling `createChild` with `SeedERC20Config` struct.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `SaleConfig` constructor configuration.\n    /// @return New `Sale` child contract.\n    function createChildTyped(\n        SaleConfig calldata config_,\n        SaleRedeemableERC20Config memory saleRedeemableERC20Config_\n    ) external returns (Sale) {\n        return\n            Sale(createChild(abi.encode(config_, saleRedeemableERC20Config_)));\n    }\n}\n"
    },
    "contracts/sentinel/LibSentinel.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nbytes32 constant SENTINEL_HIGH_BITS = bytes32(\n    0xF000000000000000000000000000000000000000000000000000000000000000\n);\n"
    },
    "contracts/sstore2/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"./utils/Bytecode.sol\";\n\n/**\n  @title A key-value storage with auto-generated keys for storing chunks of\n  data with a lower write & read cost.\n  @author Agustin Aguilar <aa@horizon.io>\n\n  Readme: https://github.com/0xsequence/sstore2#readme\n*/\nlibrary SSTORE2 {\n    error WriteError();\n\n    /**\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\n    @dev The pointer is a contract address with `_data` as code\n    @param _data to be written\n    @return pointer Pointer to the written `_data`\n  */\n    function write(bytes memory _data) internal returns (address pointer) {\n        // Append 00 to _data so contract can't be called\n        // Build init code\n        bytes memory code = Bytecode.creationCodeFor(\n            abi.encodePacked(hex\"00\", _data)\n        );\n\n        // Deploy contract using create\n        assembly (\"memory-safe\") {\n            pointer := create(0, add(code, 32), mload(code))\n        }\n\n        // Address MUST be non-zero\n        if (pointer == address(0)) revert WriteError();\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first\n    byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @return data read from `_pointer` contract\n  */\n    function read(address _pointer) internal view returns (bytes memory) {\n        return Bytecode.codeAt(_pointer, 1, type(uint256).max);\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first\n    byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @return data read from `_pointer` contract\n  */\n    function read(\n        address _pointer,\n        uint256 _start\n    ) internal view returns (bytes memory) {\n        return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first\n    byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @param _end index before which to end extraction\n    @return data read from `_pointer` contract\n  */\n    function read(\n        address _pointer,\n        uint256 _start,\n        uint256 _end\n    ) internal view returns (bytes memory) {\n        return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\n    }\n}\n"
    },
    "contracts/sstore2/utils/Bytecode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nlibrary Bytecode {\n    error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\n\n    /**\n    @notice Generate a creation code that results on a contract with `_code` as\n    bytecode\n    @param _code The returning value of the resulting `creationCode`\n    @return creationCode (constructor) for new contract\n  */\n    function creationCodeFor(\n        bytes memory _code\n    ) internal pure returns (bytes memory) {\n        /*\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\n      0x01    0x80         0x80        DUP1                size size\n      0x02    0x60         0x600e      PUSH1 14            14 size size\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\n      0x04    0x39         0x39        CODECOPY            size\n      0x05    0x60         0x6000      PUSH1 00            0 size\n      0x06    0xf3         0xf3        RETURN\n      <CODE>\n    */\n\n        return\n            abi.encodePacked(\n                hex\"63\",\n                uint32(_code.length),\n                hex\"80_60_0E_60_00_39_60_00_F3\",\n                _code\n            );\n    }\n\n    /**\n    @notice Returns the size of the code on a given address\n    @param _addr Address that may or may not contain code\n    @return size of the code on the given `_addr`\n  */\n    function codeSize(address _addr) internal view returns (uint256 size) {\n        assembly (\"memory-safe\") {\n            size := extcodesize(_addr)\n        }\n    }\n\n    /**\n    @notice Returns the code of a given address\n    @dev It will fail if `_end < _start`\n    @param _addr Address that may or may not contain code\n    @param _start number of bytes of code to skip on read\n    @param _end index before which to end extraction\n    @return oCode read from `_addr` deployed bytecode\n\n    Forked: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\n  */\n    function codeAt(\n        address _addr,\n        uint256 _start,\n        uint256 _end\n    ) internal view returns (bytes memory oCode) {\n        uint256 csize = codeSize(_addr);\n        if (csize == 0) return bytes(\"\");\n\n        if (_start > csize) return bytes(\"\");\n        if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end);\n\n        unchecked {\n            uint256 reqSize = _end - _start;\n            uint256 maxSize = csize - _start;\n\n            uint256 size = maxSize < reqSize ? maxSize : reqSize;\n\n            assembly (\"memory-safe\") {\n                // allocate output byte array - this could also be done without\n                // assembly\n                // by using o_code = new bytes(size)\n                oCode := mload(0x40)\n                // new \"memory end\" including padding\n                mstore(\n                    0x40,\n                    add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f)))\n                )\n                // store length in memory\n                mstore(oCode, size)\n                // actually retrieve the code, this needs assembly\n                extcodecopy(_addr, add(oCode, 0x20), _start, size)\n            }\n        }\n    }\n}\n"
    },
    "contracts/stake/Stake.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"../interpreter/deploy/IExpressionDeployerV1.sol\";\nimport \"../interpreter/run/LibEncodedDispatch.sol\";\nimport \"../interpreter/run/LibStackPointer.sol\";\nimport \"../interpreter/run/LibContext.sol\";\nimport \"../array/LibUint256Array.sol\";\n\nimport \"../tier/TierV2.sol\";\nimport \"../tier/libraries/TierConstants.sol\";\n\nimport \"../tier/libraries/TierReport.sol\";\n\nimport {IERC20MetadataUpgradeable as IERC20Metadata} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ERC4626Upgradeable as ERC4626} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport {SafeCastUpgradeable as SafeCast} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable as ReentrancyGuard} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\n/// @dev Entrypoint for calculating the max deposit as per ERC4626.\nSourceIndex constant MAX_DEPOSIT_ENTRYPOINT = SourceIndex.wrap(0);\n/// @dev Entrypoint for calculating the max withdraw as per ERC4626.\nSourceIndex constant MAX_WITHDRAW_ENTRYPOINT = SourceIndex.wrap(1);\n\n/// @dev Minimum required outputs for the max deposit entrypoint.\nuint256 constant MAX_DEPOSIT_MIN_OUTPUTS = 1;\n/// @dev Minimum required outputs for the max withdraw entrypoint.\nuint256 constant MAX_WITHDRAW_MIN_OUTPUTS = 1;\n\n/// @dev Maximum usable outputs for the max deposit entrypoint.\nuint256 constant MAX_DEPOSIT_MAX_OUTPUTS = 1;\n/// @dev Maximum usable outputs for the max withdraw entrypoint.\nuint256 constant MAX_WITHDRAW_MAX_OUTPUTS = 1;\n\n/// Configuration required to initialized the Stake contract.\n/// @param asset The underlying ERC20 asset for the 4626 vault.\n/// @param name ERC20 name of the 4626 share token to be minted.\n/// @param symbol ERC20 symbol of the 4626 share token to be minted.\n/// @param expressionDeployer the address of the `IExpressionDeployerV1`.\n/// @param interpreter the address of the `IInterpreterV1`.\n/// @param stateConfig the expression to calculate max deposits and withdrawals.\nstruct StakeConfig {\n    IERC20Metadata asset;\n    string name;\n    string symbol;\n    address expressionDeployer;\n    address interpreter;\n    StateConfig stateConfig;\n}\n\n/// Similar to OpenZeppelin voting checkpoints. Consists of a timestamp and some\n/// amount. The timestamp is 32 bits leaving \"only\" 224 bits for the amount.\n/// The use case is\n/// @param timestamp\n/// @param amount Largest value we can squeeze into a uint256 alongside a\n/// uint32.\nstruct DepositRecord {\n    uint32 timestamp;\n    uint224 amount;\n}\n\n/// @title Stake\n/// @notice Extension of ERC4626 and implementation of `ITierV2` that records all\n/// mints and burns of the ERC4626 share token. `ITierV2` reports can be\n/// generated according to the internal ledger of share mints. The `ITierV2`\n/// context is treated as a list of thresholds that the owner must have minted\n/// corresponding shares for. As per `ITierV2` the times that the owner minted\n/// each threshold's amount of shares will be returned as a standard `ITierV2`\n/// encoded report.\n///\n/// As per ERC4626 shares are minted according to prorata deposits of the\n/// underlying asset defined at initialization. For example, increasing the total\n/// assets deposited by 10% entitles the depositor to increase the total supply\n/// of share tokens by 10%, minted for themselves on their ledger. Burns are the\n/// inverse logic, e.g. burning 10% of the share supply releases 10% of the\n/// underlying asset.\n///\n/// The dual ERC4626/ITierV2 implementation allows for native hybrid incentives.\n///\n/// The underlying ERC4626 asset can be transferred directly to `Stake` without\n/// minting any shares for the transfer. This effectively distributes those\n/// assets prorata between all shares outstanding at that moment. Subsequent\n/// share mints and burns will calculate against this larger underlying asset\n/// pool. I.e. new entrants have to provide more assets to mint the same number\n/// of shares and existing holders receive more assets per share when they burn\n/// than when they deposited.\n///\n/// At the same time, the staking ledger is exposed dynamically to incoming\n/// `report` calls according to runtime thresholds. This allows external\n/// incentives/access to be defined and updated over time. A single staking\n/// ledger could be reinterpreted for use in many external tier-based algorithms.\n/// For example, users could lose access to some exclusive event/group unless\n/// they periodically increase their share ledger to a minimum by some deadline.\n/// The external group simply winds up the thresholds passed as context to\n/// `report` over time and the existing ledger is reinterpreted accordingly.\n///\n/// Deposits and withdrawals are throttled/gated behind a deployed expression\n/// that is interpreted to calculate the maximum deposit and withdrawal values\n/// as per ERC4626.\n///\n/// Note that the total shares in circulation and the totals of the final entries\n/// in every account's ledgers is always 1:1. `Stake` doesn't allow for\n/// expressing inflationary tokenomics in the share token itself. Third party\n/// tokens may mint/burn themselves according to the share balances and ledger\n/// reports provided by `Stake`.\ncontract Stake is ERC4626, TierV2, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeCast for uint256;\n    using Math for uint256;\n    using LibUint256Array for uint256;\n    using LibUint256Array for uint256[];\n    using LibStackPointer for uint256[];\n    using LibStackPointer for StackPointer;\n\n    /// Emitted when the contract initializes.\n    /// @param sender msg.sender that initializes the contract.\n    /// @param config All config that initialized the contract.\n    event Initialize(address sender, StakeConfig config);\n\n    /// The ledger that records the time and amount of all share mints and burns.\n    mapping(address => DepositRecord[]) public depositRecords;\n\n    /// The interpreter that evaluates max deposits and withdrawal limits.\n    IInterpreterV1 internal interpreter;\n\n    /// The onchain address of the deployed expression.\n    address internal expression;\n\n    /// The encoded dispatch of the max deposit entrypoint.\n    EncodedDispatch internal dispatchMaxDeposit;\n\n    /// The encoded dispatch of the max withdraw entrypoint.\n    EncodedDispatch internal dispatchMaxWithdraw;\n\n    /// Constructor does nothing but prevents accidental initialization of an\n    /// implementation template intended to be referenced by a cloning factory.\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// Initializes the `Stake` contract in a proxy compatible way to support\n    /// cloning many staking contracts from a single onchain factory.\n    /// @param config_ All the initialization config.\n    function initialize(StakeConfig calldata config_) external initializer {\n        require(address(config_.asset) != address(0), \"0_ASSET\");\n        __ReentrancyGuard_init();\n        __ERC20_init(config_.name, config_.symbol);\n        __ERC4626_init(config_.asset);\n        __TierV2_init();\n        interpreter = IInterpreterV1(config_.interpreter);\n        address expression_ = IExpressionDeployerV1(config_.expressionDeployer)\n            .deployExpression(\n                config_.stateConfig,\n                LibUint256Array.arrayFrom(\n                    MAX_DEPOSIT_MIN_OUTPUTS,\n                    MAX_WITHDRAW_MIN_OUTPUTS\n                )\n            );\n        expression = expression_;\n        emit Initialize(msg.sender, config_);\n    }\n\n    /// General purpose eval for setting context, dispatching and catching the\n    /// result to downcast to `0` in the case of an external error.\n    /// @param dispatch_ The encoded dispatch to pass to the interpreter for\n    /// logic dispatch.\n    /// @param account_ The account to add to context, e.g. the receiver or owner\n    /// that is depositing or withdrawing.\n    /// @return The eval'd amount or `0` if there was an error during `eval` that\n    /// prevents an amount from being calculated.\n    function _eval(\n        EncodedDispatch dispatch_,\n        address account_\n    ) internal view returns (uint256) {\n        // ERC4626 mandates that maxDeposit MUST NOT revert. Any error must be\n        // caught and converted to a 0 max deposit. Note that `try` MAY NOT catch\n        // every error if the interpreter eval is sufficiently malformed the call\n        // will revert despite the `try`. For a well behaved expression on a well\n        // behaved interpreter the class of errors possible will be caught by the\n        // `try` and this will perform according to 4626 spec.\n        try\n            interpreter.eval(\n                dispatch_,\n                // Sadly there's no affordance in ERC4626 to allow either signed\n                // context or much in the way of caller context.\n                LibContext.build(\n                    new uint256[][](0),\n                    // We put the account being eval'd against as a single item\n                    // in caller context and that's the best we can do.\n                    uint256(uint160(account_)).arrayFrom(),\n                    new SignedContext[](0)\n                )\n            )\n        returns (\n            // Sadly ERC4626 mandates view behaviour of preview functions and that\n            // the preview and actual values are as close as possible. It is not\n            // obvious how to best handle state changes in this case so they are\n            // currently not supported.\n            uint256[] memory stack_,\n            uint256[] memory\n        ) {\n            // Guard against a 0 length stack, which well behaved expression\n            // deployers and interpreters should never return, but in case we\n            // hit this codepath return `0` instead of reverting.\n            if (stack_.length == 0) {\n                return 0;\n            } else {\n                unchecked {\n                    return stack_[stack_.length - 1];\n                }\n            }\n        } catch {\n            return 0;\n        }\n    }\n\n    /// Encodes a dispatch for the max deposit calculations.\n    /// @return The encoded dispatch for a max deposit calculation.\n    function _dispatchMaxDeposit() internal view returns (EncodedDispatch) {\n        return\n            LibEncodedDispatch.encode(\n                expression,\n                MAX_DEPOSIT_ENTRYPOINT,\n                MAX_DEPOSIT_MAX_OUTPUTS\n            );\n    }\n\n    /// Encodes a dispatch for the max withdrawal calculations.\n    /// @return The encoded dispatch for a max withdrawal calculation.\n    function _dispatchMaxWithdraw() internal view returns (EncodedDispatch) {\n        return\n            LibEncodedDispatch.encode(\n                expression,\n                MAX_WITHDRAW_ENTRYPOINT,\n                MAX_WITHDRAW_MAX_OUTPUTS\n            );\n    }\n\n    /// Thin wrapper around _eval for max deposit calculations.\n    /// @param receiver_ As per `maxDeposit`.\n    function _maxDeposit(address receiver_) internal view returns (uint256) {\n        return _eval(_dispatchMaxDeposit(), receiver_);\n    }\n\n    /// Dispatches a max withdraw calculation to the interpreter.\n    /// The interpreter expression MAY revert due to internal `ensure` calls or\n    /// similar so we have to try/catch down to a `0` value max withdrawal in\n    /// that case.\n    function _maxWithdraw(address owner_) internal view returns (uint256) {\n        return _eval(_dispatchMaxWithdraw(), owner_);\n    }\n\n    /// We will treat the max deposit as whatever the interpreter calculates,\n    /// capped to the inherited logic.\n    /// @inheritdoc ERC4626\n    function maxDeposit(\n        address receiver_\n    ) public view virtual override returns (uint256) {\n        return _maxDeposit(receiver_).min(super.maxDeposit(receiver_));\n    }\n\n    /// We will treat our max mint as the share-converted equivalent of our max\n    /// deposit as calculated by the interpreter, capped to the inherited logic.\n    /// @inheritdoc ERC4626\n    function maxMint(\n        address receiver_\n    ) public view virtual override returns (uint256) {\n        // > If (1) it’s calculating how many shares to issue to a user for a\n        // > certain amount of the underlying tokens they provide or (2) it’s\n        // > determining the amount of the underlying tokens to transfer to them\n        // > for returning a certain amount of shares, it should round down.\n        return\n            _convertToShares(_maxDeposit(receiver_), Math.Rounding.Down).min(\n                super.maxMint(receiver_)\n            );\n    }\n\n    /// @inheritdoc ERC4626\n    function maxWithdraw(\n        address owner_\n    ) public view virtual override returns (uint256) {\n        return _maxWithdraw(owner_).min(super.maxWithdraw(owner_));\n    }\n\n    /// @inheritdoc ERC4626\n    function maxRedeem(\n        address owner_\n    ) public view virtual override returns (uint256) {\n        // > If (1) it’s calculating the amount of shares a user has to supply\n        // > to receive a given amount of the underlying tokens or (2) it’s\n        // > calculating the amount of underlying tokens a user has to provide\n        // > to receive a certain amount of shares, it should round up.\n        return\n            _convertToShares(_maxWithdraw(owner_), Math.Rounding.Up).min(\n                super.maxRedeem(owner_)\n            );\n    }\n\n    /// @inheritdoc ERC4626\n    function _deposit(\n        address caller_,\n        address receiver_,\n        uint256 assets_,\n        uint256 shares_\n    ) internal virtual override nonReentrant {\n        require(receiver_ != address(0), \"0_DEPOSIT_RECEIVER\");\n        require(assets_ > 0, \"0_DEPOSIT_ASSETS\");\n        require(shares_ > 0, \"0_DEPOSIT_SHARES\");\n        // Deposit first then upgrade ledger.\n        super._deposit(caller_, receiver_, assets_, shares_);\n        _addSharesToStakingLedger(receiver_, shares_);\n    }\n\n    /// @inheritdoc ERC4626\n    function _withdraw(\n        address caller_,\n        address receiver_,\n        address owner_,\n        uint256 assets_,\n        uint256 shares_\n    ) internal virtual override nonReentrant {\n        require(receiver_ != address(0), \"0_WITHDRAW_RECEIVER\");\n        require(owner_ != address(0), \"0_WITHDRAW_OWNER\");\n        require(assets_ > 0, \"0_WITHDRAW_ASSETS\");\n        require(shares_ > 0, \"0_WITHDRAW_SHARES\");\n        // Downgrade ledger first then send assets.\n        _removeSharesFromStakingLedger(owner_, shares_);\n        super._withdraw(caller_, receiver_, owner_, assets_, shares_);\n    }\n\n    /// Add shares to the staking ledger. The ledger records absolute amounts at\n    /// as snapshots not relative increments. For example, if the ledger contains\n    /// one entry of 100 shares and another 50 shares are minted the second entry\n    /// will record 150 shares NOT 50. This is a tradeoff to increase the gas of\n    /// writes slightly to significantly decrease the gas and complexity of\n    /// subsequent reads.\n    /// @param owner_ The owner of the staking ledger that shares are added to.\n    /// @param shares_ Amount of shares being added to the ledger.\n    function _addSharesToStakingLedger(\n        address owner_,\n        uint256 shares_\n    ) internal {\n        uint256 len_ = depositRecords[owner_].length;\n        uint256 highwater_ = len_ > 0\n            ? depositRecords[owner_][len_ - 1].amount\n            : 0;\n        depositRecords[owner_].push(\n            DepositRecord(\n                uint32(block.timestamp),\n                (highwater_ + shares_).toUint224()\n            )\n        );\n    }\n\n    /// Update the staking ledger so that the given amount of shares are removed.\n    /// This involves ensuring the user has enough shares on their ledger total,\n    /// then finding the closest entry to the target number of shares remaining\n    /// on their ledger. There are a few edge cases near zero to handle but\n    /// overall the process is conceptually the same as generating a report and\n    /// deleting everything after it. Partial removals of an entry preserve times\n    /// but modify amounts.\n    ///\n    /// Case 1. Adding and removing the same number of shares\n    /// - Add 100 shares at index 0 time 0\n    /// - Add 100 shares at index 1 time 1\n    /// - Remove 200 shares at time 2\n    /// - Final ledger is empty (no indexes or times)\n    ///\n    /// Case 2. Adding and removing a single ledger entry exactly\n    /// - Add 100 shares at index 0 time 0\n    /// - Add 100 shares at index 1 time 1\n    /// - Remove 100 shares at time 2\n    /// - Final ledger contains only 100 shares at index 0 time 0\n    ///\n    /// Case 3. Adding and removing a single ledger entry partially\n    /// - Add 100 shares at index 0 time 0\n    /// - Add 100 shares at index 1 time 1\n    /// - Remove 50 shares at time 2\n    /// - Final ledger contains:\n    ///   - 100 shares at index 0 time 0\n    ///   - 150 shares at index 1 time 1\n    ///\n    /// Case 4. Adding and removing more than one entry\n    /// - Add 100 shares at index 0 time 0\n    /// - Add 100 shares at index 1 time 1\n    /// - Remove 150 shares at time 2\n    /// - Final ledger contains only 50 shares at index 0 time 0\n    ///\n    /// Case 5. Adding and removing more share than is on the ledger\n    /// - Add 100 shares at index 0 time 0\n    /// - Add 100 shares at index 1 time 1\n    /// - Remove 250 shares at time 2\n    /// - ERROR and rollback transaction, final ledger is unmodified\n    ///\n    /// @param owner_ Owner of the ledger the shares will be removed from.\n    /// @param shares_ Amount of shares to remove from the ledger.\n    function _removeSharesFromStakingLedger(\n        address owner_,\n        uint256 shares_\n    ) internal {\n        // MUST revert if length is 0 so we're guaranteed to have some amount\n        // for the old highwater. Users without deposits can't withdraw so there\n        // will be an overflow here.\n        uint256 i_ = depositRecords[owner_].length - 1;\n        uint256 oldHighwater_ = uint256(depositRecords[owner_][i_].amount);\n        // MUST revert if withdraw amount exceeds highwater. Overflow will\n        // ensure this.\n        uint256 newHighwater_ = oldHighwater_ - shares_;\n\n        uint256 high_ = 0;\n        if (newHighwater_ > 0) {\n            (high_, ) = _earliestTimeAtLeastThreshold(owner_, newHighwater_, 0);\n        }\n\n        unchecked {\n            while (i_ > high_) {\n                depositRecords[owner_].pop();\n                i_--;\n            }\n        }\n\n        // For non-zero highwaters we preserve the timestamp on the new top\n        // deposit and only set the amount to the new highwater.\n        if (newHighwater_ > 0) {\n            depositRecords[owner_][high_].amount = newHighwater_.toUint224();\n        } else {\n            depositRecords[owner_].pop();\n        }\n    }\n\n    /// @inheritdoc ITierV2\n    function report(\n        address account_,\n        uint256[] calldata context_\n    ) external view returns (uint256 report_) {\n        unchecked {\n            report_ = type(uint256).max;\n            if (context_.length > 0) {\n                uint256 high_ = 0;\n                uint256 time_ = uint256(TierConstants.NEVER_TIME);\n                for (uint256 t_ = 0; t_ < context_.length; t_++) {\n                    uint256 threshold_ = context_[t_];\n                    (, time_) = _earliestTimeAtLeastThreshold(\n                        account_,\n                        threshold_,\n                        high_\n                    );\n                    if (time_ == uint256(TierConstants.NEVER_TIME)) {\n                        break;\n                    }\n                    report_ = TierReport.updateTimeAtTier(report_, t_, time_);\n                }\n            }\n        }\n    }\n\n    /// @inheritdoc ITierV2\n    function reportTimeForTier(\n        address account_,\n        uint256 tier_,\n        uint256[] calldata context_\n    ) external view returns (uint256 time_) {\n        if (tier_ == 0) {\n            time_ = TierConstants.ALWAYS;\n        } else if (tier_ <= context_.length) {\n            uint256 threshold_ = context_[tier_ - 1];\n            (, time_) = _earliestTimeAtLeastThreshold(account_, threshold_, 0);\n        } else {\n            time_ = uint256(TierConstants.NEVER_TIME);\n        }\n    }\n\n    /// Inspired by the binary search implementation found in OpenZeppelin voting\n    /// checkpoints. Modified to fit expected tier/report time logic.\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.5/contracts/utils/Checkpoints.sol#L39\n    /// @param account_ Account to lookup times for the threshold for.\n    /// @param threshold_ Minimum (gte) amount that must have been deposited by\n    /// some time for a timestamp to be considered as relevant.\n    /// @param low_ Starting index of binary search. Setting anything other than\n    /// 0 will ignore lower indexes. Useful in loops where the previous high_\n    /// becomes the subsequent low.\n    /// @return high_ The index of the discovered time_.\n    /// @return time_ The earliest time deposits were found at or above the\n    /// given threshold.\n    function _earliestTimeAtLeastThreshold(\n        address account_,\n        uint256 threshold_,\n        uint256 low_\n    ) internal view returns (uint256 high_, uint256 time_) {\n        unchecked {\n            uint256 len_ = depositRecords[account_].length;\n            high_ = len_;\n            uint256 mid_;\n            DepositRecord memory depositRecord_;\n            while (low_ < high_) {\n                mid_ = Math.average(low_, high_);\n                depositRecord_ = depositRecords[account_][mid_];\n                if (uint256(depositRecord_.amount) >= threshold_) {\n                    high_ = mid_;\n                } else {\n                    low_ = mid_ + 1;\n                }\n            }\n            // At this point high_ and low_ are equal, but mid_ has not been\n            // updated to match, so high_ is what we return as-is.\n            time_ = high_ == len_\n                ? uint256(TierConstants.NEVER_TIME)\n                : depositRecords[account_][high_].timestamp;\n        }\n    }\n}\n"
    },
    "contracts/stake/StakeFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport {Stake, StakeConfig} from \"./Stake.sol\";\nimport {ClonesUpgradeable as Clones} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\n/// @title StakeFactory\n/// @notice Factory for deploying and registering `Stake` contracts.\ncontract StakeFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new Stake());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(\n        bytes memory data_\n    ) internal virtual override returns (address) {\n        StakeConfig memory config_ = abi.decode(data_, (StakeConfig));\n        address clone_ = Clones.clone(implementation);\n        Stake(clone_).initialize(config_);\n        return clone_;\n    }\n\n    /// Allows calling `createChild` with `StakeConfig` struct.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `Stake` initializer configuration.\n    /// @return New `Stake` child contract.\n    function createChildTyped(\n        StakeConfig memory config_\n    ) external returns (Stake) {\n        return Stake(createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "contracts/test/array/LibUint256Array/LibUint256ArrayTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../array/LibUint256Array.sol\";\nimport \"../../../interpreter/run/LibStackPointer.sol\";\n\n/// @title LibUint256ArrayTest\n/// Thin wrapper around `LibUint256Array` library exposing methods for testing\ncontract LibUint256ArrayTest {\n    using LibUint256Array for uint256[];\n    using LibStackPointer for uint256[];\n    using LibStackPointer for StackPointer;\n\n    function arrayFrom(uint256 a_) external pure returns (uint256[] memory) {\n        return LibUint256Array.arrayFrom(a_);\n    }\n\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_\n    ) external pure returns (uint256[] memory) {\n        return LibUint256Array.arrayFrom(a_, b_);\n    }\n\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_,\n        uint256 c_\n    ) external pure returns (uint256[] memory) {\n        return LibUint256Array.arrayFrom(a_, b_, c_);\n    }\n\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_,\n        uint256 c_,\n        uint256 d_\n    ) external pure returns (uint256[] memory) {\n        return LibUint256Array.arrayFrom(a_, b_, c_, d_);\n    }\n\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_,\n        uint256 c_,\n        uint256 d_,\n        uint256 e_\n    ) external pure returns (uint256[] memory) {\n        return LibUint256Array.arrayFrom(a_, b_, c_, d_, e_);\n    }\n\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_,\n        uint256 c_,\n        uint256 d_,\n        uint256 e_,\n        uint256 f_\n    ) external pure returns (uint256[] memory) {\n        return LibUint256Array.arrayFrom(a_, b_, c_, d_, e_, f_);\n    }\n\n    function arrayFrom(\n        uint256 a_,\n        uint256[] memory tail_\n    ) external pure returns (uint256[] memory) {\n        return LibUint256Array.arrayFrom(a_, tail_);\n    }\n\n    function arrayFrom(\n        uint256 a_,\n        uint256 b_,\n        uint256[] memory tail_\n    ) external pure returns (uint256[] memory) {\n        return LibUint256Array.arrayFrom(a_, b_, tail_);\n    }\n\n    function truncate(\n        uint256[] memory array_,\n        uint256 newLength_\n    ) external pure returns (uint256[] memory) {\n        array_.truncate(newLength_);\n        return array_;\n    }\n\n    function extend(\n        uint256[] memory base_,\n        uint256[] memory extend_\n    ) external pure returns (uint256[] memory baseCopy_) {\n        baseCopy_ = new uint256[](base_.length);\n        LibUint256Array.unsafeCopyValuesTo(\n            base_,\n            StackPointer.unwrap(baseCopy_.asStackPointer().up())\n        );\n        baseCopy_.extend(extend_);\n        return baseCopy_;\n    }\n\n    function unsafeCopyValuesTo(\n        uint256[] memory inputs_\n    ) external pure returns (uint256[] memory) {\n        uint256[] memory outputs_ = new uint256[](inputs_.length);\n        LibUint256Array.unsafeCopyValuesTo(\n            inputs_,\n            StackPointer.unwrap(outputs_.asStackPointer().up())\n        );\n        return outputs_;\n    }\n\n    function copyToNewUint256Array(\n        uint256[] memory inputs_\n    ) external pure returns (uint256[] memory) {\n        uint256 inputCursor_;\n        assembly (\"memory-safe\") {\n            inputCursor_ := add(inputs_, 0x20)\n        }\n        return\n            LibUint256Array.copyToNewUint256Array(inputCursor_, inputs_.length);\n    }\n\n    function matrixFrom(\n        uint256[] memory a_\n    ) external pure returns (uint256[][] memory) {\n        return LibUint256Array.matrixFrom(a_);\n    }\n}\n"
    },
    "contracts/test/bytes/LibBytes/LibBytesTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../bytes/LibBytes.sol\";\nimport \"../../../interpreter/run/LibStackPointer.sol\";\nimport \"../../../debug/LibDebug.sol\";\n\n/// @title LibBytesTest\n/// Thin wrapper around `LibBytes` library exposing methods for testing\ncontract LibBytesTest {\n    using LibBytes for uint256;\n    using LibStackPointer for bytes;\n    using LibStackPointer for StackPointer;\n\n    function unsafeCopyBytesTo(\n        bytes memory bytes0_,\n        bytes memory bytes1_\n    ) external returns (StackPointer) {\n        LibDebug.dumpMemory();\n        LibBytes.unsafeCopyBytesTo(\n            StackPointer.unwrap(bytes1_.asStackPointer().up()),\n            StackPointer.unwrap(bytes0_.asStackPointer()),\n            bytes1_.length\n        );\n        LibDebug.dumpMemory();\n        return bytes0_.asStackPointer().upBytes(bytes1_.length);\n    }\n}\n"
    },
    "contracts/test/dance/SeedDance/LibCommitmentTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {LibCommitment, Commitment, Secret} from \"../../../dance/SeedDance.sol\";\n\n/// @title LibCommitmentTest\n/// Thin wrapper around the `LibCommitment` library\ncontract LibCommitmentTest {\n    function eq(Commitment a_, Commitment b_) external pure returns (bool eq_) {\n        eq_ = LibCommitment.eq(a_, b_);\n    }\n\n    function fromSecret(\n        Secret secret_\n    ) external pure returns (Commitment commitment_) {\n        commitment_ = LibCommitment.fromSecret(secret_);\n    }\n\n    function nil() external pure returns (Commitment nil_) {\n        nil_ = LibCommitment.nil();\n    }\n}\n"
    },
    "contracts/test/dance/SeedDance/LibSeedTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {LibSeed, Seed} from \"../../../dance/SeedDance.sol\";\n\n/// @title LibSeedTest\n/// Thin wrapper around the `LibSeed` library\ncontract LibSeedTest {\n    function with(\n        Seed seed_,\n        uint256 val_\n    ) external pure returns (Seed newSeed_) {\n        newSeed_ = LibSeed.with(seed_, val_);\n    }\n}\n"
    },
    "contracts/test/dance/SeedDance/SeedDanceTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport {SeedDance, Seed, Commitment, TimeBound, Secret} from \"../../../dance/SeedDance.sol\";\n\n/// @title SeedDanceTest\n/// Thin wrapper around the `SeedDance` contract to expose internal functions\n/// for testing\ncontract SeedDanceTest is SeedDance {\n    function sharedSeed() external view returns (Seed) {\n        return _sharedSeed;\n    }\n\n    function start(Seed initialSeed_) external {\n        _start(initialSeed_);\n    }\n\n    function commit(Commitment commitment_) external {\n        _commit(commitment_);\n    }\n\n    function reveal(TimeBound memory timeBound_, Secret secret_) external {\n        _reveal(timeBound_, secret_);\n    }\n}\n"
    },
    "contracts/test/erc3156/ERC3156FlashBorrowerBuyTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport \"../../ierc3156/IERC3156FlashBorrower.sol\";\nimport {ERC20Upgradeable as ERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"../../math/FixedPointMath.sol\";\nimport {OrderBook, TakeOrderConfig, TakeOrdersConfig} from \"../../orderbook/OrderBook.sol\";\n\n/// @title ERC3156FlashBorrowerBuyTest\ncontract ERC3156FlashBorrowerBuyTest is IERC3156FlashBorrower {\n    using FixedPointMath for uint256;\n    using SafeERC20 for IERC20;\n\n    function onFlashLoan(\n        address,\n        address tokenA_,\n        uint256 amount_,\n        uint256,\n        bytes calldata data_\n    ) external returns (bytes32) {\n        TakeOrdersConfig memory takeOrdersConfig = abi.decode(\n            data_,\n            (TakeOrdersConfig)\n        );\n\n        // simulate 'buy' from external market using loaned tokenA_\n\n        // 'gives' tokenA_ to market\n        IERC20(tokenA_).safeTransfer(address(1), amount_);\n\n        // 'receives' tokenB from market.\n        // make sure this contract has at least a balance of `receiveAmountB`\n        // before triggering `onFlashLoan` callback.\n        uint256 receiveAmountB = amount_.fixedPointMul(1020000000000000000);\n        require(\n            IERC20(takeOrdersConfig.output).balanceOf(address(this)) ==\n                receiveAmountB,\n            \"PRE_BUY\"\n        );\n\n        // approve orderbook transfer\n        IERC20(takeOrdersConfig.output).approve(msg.sender, receiveAmountB);\n\n        // take orderbook order\n        OrderBook(msg.sender).takeOrders(takeOrdersConfig);\n\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n}\n"
    },
    "contracts/test/erc3156/ERC3156FlashBorrowerDepositTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport \"../../ierc3156/IERC3156FlashBorrower.sol\";\nimport {ERC20Upgradeable as ERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"../../math/FixedPointMath.sol\";\nimport {OrderBook, DepositConfig} from \"../../orderbook/OrderBook.sol\";\n\n/// @title ERC3156FlashBorrowerDepositTest\ncontract ERC3156FlashBorrowerDepositTest is IERC3156FlashBorrower {\n    using FixedPointMath for uint256;\n    using SafeERC20 for IERC20;\n\n    function onFlashLoan(\n        address,\n        address token_,\n        uint256 amount_,\n        uint256,\n        bytes calldata data_\n    ) external returns (bytes32) {\n        DepositConfig memory depositConfig = abi.decode(data_, (DepositConfig));\n\n        // approve orderbook transfer\n        IERC20(token_).approve(msg.sender, amount_);\n\n        // deposit the flash loan\n        OrderBook(msg.sender).deposit(depositConfig);\n\n        // 'Approve' debt finalization.\n        IERC20(token_).approve(msg.sender, amount_);\n\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n}\n"
    },
    "contracts/test/erc3156/ERC3156FlashBorrowerWithdrawTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport \"../../ierc3156/IERC3156FlashBorrower.sol\";\nimport {ERC20Upgradeable as ERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"../../math/FixedPointMath.sol\";\nimport {OrderBook, WithdrawConfig, DepositConfig} from \"../../orderbook/OrderBook.sol\";\n\n/// @title ERC3156FlashBorrowerWithdrawTest\ncontract ERC3156FlashBorrowerWithdrawTest is IERC3156FlashBorrower {\n    using FixedPointMath for uint256;\n    using SafeERC20 for IERC20;\n\n    function orderBookDeposit(\n        address orderbook_,\n        DepositConfig calldata config_\n    ) external {\n        IERC20(config_.token).approve(orderbook_, config_.amount);\n        OrderBook(orderbook_).deposit(config_);\n    }\n\n    function onFlashLoan(\n        address,\n        address token_,\n        uint256 amount_,\n        uint256,\n        bytes calldata data_\n    ) external returns (bytes32) {\n        WithdrawConfig memory withdrawConfig = abi.decode(\n            data_,\n            (WithdrawConfig)\n        );\n\n        OrderBook(msg.sender).withdraw(withdrawConfig);\n\n        // approve orderbook transfer\n        IERC20(token_).approve(msg.sender, amount_);\n\n        return keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    }\n}\n"
    },
    "contracts/test/escrow/RedeemableERC20ClaimEscrow/RedeemableERC20ClaimEscrowWrapper.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {RedeemableERC20ClaimEscrow} from \"../../../escrow/RedeemableERC20ClaimEscrow.sol\";\n\n/// @title RedeemableERC20ClaimEscrowWrapper\n/// Thin wrapper around the `RedeemableERC20ClaimEscrow` contract with\n/// accessors to facilitate hardhat unit testing of `internal` variables.\ncontract RedeemableERC20ClaimEscrowWrapper is RedeemableERC20ClaimEscrow {\n    function getWithdrawals(\n        address trust_,\n        address token_,\n        uint256 supply_,\n        address withdrawer_\n    ) external view returns (uint256) {\n        return withdrawals[trust_][token_][supply_][withdrawer_];\n    }\n\n    function getPendingDeposits(\n        address trust_,\n        address token_,\n        address depositor_\n    ) external view returns (uint256) {\n        return pendingDeposits[trust_][token_][depositor_];\n    }\n\n    function getDeposits(\n        address trust_,\n        address token_,\n        address depositor_,\n        uint256 supply_\n    ) external view returns (uint256) {\n        return deposits[trust_][token_][depositor_][supply_];\n    }\n\n    function getTotalDeposits(\n        address trust_,\n        address token_,\n        uint256 supply_\n    ) external view returns (uint256) {\n        return totalDeposits[trust_][token_][supply_];\n    }\n}\n"
    },
    "contracts/test/factory/Factory/FactoryChildTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/// @notice Test contract to act as mock child contract for `FactoryTest`.\ncontract FactoryChildTest is Initializable {\n    /// Contract is constructing.\n    /// @param sender `msg.sender` of the contract deployer.\n    event Construct(address sender);\n\n    /// Contract is initializing (being cloned by factory).\n    /// @param sender `msg.sender` of the contract initializer (cloner).\n    /// @param value just some value.\n    event Initialize(address sender, uint256 value);\n\n    constructor() {\n        emit Construct(msg.sender);\n    }\n\n    function initialize(uint256 value_) external initializer {\n        emit Initialize(msg.sender, value_);\n    }\n}\n"
    },
    "contracts/test/factory/Factory/FactoryTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {Factory} from \"../../../factory/Factory.sol\";\nimport \"./FactoryChildTest.sol\";\n\nimport {ClonesUpgradeable as Clones} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\n/// @title FactoryTest\n/// @notice Test factory for creating and deploying `FactoryChildTest` contracts.\ncontract FactoryTest is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address private immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new FactoryChildTest());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(\n        bytes memory data_\n    ) internal virtual override returns (address) {\n        uint256 value_ = abi.decode(data_, (uint256));\n        address clone_ = Clones.clone(implementation);\n        FactoryChildTest(clone_).initialize(value_);\n        return clone_;\n    }\n\n    /// Allows calling `createChild` with `uint256` type.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param value_ `uint256` some value to be sent down to child.\n    /// @return New `FactoryChildTest` child contract.\n    function createChildTyped(\n        uint256 value_\n    ) external returns (FactoryChildTest) {\n        return FactoryChildTest(createChild(abi.encodePacked(value_)));\n    }\n}\n"
    },
    "contracts/test/interpreter/integrity/LibIntegrityState/LibIntegrityStateTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../interpreter/deploy/LibIntegrityCheck.sol\";\nimport \"../../../../debug/LibDebug.sol\";\nimport \"../../../../type/LibCast.sol\";\nimport \"../../../../interpreter/ops/AllStandardOps.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @title LibIntegrityCheckTest\n/// Test wrapper around `LibIntegrityCheck` library.\ncontract LibIntegrityCheckTest {\n    using LibIntegrityCheck for IntegrityCheckState;\n    using LibCast for uint256[];\n\n    function integrityFunctionPointers()\n        internal\n        view\n        virtual\n        returns (\n            function(IntegrityCheckState memory, Operand, StackPointer)\n                view\n                returns (StackPointer)[]\n                memory\n        )\n    {\n        function(IntegrityCheckState memory, Operand, StackPointer)\n            view\n            returns (StackPointer)[]\n            memory localFnPtrs_ = new function(\n                IntegrityCheckState memory,\n                Operand,\n                StackPointer\n            ) view returns (StackPointer)[](0);\n        return AllStandardOps.integrityFunctionPointers(localFnPtrs_);\n    }\n\n    function syncStackMaxTop(\n        StateConfig memory config_,\n        StackPointer stackMaxTop_,\n        StackPointer stackTop_\n    ) external returns (StackPointer) {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(config_, integrityFunctionPointers());\n        integrityCheckState_.stackMaxTop = stackMaxTop_;\n        LibDebug.dumpMemory();\n        integrityCheckState_.syncStackMaxTop(stackTop_);\n        LibDebug.dumpMemory();\n        return integrityCheckState_.stackMaxTop;\n    }\n\n    function ensureIntegrityTest(\n        StateConfig memory config_,\n        SourceIndex sourceIndex_,\n        StackPointer stackTop_,\n        uint256 minStackOutputs_\n    ) external returns (StackPointer) {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(config_, integrityFunctionPointers());\n        LibDebug.dumpMemory();\n        integrityCheckState_.ensureIntegrity(\n            sourceIndex_,\n            stackTop_,\n            minStackOutputs_\n        );\n        LibDebug.dumpMemory();\n        return stackTop_;\n    }\n\n    function push(\n        StateConfig memory config_,\n        StackPointer stackMaxTop_,\n        StackPointer stackTop_\n    )\n        external\n        view\n        returns (StackPointer stackTopAfter_, uint256 newStackMaxTop)\n    {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(config_, integrityFunctionPointers());\n        integrityCheckState_.stackMaxTop = stackMaxTop_;\n\n        stackTopAfter_ = integrityCheckState_.push(stackTop_);\n        newStackMaxTop = StackPointer.unwrap(integrityCheckState_.stackMaxTop);\n    }\n\n    function push(\n        StateConfig memory config_,\n        StackPointer stackMaxTop_,\n        StackPointer stackTop_,\n        uint256 n_\n    )\n        external\n        view\n        returns (StackPointer stackTopAfter_, uint256 newStackMaxTop)\n    {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(config_, integrityFunctionPointers());\n        integrityCheckState_.stackMaxTop = stackMaxTop_;\n\n        stackTopAfter_ = integrityCheckState_.push(stackTop_, n_);\n        newStackMaxTop = StackPointer.unwrap(integrityCheckState_.stackMaxTop);\n    }\n\n    function pushIgnoreHighwater(\n        StateConfig memory config_,\n        StackPointer stackMaxTop_,\n        StackPointer stackTop_\n    )\n        external\n        view\n        returns (StackPointer stackTopAfter_, uint256 newStackMaxTop)\n    {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(config_, integrityFunctionPointers());\n        integrityCheckState_.stackMaxTop = stackMaxTop_;\n\n        stackTopAfter_ = integrityCheckState_.push(stackTop_);\n        newStackMaxTop = StackPointer.unwrap(integrityCheckState_.stackMaxTop);\n    }\n\n    function popUnderflowCheck(\n        StateConfig memory config_,\n        StackPointer stackBottom_,\n        StackPointer stackHighwater_,\n        StackPointer stackMaxTop_,\n        StackPointer stackTop_\n    ) external view {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(config_, integrityFunctionPointers());\n        integrityCheckState_.stackBottom = stackBottom_;\n        integrityCheckState_.stackHighwater = stackHighwater_;\n        integrityCheckState_.stackMaxTop = stackMaxTop_;\n\n        integrityCheckState_.popUnderflowCheck(stackTop_);\n    }\n\n    function pop(\n        StateConfig memory config_,\n        StackPointer stackBottom_,\n        StackPointer stackHighwater_,\n        StackPointer stackMaxTop_,\n        StackPointer stackTop_\n    ) external view returns (StackPointer stackTopAfter_) {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(config_, integrityFunctionPointers());\n        integrityCheckState_.stackBottom = stackBottom_;\n        integrityCheckState_.stackHighwater = stackHighwater_;\n        integrityCheckState_.stackMaxTop = stackMaxTop_;\n        stackTopAfter_ = integrityCheckState_.pop(stackTop_);\n    }\n\n    function pop(\n        StateConfig memory config_,\n        StackPointer stackBottom_,\n        StackPointer stackHighwater_,\n        StackPointer stackMaxTop_,\n        StackPointer stackTop_,\n        uint256 n_\n    ) external view returns (StackPointer stackTopAfter_) {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(config_, integrityFunctionPointers());\n        integrityCheckState_.stackBottom = stackBottom_;\n        integrityCheckState_.stackHighwater = stackHighwater_;\n        integrityCheckState_.stackMaxTop = stackMaxTop_;\n        stackTopAfter_ = integrityCheckState_.pop(stackTop_, n_);\n    }\n\n    function _fn0(uint256) internal pure returns (uint256) {\n        return 0;\n    }\n\n    function _fn1(Operand, uint256) internal pure returns (uint256) {\n        return 0;\n    }\n\n    function _fn2(uint256, uint256) internal pure returns (uint256) {\n        return 0;\n    }\n\n    function _fn3(Operand, uint256, uint256) internal pure returns (uint256) {\n        return 0;\n    }\n\n    function _fn4(uint256, uint256, uint256) internal pure returns (uint256) {\n        return 0;\n    }\n\n    function _fn5(uint256[] memory) internal pure returns (uint256) {\n        return 0;\n    }\n\n    function _fn6(\n        uint256,\n        uint256,\n        uint256[] memory\n    ) internal pure returns (uint256) {\n        return 0;\n    }\n\n    function _fn7(\n        uint256,\n        uint256,\n        uint256,\n        uint256[] memory\n    ) internal pure returns (uint256) {\n        return 0;\n    }\n\n    function _fn8(\n        uint256,\n        uint256[] memory,\n        uint256[] memory\n    ) internal pure returns (uint256[] memory) {\n        return new uint256[](3); // arbitrary length\n    }\n\n    // function(uint256, uint256) internal view returns (uint256)\n    function applyFnN(\n        StackPointer stackTop_,\n        uint256 n_\n    ) external view returns (StackPointer) {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(\n                StateConfig(new bytes[](0), new uint256[](0)),\n                integrityFunctionPointers()\n            );\n        integrityCheckState_.stackMaxTop = stackTop_;\n        return integrityCheckState_.applyFnN(stackTop_, _fn2, n_);\n    }\n\n    // function(uint256) internal view returns (uint256)\n    function applyFn0(\n        StackPointer stackTop_\n    ) external view returns (StackPointer) {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(\n                StateConfig(new bytes[](0), new uint256[](0)),\n                integrityFunctionPointers()\n            );\n        integrityCheckState_.stackMaxTop = stackTop_;\n        return integrityCheckState_.applyFn(stackTop_, _fn0);\n    }\n\n    // function(Operand, uint256) internal view returns (uint256)\n    function applyFn1(\n        StackPointer stackTop_\n    ) external view returns (StackPointer) {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(\n                StateConfig(new bytes[](0), new uint256[](0)),\n                integrityFunctionPointers()\n            );\n        integrityCheckState_.stackMaxTop = stackTop_;\n        return integrityCheckState_.applyFn(stackTop_, _fn1);\n    }\n\n    // function(uint256, uint256) internal view returns (uint256)\n    function applyFn2(\n        StackPointer stackTop_\n    ) external view returns (StackPointer) {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(\n                StateConfig(new bytes[](0), new uint256[](0)),\n                integrityFunctionPointers()\n            );\n        integrityCheckState_.stackMaxTop = stackTop_;\n        return integrityCheckState_.applyFn(stackTop_, _fn2);\n    }\n\n    // function(Operand, uint256, uint256) internal view returns (uint256)\n    function applyFn3(\n        StackPointer stackTop_\n    ) external view returns (StackPointer) {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(\n                StateConfig(new bytes[](0), new uint256[](0)),\n                integrityFunctionPointers()\n            );\n        integrityCheckState_.stackMaxTop = stackTop_;\n        return integrityCheckState_.applyFn(stackTop_, _fn3);\n    }\n\n    // function(uint256, uint256, uint256) internal view returns (uint256)\n    function applyFn4(\n        StackPointer stackTop_\n    ) external view returns (StackPointer) {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(\n                StateConfig(new bytes[](0), new uint256[](0)),\n                integrityFunctionPointers()\n            );\n        integrityCheckState_.stackMaxTop = stackTop_;\n        return integrityCheckState_.applyFn(stackTop_, _fn4);\n    }\n\n    // function(uint256[] memory) internal view returns (uint256)\n    function applyFn5(\n        StackPointer stackTop_,\n        uint256 length_\n    ) external view returns (StackPointer) {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(\n                StateConfig(new bytes[](0), new uint256[](0)),\n                integrityFunctionPointers()\n            );\n        integrityCheckState_.stackMaxTop = stackTop_;\n        return integrityCheckState_.applyFn(stackTop_, _fn5, length_);\n    }\n\n    // function(uint256, uint256, uint256[] memory) internal view returns (uint256)\n    function applyFn6(\n        StackPointer stackTop_,\n        uint256 length_\n    ) external view returns (StackPointer) {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(\n                StateConfig(new bytes[](0), new uint256[](0)),\n                integrityFunctionPointers()\n            );\n        integrityCheckState_.stackMaxTop = stackTop_;\n        return integrityCheckState_.applyFn(stackTop_, _fn6, length_);\n    }\n\n    // function(uint256, uint256, uint256, uint256[] memory) internal view returns (uint256)\n    function applyFn7(\n        StackPointer stackTop_,\n        uint256 length_\n    ) external view returns (StackPointer) {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(\n                StateConfig(new bytes[](0), new uint256[](0)),\n                integrityFunctionPointers()\n            );\n        integrityCheckState_.stackMaxTop = stackTop_;\n        return integrityCheckState_.applyFn(stackTop_, _fn7, length_);\n    }\n\n    // function(uint256, uint256[] memory, uint256[] memory) internal view returns (uint256[] memory)\n    function applyFn8(\n        StackPointer stackTop_,\n        uint256 length_\n    ) external view returns (StackPointer) {\n        IntegrityCheckState memory integrityCheckState_ = LibIntegrityCheck\n            .newState(\n                StateConfig(new bytes[](0), new uint256[](0)),\n                integrityFunctionPointers()\n            );\n        integrityCheckState_.stackMaxTop = stackTop_;\n        return integrityCheckState_.applyFn(stackTop_, _fn8, length_);\n    }\n}\n"
    },
    "contracts/test/interpreter/runtime/IInterpreterV1Consumer.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../interpreter/run/IInterpreterV1.sol\";\nimport \"../../../interpreter/shared/Rainterpreter.sol\";\nimport \"hardhat/console.sol\";\n\ncontract IInterpreterV1Consumer {\n    uint256[] private _stack;\n    uint256[] private _stateChanges;\n\n    function eval(\n        IInterpreterV1 interpreter_,\n        EncodedDispatch dispatch_,\n        uint256[][] memory context_\n    ) external {\n        uint256 a_ = gasleft();\n        (uint256[] memory stack_, uint256[] memory stateChanges_) = interpreter_\n            .eval(dispatch_, context_);\n        uint256 b_ = gasleft();\n        console.log(\"eval gas\", a_ - b_);\n        _stack = stack_;\n        _stateChanges = stateChanges_;\n    }\n\n    function stateChanges(\n        IInterpreterV1 interpreter_,\n        uint256[] memory stateChanges_\n    ) external {\n        uint256 a_ = gasleft();\n        interpreter_.stateChanges(stateChanges_);\n        uint256 b_ = gasleft();\n        console.log(\"state changes gas\", a_ - b_);\n    }\n\n    function evalWithNamespace(\n        IInterpreterV1 interpreter_,\n        StateNamespace namespace_,\n        EncodedDispatch dispatch_,\n        uint256[][] memory context_\n    ) external {\n        uint256 a_ = gasleft();\n        (uint256[] memory stack_, uint256[] memory stateChanges_) = interpreter_\n            .evalWithNamespace(namespace_, dispatch_, context_);\n        uint256 b_ = gasleft();\n        console.log(\"eval with namespace gas\", a_ - b_);\n        _stack = stack_;\n        _stateChanges = stateChanges_;\n    }\n\n    function stateChangesWithNamespace(\n        IInterpreterV1 interpreter_,\n        StateNamespace namespace_,\n        uint256[] memory stateChanges_\n    ) external {\n        uint256 a_ = gasleft();\n        interpreter_.stateChangesWithNamespace(namespace_, stateChanges_);\n        uint256 b_ = gasleft();\n        console.log(\"state changes with namespace gas\", a_ - b_);\n    }\n\n    function stack() external view returns (uint256[] memory) {\n        return _stack;\n    }\n\n    function stackTop() external view returns (uint256) {\n        return _stack[_stack.length - 1];\n    }\n\n    function stateChanges() external view returns (uint256[] memory) {\n        return _stateChanges;\n    }\n}\n"
    },
    "contracts/test/interpreter/runtime/LibEncodedDispatch/LibEncodedDispatchTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../interpreter/run/LibEncodedDispatch.sol\";\n\n/// @title LibEncodedDispatchTest\n/// Thin wrapper around `LibEncodedDispatchTest` library exposing methods for testing\ncontract LibEncodedDispatchTest {\n    function encode(\n        address expressionPointer_,\n        uint256 sourceIndex_,\n        uint256 maxOutputs_\n    ) external pure returns (EncodedDispatch) {\n        return\n            LibEncodedDispatch.encode(\n                expressionPointer_,\n                SourceIndex.wrap(sourceIndex_),\n                maxOutputs_\n            );\n    }\n\n    function decode(\n        EncodedDispatch dispatch_\n    ) external pure returns (address, SourceIndex, uint256) {\n        return LibEncodedDispatch.decode(dispatch_);\n    }\n}\n"
    },
    "contracts/test/interpreter/runtime/LibInterpreterState/LibInterpreterStateTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../interpreter/run/LibInterpreterState.sol\";\nimport \"../../../../interpreter/run/LibStackPointer.sol\";\nimport \"../../../../interpreter/ops/AllStandardOps.sol\";\nimport \"../../../../type/LibCast.sol\";\nimport \"../../../../array/LibUint256Array.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title LibInterpreterStateTest\n/// Test wrapper around `LibInterpreterState` library.\ncontract LibInterpreterStateTest {\n    using LibInterpreterState for InterpreterState;\n    using LibInterpreterState for bytes;\n    using LibInterpreterState for StateConfig;\n    using LibStackPointer for uint256[];\n    using LibStackPointer for StackPointer;\n    using LibUint256Array for uint256;\n    using LibCast for function(InterpreterState memory, Operand, StackPointer)\n        view\n        returns (StackPointer)[];\n    using LibConvert for uint256[];\n\n    constructor() {}\n\n    function debug(\n        StateConfig memory config_,\n        uint256 stackLength_,\n        uint256[][] memory context_,\n        DebugStyle debugStyle_,\n        IInterpreterV1 interpreter_\n    )\n        external\n        view\n        returns (StackPointer stackTop_, StackPointer stackTopAfter_)\n    {\n        InterpreterState memory state_;\n        bytes memory serialized_ = serialize(\n            interpreter_,\n            config_,\n            stackLength_\n        );\n        state_ = serialized_.deserialize();\n        state_.context = context_;\n        stackTop_ = state_.stackBottom;\n        stackTopAfter_ = state_.debug(stackTop_.up(stackLength_), debugStyle_);\n    }\n\n    function serDeserialize(\n        StateConfig memory config_,\n        uint256 stackLength_,\n        uint256[][] memory context_,\n        IInterpreterV1 interpreter_\n    ) public view returns (InterpreterState memory state_) {\n        // TODO FIXME\n        // bytes memory serialized_ = serialize(config_, minStackOutputs_);\n        // state_ = serialized_.deserialize();\n        //state_.context = context_;\n\n        bytes memory serialized_ = serialize(\n            interpreter_,\n            config_,\n            stackLength_\n        );\n        state_ = serialized_.deserialize();\n        state_.context = context_;\n    }\n\n    function serialize(\n        IInterpreterV1 interpreter_,\n        StateConfig memory config_,\n        uint256 stackLength_\n    )\n        public\n        view\n        returns (\n            // uint256[] memory minStackOutputs_\n            bytes memory serialized_\n        )\n    {\n        // (, uint256 stackLength_) = IRainInterpreterIntegrity(\n        //     interpreterIntegrity\n        // ).ensureIntegrity(\n        //         config_.sources,\n        //         config_.constants.length,\n        //         minStackOutputs_\n        //     );\n\n        serialized_ = config_.serialize(\n            stackLength_,\n            interpreter_.functionPointers()\n        );\n    }\n\n    // function eval(\n    //     StateConfig memory config_,\n    //     uint256[] memory minStackOutputs_\n    // )\n    //     external\n    //     view\n    //     returns (StackPointer stackTopAfter_, uint256 stackBottom_)\n    // {\n    //     InterpreterState memory state_ = serDeserialize(\n    //         config_,\n    //         new uint256[][](0), // context,\n    //         minStackOutputs_\n    //     );\n\n    //     stackBottom_ = StackPointer.unwrap(state_.stackBottom);\n    //     stackTopAfter_ = state_.eval(SourceIndex.wrap(0), state_.stackBottom);\n    // }\n\n    // function eval(\n    //     StateConfig memory config_,\n    //     SourceIndex sourceIndex_,\n    //     uint256[] memory minStackOutputs_\n    // )\n    //     external\n    //     view\n    //     returns (StackPointer stackTopAfter_, uint256 stackBottom_)\n    // {\n    //     InterpreterState memory state_ = serDeserialize(\n    //         config_,\n    //         new uint256[][](0), // context\n    //         minStackOutputs_\n    //     );\n\n    //     stackBottom_ = StackPointer.unwrap(state_.stackBottom);\n    //     stackTopAfter_ = state_.eval(sourceIndex_, state_.stackBottom);\n    // }\n\n    // function evalStackPointer(\n    //     StateConfig memory config_,\n    //     uint256[] memory minStackOutputs_\n    // )\n    //     external\n    //     view\n    //     returns (StackPointer stackTopAfter_, uint256 stackBottom_)\n    // {\n    //     InterpreterState memory state_ = serDeserialize(\n    //         config_,\n    //         new uint256[][](0), // context\n    //         minStackOutputs_\n    //     );\n\n    //     stackBottom_ = StackPointer.unwrap(state_.stackBottom);\n    //     stackTopAfter_ = state_.eval(SourceIndex.wrap(0), state_.stackBottom); // just use normal stackBottom for testing\n    // }\n\n    // function evalStackPointer(\n    //     StateConfig memory config_,\n    //     SourceIndex sourceIndex_,\n    //     uint256[] memory minStackOutputs_\n    // )\n    //     external\n    //     view\n    //     returns (StackPointer stackTopAfter_, uint256 stackBottom_)\n    // {\n    //     InterpreterState memory state_ = serDeserialize(\n    //         config_,\n    //         new uint256[][](0), // context\n    //         minStackOutputs_\n    //     );\n\n    //     stackBottom_ = StackPointer.unwrap(state_.stackBottom);\n    //     stackTopAfter_ = state_.eval(sourceIndex_, state_.stackBottom); // just use normal stackBottom for testing\n    // }\n}\n"
    },
    "contracts/test/interpreter/runtime/LibStackTop/LibStackTopTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../../interpreter/run/LibStackPointer.sol\";\nimport \"../../../../debug/LibDebug.sol\";\nimport \"../../../../memory/LibMemorySize.sol\";\n\n/// @title LibStackPointerTest\n/// Test wrapper around `LibStackPointer` library.\n/// This contract DOES NOT simply expose library functions.\n/// Liberties have been made to make these functions testable, such as\n/// converting inputs to StackPointer type, or adding `up(n_)` shift functionality\n/// to functions so we can test in cases where a function is called when stack\n/// top is not at the bottom of the stack.\ncontract LibStackPointerTest {\n    using LibStackPointer for bytes;\n    using LibStackPointer for uint256;\n    using LibStackPointer for uint256[];\n    using LibStackPointer for StackPointer;\n    using LibMemorySize for bytes;\n    using LibMemorySize for bytes[];\n    using LibMemorySize for uint256;\n    using LibMemorySize for uint256[];\n\n    function doubler(uint256 a_) internal pure returns (uint256) {\n        return a_ * 2;\n    }\n\n    function multiplier(\n        Operand operand_,\n        uint256 a_\n    ) internal pure returns (uint256) {\n        return a_ * Operand.unwrap(operand_);\n    }\n\n    function summer(uint256 a_, uint256 b_) internal pure returns (uint256) {\n        return a_ + b_;\n    }\n\n    function summer3(\n        uint256 a_,\n        uint256 b_,\n        uint256 c_\n    ) internal pure returns (uint256) {\n        return a_ + b_ + c_;\n    }\n\n    function multiplier2(\n        Operand operand_,\n        uint256 a_,\n        uint256 b_\n    ) internal pure returns (uint256) {\n        return (a_ + b_) * Operand.unwrap(operand_);\n    }\n\n    function multiply2HeadsWithTailSum(\n        uint256 a_,\n        uint256 b_,\n        uint256[] memory tail_\n    ) internal pure returns (uint256) {\n        uint256 sum;\n        for (uint256 i_ = 0; i_ < tail_.length; i_++) {\n            sum += tail_[i_];\n        }\n        return (a_ + b_) * sum;\n    }\n\n    function multiply3HeadsWithTailSum(\n        uint256 a_,\n        uint256 b_,\n        uint256 c_,\n        uint256[] memory tail_\n    ) internal pure returns (uint256) {\n        uint256 sum;\n        for (uint256 i_ = 0; i_ < tail_.length; i_++) {\n            sum += tail_[i_];\n        }\n        return (a_ + b_ + c_) * sum;\n    }\n\n    function addHeadToTailsProduct(\n        uint256 a_,\n        uint256[] memory bs_,\n        uint256[] memory cs_\n    ) internal pure returns (uint256[] memory results_) {\n        results_ = new uint256[](bs_.length);\n        for (uint256 i_ = 0; i_ < bs_.length; i_++) {\n            results_[i_] = bs_[i_] * cs_[i_] + a_;\n        }\n    }\n\n    /// peekUp returning value above stack top\n\n    function peekUp(bytes memory bytes_) external returns (uint256 a_) {\n        LibDebug.dumpMemory();\n        a_ = bytes_.asStackPointer().peekUp();\n        LibDebug.dumpMemory();\n    }\n\n    function peekUp(\n        bytes memory bytes_,\n        uint256 n_\n    ) external returns (uint256 a_) {\n        LibDebug.dumpMemory();\n        a_ = bytes_.asStackPointer().up(n_).peekUp();\n        LibDebug.dumpMemory();\n    }\n\n    function peekUp(uint256[] memory array_) external returns (uint256 a_) {\n        LibDebug.dumpMemory();\n        a_ = array_.asStackPointer().peekUp();\n        LibDebug.dumpMemory();\n    }\n\n    function peekUp(\n        uint256[] memory array_,\n        uint256 n_\n    ) external returns (uint256 a_) {\n        LibDebug.dumpMemory();\n        a_ = array_.asStackPointer().up(n_).peekUp();\n        LibDebug.dumpMemory();\n    }\n\n    /// peekUp returning original stack top\n\n    function peekUpStackPointer(\n        bytes memory bytes_\n    ) external returns (StackPointer) {\n        LibDebug.dumpMemory();\n        bytes_.asStackPointer().peekUp();\n        LibDebug.dumpMemory();\n        return bytes_.asStackPointer();\n    }\n\n    function peekUpStackPointer(\n        bytes memory bytes_,\n        uint256 n_\n    ) external returns (StackPointer) {\n        LibDebug.dumpMemory();\n        bytes_.asStackPointer().up(n_).peekUp();\n        LibDebug.dumpMemory();\n        return bytes_.asStackPointer();\n    }\n\n    function peekUpStackPointer(\n        uint256[] memory array_\n    ) external returns (StackPointer) {\n        LibDebug.dumpMemory();\n        array_.asStackPointer().peekUp();\n        LibDebug.dumpMemory();\n        return array_.asStackPointer();\n    }\n\n    function peekUpStackPointer(\n        uint256[] memory array_,\n        uint256 n_\n    ) external returns (StackPointer) {\n        LibDebug.dumpMemory();\n        array_.asStackPointer().up(n_).peekUp();\n        LibDebug.dumpMemory();\n        return array_.asStackPointer();\n    }\n\n    function peek(bytes memory bytes_) external returns (uint256 a_) {\n        LibDebug.dumpMemory();\n        a_ = bytes_.asStackPointer().peek();\n        LibDebug.dumpMemory();\n    }\n\n    function peek(\n        bytes memory bytes_,\n        uint256 n_\n    ) external returns (uint256 a_) {\n        LibDebug.dumpMemory();\n        a_ = bytes_.asStackPointer().up(n_).peek();\n        LibDebug.dumpMemory();\n    }\n\n    function peek(uint256[] memory array_) external returns (uint256 a_) {\n        LibDebug.dumpMemory();\n        a_ = array_.asStackPointer().peek();\n        LibDebug.dumpMemory();\n    }\n\n    function peek(\n        uint256[] memory array_,\n        uint256 n_\n    ) external returns (uint256 a_) {\n        LibDebug.dumpMemory();\n        a_ = array_.asStackPointer().up(n_).peek();\n        LibDebug.dumpMemory();\n    }\n\n    function peek2(\n        bytes memory bytes_,\n        uint256 n_\n    ) external returns (uint256 a_, uint256 b_) {\n        LibDebug.dumpMemory();\n        (a_, b_) = bytes_.asStackPointer().up(n_).peek2();\n        LibDebug.dumpMemory();\n    }\n\n    function peek2(\n        uint256[] memory array_,\n        uint256 n_\n    ) external returns (uint256 a_, uint256 b_) {\n        LibDebug.dumpMemory();\n        (a_, b_) = array_.asStackPointer().up(n_).peek2();\n        LibDebug.dumpMemory();\n    }\n\n    function pop(\n        bytes memory bytes_,\n        uint256 n_\n    ) external returns (StackPointer stackTopAfter_, uint256 a_) {\n        LibDebug.dumpMemory();\n        (stackTopAfter_, a_) = bytes_.asStackPointer().up(n_).pop();\n        LibDebug.dumpMemory();\n    }\n\n    function pop(\n        uint256[] memory array_,\n        uint256 n_\n    ) external returns (StackPointer stackTopAfter_, uint256 a_) {\n        LibDebug.dumpMemory();\n        (stackTopAfter_, a_) = array_.asStackPointer().up(n_).pop();\n        LibDebug.dumpMemory();\n    }\n\n    function consumeSentinel(\n        uint256[] memory array_,\n        uint256 sentinel_,\n        uint256 stepSize_\n    )\n        external\n        pure\n        returns (\n            StackPointer stackTopSentinel_,\n            uint256[] memory arraySentinel_,\n            StackPointer stackTop_,\n            StackPointer stackBottom_\n        )\n    {\n        stackTop_ = array_.asStackPointer().up(array_.size() / 0x20);\n        stackBottom_ = array_.asStackPointer();\n        (stackTopSentinel_, arraySentinel_) = LibStackPointer.consumeSentinel(\n            stackTop_,\n            stackBottom_,\n            sentinel_,\n            stepSize_\n        );\n    }\n\n    function consumeSentinels(\n        uint256[] memory array_,\n        uint256 sentinel_,\n        uint256 stepSize0_,\n        uint256 stepSize1_\n    )\n        external\n        pure\n        returns (\n            StackPointer stackTopSentinel_,\n            uint256[] memory arraySentinel0_,\n            uint256[] memory arraySentinel1_,\n            StackPointer stackTop_,\n            StackPointer stackBottom_\n        )\n    {\n        // move stackTop to typical `eval` start position\n        stackTop_ = array_.asStackPointer().up(array_.size() / 0x20);\n        stackBottom_ = array_.asStackPointer();\n\n        (stackTopSentinel_, arraySentinel0_) = LibStackPointer.consumeSentinel(\n            stackTop_,\n            stackBottom_,\n            sentinel_,\n            stepSize0_\n        );\n\n        // consume another sentinel using new stackTop\n        (stackTopSentinel_, arraySentinel1_) = LibStackPointer.consumeSentinel(\n            stackTopSentinel_,\n            stackBottom_,\n            sentinel_,\n            stepSize1_\n        );\n    }\n\n    function set(\n        bytes memory bytes_,\n        uint256 a_,\n        uint256 n_\n    ) external returns (StackPointer) {\n        LibDebug.dumpMemory();\n        bytes_.asStackPointer().up(n_).set(a_);\n        LibDebug.dumpMemory();\n        return bytes_.asStackPointer();\n    }\n\n    function set(\n        uint256[] memory array_,\n        uint256 a_,\n        uint256 n_\n    ) external returns (StackPointer) {\n        LibDebug.dumpMemory();\n        array_.asStackPointer().up(n_).set(a_);\n        LibDebug.dumpMemory();\n        return array_.asStackPointer();\n    }\n\n    function push(\n        uint256[] memory array_,\n        uint256 a_\n    ) external returns (StackPointer stackTop_) {\n        LibDebug.dumpMemory();\n        stackTop_ = array_.asStackPointer().push(a_);\n        LibDebug.dumpMemory();\n    }\n\n    function push(\n        uint256[] memory array_,\n        uint256[] memory pushArray_\n    ) external returns (StackPointer stackTop_) {\n        LibDebug.dumpMemory();\n        stackTop_ = array_.asStackPointer().push(pushArray_);\n        LibDebug.dumpMemory();\n    }\n\n    function pushWithLength(\n        uint256[] memory array_,\n        uint256[] memory pushArray_\n    ) external returns (StackPointer stackTop_) {\n        LibDebug.dumpMemory();\n        stackTop_ = array_.asStackPointer().pushWithLength(pushArray_);\n        LibDebug.dumpMemory();\n    }\n\n    function unalignedPush(\n        bytes memory bytes0_,\n        bytes memory bytes1_\n    ) external returns (StackPointer stackTop_) {\n        LibDebug.dumpMemory();\n        stackTop_ = bytes0_.asStackPointer().unalignedPush(bytes1_);\n        LibDebug.dumpMemory();\n    }\n\n    function unalignedPushWithLength(\n        bytes memory bytes0_,\n        bytes memory bytes1_\n    ) external returns (StackPointer stackTop_) {\n        LibDebug.dumpMemory();\n        stackTop_ = bytes0_.asStackPointer().unalignedPushWithLength(bytes1_);\n        LibDebug.dumpMemory();\n    }\n\n    function push(\n        uint256[] memory array_,\n        uint256 a_,\n        uint256 b_,\n        uint256 c_,\n        uint256 d_,\n        uint256 e_,\n        uint256 f_,\n        uint256 g_,\n        uint256 h_\n    ) external returns (StackPointer stackTop_) {\n        stackTop_ = array_.asStackPointer();\n        LibDebug.dumpMemory();\n        stackTop_ = stackTop_.push(a_, b_, c_, d_, e_, f_, g_, h_);\n        LibDebug.dumpMemory();\n    }\n\n    function asStackPointer(\n        bytes memory bytes_\n    ) external returns (StackPointer stackTop_) {\n        LibDebug.dumpMemory();\n        stackTop_ = bytes_.asStackPointer();\n        LibDebug.dumpMemory();\n    }\n\n    function asStackPointerAsBytes(\n        bytes memory bytes_\n    ) external returns (bytes memory bytesCopy_) {\n        StackPointer stackTop_ = bytes_.asStackPointer();\n        LibDebug.dumpMemory();\n        bytesCopy_ = stackTop_.asBytes();\n        LibDebug.dumpMemory();\n        return bytesCopy_;\n    }\n\n    function asStackPointer(\n        uint256[] memory array_\n    ) external returns (StackPointer stackTop_) {\n        LibDebug.dumpMemory();\n        stackTop_ = array_.asStackPointer();\n        LibDebug.dumpMemory();\n    }\n\n    function asStackPointerAsUint256Array(\n        uint256[] memory array_\n    ) external returns (uint256[] memory arrayCopy_) {\n        StackPointer stackTop_ = array_.asStackPointer();\n        LibDebug.dumpMemory();\n        arrayCopy_ = stackTop_.asUint256Array();\n        LibDebug.dumpMemory();\n        return arrayCopy_;\n    }\n\n    function list(\n        uint256[] memory array_,\n        uint256 length_\n    ) external returns (uint256 head_, uint256[] memory tail_) {\n        LibDebug.dumpMemory();\n        (head_, tail_) = array_.asStackPointerUp().up(length_).list(length_);\n        LibDebug.dumpMemory();\n    }\n\n    function up(\n        uint256[] memory array_\n    )\n        external\n        returns (StackPointer stackTopBefore_, StackPointer stackTopAfter_)\n    {\n        stackTopBefore_ = array_.asStackPointer();\n        LibDebug.dumpMemory();\n        stackTopAfter_ = stackTopBefore_.up();\n        LibDebug.dumpMemory();\n    }\n\n    function up(\n        uint256[] memory array_,\n        uint256 n_\n    )\n        external\n        returns (StackPointer stackTopBefore_, StackPointer stackTopAfter_)\n    {\n        stackTopBefore_ = array_.asStackPointer();\n        LibDebug.dumpMemory();\n        stackTopAfter_ = stackTopBefore_.up(n_);\n        LibDebug.dumpMemory();\n    }\n\n    function upBytes(\n        uint256[] memory array_,\n        uint256 n_\n    )\n        external\n        returns (StackPointer stackTopBefore_, StackPointer stackTopAfter_)\n    {\n        stackTopBefore_ = array_.asStackPointer();\n        LibDebug.dumpMemory();\n        stackTopAfter_ = stackTopBefore_.upBytes(n_);\n        LibDebug.dumpMemory();\n    }\n\n    function down(\n        uint256[] memory array_\n    )\n        external\n        returns (StackPointer stackTopBefore_, StackPointer stackTopAfter_)\n    {\n        stackTopBefore_ = array_.asStackPointer();\n        LibDebug.dumpMemory();\n        stackTopAfter_ = stackTopBefore_.down();\n        LibDebug.dumpMemory();\n    }\n\n    function down(\n        uint256[] memory array_,\n        uint256 n_\n    )\n        external\n        returns (StackPointer stackTopBefore_, StackPointer stackTopAfter_)\n    {\n        stackTopBefore_ = array_.asStackPointer();\n        LibDebug.dumpMemory();\n        stackTopAfter_ = stackTopBefore_.down(n_);\n        LibDebug.dumpMemory();\n    }\n\n    function toIndex(\n        uint256[] memory array0_,\n        uint256[] memory array1_\n    )\n        external\n        returns (\n            uint256 index_,\n            StackPointer stackBottom_,\n            StackPointer stackTop_\n        )\n    {\n        stackBottom_ = array0_.asStackPointer();\n        stackTop_ = array1_.asStackPointer();\n        LibDebug.dumpMemory();\n        index_ = stackBottom_.toIndex(stackTop_);\n        LibDebug.dumpMemory();\n    }\n\n    // function(uint256) internal view returns (uint256)\n    function applyFn(\n        uint256[] memory array_\n    ) external returns (StackPointer stackTop_) {\n        LibDebug.dumpMemory();\n        stackTop_ = array_.asStackPointer().up(array_.size() / 0x20).applyFn(\n            doubler\n        );\n        LibDebug.dumpMemory();\n    }\n\n    // function(Operand, uint256) internal view returns (uint256)\n    function applyFn(\n        uint256[] memory array_,\n        uint256 operand_\n    ) external returns (StackPointer stackTop_) {\n        LibDebug.dumpMemory();\n        stackTop_ = array_.asStackPointer().up(array_.size() / 0x20).applyFn(\n            multiplier,\n            Operand.wrap(operand_)\n        );\n        LibDebug.dumpMemory();\n    }\n\n    // function(uint256, uint256) internal view returns (uint256)\n    function applyFnSummer(\n        uint256[] memory array_\n    ) external returns (StackPointer stackTop_) {\n        LibDebug.dumpMemory();\n        stackTop_ = array_.asStackPointer().up(array_.size() / 0x20).applyFn(\n            summer\n        );\n        LibDebug.dumpMemory();\n    }\n\n    // loop of function(uint256, uint256) internal view returns (uint256)\n    function applyFnNSummer(\n        uint256[] memory array_,\n        uint256 n_\n    ) external returns (StackPointer stackTop_) {\n        LibDebug.dumpMemory();\n        stackTop_ = array_.asStackPointer().up(array_.size() / 0x20).applyFnN(\n            summer,\n            n_\n        );\n        LibDebug.dumpMemory();\n    }\n\n    // function(uint256, uint256, uint256) internal view returns (uint256)\n    function applyFn3Summer(\n        uint256[] memory array_\n    ) external returns (StackPointer stackTop_) {\n        LibDebug.dumpMemory();\n        stackTop_ = array_.asStackPointer().up(array_.size() / 0x20).applyFn(\n            summer3\n        );\n        LibDebug.dumpMemory();\n    }\n\n    // function(Operand, uint256, uint256) internal view returns (uint256)\n    function applyFn2Operand(\n        uint256[] memory array_,\n        uint256 operand_\n    ) external returns (StackPointer stackTop_) {\n        LibDebug.dumpMemory();\n        stackTop_ = array_.asStackPointer().up(array_.size() / 0x20).applyFn(\n            multiplier2,\n            Operand.wrap(operand_)\n        );\n        LibDebug.dumpMemory();\n    }\n\n    // function(uint256, uint256, uint256[] memory) internal view returns (uint256)\n    function applyFn2Heads(\n        uint256[] memory array_,\n        uint256 length_\n    ) external returns (StackPointer stackTop_) {\n        LibDebug.dumpMemory();\n        stackTop_ = array_.asStackPointer().up(array_.size() / 0x20).applyFn(\n            multiply2HeadsWithTailSum,\n            length_\n        );\n        LibDebug.dumpMemory();\n    }\n\n    // function(uint256, uint256,, uint256 uint256[] memory) internal view returns (uint256)\n    function applyFn3Heads(\n        uint256[] memory array_,\n        uint256 length_\n    ) external returns (StackPointer stackTop_) {\n        LibDebug.dumpMemory();\n        stackTop_ = array_.asStackPointer().up(array_.size() / 0x20).applyFn(\n            multiply3HeadsWithTailSum,\n            length_\n        );\n        LibDebug.dumpMemory();\n    }\n\n    // function(uint256, uint256[] memory, uint256[] memory) internal view returns (uint256[] memory)\n    function applyFn2Tails(\n        uint256[] memory array_,\n        uint256 length_\n    ) external returns (StackPointer stackTop_) {\n        LibDebug.dumpMemory();\n        stackTop_ = array_.asStackPointer().up(array_.size() / 0x20).applyFn(\n            addHeadToTailsProduct,\n            length_\n        );\n        LibDebug.dumpMemory();\n    }\n}\n"
    },
    "contracts/test/kv/LibMemoryKVTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../kv/LibMemoryKV.sol\";\nimport \"../../debug/LibDebug.sol\";\n\n/// @title LibMemoryKVTest\n/// Thin wrapper around `LibMemoryKV` library exposing methods for testing\ncontract LibMemoryKVTest {\n    using LibMemoryKV for MemoryKV;\n    using LibMemoryKV for MemoryKVPtr;\n    using LibMemoryKV for MemoryKVKey;\n    using LibMemoryKV for MemoryKVVal;\n\n    /// BEGIN IN-MEMORY SCENARIOS\n\n    function scenario0(\n        MemoryKV kv_,\n        MemoryKVKey k_,\n        MemoryKVVal v_\n    ) external pure returns (uint256[] memory array_) {\n        kv_ = kv_.setVal(k_, v_);\n        array_ = kv_.toUint256Array();\n    }\n\n    function scenario1(\n        MemoryKV kv_,\n        MemoryKVKey k_,\n        MemoryKVVal v_\n    ) external pure returns (MemoryKVPtr ptr_) {\n        kv_ = kv_.setVal(k_, v_);\n        ptr_ = kv_.getPtr(k_);\n    }\n\n    function scenario2(\n        MemoryKV kv_,\n        MemoryKVKey k_\n    ) external pure returns (MemoryKVPtr ptr_) {\n        ptr_ = kv_.getPtr(k_);\n    }\n\n    function scenario3(\n        MemoryKV kv_,\n        MemoryKVKey k_,\n        MemoryKVVal v_\n    ) external pure returns (MemoryKVVal val_) {\n        kv_ = kv_.setVal(k_, v_);\n        MemoryKVPtr ptr_ = kv_.getPtr(k_);\n        val_ = ptr_.readPtrVal();\n    }\n\n    function scenario4(\n        MemoryKV kv_,\n        MemoryKVKey k_,\n        MemoryKVVal v0_,\n        MemoryKVVal v1_\n    ) external returns (MemoryKVVal val_) {\n        kv_ = kv_.setVal(k_, v0_);\n        LibDebug.dumpMemory();\n        kv_ = kv_.setVal(k_, v1_);\n        LibDebug.dumpMemory();\n        MemoryKVPtr ptr_ = kv_.getPtr(k_);\n        val_ = ptr_.readPtrVal();\n        LibDebug.emitEvent(MemoryKVVal.unwrap(val_));\n    }\n\n    function scenario5(\n        MemoryKV kv_,\n        MemoryKVKey k0_,\n        MemoryKVVal v0_,\n        MemoryKVKey k1_,\n        MemoryKVVal v1_\n    ) external pure returns (uint256[] memory array_) {\n        kv_ = kv_.setVal(k0_, v0_);\n        kv_ = kv_.setVal(k1_, v1_);\n        array_ = kv_.toUint256Array();\n    }\n\n    function scenario6(\n        MemoryKV kv0_,\n        MemoryKV kv1_,\n        MemoryKVKey k_,\n        MemoryKVVal v0_,\n        MemoryKVVal v1_\n    ) external returns (MemoryKVVal val0_, MemoryKVVal val1_) {\n        kv0_ = kv0_.setVal(k_, v0_);\n        LibDebug.dumpMemory();\n        kv1_ = kv1_.setVal(k_, v1_);\n        LibDebug.dumpMemory();\n        MemoryKVPtr ptr0_ = kv0_.getPtr(k_);\n        val0_ = ptr0_.readPtrVal();\n        MemoryKVPtr ptr1_ = kv1_.getPtr(k_);\n        val1_ = ptr1_.readPtrVal();\n        LibDebug.emitEvent(MemoryKVVal.unwrap(val0_));\n        LibDebug.emitEvent(MemoryKVVal.unwrap(val1_));\n    }\n\n    function scenario7(\n        MemoryKV kv_,\n        uint256[] memory kvPair_\n    ) external pure returns (uint256[] memory array_) {\n        uint256 j = 0;\n        for (uint256 i = 0; i < kvPair_.length - 1; i += 2) {\n            j++;\n            kv_ = kv_.setVal(\n                MemoryKVKey.wrap(kvPair_[i]),\n                MemoryKVVal.wrap(kvPair_[i + 1])\n            );\n        }\n        array_ = kv_.toUint256Array();\n    }\n\n    /// END IN-MEMORY SCENARIOS\n\n    /// Wraps `LibMemoryKV.readPtrVal`.\n    function readPtrVal(MemoryKVPtr ptr_) public returns (MemoryKVVal val_) {\n        LibDebug.dumpMemory();\n        val_ = ptr_.readPtrVal();\n        LibDebug.dumpMemory();\n        LibDebug.emitEvent(MemoryKVVal.unwrap(val_));\n    }\n\n    /// Wraps `LibMemoryKV.getPtr`.\n    function getPtr(\n        MemoryKV kv_,\n        MemoryKVKey k_\n    ) public returns (MemoryKVPtr ptr_) {\n        LibDebug.dumpMemory();\n        ptr_ = kv_.getPtr(k_);\n        LibDebug.dumpMemory();\n        LibDebug.emitEvent(MemoryKVPtr.unwrap(ptr_));\n    }\n\n    /// Wraps `LibMemoryKV.setVal`.\n    function setVal(\n        MemoryKV kv_,\n        MemoryKVKey k_,\n        MemoryKVVal v_\n    ) public returns (MemoryKV kvSetVal_) {\n        LibDebug.dumpMemory();\n        kvSetVal_ = kv_.setVal(k_, v_);\n        LibDebug.dumpMemory();\n        LibDebug.emitEvent(MemoryKV.unwrap(kvSetVal_));\n    }\n\n    /// Wraps `LibMemoryKV.toUint256Array`.\n    function toUint256Array(\n        MemoryKV kv_\n    ) public returns (uint256[] memory array_) {\n        LibDebug.dumpMemory();\n        array_ = kv_.toUint256Array();\n        LibDebug.dumpMemory();\n        LibDebug.emitEvent(array_);\n    }\n}\n"
    },
    "contracts/test/math/FixedPointMath/FixedPointMathTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {FixedPointMath} from \"../../../math/FixedPointMath.sol\";\n\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\n/// @title FixedPointMathTest\n/// Thin wrapper around the `SaturatingMath` library for hardhat unit testing.\ncontract FixedPointMathTest {\n    using FixedPointMath for uint256;\n\n    /// Wraps `FixedPointMath.scale18`.\n    /// Scale a fixed point decimal of some scale factor to match `DECIMALS`.\n    /// @param a_ Some fixed point decimal value.\n    /// @param aDecimals_ The number of fixed decimals of `a_`.\n    /// @return `a_` scaled to match `DECIMALS`.\n    function scale18(\n        uint256 a_,\n        uint256 aDecimals_\n    ) external pure returns (uint256) {\n        return a_.scale18(aDecimals_);\n    }\n\n    /// Wraps `FixedPointMath.scaleN`.\n    /// Scale a fixed point decimals of `DECIMALS` to some other scale.\n    /// @param a_ A `DECIMALS` fixed point decimals.\n    /// @param targetDecimals_ The new scale of `a_`.\n    /// @return `a_` rescaled from `DECIMALS` to `targetDecimals_`.\n    function scaleN(\n        uint256 a_,\n        uint256 targetDecimals_\n    ) external pure returns (uint256) {\n        return a_.scaleN(targetDecimals_);\n    }\n\n    /// Wraps `FixedPointMath.scaleBy`.\n    /// Scale a fixed point up or down by `scaleBy_` orders of magnitude.\n    /// @param a_ Some integer of any scale.\n    /// @param scaleBy_ OOMs to scale `a_` up or down by.\n    /// @return `a_` rescaled according to `scaleBy_`.\n    function scaleBy(\n        uint256 a_,\n        int8 scaleBy_\n    ) external pure returns (uint256) {\n        return a_.scaleBy(scaleBy_);\n    }\n\n    /// Wraps `FixedPointMath.fixedPointMul`.\n    /// Fixed point multiplication in native scale decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` multiplied by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointMul(\n        uint256 a_,\n        uint256 b_\n    ) external pure returns (uint256) {\n        return a_.fixedPointMul(b_);\n    }\n\n    /// Overloaded `fixedPointMul` that exposes underlying `mulDiv` rounding.\n    function fixedPointMul(\n        uint256 a_,\n        uint256 b_,\n        Math.Rounding rounding_\n    ) external pure returns (uint256) {\n        return a_.fixedPointMul(b_, rounding_);\n    }\n\n    /// Wraps `FixedPointMath.fixedPointDiv`.\n    /// Fixed point division in native scale decimals.\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` divided by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointDiv(\n        uint256 a_,\n        uint256 b_\n    ) external pure returns (uint256) {\n        return a_.fixedPointDiv(b_);\n    }\n\n    /// Overloaded `fixedPointDiv` that exposes underlying `mulDiv` rounding.\n    function fixedPointDiv(\n        uint256 a_,\n        uint256 b_,\n        Math.Rounding rounding_\n    ) external pure returns (uint256) {\n        return a_.fixedPointDiv(b_, rounding_);\n    }\n}\n"
    },
    "contracts/test/phased/PhasedScheduleTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {Phased} from \"../../phased/Phased.sol\";\n\n/// @title PhasedScheduleTest\n/// Contract for testing phase hook functionality.\ncontract PhasedScheduleTest is Phased {\n    constructor() {\n        initializePhased();\n    }\n\n    /// Exposes `schedulePhase` for testing.\n    function testScheduleNextPhase() external {\n        uint256 initialPhase_ = currentPhase();\n\n        succeedsOnlyPhase(initialPhase_);\n        schedulePhase(initialPhase_ + 1, block.timestamp);\n        succeedsOnlyPhase(initialPhase_ + 1);\n    }\n\n    /// Exposes `onlyPhase` for testing.\n    /// @param phase_ As per `onlyPhase`.\n    function succeedsOnlyPhase(uint256 phase_) internal onlyPhase(phase_) {}\n}\n"
    },
    "contracts/test/phased/PhasedTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {Phased} from \"../../phased/Phased.sol\";\n\n/// @title PhasedTest\n/// Empty contract for tests enumerating behaviour of the `Phased` modifiers.\ncontract PhasedTest is Phased {\n    bool public condition = true;\n\n    constructor() {\n        initializePhased();\n    }\n\n    /// Exposes `schedulePhase` for testing.\n    /// @param timestamp_ As per `schedulePhase`.\n    function testScheduleNextPhase(uint256 timestamp_) external {\n        require(condition, \"CONDITION\");\n        schedulePhase(currentPhase() + 1, timestamp_);\n    }\n\n    /// This function wraps `onlyPhase` modifier, passing phase directly into\n    /// modifier argument.\n    /// @param phase_ Modifier MUST error if current phase is not `phase_`.\n    /// @return Always true if not error.\n    function runsOnlyPhase(\n        uint256 phase_\n    ) external view onlyPhase(phase_) returns (bool) {\n        return true;\n    }\n\n    /// This function wraps `onlyAtLeastPhase` modifier, passing phase directly\n    /// into modifier argument.\n    /// @param phase_ Modifier MUST error if current phase is not AT LEAST\n    /// `phase_`.\n    /// @return Always true if not error.\n    function runsOnlyAtLeastPhase(\n        uint256 phase_\n    ) external view onlyAtLeastPhase(phase_) returns (bool) {\n        return true;\n    }\n\n    /// Toggles `condition` for testing phase scheduling hook.\n    function toggleCondition() external {\n        condition = !condition;\n    }\n}\n"
    },
    "contracts/test/redeemableERC20/RedeemableERC20/ERC20PulleeTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {RedeemableERC20} from \"../../../redeemableERC20/RedeemableERC20.sol\";\n\ncontract ERC20PulleeTest {\n    using SafeERC20 for IERC20;\n\n    function approve(\n        address token_,\n        address recipient_,\n        uint256 amount_\n    ) external {\n        IERC20(token_).safeIncreaseAllowance(recipient_, amount_);\n    }\n\n    function transfer(\n        address token_,\n        address recipient_,\n        uint256 amount_\n    ) external {\n        IERC20(token_).transfer(recipient_, amount_);\n    }\n\n    function endDistribution(address token_, address distributor_) external {\n        RedeemableERC20(token_).endDistribution(distributor_);\n    }\n\n    function grantSender(address token_, address sender_) external {\n        RedeemableERC20(token_).grantSender(sender_);\n    }\n\n    function grantReceiver(address token_, address receiver_) external {\n        RedeemableERC20(token_).grantReceiver(receiver_);\n    }\n\n    function redeem(\n        address token_,\n        IERC20[] calldata assets_,\n        uint256 amount_\n    ) external {\n        RedeemableERC20(token_).redeem(assets_, amount_);\n    }\n}\n"
    },
    "contracts/test/redeemableERC20/RedeemableERC20/RedeemableERC20Reentrant.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport {ReserveToken} from \"../../testToken/ReserveToken.sol\";\nimport {RedeemableERC20} from \"../../../redeemableERC20/RedeemableERC20.sol\";\n\n/// @title RedeemableERC20Reentrant\n/// Test contract that attempts to call reentrant code on `RedeemableERC20`.\n/// The calls MUST fail when driven by the test harness.\ncontract RedeemableERC20Reentrant is ReserveToken {\n    RedeemableERC20 private redeemableERC20;\n\n    /// Set the contract to attempt to reenter.\n    /// @param redeemableERC20_ RedeemableERC20 contract to reeenter.\n    function addReentrantTarget(RedeemableERC20 redeemableERC20_) external {\n        redeemableERC20 = redeemableERC20_;\n    }\n\n    /// @inheritdoc ReserveToken\n    function _beforeTokenTransfer(\n        address sender_,\n        address receiver_,\n        uint256 amount_\n    ) internal virtual override {\n        super._beforeTokenTransfer(sender_, receiver_, amount_);\n        if (sender_ != address(0) && sender_ == address(redeemableERC20)) {\n            IERC20[] memory treasuryAssets_ = new IERC20[](1);\n            treasuryAssets_[0] = IERC20(address(this));\n            // This call MUST fail.\n            redeemableERC20.redeem(treasuryAssets_, amount_);\n        }\n    }\n}\n"
    },
    "contracts/test/sale/Sale/SaleReentrant.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {IERC20Upgradeable as IERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport {ReserveToken} from \"../../testToken/ReserveToken.sol\";\nimport {Sale, BuyConfig} from \"../../../sale/Sale.sol\";\n\n/// @title SaleReentrant\n/// Test contract that attempts to call reentrant code on `Sale`.\n/// The calls MUST fail when driven by the test harness.\ncontract SaleReentrant is ReserveToken {\n    Sale private sale;\n    BuyConfig private buyConfig;\n\n    /// Configures the contract to attempt to reenter.\n    constructor() ReserveToken() {}\n\n    /// Set the contract to attempt to reenter.\n    /// @param sale_ Sale contract to reeenter.\n    /// @param config_ BuyConfig for reentrant buy call.\n    function addReentrantTarget(\n        Sale sale_,\n        BuyConfig calldata config_\n    ) external {\n        sale = sale_;\n        buyConfig = config_;\n    }\n\n    /// @inheritdoc ReserveToken\n    function _beforeTokenTransfer(\n        address sender_,\n        address receiver_,\n        uint256 amount_\n    ) internal virtual override {\n        super._beforeTokenTransfer(sender_, receiver_, amount_);\n        if (receiver_ != address(0) && receiver_ == address(sale)) {\n            // This call MUST fail.\n            sale.buy(buyConfig);\n        }\n    }\n}\n"
    },
    "contracts/test/testToken/ReserveToken.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {ERC20Upgradeable as ERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {ERC20BurnableUpgradeable as ERC20Burnable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\n\n/// @title ReserveToken\n/// A test token that can be used as a reserve asset.\n/// On mainnet this would likely be some brand of stablecoin but can be\n/// anything.\n/// Notably mimics 6 decimals commonly used by stables in production.\ncontract ReserveToken is ERC20, ERC20Burnable {\n    /// Accounts to freeze during testing.\n    mapping(address => bool) public freezables;\n\n    // Stables such as USDT and USDC commonly have 6 decimals.\n    uint256 public constant DECIMALS = 6;\n    // One _billion_ dollars 👷😈.\n    uint256 public constant TOTAL_SUPPLY = 10 ** (DECIMALS + 9);\n\n    /// Define and mint the erc20 token.\n    function initialize() external initializer {\n        __ERC20_init(\"USD Classic\", \"USDCC\");\n        _mint(msg.sender, TOTAL_SUPPLY);\n    }\n\n    function decimals() public pure override returns (uint8) {\n        return uint8(DECIMALS);\n    }\n\n    /// Add an account to the freezables list.\n    /// @param account_ The account to freeze.\n    function addFreezable(address account_) external {\n        freezables[account_] = true;\n    }\n\n    /// Block any transfers to a frozen account.\n    /// @inheritdoc ERC20\n    function _beforeTokenTransfer(\n        address sender_,\n        address receiver_,\n        uint256 amount_\n    ) internal virtual override {\n        super._beforeTokenTransfer(sender_, receiver_, amount_);\n        require(!freezables[receiver_], \"FROZEN\");\n    }\n}\n"
    },
    "contracts/test/type/LibCast/LibCastTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../type/LibCast.sol\";\nimport \"../../../debug/LibDebug.sol\";\n\n/// @title LibCastTest\n/// Thin wrapper around `LibCast` library exposing functions for testing\ncontract LibCastTest {\n    function asOpFunctionPointer(uint256 i_) external {\n        LibDebug.dumpMemory();\n        LibCast.asOpFunctionPointer(i_);\n        LibDebug.dumpMemory();\n    }\n\n    function asIntegrityFunctionPointer(uint256 i_) external {\n        LibDebug.dumpMemory();\n        LibCast.asIntegrityFunctionPointer(i_);\n        LibDebug.dumpMemory();\n    }\n\n    function identity(uint256 a_) internal pure returns (uint256) {\n        return a_;\n    }\n\n    function asUint256ArrayOpPtrs(\n        uint256[] memory is_\n    ) external returns (uint256[] memory) {\n        LibDebug.dumpMemory();\n        is_ = LibCast.asUint256Array(LibCast.asOpcodeFunctionPointers(is_));\n        LibDebug.dumpMemory();\n        return is_;\n    }\n\n    function asUint256ArrayIntPtrs(\n        uint256[] memory is_\n    ) external returns (uint256[] memory) {\n        LibDebug.dumpMemory();\n        is_ = LibCast.asUint256Array(LibCast.asIntegrityPointers(is_));\n        LibDebug.dumpMemory();\n        return is_;\n    }\n\n    function asAddresses(\n        uint256[] memory is_\n    ) external pure returns (address[] memory addresses_) {\n        addresses_ = LibCast.asAddresses(is_);\n    }\n\n    function asOpFunctionPointers(uint256[] memory is_) external {\n        LibDebug.dumpMemory();\n        LibCast.asOpcodeFunctionPointers(is_);\n        LibDebug.dumpMemory();\n    }\n\n    function asIntegrityPointers(uint256[] memory is_) external {\n        LibDebug.dumpMemory();\n        LibCast.asIntegrityPointers(is_);\n        LibDebug.dumpMemory();\n    }\n}\n"
    },
    "contracts/test/type/LibConvert/LibConvertTest.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../../../type/LibConvert.sol\";\nimport \"../../../debug/LibDebug.sol\";\n\n/// @title LibConvertTest\n/// Thin wrapper around `LibConvert` library exposing functions for testing\ncontract LibConvertTest {\n    function toBytes(\n        uint256[] memory is_\n    ) external returns (bytes memory bytes_) {\n        LibDebug.dumpMemory();\n        bytes_ = LibConvert.toBytes(is_);\n        LibDebug.dumpMemory();\n    }\n\n    function unsafeTo16BitBytes(\n        uint256[] memory is_\n    ) external returns (bytes memory bytes_) {\n        LibDebug.dumpMemory();\n        bytes_ = LibConvert.unsafeTo16BitBytes(is_);\n        LibDebug.dumpMemory();\n    }\n}\n"
    },
    "contracts/tier/CombineTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {TierwiseCombine} from \"./libraries/TierwiseCombine.sol\";\nimport {ITierV2} from \"./ITierV2.sol\";\nimport {TierV2} from \"./TierV2.sol\";\nimport \"../interpreter/deploy/IExpressionDeployerV1.sol\";\nimport \"../interpreter/run/LibEncodedDispatch.sol\";\nimport \"../interpreter/run/LibStackPointer.sol\";\nimport \"../interpreter/run/LibInterpreterState.sol\";\nimport \"../interpreter/run/LibContext.sol\";\n\nimport {ERC165CheckerUpgradeable as ERC165Checker} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\n\nSourceIndex constant REPORT_ENTRYPOINT = SourceIndex.wrap(0);\nSourceIndex constant REPORT_FOR_TIER_ENTRYPOINT = SourceIndex.wrap(1);\n\nuint256 constant REPORT_MIN_OUTPUTS = 1;\nuint256 constant REPORT_MAX_OUTPUTS = 1;\n\nuint256 constant REPORT_FOR_TIER_MIN_OUTPUTS = 1;\nuint256 constant REPORT_FOR_TIER_MAX_OUTPUTS = 1;\n\n/// All config used during initialization of a CombineTier.\n/// @param combinedTiersLength The first N values in the constants array of the\n/// stateConfig MUST be all the combined tiers that are known statically. Of\n/// course some tier addresses MAY only be known at runtime and so these cannot\n/// be included. For those that are included there will be additional deploy\n/// time checks to ensure compatibility with each other (i.e. reportUnits).\n/// @param stateConfig Source to run for both report and reportForTier as\n/// sources 0 and 1 respectively.\nstruct CombineTierConfig {\n    address expressionDeployer;\n    address interpreter;\n    uint256 combinedTiersLength;\n    StateConfig stateConfig;\n}\n\n/// @title CombineTier\n/// @notice Allows combining the reports from any `ITierV2` contracts.\n/// The value at the top of the stack after executing the Rain expression will be\n/// used as the return of all `ITierV2` functions exposed by `CombineTier`.\ncontract CombineTier is TierV2 {\n    using LibStackPointer for StackPointer;\n    using LibStackPointer for uint256[];\n    using LibUint256Array for uint256;\n    using LibUint256Array for uint256[];\n    using LibInterpreterState for InterpreterState;\n\n    event Initialize(address sender, CombineTierConfig config);\n\n    IInterpreterV1 internal interpreter;\n    address internal expression;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        CombineTierConfig calldata config_\n    ) external initializer {\n        __TierV2_init();\n        interpreter = IInterpreterV1(config_.interpreter);\n        expression = IExpressionDeployerV1(config_.expressionDeployer)\n            .deployExpression(\n                config_.stateConfig,\n                LibUint256Array.arrayFrom(\n                    REPORT_MIN_OUTPUTS,\n                    REPORT_FOR_TIER_MIN_OUTPUTS\n                )\n            );\n\n        // Integrity check for all known combined tiers.\n        for (uint256 i_ = 0; i_ < config_.combinedTiersLength; i_++) {\n            require(\n                ERC165Checker.supportsInterface(\n                    address(uint160(config_.stateConfig.constants[i_])),\n                    type(ITierV2).interfaceId\n                ),\n                \"ERC165_TIERV2\"\n            );\n        }\n\n        emit Initialize(msg.sender, config_);\n    }\n\n    /// @inheritdoc ITierV2\n    function report(\n        address account_,\n        uint256[] memory callerContext_\n    ) external view virtual override returns (uint256) {\n        (uint256[] memory stack_, ) = interpreter.eval(\n            LibEncodedDispatch.encode(\n                expression,\n                REPORT_ENTRYPOINT,\n                REPORT_MAX_OUTPUTS\n            ),\n            LibContext.build(\n                uint256(uint160(account_)).arrayFrom().matrixFrom(),\n                callerContext_,\n                new SignedContext[](0)\n            )\n        );\n        return stack_.asStackPointerAfter().peek();\n    }\n\n    /// @inheritdoc ITierV2\n    function reportTimeForTier(\n        address account_,\n        uint256 tier_,\n        uint256[] memory callerContext_\n    ) external view returns (uint256) {\n        (uint256[] memory stack_, ) = interpreter.eval(\n            LibEncodedDispatch.encode(\n                expression,\n                REPORT_FOR_TIER_ENTRYPOINT,\n                REPORT_FOR_TIER_MAX_OUTPUTS\n            ),\n            LibContext.build(\n                LibUint256Array\n                    .arrayFrom(uint256(uint160(account_)), tier_)\n                    .matrixFrom(),\n                callerContext_,\n                new SignedContext[](0)\n            )\n        );\n        return stack_.asStackPointerAfter().peek();\n    }\n}\n"
    },
    "contracts/tier/CombineTierFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {ClonesUpgradeable as Clones} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\nimport {Factory} from \"../factory/Factory.sol\";\nimport {CombineTier, CombineTierConfig} from \"./CombineTier.sol\";\n\n/// @title CombineTierFactory\n/// @notice Factory for creating and deploying `CombineTier` contracts.\ncontract CombineTierFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new CombineTier());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(\n        bytes memory data_\n    ) internal virtual override returns (address) {\n        CombineTierConfig memory config_ = abi.decode(\n            data_,\n            (CombineTierConfig)\n        );\n        address clone_ = Clones.clone(implementation);\n        CombineTier(clone_).initialize(config_);\n        return clone_;\n    }\n\n    /// Typed wrapper for `createChild` with Source.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @return New `CombineTier` child contract address.\n    function createChildTyped(\n        CombineTierConfig memory config_\n    ) external returns (CombineTier) {\n        return CombineTier(createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "contracts/tier/ITierV2.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// @title ITierV2\n/// @notice `ITierV2` is a simple interface that contracts can implement to\n/// provide membership lists for other contracts.\n///\n/// There are many use-cases for a time-preserving conditional membership list.\n///\n/// Some examples include:\n///\n/// - Self-serve whitelist to participate in fundraising\n/// - Lists of users who can claim airdrops and perks\n/// - Pooling resources with implied governance/reward tiers\n/// - POAP style attendance proofs allowing access to future exclusive events\n///\n/// @dev Standard interface to a tiered membership.\n///\n/// A \"membership\" can represent many things:\n/// - Exclusive access.\n/// - Participation in some event or process.\n/// - KYC completion.\n/// - Combination of sub-memberships.\n/// - Etc.\n///\n/// The high level requirements for a contract implementing `ITierV2`:\n/// - MUST represent held tiers as a `uint`.\n/// - MUST implement `report`.\n///   - The report is a `uint256` that SHOULD represent the time each tier has\n///     been continuously held since encoded as `uint32`.\n///   - The encoded tiers start at `1`; Tier `0` is implied if no tier has ever\n///     been held.\n///   - Tier `0` is NOT encoded in the report, it is simply the fallback value.\n///   - If a tier is lost the time data is erased for that tier and will be\n///     set if/when the tier is regained to the new time.\n///   - If a tier is held but the historical time information is not available\n///     the report MAY return `0x00000000` for all held tiers.\n///   - Tiers that are lost or have never been held MUST return `0xFFFFFFFF`.\n///   - Context can be a list of numbers that MAY pairwise define tiers such as\n///     minimum thresholds, or MAY simply provide global context such as a\n///     relevant NFT ID for example.\n/// - MUST implement `reportTimeForTier`\n///   - Functions exactly as `report` but only returns a single time for a\n///     single tier\n///   - MUST return the same time value `report` would for any given tier and\n///     context combination.\n///\n/// So the four possible states and report values are:\n/// - Tier is held and time is known: Timestamp is in the report\n/// - Tier is held but time is NOT known: `0` is in the report\n/// - Tier is NOT held: `0xFF..` is in the report\n/// - Tier is unknown: `0xFF..` is in the report\n///\n/// The reason `context` is specified as a list of values rather than arbitrary\n/// bytes is to allow clear and efficient compatibility with interpreter stacks.\n/// Some N values can be taken from an interpreter stack and used directly as a\n/// context, which would be difficult or impossible to ensure is safe for\n/// arbitrary bytes.\ninterface ITierV2 {\n    /// Same as report but only returns the time for a single tier.\n    /// Often the implementing contract can calculate a single tier more\n    /// efficiently than all 8 tiers. If the consumer only needs one or a few\n    /// tiers it MAY be much cheaper to request only those tiers individually.\n    /// This DOES NOT apply to all contracts, an obvious example is token\n    /// balance based tiers which always return `ALWAYS` or `NEVER` for all\n    /// tiers so no efficiency is gained.\n    /// The return value is a `uint256` for gas efficiency but the values will\n    /// be bounded by `type(uint32).max` as no single tier can report a value\n    /// higher than this.\n    function reportTimeForTier(\n        address account,\n        uint256 tier,\n        uint256[] calldata context\n    ) external view returns (uint256 time);\n\n    /// Returns an 8 tier encoded report of 32 bit timestamps for the given\n    /// account.\n    ///\n    /// Same as `ITier` (legacy interface) but with a list of values for\n    /// `context` which allows a single underlying state to present many\n    /// different reports dynamically.\n    ///\n    /// For example:\n    /// - Staking ledgers can calculate different tier thresholds\n    /// - NFTs can give different tiers based on different IDs\n    /// - Snapshot ERC20s can give different reports based on snapshot ID\n    ///\n    /// `context` supercedes `setTier` function and `TierChange` event from\n    /// `ITier` at the interface level.\n    function report(\n        address account,\n        uint256[] calldata context\n    ) external view returns (uint256 report);\n}\n"
    },
    "contracts/tier/libraries/TierConstants.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// @title TierConstants\n/// @notice Constants for use with tier logic.\nlibrary TierConstants {\n    /// NEVER is 0xFF.. as it is infinitely in the future.\n    /// NEVER for an entire report.\n    uint256 internal constant NEVER_REPORT = type(uint256).max;\n    /// NEVER for a single tier time.\n    uint32 internal constant NEVER_TIME = type(uint32).max;\n\n    /// Always is 0 as negative timestamps are not possible/supported onchain.\n    /// Tiers can't predate the chain but they can predate an `ITierV2`\n    /// contract.\n    uint256 internal constant ALWAYS = 0;\n\n    /// Account has never held a tier.\n    uint256 internal constant TIER_ZERO = 0;\n\n    /// Magic number for tier one.\n    uint256 internal constant TIER_ONE = 1;\n    /// Magic number for tier two.\n    uint256 internal constant TIER_TWO = 2;\n    /// Magic number for tier three.\n    uint256 internal constant TIER_THREE = 3;\n    /// Magic number for tier four.\n    uint256 internal constant TIER_FOUR = 4;\n    /// Magic number for tier five.\n    uint256 internal constant TIER_FIVE = 5;\n    /// Magic number for tier six.\n    uint256 internal constant TIER_SIX = 6;\n    /// Magic number for tier seven.\n    uint256 internal constant TIER_SEVEN = 7;\n    /// Magic number for tier eight.\n    uint256 internal constant TIER_EIGHT = 8;\n    /// Maximum tier is `TIER_EIGHT`.\n    uint256 internal constant MAX_TIER = TIER_EIGHT;\n}\n"
    },
    "contracts/tier/libraries/TierReport.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport {ITierV2} from \"../ITierV2.sol\";\nimport \"./TierConstants.sol\";\n\n/// @title TierReport\n/// @notice `TierReport` implements several pure functions that can be\n/// used to interface with reports.\n/// - `tierAtTimeFromReport`: Returns the highest status achieved relative to\n/// a block timestamp and report. Statuses gained after that block are ignored.\n/// - `tierTime`: Returns the timestamp that a given tier has been held\n/// since according to a report.\n/// - `truncateTiersAbove`: Resets all the tiers above the reference tier.\n/// - `updateTimesForTierRange`: Updates a report with a timestamp for every\n///    tier in a range.\n/// - `updateReportWithTierAtTime`: Updates a report to a new tier.\n/// @dev Utilities to consistently read, write and manipulate tiers in reports.\n/// The low-level bit shifting can be difficult to get right so this\n/// factors that out.\nlibrary TierReport {\n    /// Enforce upper limit on tiers so we can do unchecked math.\n    /// @param tier_ The tier to enforce bounds on.\n    modifier maxTier(uint256 tier_) {\n        require(tier_ <= TierConstants.MAX_TIER, \"MAX_TIER\");\n        _;\n    }\n\n    /// Returns the highest tier achieved relative to a block timestamp\n    /// and report.\n    ///\n    /// Note that typically the report will be from the _current_ contract\n    /// state, i.e. `block.timestamp` but not always. Tiers gained after the\n    /// reference time are ignored.\n    ///\n    /// When the `report` comes from a later block than the `timestamp_` this\n    /// means the user must have held the tier continuously from `timestamp_`\n    /// _through_ to the report time.\n    /// I.e. NOT a snapshot.\n    ///\n    /// @param report_ A report as per `ITierV2`.\n    /// @param timestamp_ The timestamp to check the tiers against.\n    /// @return tier_ The highest tier held since `timestamp_` as per `report`.\n    function tierAtTimeFromReport(\n        uint256 report_,\n        uint256 timestamp_\n    ) internal pure returns (uint256 tier_) {\n        unchecked {\n            for (tier_ = 0; tier_ < 8; tier_++) {\n                if (uint32(uint256(report_ >> (tier_ * 32))) > timestamp_) {\n                    break;\n                }\n            }\n        }\n    }\n\n    /// Returns the timestamp that a given tier has been held since from a\n    /// report.\n    ///\n    /// The report MUST encode \"never\" as 0xFFFFFFFF. This ensures\n    /// compatibility with `tierAtTimeFromReport`.\n    ///\n    /// @param report_ The report to read a timestamp from.\n    /// @param tier_ The Tier to read the timestamp for.\n    /// @return The timestamp the tier has been held since.\n    function reportTimeForTier(\n        uint256 report_,\n        uint256 tier_\n    ) internal pure maxTier(tier_) returns (uint256) {\n        unchecked {\n            // ZERO is a special case. Everyone has always been at least ZERO,\n            // since block 0.\n            if (tier_ == 0) {\n                return 0;\n            }\n\n            uint256 offset_ = (tier_ - 1) * 32;\n            return uint256(uint32(uint256(report_ >> offset_)));\n        }\n    }\n\n    /// Resets all the tiers above the reference tier to 0xFFFFFFFF.\n    ///\n    /// @param report_ Report to truncate with high bit 1s.\n    /// @param tier_ Tier to truncate above (exclusive).\n    /// @return Truncated report.\n    function truncateTiersAbove(\n        uint256 report_,\n        uint256 tier_\n    ) internal pure maxTier(tier_) returns (uint256) {\n        unchecked {\n            uint256 offset_ = tier_ * 32;\n            uint256 mask_ = (TierConstants.NEVER_REPORT >> offset_) << offset_;\n            return report_ | mask_;\n        }\n    }\n\n    /// Updates a report with a timestamp for a given tier.\n    /// More gas efficient than `updateTimesForTierRange` if only a single\n    /// tier is being modified.\n    /// The tier at/above the given tier is updated. E.g. tier `0` will update\n    /// the time for tier `1`.\n    /// @param report_ Report to use as the baseline for the updated report.\n    /// @param tier_ The tier level to update.\n    /// @param timestamp_ The new block number for `tier_`.\n    /// @return The newly updated `report_`.\n    function updateTimeAtTier(\n        uint256 report_,\n        uint256 tier_,\n        uint256 timestamp_\n    ) internal pure maxTier(tier_) returns (uint256) {\n        unchecked {\n            uint256 offset_ = tier_ * 32;\n            return\n                (report_ &\n                    ~uint256(uint256(TierConstants.NEVER_TIME) << offset_)) |\n                uint256(timestamp_ << offset_);\n        }\n    }\n\n    /// Updates a report with a block number for every tier in a range.\n    ///\n    /// Does nothing if the end status is equal or less than the start tier.\n    /// @param report_ The report to update.\n    /// @param startTier_ The tier at the start of the range (exclusive).\n    /// @param endTier_ The tier at the end of the range (inclusive).\n    /// @param timestamp_ The timestamp to set for every tier in the range.\n    /// @return The updated report.\n    function updateTimesForTierRange(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 timestamp_\n    ) internal pure maxTier(endTier_) returns (uint256) {\n        unchecked {\n            uint256 offset_;\n            for (uint256 i_ = startTier_; i_ < endTier_; i_++) {\n                offset_ = i_ * 32;\n                report_ =\n                    (report_ &\n                        ~uint256(\n                            uint256(TierConstants.NEVER_TIME) << offset_\n                        )) |\n                    uint256(timestamp_ << offset_);\n            }\n            return report_;\n        }\n    }\n\n    /// Updates a report to a new status.\n    ///\n    /// Internally dispatches to `truncateTiersAbove` and\n    /// `updateBlocksForTierRange`.\n    /// The dispatch is based on whether the new tier is above or below the\n    /// current tier.\n    /// The `startTier_` MUST match the result of `tierAtBlockFromReport`.\n    /// It is expected the caller will know the current tier when\n    /// calling this function and need to do other things in the calling scope\n    /// with it.\n    ///\n    /// @param report_ The report to update.\n    /// @param startTier_ The tier to start updating relative to. Data above\n    /// this tier WILL BE LOST so probably should be the current tier.\n    /// @param endTier_ The new highest tier held, at the given timestamp_.\n    /// @param timestamp_ The timestamp_ to update the highest tier to, and\n    /// intermediate tiers from `startTier_`.\n    /// @return The updated report.\n    function updateReportWithTierAtTime(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 timestamp_\n    ) internal pure returns (uint256) {\n        return\n            endTier_ < startTier_\n                ? truncateTiersAbove(report_, endTier_)\n                : updateTimesForTierRange(\n                    report_,\n                    startTier_,\n                    endTier_,\n                    timestamp_\n                );\n    }\n}\n"
    },
    "contracts/tier/libraries/TierwiseCombine.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport \"./TierReport.sol\";\nimport \"../../math/SaturatingMath.sol\";\n\nlibrary TierwiseCombine {\n    using Math for uint256;\n    using SaturatingMath for uint256;\n\n    /// Every lte check in `selectLte` must pass.\n    uint256 internal constant LOGIC_EVERY = 0;\n    /// Only one lte check in `selectLte` must pass.\n    uint256 internal constant LOGIC_ANY = 1;\n\n    /// Select the minimum block number from passing blocks in `selectLte`.\n    uint256 internal constant MODE_MIN = 0;\n    /// Select the maximum block number from passing blocks in `selectLte`.\n    uint256 internal constant MODE_MAX = 1;\n    /// Select the first block number that passes in `selectLte`.\n    uint256 internal constant MODE_FIRST = 2;\n\n    /// Performs a tierwise saturating subtraction of two reports.\n    /// Intepret as \"# of blocks older report was held before newer report\".\n    /// If older report is in fact newer then `0` will be returned.\n    /// i.e. the diff cannot be negative, older report as simply spent 0 blocks\n    /// existing before newer report, if it is in truth the newer report.\n    /// @param newerReport_ Block to subtract from.\n    /// @param olderReport_ Block to subtract.\n    function saturatingSub(\n        uint256 newerReport_,\n        uint256 olderReport_\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 ret_;\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\n                uint256 newerBlock_ = TierReport.reportTimeForTier(\n                    newerReport_,\n                    tier_\n                );\n                uint256 olderBlock_ = TierReport.reportTimeForTier(\n                    olderReport_,\n                    tier_\n                );\n                uint256 diff_ = newerBlock_.saturatingSub(olderBlock_);\n                ret_ = TierReport.updateTimeAtTier(ret_, tier_ - 1, diff_);\n            }\n            return ret_;\n        }\n    }\n\n    /// Given a list of reports, selects the best tier in a tierwise fashion.\n    /// The \"best\" criteria can be configured by `logic_` and `mode_`.\n    /// Logic can be \"every\" or \"any\", which means that the reports for a given\n    /// tier must either all or any be less than or equal to the reference\n    /// `blockNumber_`.\n    /// Mode can be \"min\", \"max\", \"first\" which selects between all the block\n    /// numbers for a given tier that meet the lte criteria.\n    /// IMPORTANT: If the output of `selectLte` is used to write to storage\n    /// care must be taken to ensure that \"upcoming\" tiers relative to the\n    /// `blockNumber_` are not overwritten inappropriately. Typically this\n    /// function should be used as a filter over reads only from an upstream\n    /// source of truth.\n    /// @param reports_ The list of reports to select over.\n    /// @param blockNumber_ The block number that tier blocks must be lte.\n    /// @param logic_ `LOGIC_EVERY` or `LOGIC_ANY`.\n    /// @param mode_ `MODE_MIN`, `MODE_MAX` or `MODE_FIRST`.\n    function selectLte(\n        uint256 logic_,\n        uint256 mode_,\n        uint256 blockNumber_,\n        uint256[] memory reports_\n    ) internal pure returns (uint256) {\n        unchecked {\n            uint256 ret_;\n            uint256 block_;\n            bool anyLte_;\n            uint256 length_ = reports_.length;\n            for (uint256 tier_ = 1; tier_ <= 8; tier_++) {\n                uint256 accumulator_;\n                // Nothing lte the reference block for this tier yet.\n                anyLte_ = false;\n\n                // Initialize the accumulator for this tier.\n                if (mode_ == MODE_MIN) {\n                    accumulator_ = TierConstants.NEVER_REPORT;\n                } else {\n                    accumulator_ = 0;\n                }\n\n                // Filter all the blocks at the current tier from all the\n                // reports against the reference tier and each other.\n                for (uint256 i_ = 0; i_ < length_; i_++) {\n                    block_ = TierReport.reportTimeForTier(reports_[i_], tier_);\n\n                    if (block_ <= blockNumber_) {\n                        // Min and max need to compare current value against\n                        // the accumulator.\n                        if (mode_ == MODE_MIN) {\n                            accumulator_ = block_.min(accumulator_);\n                        } else if (mode_ == MODE_MAX) {\n                            accumulator_ = block_.max(accumulator_);\n                        } else if (mode_ == MODE_FIRST && !anyLte_) {\n                            accumulator_ = block_;\n                        }\n                        anyLte_ = true;\n                    } else if (logic_ == LOGIC_EVERY) {\n                        // Can short circuit for an \"every\" check.\n                        accumulator_ = TierConstants.NEVER_REPORT;\n                        break;\n                    }\n                }\n                if (!anyLte_) {\n                    accumulator_ = TierConstants.NEVER_REPORT;\n                }\n                ret_ = TierReport.updateTimeAtTier(\n                    ret_,\n                    tier_ - 1,\n                    accumulator_\n                );\n            }\n            return ret_;\n        }\n    }\n}\n"
    },
    "contracts/tier/TierV2.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport {ERC165Upgradeable as ERC165} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"./ITierV2.sol\";\n\nabstract contract TierV2 is ITierV2, ERC165 {\n    // solhint-disable-next-line func-name-mixedcase\n    function __TierV2_init() internal onlyInitializing {\n        __ERC165_init();\n    }\n\n    // @inheritdoc ERC165\n    function supportsInterface(\n        bytes4 interfaceId_\n    ) public view virtual override returns (bool) {\n        return\n            interfaceId_ == type(ITierV2).interfaceId ||\n            super.supportsInterface(interfaceId_);\n    }\n}\n"
    },
    "contracts/type/LibCast.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\nimport \"../interpreter/run/LibStackPointer.sol\";\nimport \"../interpreter/run/LibInterpreterState.sol\";\nimport \"../interpreter/deploy/LibIntegrityCheck.sol\";\n\n/// @title LibCast\n/// @notice Additional type casting logic that the Solidity compiler doesn't\n/// give us by default. A type cast (vs. conversion) is considered one where the\n/// structure is unchanged by the cast. The cast does NOT (can't) check that the\n/// input is a valid output, for example any integer MAY be cast to a function\n/// pointer but almost all integers are NOT valid function pointers. It is the\n/// calling context that MUST ensure the validity of the data, the cast will\n/// merely retype the data in place, generally without additional checks.\n/// As most structures in solidity have the same memory structure as a `uint256`\n/// or fixed/dynamic array of `uint256` there are many conversions that can be\n/// done with near zero or minimal overhead.\nlibrary LibCast {\n    /// Retype an integer to an opcode function pointer.\n    /// @param u_ The integer to cast to an opcode function pointer.\n    /// @return fn_ The opcode function pointer.\n    function asOpFunctionPointer(\n        uint256 u_\n    )\n        internal\n        pure\n        returns (\n            function(InterpreterState memory, Operand, StackPointer)\n                view\n                returns (StackPointer) fn_\n        )\n    {\n        assembly (\"memory-safe\") {\n            fn_ := u_\n        }\n    }\n\n    /// Retype an array of integers to an array of opcode function pointers.\n    /// @param us_ The array of integers to cast to an array of opcode fuction\n    /// pointers.\n    /// @return fns_ The array of opcode function pointers.\n    function asOpcodeFunctionPointers(\n        uint256[] memory us_\n    )\n        internal\n        pure\n        returns (\n            function(InterpreterState memory, Operand, StackPointer)\n                view\n                returns (StackPointer)[]\n                memory fns_\n        )\n    {\n        assembly (\"memory-safe\") {\n            fns_ := us_\n        }\n    }\n\n    /// Retype an integer to an integrity function pointer.\n    /// @param u_ The integer to cast to an integrity function pointer.\n    /// @return fn_ The integrity function pointer.\n    function asIntegrityFunctionPointer(\n        uint256 u_\n    )\n        internal\n        pure\n        returns (\n            function(IntegrityCheckState memory, Operand, StackPointer)\n                internal\n                view\n                returns (StackPointer) fn_\n        )\n    {\n        assembly (\"memory-safe\") {\n            fn_ := u_\n        }\n    }\n\n    /// Retype a list of integrity check function pointers to a `uint256[]`.\n    /// @param fns_ The list of function pointers.\n    /// @return us_ The list of pointers as `uint256[]`.\n    function asUint256Array(\n        function(IntegrityCheckState memory, Operand, StackPointer)\n            internal\n            view\n            returns (StackPointer)[]\n            memory fns_\n    ) internal pure returns (uint256[] memory us_) {\n        assembly (\"memory-safe\") {\n            us_ := fns_\n        }\n    }\n\n    /// Retype a list of interpreter opcode function pointers to a `uint256[]`.\n    /// @param fns_ The list of function pointers.\n    /// @return us_ The list of pointers as `uint256[]`.\n    function asUint256Array(\n        function(InterpreterState memory, Operand, StackPointer)\n            view\n            returns (StackPointer)[]\n            memory fns_\n    ) internal pure returns (uint256[] memory us_) {\n        assembly (\"memory-safe\") {\n            us_ := fns_\n        }\n    }\n\n    /// Retype a list of `uint256[]` to `address[]`.\n    /// @param us_ The list of integers to cast to addresses.\n    /// @return addresses_ The list of addresses cast from each integer.\n    function asAddresses(\n        uint256[] memory us_\n    ) internal pure returns (address[] memory addresses_) {\n        assembly (\"memory-safe\") {\n            addresses_ := us_\n        }\n    }\n\n    /// Retype a list of integers to integrity check function pointers.\n    /// @param us_ The list of integers to use as function pointers.\n    /// @return fns_ The list of integrity check function pointers.\n    function asIntegrityPointers(\n        uint256[] memory us_\n    )\n        internal\n        pure\n        returns (\n            function(IntegrityCheckState memory, Operand, StackPointer)\n                view\n                returns (StackPointer)[]\n                memory fns_\n        )\n    {\n        assembly (\"memory-safe\") {\n            fns_ := us_\n        }\n    }\n}\n"
    },
    "contracts/type/LibConvert.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\n/// @title LibConvert\n/// @notice Type conversions that require additional structural changes to\n/// complete safely. These are NOT mere type casts and involve additional\n/// reads and writes to complete, such as recalculating the length of an array.\n/// The convention \"toX\" is adopted from Rust to imply the additional costs and\n/// consumption of the source to produce the target.\nlibrary LibConvert {\n    /// Convert an array of integers to `bytes` data. This requires modifying\n    /// the length in situ as the integer array length is measured in 32 byte\n    /// increments while the length of `bytes` is the literal number of bytes.\n    /// @return bytes_ The integer array converted to `bytes` data.\n    function toBytes(\n        uint256[] memory us_\n    ) internal pure returns (bytes memory bytes_) {\n        assembly (\"memory-safe\") {\n            bytes_ := us_\n            // Length in bytes is 32x the length in uint256\n            mstore(bytes_, mul(0x20, mload(bytes_)))\n        }\n    }\n\n    /// Truncate `uint256[]` values down to `uint16[]` then pack this to `bytes`\n    /// without padding or length prefix. Unsafe because the starting `uint256`\n    /// values are not checked for overflow due to the truncation. The caller\n    /// MUST ensure that all values fit in `type(uint16).max` or that silent\n    /// overflow is safe.\n    /// @param us_ The `uint256[]` to truncate and concatenate to 16 bit `bytes`.\n    /// @return The concatenated 2-byte chunks.\n    function unsafeTo16BitBytes(\n        uint256[] memory us_\n    ) internal pure returns (bytes memory) {\n        unchecked {\n            // We will keep 2 bytes (16 bits) from each integer.\n            bytes memory bytes_ = new bytes(us_.length * 2);\n            assembly (\"memory-safe\") {\n                let replaceMask_ := 0xFFFF\n                let preserveMask_ := not(replaceMask_)\n                for {\n                    let cursor_ := add(us_, 0x20)\n                    let end_ := add(cursor_, mul(mload(us_), 0x20))\n                    let bytesCursor_ := add(bytes_, 0x02)\n                } lt(cursor_, end_) {\n                    cursor_ := add(cursor_, 0x20)\n                    bytesCursor_ := add(bytesCursor_, 0x02)\n                } {\n                    let data_ := mload(bytesCursor_)\n                    mstore(\n                        bytesCursor_,\n                        or(and(preserveMask_, data_), mload(cursor_))\n                    )\n                }\n            }\n            return bytes_;\n        }\n    }\n}\n"
    },
    "contracts/verify/auto/AutoApprove.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {LibEvidence, Verify} from \"../Verify.sol\";\nimport \"../VerifyCallback.sol\";\nimport \"../../array/LibUint256Array.sol\";\nimport {AllStandardOps} from \"../../interpreter/ops/AllStandardOps.sol\";\nimport \"../../interpreter/deploy/IExpressionDeployerV1.sol\";\nimport \"../../interpreter/run/IInterpreterV1.sol\";\nimport \"../../interpreter/run/LibStackPointer.sol\";\nimport \"../../interpreter/run/LibEncodedDispatch.sol\";\n\nuint256 constant CAN_APPROVE_MIN_OUTPUTS = 1;\nuint256 constant CAN_APPROVE_MAX_OUTPUTS = 1;\nSourceIndex constant CAN_APPROVE_ENTRYPOINT = SourceIndex.wrap(0);\n\nstruct AutoApproveConfig {\n    address expressionDeployer;\n    address interpreter;\n    StateConfig stateConfig;\n}\n\ncontract AutoApprove is VerifyCallback {\n    using LibStackPointer for StackPointer;\n    using LibUint256Array for uint256;\n    using LibUint256Array for uint256[];\n    using LibEvidence for uint256[];\n    using LibStackPointer for uint256[];\n    using LibStackPointer for StackPointer;\n\n    /// Contract has initialized.\n    /// @param sender `msg.sender` initializing the contract (factory).\n    /// @param config All initialized config.\n    event Initialize(address sender, AutoApproveConfig config);\n\n    IInterpreterV1 internal interpreter;\n    address internal expression;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        AutoApproveConfig calldata config_\n    ) external initializer {\n        __VerifyCallback_init();\n\n        expression = IExpressionDeployerV1(config_.expressionDeployer)\n            .deployExpression(\n                config_.stateConfig,\n                LibUint256Array.arrayFrom(CAN_APPROVE_MIN_OUTPUTS)\n            );\n        interpreter = IInterpreterV1(config_.interpreter);\n\n        _transferOwnership(msg.sender);\n\n        emit Initialize(msg.sender, config_);\n    }\n\n    function afterAdd(\n        address,\n        Evidence[] calldata evidences_\n    ) external virtual override {\n        unchecked {\n            IInterpreterV1 interpreter_ = interpreter;\n            uint256[] memory approvedRefs_ = new uint256[](evidences_.length);\n            uint256 approvals_ = 0;\n            uint256[][] memory context_ = new uint256[][](1);\n            context_[0] = new uint256[](2);\n            EncodedDispatch dispatch_ = LibEncodedDispatch.encode(\n                expression,\n                CAN_APPROVE_ENTRYPOINT,\n                CAN_APPROVE_MAX_OUTPUTS\n            );\n            for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n                // Currently we only support 32 byte evidence for auto approve.\n                if (evidences_[i_].data.length == 0x20) {\n                    context_[0][0] = uint256(uint160(evidences_[i_].account));\n                    context_[0][1] = uint256(bytes32(evidences_[i_].data));\n                    (\n                        uint256[] memory stack_,\n                        uint256[] memory stateChanges_\n                    ) = interpreter_.eval(dispatch_, context_);\n                    if (stack_.asStackPointerAfter().peek() > 0) {\n                        LibEvidence._updateEvidenceRef(\n                            approvedRefs_,\n                            evidences_[i_],\n                            approvals_\n                        );\n                        approvals_++;\n                    }\n                    if (stateChanges_.length > 0) {\n                        interpreter_.stateChanges(stateChanges_);\n                    }\n                }\n            }\n\n            if (approvals_ > 0) {\n                approvedRefs_.truncate(approvals_);\n                Verify(msg.sender).approve(approvedRefs_.asEvidences());\n            }\n        }\n    }\n}\n"
    },
    "contracts/verify/auto/AutoApproveFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {Factory} from \"../../factory/Factory.sol\";\nimport \"./AutoApprove.sol\";\n\nimport {ClonesUpgradeable as Clones} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\n/// @title AutoApproveFactory\n/// @notice Factory for creating and deploying `AutoApprove` contracts.\ncontract AutoApproveFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address private immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new AutoApprove());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// Note: Caller MUST transfer ownership to the `Verify` contract that is\n    /// attempting to call the autoapprover callbacks, otherwise every\n    /// callback will revert.\n    /// @inheritdoc Factory\n    function _createChild(\n        bytes memory data_\n    ) internal virtual override returns (address) {\n        AutoApproveConfig memory config_ = abi.decode(\n            data_,\n            (AutoApproveConfig)\n        );\n        address clone_ = Clones.clone(implementation);\n        AutoApprove(clone_).initialize(config_);\n        AutoApprove(clone_).transferOwnership(msg.sender);\n        return clone_;\n    }\n\n    /// Allows calling `createChild` with typed arguments.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ initialize configuration.\n    /// @return New `AutoApprove` child contract.\n    function createChildTyped(\n        AutoApproveConfig memory config_\n    ) external returns (AutoApprove) {\n        return AutoApprove(createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "contracts/verify/IVerifyCallbackV1.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport \"./LibEvidence.sol\";\n\n/// Deployers of `Verify` contracts (e.g. via `VerifyFactory`) may want to\n/// apply additional processing and/or restrictions to each of the basic\n/// verification actions. Examples may be reading from onchain state or\n/// requiring token transfers to complete before allowing an add/approve to\n/// complete successfully. The reason this is an interface rather than\n/// implementors extending `Verify` directly is that it allows for more\n/// implementations to sit under a single `VerifyFactory` which in turn allows\n/// a more readily composed ecosystem of verified accounts.\n///\n/// There's no reentrancy concerns for external calls from the `Verify`\n/// contract to the `IVerifyCallbackV1` contract because:\n/// - All the callbacks happen after state changes in `Verify`\n/// - All `Verify` actions are bound to the authority of the `msg.sender`\n/// The `IVerifyCallbackV1` contract can and should rollback transactions if\n/// their restrictions/processing requirements are not met, but otherwise have\n/// no more authority over the `Verify` state than anon users.\n///\n/// The security model for platforms consuming `Verify` contracts is that they\n/// should index or otherwise filter children from the `VerifyFactory` down to\n/// those that also set a supported `IVerifyCallbackV1` contract. The factory is\n/// completely agnostic to callback concerns and doesn't even require that a\n/// callback contract be set at all.\ninterface IVerifyCallbackV1 {\n    /// Additional processing after a batch of additions.\n    /// SHOULD revert/rollback transactions if processing fails.\n    /// @param adder_ The `msg.sender` that authorized the additions.\n    /// MAY be the addee without any specific role.\n    /// @param evidences_ All evidences associated with the additions.\n    function afterAdd(address adder_, Evidence[] calldata evidences_) external;\n\n    /// Additional processing after a batch of approvals.\n    /// SHOULD revert/rollback transactions if processing fails.\n    /// @param approver_ The `msg.sender` that authorized the approvals.\n    /// @param evidences_ All evidences associated with the approvals.\n    function afterApprove(\n        address approver_,\n        Evidence[] calldata evidences_\n    ) external;\n\n    /// Additional processing after a batch of bannings.\n    /// SHOULD revert/rollback transactions if processing fails.\n    /// @param banner_ The `msg.sender` that authorized the bannings.\n    /// @param evidences_ All evidences associated with the bannings.\n    function afterBan(address banner_, Evidence[] calldata evidences_) external;\n\n    /// Additional processing after a batch of removals.\n    /// SHOULD revert/rollback transactions if processing fails.\n    /// @param remover_ The `msg.sender` that authorized the removals.\n    /// @param evidences_ All evidences associated with the removals.\n    function afterRemove(\n        address remover_,\n        Evidence[] calldata evidences_\n    ) external;\n}\n"
    },
    "contracts/verify/IVerifyV1.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\ntype VerifyStatus is uint256;\n\ninterface IVerifyV1 {\n    function accountStatusAtTime(\n        address account,\n        uint256 timestamp\n    ) external view returns (VerifyStatus);\n}\n"
    },
    "contracts/verify/LibEvidence.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.15;\n\n/// Structure of arbitrary evidence to support any action taken.\n/// Privileged roles are expected to provide evidence just as applicants as an\n/// audit trail will be preserved permanently in the logs.\n/// @param account The account this evidence is relevant to.\n/// @param data Arbitrary bytes representing evidence. MAY be e.g. a reference\n/// to a sufficiently decentralised external system such as an IPFS hash.\nstruct Evidence {\n    address account;\n    bytes data;\n}\n\nlibrary LibEvidence {\n    function _updateEvidenceRef(\n        uint256[] memory refs_,\n        Evidence memory evidence_,\n        uint256 refsIndex_\n    ) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(add(refs_, add(0x20, mul(0x20, refsIndex_))), evidence_)\n        }\n    }\n\n    function asEvidences(\n        uint256[] memory refs_\n    ) internal pure returns (Evidence[] memory evidences_) {\n        assembly (\"memory-safe\") {\n            evidences_ := refs_\n        }\n    }\n}\n"
    },
    "contracts/verify/libraries/LibVerifyStatus.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"../IVerifyV1.sol\";\n\nlibrary LibVerifyStatus {\n    function eq(VerifyStatus a_, VerifyStatus b_) internal pure returns (bool) {\n        return VerifyStatus.unwrap(a_) == VerifyStatus.unwrap(b_);\n    }\n}\n"
    },
    "contracts/verify/libraries/VerifyConstants.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\nimport \"../IVerifyV1.sol\";\n\n/// Summary statuses derived from a `State` by comparing the `Since` times\n/// against a specific block number.\nlibrary VerifyConstants {\n    /// Account has not interacted with the system yet or was removed.\n    VerifyStatus internal constant STATUS_NIL = VerifyStatus.wrap(0);\n    /// Account has added evidence for themselves.\n    VerifyStatus internal constant STATUS_ADDED = VerifyStatus.wrap(1);\n    /// Approver has reviewed added/approve evidence and approved the account.\n    VerifyStatus internal constant STATUS_APPROVED = VerifyStatus.wrap(2);\n    /// Banner has reviewed a request to ban an account and banned it.\n    VerifyStatus internal constant STATUS_BANNED = VerifyStatus.wrap(3);\n}\n"
    },
    "contracts/verify/Verify.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"./IVerifyCallbackV1.sol\";\n\nimport {AccessControlUpgradeable as AccessControl} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"./libraries/VerifyConstants.sol\";\nimport \"./LibEvidence.sol\";\nimport \"../array/LibUint256Array.sol\";\nimport \"./IVerifyV1.sol\";\nimport \"./libraries/LibVerifyStatus.sol\";\n\n/// Records the time a verify session reaches each status.\n/// If a status is not reached it is left as UNINITIALIZED, i.e. 0xFFFFFFFF.\n/// Most accounts will never be banned so most accounts will never reach every\n/// status, which is a good thing.\n/// @param addedSince Time the address was added else 0xFFFFFFFF.\n/// @param approvedSince Time the address was approved else 0xFFFFFFFF.\n/// @param bannedSince Time the address was banned else 0xFFFFFFFF.\nstruct State {\n    uint32 addedSince;\n    uint32 approvedSince;\n    uint32 bannedSince;\n}\n\n/// Config to initialize a Verify contract with.\n/// @param admin The address to ASSIGN ALL ADMIN ROLES to initially. This\n/// address is free and encouraged to delegate fine grained permissions to\n/// many other sub-admin addresses, then revoke it's own \"root\" access.\n/// @param callback The address of the `IVerifyCallbackV1` contract if it exists.\n/// MAY be `address(0)` to signify that callbacks should NOT run.\nstruct VerifyConfig {\n    address admin;\n    address callback;\n}\n\n/// @title Verify\n/// Trust-minimised contract to record the state of some verification process.\n/// When some off-chain identity is to be reified on chain there is inherently\n/// some multi-party, multi-faceted trust relationship. For example, the DID\n/// (Decentralized Identifiers) specification from W3C outlines that the\n/// controller and the subject of an identity are two different entities.\n///\n/// This is because self-identification is always problematic to the point of\n/// being uselessly unbelievable.\n///\n/// For example, I can simply say \"I am the queen of England\" and what\n/// onchain mechanism could possibly check, let alone stop me?\n/// The same problem exists in any situation where some privilege or right is\n/// associated with identity. Consider passports, driver's licenses,\n/// celebrity status, age, health, accredited investor, social media account,\n/// etc. etc.\n///\n/// Typically crypto can't and doesn't want to deal with this issue. The usual\n/// scenario is that some system demands personal information, which leads to:\n///\n/// - Data breaches that put individual's safety at risk. Consider the December\n///   2020 leak from Ledger that dumped 270 000 home addresses and phone\n///   numbers, and another million emails, of hardware wallet owners on a\n///   public forum.\n/// - Discriminatory access, undermining an individual's self-sovereign right\n///   to run a full node, self-host a GUI and broadcast transactions onchain.\n///   Consider the dydx airdrop of 2021 where metadata about a user's access\n///   patterns logged on a server were used to deny access to presumed\n///   Americans over regulatory fears.\n/// - An entrenched supply chain of centralized actors from regulators, to\n///   government databases, through KYC corporations, platforms, etc. each of\n///   which holds an effective monopoly over, and ability to manipulate user's\n///   \"own\" identity.\n///\n/// These examples and others are completely antithetical to and undermine the\n/// safety of an opt-in, permissionless system based on pseudonomous actors\n/// self-signing actions into a shared space.\n///\n/// That said, one can hardly expect a permissionless pseudonomous system\n/// founded on asynchronous value transfers to succeed without at least some\n/// concept of curation and reputation.\n///\n/// Anon, will you invest YOUR money in anon's project?\n///\n/// Clearly for every defi blue chip there are 10 000 scams and nothing onchain\n/// can stop a scam, this MUST happen at the social layer.\n///\n/// Rain protocol is agnostic to how this verification happens. A government\n/// regulator is going to want a government issued ID cross-referenced against\n/// international sanctions. A fan of some social media influencer wants to\n/// see a verified account on that platform. An open source software project\n/// should show a github profile. A security token may need evidence from an\n/// accountant showing accredited investor status. There are so many ways in\n/// which BOTH sides of a fundraise may need to verify something about\n/// themselves to each other via a THIRD PARTY that Rain cannot assume much.\n///\n/// The trust model and process for Rain verification is:\n///\n/// - There are many `Verify` contracts, each represents a specific\n///   verification method with a (hopefully large) set of possible reviewers.\n/// - The verifyee compiles some evidence that can be referenced in some\n///   relevant system. It could be a session ID in a KYC provider's database or\n///   a tweet from a verified account, etc. The evidence is passed to the\n///   `Verify` contract as raw bytes so it is opaque onchain, but visible as an\n///   event to verifiers.\n/// - The verifyee calls `add` _for themselves_ to initialize their state and\n///   emit the evidence for their account, after which they _cannot change_\n///   their submission without appealing to someone who can remove. This costs\n///   gas, so why don't we simply ask the user to sign something and have an\n///   approver verify the signed data? Because we want to leverage both the\n///   censorship resistance and asynchronous nature of the underlying\n///   blockchain. Assuming there are N possible approvers, we want ANY 1 of\n///   those N approvers to be able to review and approve an application. If the\n///   user is forced to submit their application directly to one SPECIFIC\n///   approver we lose this property. In the gasless model the user must then\n///   rely on their specific approver both being online and not to censor the\n///   request. It's also possible that many accounts add the same evidence,\n///   after all it will be public in the event logs, so it is important for\n///   approvers to verify the PAIRING between account and evidence.\n/// - ANY account with the `APPROVER` role can review the evidence by\n///   inspecting the event logs. IF the evidence is valid then the `approve`\n///   function should be called by the approver. Approvers MAY also approve and\n///   implicitly add any account atomically if the account did not previously\n///   add itself.\n/// - ANY account with the `BANNER` role can veto either an add OR a prior\n///   approval. In the case of a false positive, i.e. where an account was\n///   mistakenly approved, an appeal can be made to a banner to update the\n///   status. Bad accounts SHOULD BE BANNED NOT REMOVED. When an account is\n///   removed, its onchain state is once again open for the attacker to\n///   resubmit new fraudulent evidence and potentially be reapproved.\n///   Once an account is banned, any attempt by the account holder to change\n///   their status, or an approver to approve will be rejected. Downstream\n///   consumers of a `State` MUST check for an existing ban. Banners MAY ban\n///   and implicity add any account atomically if the account did not\n///   previously add itself.\n///   - ANY account with the `REMOVER` role can scrub the `State` from an\n///   account. Of course, this is a blockchain so the state changes are all\n///   still visible to full nodes and indexers in historical data, in both the\n///   onchain history and the event logs for each state change. This allows an\n///   account to appeal to a remover in the case of a MISTAKEN BAN or also in\n///   the case of a MISTAKEN ADD (e.g. mistake in evidence), effecting a\n///   \"hard reset\" at the contract storage level.\n///\n/// Banning some account with an invalid session is NOT required. It is\n/// harmless for an added session to remain as `Status.Added` indefinitely.\n/// For as long as no approver decides to approve some invalid added session it\n/// MUST be treated as equivalent to a ban by downstream contracts. This is\n/// important so that admins are only required to spend gas on useful actions.\n///\n/// In addition to `Approve`, `Ban`, `Remove` there are corresponding events\n/// `RequestApprove`, `RequestBan`, `RequestRemove` that allow for admins to be\n/// notified that some new evidence must be considered that may lead to each\n/// action. `RequestApprove` is automatically submitted as part of the `add`\n/// call, but `RequestBan` and `RequestRemove` must be manually called\n///\n/// Rain uses standard Open Zeppelin `AccessControl` and is agnostic to how the\n/// approver/remover/banner roles and associated admin roles are managed.\n/// Ideally the more credibly neutral qualified parties assigend to each role\n/// for each `Verify` contract the better. This improves the censorship\n/// resistance of the verification process and the responsiveness of the\n/// end-user experience.\n///\n/// Ideally the admin account assigned at deployment would renounce their admin\n/// rights after establishing a more granular and appropriate set of accounts\n/// with each specific role.\n///\n/// There is no requirement that any of the privileged accounts with roles are\n/// a single-key EOA, they may be multisig accounts or even a DAO with formal\n/// governance processes mediated by a smart contract.\n///\n/// Every action emits an associated event and optionally calls an onchain\n/// callback on a `IVerifyCallbackV1` contract set during initialize. As each\n/// action my be performed in bulk dupes are not rolled back, instead the\n/// events are emitted for every time the action is called and the callbacks\n/// and onchain state changes are deduped. For example, an approve may be\n/// called twice for a single account, but by different approvers, potentially\n/// submitting different evidence for each approval. In this case the time of\n/// the first approve will be used and the onchain callback will be called for\n/// the first transaction only, but BOTH approvals will emit an event. This\n/// logic is applied per-account, per-action across a batch of evidences.\ncontract Verify is IVerifyV1, AccessControl {\n    using LibUint256Array for uint256[];\n    using LibEvidence for uint256[];\n    using LibVerifyStatus for VerifyStatus;\n\n    /// Any state never held is UNINITIALIZED.\n    /// Note that as per default evm an unset state is 0 so always check the\n    /// `addedSince` time on a `State` before trusting an equality check on\n    /// any other time.\n    /// (i.e. removed or never added)\n    uint32 private constant UNINITIALIZED = type(uint32).max;\n\n    /// Emitted when the `Verify` contract is initialized.\n    event Initialize(address sender, VerifyConfig config);\n\n    /// Emitted when evidence is first submitted to approve an account.\n    /// The requestor is always the `msg.sender` of the user calling `add`.\n    /// @param sender The `msg.sender` that submitted its own evidence.\n    /// @param evidence The evidence to support an approval.\n    /// NOT written to contract storage.\n    event RequestApprove(address sender, Evidence evidence);\n    /// Emitted when a previously added account is approved.\n    /// @param sender The `msg.sender` that approved `account`.\n    /// @param evidence The approval data.\n    event Approve(address sender, Evidence evidence);\n\n    /// Currently approved accounts can request that any account be banned.\n    /// The requestor is expected to provide supporting data for the ban.\n    /// The requestor MAY themselves be banned if vexatious.\n    /// @param sender The `msg.sender` requesting a ban of `account`.\n    /// @param evidence Account + data the `requestor` feels will strengthen\n    /// its case for the ban. NOT written to contract storage.\n    event RequestBan(address sender, Evidence evidence);\n    /// Emitted when an added or approved account is banned.\n    /// @param sender The `msg.sender` that banned `account`.\n    /// @param evidence Account + the evidence to support a ban.\n    /// NOT written to contract storage.\n    event Ban(address sender, Evidence evidence);\n\n    /// Currently approved accounts can request that any account be removed.\n    /// The requestor is expected to provide supporting data for the removal.\n    /// The requestor MAY themselves be banned if vexatious.\n    /// @param sender The `msg.sender` requesting a removal of `account`.\n    /// @param evidence `Evidence` to justify a removal.\n    event RequestRemove(address sender, Evidence evidence);\n    /// Emitted when an account is scrubbed from blockchain state.\n    /// Historical logs still visible offchain of course.\n    /// @param sender The `msg.sender` that removed `account`.\n    /// @param evidence `Evidence` to justify the removal.\n    event Remove(address sender, Evidence evidence);\n\n    /// Admin role for `APPROVER`.\n    bytes32 public constant APPROVER_ADMIN = keccak256(\"APPROVER_ADMIN\");\n    /// Role for `APPROVER`.\n    bytes32 public constant APPROVER = keccak256(\"APPROVER\");\n\n    /// Admin role for `REMOVER`.\n    bytes32 public constant REMOVER_ADMIN = keccak256(\"REMOVER_ADMIN\");\n    /// Role for `REMOVER`.\n    bytes32 public constant REMOVER = keccak256(\"REMOVER\");\n\n    /// Admin role for `BANNER`.\n    bytes32 public constant BANNER_ADMIN = keccak256(\"BANNER_ADMIN\");\n    /// Role for `BANNER`.\n    bytes32 public constant BANNER = keccak256(\"BANNER\");\n\n    /// Account => State\n    mapping(address => State) private states;\n\n    /// Optional IVerifyCallbackV1 contract.\n    /// MAY be address 0.\n    IVerifyCallbackV1 public callback;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// Initializes the `Verify` contract e.g. as cloned by a factory.\n    /// @param config_ The config required to initialize the contract.\n    function initialize(VerifyConfig memory config_) external initializer {\n        require(config_.admin != address(0), \"0_ACCOUNT\");\n        __AccessControl_init();\n\n        // `APPROVER_ADMIN` can admin each other in addition to\n        // `APPROVER` addresses underneath.\n        _setRoleAdmin(APPROVER_ADMIN, APPROVER_ADMIN);\n        _setRoleAdmin(APPROVER, APPROVER_ADMIN);\n\n        // `REMOVER_ADMIN` can admin each other in addition to\n        // `REMOVER` addresses underneath.\n        _setRoleAdmin(REMOVER_ADMIN, REMOVER_ADMIN);\n        _setRoleAdmin(REMOVER, REMOVER_ADMIN);\n\n        // `BANNER_ADMIN` can admin each other in addition to\n        // `BANNER` addresses underneath.\n        _setRoleAdmin(BANNER_ADMIN, BANNER_ADMIN);\n        _setRoleAdmin(BANNER, BANNER_ADMIN);\n\n        // It is STRONGLY RECOMMENDED that the `admin_` delegates specific\n        // admin roles then revokes the `X_ADMIN` roles. From themselves.\n        // It is ALSO RECOMMENDED that each of the sub-`X_ADMIN` roles revokes\n        // their admin rights once sufficient approvers/removers/banners have\n        // been assigned, if possible. Admins can instantly/atomically assign\n        // and revoke admin privileges from each other, so a compromised key\n        // can irreperably damage a `Verify` contract instance.\n        _grantRole(APPROVER_ADMIN, config_.admin);\n        _grantRole(REMOVER_ADMIN, config_.admin);\n        _grantRole(BANNER_ADMIN, config_.admin);\n\n        callback = IVerifyCallbackV1(config_.callback);\n\n        emit Initialize(msg.sender, config_);\n    }\n\n    /// Typed accessor into states.\n    /// @param account_ The account to return the current `State` for.\n    function state(address account_) external view returns (State memory) {\n        return states[account_];\n    }\n\n    /// Derives a single `Status` from a `State` and a reference timestamp.\n    /// @param state_ The raw `State` to reduce into a `Status`.\n    /// @param timestamp_ The timestamp to compare `State` against.\n    /// @return status_ The status in `State` given `timestamp_`.\n    function statusAtTime(\n        State memory state_,\n        uint256 timestamp_\n    ) public pure returns (VerifyStatus status_) {\n        // The state hasn't even been added so is picking up time zero as the\n        // evm fallback value. In this case if we checked other times using\n        // a `<=` equality they would incorrectly return `true` always due to\n        // also having a `0` fallback value.\n        // Using `< 1` here to silence slither.\n        if (state_.addedSince < 1) {\n            status_ = VerifyConstants.STATUS_NIL;\n        }\n        // Banned takes priority over everything.\n        else if (state_.bannedSince <= timestamp_) {\n            status_ = VerifyConstants.STATUS_BANNED;\n        }\n        // Approved takes priority over added.\n        else if (state_.approvedSince <= timestamp_) {\n            status_ = VerifyConstants.STATUS_APPROVED;\n        }\n        // Added is lowest priority.\n        else if (state_.addedSince <= timestamp_) {\n            status_ = VerifyConstants.STATUS_ADDED;\n        }\n        // The `addedSince` time is after `timestamp_` so `Status` is nil\n        // relative to `timestamp_`.\n        else {\n            status_ = VerifyConstants.STATUS_NIL;\n        }\n    }\n\n    /// @inheritdoc IVerifyV1\n    function accountStatusAtTime(\n        address account_,\n        uint256 timestamp_\n    ) external view virtual returns (VerifyStatus) {\n        return statusAtTime(states[account_], timestamp_);\n    }\n\n    /// Requires that `msg.sender` is approved as at the current timestamp.\n    modifier onlyApproved() {\n        require(\n            statusAtTime(states[msg.sender], block.timestamp).eq(\n                VerifyConstants.STATUS_APPROVED\n            ),\n            \"ONLY_APPROVED\"\n        );\n        _;\n    }\n\n    /// @dev Builds a new `State` for use by `add` and `approve`.\n    function newState() private view returns (State memory state_) {\n        state_ = State(uint32(block.timestamp), UNINITIALIZED, UNINITIALIZED);\n    }\n\n    /// An account adds their own verification evidence.\n    /// Internally `msg.sender` is used; delegated `add` is not supported.\n    /// @param data_ The evidence to support approving the `msg.sender`.\n    function add(bytes calldata data_) external {\n        State memory state_ = states[msg.sender];\n        VerifyStatus currentStatus_ = statusAtTime(state_, block.timestamp);\n        require(\n            !currentStatus_.eq(VerifyConstants.STATUS_APPROVED) &&\n                !currentStatus_.eq(VerifyConstants.STATUS_BANNED),\n            \"ALREADY_EXISTS\"\n        );\n        // An account that hasn't already been added need a new state.\n        // If an account has already been added but not approved or banned\n        // they can emit many `RequestApprove` events without changing\n        // their state. This facilitates multi-step workflows for the KYC\n        // provider, e.g. to implement a commit+reveal scheme or simply\n        // request additional evidence from the applicant before final\n        // verdict.\n        if (currentStatus_.eq(VerifyConstants.STATUS_NIL)) {\n            states[msg.sender] = newState();\n        }\n        Evidence memory evidence_ = Evidence(msg.sender, data_);\n        emit RequestApprove(msg.sender, evidence_);\n\n        // Call the `afterAdd_` hook to allow inheriting contracts to enforce\n        // requirements.\n        // The inheriting contract MUST `require` or otherwise enforce its\n        // needs to rollback a bad add.\n        IVerifyCallbackV1 callback_ = callback;\n        if (address(callback_) != address(0)) {\n            Evidence[] memory evidences_ = new Evidence[](1);\n            evidences_[0] = evidence_;\n            callback_.afterAdd(msg.sender, evidences_);\n        }\n    }\n\n    /// An `APPROVER` can review added evidence and approve accounts.\n    /// Typically many approvals would be submitted in a single call which is\n    /// more convenient and gas efficient than sending individual transactions\n    /// for every approval. However, as there are many individual agents\n    /// acting concurrently and independently this requires that the approval\n    /// process be infallible so that no individual approval can rollback the\n    /// entire batch due to the actions of some other approver/banner. It is\n    /// possible to approve an already approved or banned account. The\n    /// `Approve` event will always emit but the approved time will only be\n    /// set if it was previously uninitialized. A banned account will always\n    /// be seen as banned when calling `statusAtTime` regardless of the\n    /// approval time, even if the approval is more recent than the ban. The\n    /// only way to reset a ban is to remove and reapprove the account.\n    /// @param evidences_ All evidence for all approvals.\n    function approve(Evidence[] memory evidences_) external onlyRole(APPROVER) {\n        unchecked {\n            State memory state_;\n            uint256[] memory addedRefs_ = new uint256[](evidences_.length);\n            uint256[] memory approvedRefs_ = new uint256[](evidences_.length);\n            uint256 additions_ = 0;\n            uint256 approvals_ = 0;\n\n            for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n                Evidence memory evidence_ = evidences_[i_];\n                state_ = states[evidence_.account];\n                // If the account hasn't been added an approver can still add\n                // and approve it on their behalf.\n                if (state_.addedSince < 1) {\n                    state_ = newState();\n\n                    LibEvidence._updateEvidenceRef(\n                        addedRefs_,\n                        evidence_,\n                        additions_\n                    );\n                    additions_++;\n                }\n                // If the account hasn't been approved we approve it. As there\n                // are many approvers operating independently and concurrently\n                // we do NOT `require` the approval be unique, but we also do\n                // NOT change the time as the oldest approval is most\n                // important. However we emit an event for every approval even\n                // if the state does not change.\n                // It is possible to approve a banned account but\n                // `statusAtTime` will ignore the approval time for any banned\n                // account and use the banned time only.\n                if (state_.approvedSince == UNINITIALIZED) {\n                    state_.approvedSince = uint32(block.timestamp);\n                    states[evidence_.account] = state_;\n\n                    LibEvidence._updateEvidenceRef(\n                        approvedRefs_,\n                        evidence_,\n                        approvals_\n                    );\n                    approvals_++;\n                }\n\n                // Always emit an `Approve` event even if we didn't write to\n                // storage. This ensures that supporting evidence hits the logs\n                // for offchain review.\n                emit Approve(msg.sender, evidence_);\n            }\n            IVerifyCallbackV1 callback_ = callback;\n            if (address(callback_) != address(0)) {\n                if (additions_ > 0) {\n                    addedRefs_.truncate(additions_);\n                    callback_.afterAdd(msg.sender, addedRefs_.asEvidences());\n                }\n                if (approvals_ > 0) {\n                    approvedRefs_.truncate(approvals_);\n                    callback_.afterApprove(\n                        msg.sender,\n                        approvedRefs_.asEvidences()\n                    );\n                }\n            }\n        }\n    }\n\n    /// Any approved address can request some address be approved.\n    /// Frivolous requestors SHOULD expect to find themselves banned.\n    /// @param evidences_ Array of evidences to request approvals for.\n    function requestApprove(\n        Evidence[] calldata evidences_\n    ) external onlyApproved {\n        unchecked {\n            for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n                emit RequestApprove(msg.sender, evidences_[i_]);\n            }\n        }\n    }\n\n    /// A `BANNER` can ban an added OR approved account.\n    /// @param evidences_ All evidence appropriate for all bans.\n    function ban(Evidence[] calldata evidences_) external onlyRole(BANNER) {\n        unchecked {\n            State memory state_;\n            uint256[] memory addedRefs_ = new uint256[](evidences_.length);\n            uint256[] memory bannedRefs_ = new uint256[](evidences_.length);\n            uint256 additions_ = 0;\n            uint256 bans_ = 0;\n            for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n                Evidence memory evidence_ = evidences_[i_];\n                state_ = states[evidence_.account];\n\n                // There is no requirement that an account be formerly added\n                // before it is banned. For example some fraud may be detected\n                // in an affiliated `Verify` contract and the evidence can be\n                // used to ban the same address in the current contract. In\n                // this case the account will be added and banned in this call.\n                if (state_.addedSince < 1) {\n                    state_ = newState();\n\n                    LibEvidence._updateEvidenceRef(\n                        addedRefs_,\n                        evidence_,\n                        additions_\n                    );\n                    additions_++;\n                }\n                // Respect prior bans by leaving onchain storage as-is.\n                if (state_.bannedSince == UNINITIALIZED) {\n                    state_.bannedSince = uint32(block.timestamp);\n                    states[evidence_.account] = state_;\n\n                    LibEvidence._updateEvidenceRef(\n                        bannedRefs_,\n                        evidence_,\n                        bans_\n                    );\n                    bans_++;\n                }\n\n                // Always emit a `Ban` event even if we didn't write state. This\n                // ensures that supporting evidence hits the logs for offchain\n                // review.\n                emit Ban(msg.sender, evidence_);\n            }\n            IVerifyCallbackV1 callback_ = callback;\n            if (address(callback_) != address(0)) {\n                if (additions_ > 0) {\n                    addedRefs_.truncate(additions_);\n                    callback_.afterAdd(msg.sender, addedRefs_.asEvidences());\n                }\n                if (bans_ > 0) {\n                    bannedRefs_.truncate(bans_);\n                    callback_.afterBan(msg.sender, bannedRefs_.asEvidences());\n                }\n            }\n        }\n    }\n\n    /// Any approved address can request some address be banned.\n    /// Frivolous requestors SHOULD expect to find themselves banned.\n    /// @param evidences_ Array of evidences to request banning for.\n    function requestBan(Evidence[] calldata evidences_) external onlyApproved {\n        unchecked {\n            for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n                emit RequestBan(msg.sender, evidences_[i_]);\n            }\n        }\n    }\n\n    /// A `REMOVER` can scrub state mapping from an account.\n    /// A malicious account MUST be banned rather than removed.\n    /// Removal is useful to reset the whole process in case of some mistake.\n    /// @param evidences_ All evidence to suppor the removal.\n    function remove(Evidence[] memory evidences_) external onlyRole(REMOVER) {\n        unchecked {\n            State memory state_;\n            uint256[] memory removedRefs_ = new uint256[](evidences_.length);\n            uint256 removals_ = 0;\n            for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n                Evidence memory evidence_ = evidences_[i_];\n                state_ = states[evidences_[i_].account];\n                if (state_.addedSince > 0) {\n                    delete (states[evidence_.account]);\n                    LibEvidence._updateEvidenceRef(\n                        removedRefs_,\n                        evidence_,\n                        removals_\n                    );\n                    removals_++;\n                }\n                emit Remove(msg.sender, evidence_);\n            }\n            IVerifyCallbackV1 callback_ = callback;\n            if (address(callback_) != address(0)) {\n                if (removals_ > 0) {\n                    removedRefs_.truncate(removals_);\n                    callback_.afterRemove(\n                        msg.sender,\n                        removedRefs_.asEvidences()\n                    );\n                }\n            }\n        }\n    }\n\n    /// Any approved address can request some address be removed.\n    /// Frivolous requestors SHOULD expect to find themselves banned.\n    /// @param evidences_ Array of evidences to request removal of.\n    function requestRemove(\n        Evidence[] calldata evidences_\n    ) external onlyApproved {\n        unchecked {\n            for (uint256 i_ = 0; i_ < evidences_.length; i_++) {\n                emit RequestRemove(msg.sender, evidences_[i_]);\n            }\n        }\n    }\n}\n"
    },
    "contracts/verify/VerifyCallback.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport \"./IVerifyCallbackV1.sol\";\nimport {OwnableUpgradeable as Ownable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/// @title VerifyCallback\n/// Implements empty virtual functions for every function in `IVerifyCallbackV1`\n/// so that inheriting contracts only have to override the callbacks they need\n/// to define logic for.\ncontract VerifyCallback is IVerifyCallbackV1, Ownable {\n    // solhint-disable-next-line func-name-mixedcase\n    function __VerifyCallback_init() internal onlyInitializing {\n        __Ownable_init();\n    }\n\n    function afterAdd(\n        address adder_,\n        Evidence[] calldata evidences_\n    )\n        external\n        virtual\n        override\n        onlyOwner\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n\n    function afterApprove(\n        address approver_,\n        Evidence[] calldata evidences_\n    )\n        external\n        virtual\n        override\n        onlyOwner\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n\n    function afterBan(\n        address banner_,\n        Evidence[] calldata evidences_\n    )\n        external\n        virtual\n        override\n        onlyOwner\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n\n    function afterRemove(\n        address remover_,\n        Evidence[] calldata evidences_\n    )\n        external\n        virtual\n        override\n        onlyOwner\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n}\n"
    },
    "contracts/verify/VerifyFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.17;\n\nimport {Factory} from \"../factory/Factory.sol\";\nimport {Verify, VerifyConfig} from \"./Verify.sol\";\n\nimport {ClonesUpgradeable as Clones} from \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\n/// @title VerifyFactory\n/// @notice Factory for creating and deploying `Verify` contracts.\ncontract VerifyFactory is Factory {\n    /// Template contract to clone.\n    /// Deployed by the constructor.\n    address public immutable implementation;\n\n    /// Build the reference implementation to clone for each child.\n    constructor() {\n        address implementation_ = address(new Verify());\n        emit Implementation(msg.sender, implementation_);\n        implementation = implementation_;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(\n        bytes memory data_\n    ) internal virtual override returns (address) {\n        VerifyConfig memory config_ = abi.decode(data_, (VerifyConfig));\n        address clone_ = Clones.clone(implementation);\n        Verify(clone_).initialize(config_);\n        return clone_;\n    }\n\n    /// Typed wrapper for `createChild` with admin address.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ Initialization config for the new `Verify` child.\n    /// @return New `Verify` child contract address.\n    function createChildTyped(\n        VerifyConfig memory config_\n    ) external returns (Verify) {\n        return Verify(createChild(abi.encode(config_)));\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000000,
      "details": {
        "peephole": true,
        "inliner": true,
        "jumpdestRemover": true,
        "orderLiterals": true,
        "deduplicate": true,
        "cse": true,
        "constantOptimizer": true
      }
    },
    "evmVersion": "london",
    "metadata": {
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}